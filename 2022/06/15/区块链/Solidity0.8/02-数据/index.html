<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://kongpengyq.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="数据与变量隐式转换如果上面 uint256 u &#x3D; 123; 改为 uint256 u &#x3D; &quot;Hello&quot;;，将会收到错误 Type literal_string &quot;Hello&quot; is not implicitly convertible to expected type uint256.，因为这两种类型不能隐式转换的； 如果上面 uint256 u &#x3D; 1">
<meta property="og:type" content="article">
<meta property="og:title" content="02-数据">
<meta property="og:url" content="https://kongpengyq.com/2022/06/15/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/02-%E6%95%B0%E6%8D%AE/index.html">
<meta property="og:site_name" content="YQ &amp; 博客">
<meta property="og:description" content="数据与变量隐式转换如果上面 uint256 u &#x3D; 123; 改为 uint256 u &#x3D; &quot;Hello&quot;;，将会收到错误 Type literal_string &quot;Hello&quot; is not implicitly convertible to expected type uint256.，因为这两种类型不能隐式转换的； 如果上面 uint256 u &#x3D; 1">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-14T16:00:00.000Z">
<meta property="article:modified_time" content="2023-10-27T08:03:09.673Z">
<meta property="article:author" content="幺柒YQ">
<meta property="article:tag" content="区块链">
<meta property="article:tag" content="Solidity0.8.17">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://kongpengyq.com/2022/06/15/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/02-%E6%95%B0%E6%8D%AE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>02-数据 | YQ & 博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="YQ & 博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YQ & 博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/06/15/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/02-%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          02-数据
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-15 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-15T00:00:00+08:00">2022-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>53k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>48 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="数据与变量"><a href="#数据与变量" class="headerlink" title="数据与变量"></a>数据与变量</h1><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>如果上面 <code>uint256 u = 123;</code> 改为 <code>uint256 u = &quot;Hello&quot;;</code>，将会收到错误 <code>Type literal_string &quot;Hello&quot; is not implicitly convertible to expected type uint256.</code>，因为这两种类型不能隐式转换的；</p>
<p>如果上面 <code>uint256 u = 123;</code> 改为 <code>uint256 u = uint8(123);</code>，就不会有问题，因为<code>uint8</code>类型可以隐式转换为<code>uint256</code>类型。后面介绍类型转换的时候会详细的介绍。</p>
<h1 id="两种类型的数据"><a href="#两种类型的数据" class="headerlink" title="两种类型的数据"></a>两种类型的数据</h1><p>Solidity 按照数据类型可以分为<strong>值类型</strong>和<strong>引用类型</strong>。</p>
<ul>
<li>值类型: 值类型传值时会将值拷贝一份，传递的是值本身，对其修改时并不会对原来值有影响。<ul>
<li>始终按值来传递，当被用作函数参数或者用在赋值语句中时，总会进行值拷贝。</li>
<li>值类型里有两个比较特殊的类型是函数和地址（包括合约），会分为单独的部分介绍。</li>
</ul>
</li>
<li>引用类型: 引用类型进行传递时，传递的是其指针，而引用类型进行传递时<strong>可以为值传递</strong>，<strong>也可以为引用传递</strong>。</li>
</ul>
<h1 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h1><ol>
<li>Boolean</li>
<li>Integer:uint&#x2F;int</li>
<li>定长字节数组(固定大小字节数组):bytes1-bytes32</li>
<li>Enum:枚举</li>
<li>地址（Address）</li>
<li>合约类型</li>
<li>函数（Function Types）</li>
</ol>
<h2 id="3-1-Boolean-布尔类型"><a href="#3-1-Boolean-布尔类型" class="headerlink" title="3.1 Boolean 布尔类型"></a>3.1 Boolean 布尔类型</h2><p>布尔型使用 <code>bool</code>表示，该类型只有两个值，分别是 <code>true</code>&#x2F;<code>false</code>。</p>
<p>布尔值除了赋值得到外，还可以通过<strong>运算符</strong>的计算结果得到。</p>
<p>支持的运算符:<code>!</code>逻辑非，<code>==</code>等于，<code>!=</code> 不等于,<code>&amp;&amp;</code>逻辑与 ,<code>||</code>逻辑或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo2 &#123;</span><br><span class="line">    bool public a = false;</span><br><span class="line">    bool public b = !a; // 仅用于布尔值</span><br><span class="line">    bool public c = a == b;</span><br><span class="line">    bool public d = a != b;</span><br><span class="line">    bool public e = a &amp;&amp; b;</span><br><span class="line">    bool public f = a || b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运算符 <code>||</code> 和 <code>&amp;&amp;</code> 都遵循同样的短路（ short-circuiting ）规则。就是说在表达式 <code>f(x) || g(y)</code> 中， 如果 <code>f(x)</code> 的值为 true ，那么 <code>g(y)</code> 就不会被执行，</p>
<h3 id="3-1-1-使用短路规则节省-gas"><a href="#3-1-1-使用短路规则节省-gas" class="headerlink" title="3.1.1 使用短路规则节省 gas"></a>3.1.1 使用短路规则节省 gas</h3><p>借助短路规则，可以让合约少执行一些逻辑。</p>
<ul>
<li><code>||</code> 如果第一个表达式是<code>true</code>，则第二个表达式不再执行。（因为两个表达式有一个为 true，结果就为 true，不需要计算第二个表达式就知道结果了）</li>
<li><code>&amp;&amp;</code> 如果第一个表达式是<code>false</code>，则第二个表达式不再执行。（两个表达式必须都为 true，结果才能 true，如果第一个为 false，不需要计算第二个表达式就知道结果了）</li>
</ul>
<h2 id="3-2-Integer-整数类型"><a href="#3-2-Integer-整数类型" class="headerlink" title="3.2 Integer 整数类型"></a>3.2 Integer 整数类型</h2><p>整数类型分为有符号整型，用 int 标示；和无符号整型，用 uint 标示；</p>
<ul>
<li>int 是有符号整型，支持 int8 到 int256。</li>
<li>uint 是无符号整型，支持从 uint8 到 uint256。</li>
<li><code>uint</code> 和 <code>int</code> 分别是 <code>uint256</code> 和 <code>int256</code> 的别名。</li>
</ul>
<h3 id="3-2-1-属性"><a href="#3-2-1-属性" class="headerlink" title="3.2.1 属性"></a>3.2.1 属性</h3><p>对于整型 T 有下面的全局属性可访问：</p>
<blockquote>
<p>获取整型 T 的最小值:type(T).min<br>获取整型 T 的最大值:type(T).max</p>
</blockquote>
<h3 id="3-2-2-uint-类型"><a href="#3-2-2-uint-类型" class="headerlink" title="3.2.2 uint 类型"></a>3.2.2 uint 类型</h3><p>uint 无符号整数，只能表示非负数；<code>包括数字0</code>；其中 uint256 与 uint 相同，推荐使用 uint256；支持 int8 到 int256，后面的数字是 8 的倍数。</p>
<ul>
<li><code>uint8</code>: 最小值是 0，最大值是 <code>2**8-1</code></li>
<li><code>uint256</code>:最小值是 0，最大值是 <code>2**256-1</code></li>
<li>可以使用 <code>type(uint8).max</code> 获取该类型的最大值</li>
<li>可以使用 <code>type(uint8).min</code> 获取该类型的最小值</li>
</ul>
<h3 id="3-2-3-int-类型"><a href="#3-2-3-int-类型" class="headerlink" title="3.2.3 int 类型"></a>3.2.3 int 类型</h3><p>int 是有符号整数，其中 int256 与 int 相同，推荐使用 int256； 8 位到 256 位的带符号整型数。8 的倍数。</p>
<ul>
<li><code>int8</code>: 最小值是 <code>-128</code>，最大值是 <code>127</code></li>
<li><code>int256</code>: 最小值是 <code>-(2**256/2)</code>，最大值是 <code>(2**256/2)-1</code></li>
<li>可以使用 <code>type(int8).max</code> 获取该类型的最大值</li>
<li>可以使用 <code>type(int8).min</code> 获取该类型的最小值。</li>
</ul>
<p>计算中最小一级的信息单位是 byte 和 bit: <strong>其中字节(Byte)为最小存储容量单位</strong>，<strong>位(bit)是最小储存信息的单位,也被称为最小的数据传输单位</strong>；一个位就代表一个 0 或 1（即二进制）；每 8 个 bit(简写为 b）组成一个字节 Byte（简写为 B）；所以 <code>uint256</code> 和 <code>bytes32</code> 可以转换</p>
<ul>
<li><code>bytes1 对应 uint8</code></li>
<li><code>bytes2 对应 uint16</code></li>
<li>…</li>
<li><code>bytes32 对应 uint256</code></li>
</ul>
<h3 id="3-2-4-checked-模式"><a href="#3-2-4-checked-模式" class="headerlink" title="3.2.4 checked 模式"></a>3.2.4 checked 模式</h3><p>⚠️: 在 Solidity 之前的版本中，当对无限制整数执行算术运算，其结果超出结果类型的范围，这是就发生了上溢出或下溢出。在 Solidity 0.8.0 之前，算术运算总是会在发生溢出的情况下进行“截断”，而不是抛出异常。这就会导致一些麻烦的事情，可能导致未知的错误，所以我们不得不靠引入额外检查库来解决这个问题（最常见的如 OpenZepplin 的 SafeMath）</p>
<p>而从 <code>Solidity 0.8.0</code> 开始，所有的算术运算默认就会进行溢出检查，额外引入库将不再必要。0.8.0 开始，算术运算有两种计算模式：一种是<code>checked</code>（检查）模式，另一种是 <code>unchecked</code>（不检查）模式。</p>
<p>默认情况下，算术运算在 <code>checked</code> 模式下，即都会进行溢出检查，如果结果落在取值范围之外，调用会通过 失败异常 回退。</p>
<h3 id="3-2-5-unchecked-非检查模式"><a href="#3-2-5-unchecked-非检查模式" class="headerlink" title="3.2.5 unchecked 非检查模式"></a>3.2.5 unchecked 非检查模式</h3><p>如果依然想要之前“截断”的效果，而不是抛出异常错误，那么可以使用 <code>unchecked&#123;&#125;</code> 代码块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 public a = type(uint256).max;</span><br><span class="line">    uint8 public b = 1;</span><br><span class="line"></span><br><span class="line">    function f1() public view returns (uint256) &#123;</span><br><span class="line">        // 减法溢出会返回“截断”的结果</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f2() public view returns (uint256) &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return a + 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g() public view returns (uint256) &#123;</span><br><span class="line">        // 溢出会抛出异常</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>g()</code> 会触发失败异常， 调用 <code>f1()/f2()</code> 分别是截断效果,</p>
<p>⚠️: <code>unchecked</code> 代码块可以在代码块中的任何位置使用，但不可以替代整个函数代码块，同样不可以嵌套。切此设置仅影响语法上位于 <code>unchecked</code> 块内的语句。 在块中调用的函数不会此影响。</p>
<p>⚠️: 为避免歧义，不能在 unchecked 块中使用 <code>_;</code>, 该表示方法仅用于函数修改器。</p>
<blockquote>
<p> 触发溢出检查的运算符:++<code>, </code>–<code>, </code>+<code>, </code>减 -<code>, </code>负 -<code>, </code><em><code>, </code>&#x2F;<code>, </code>%<code>, </code>**, +&#x3D;<code>,</code>-&#x3D;<code>, </code></em>&#x3D;<code>, </code>&#x2F;&#x3D;<code>, </code>%&#x3D;</p>
</blockquote>
<blockquote>
<p> 除 <code>0</code>（或<code>除 0取模</code>）的异常是不能被 <code>unchecked</code> 忽略的。会发生 <code>Panic</code> 错误。</p>
</blockquote>
<blockquote>
<p> 位运算不会执行上溢或下溢检查</p>
</blockquote>
<blockquote>
<p> -int 值需要注意:因为负数的范围比正整数的范围大 1。</p>
</blockquote>
<h2 id="3-3-Integer-整数字面常量"><a href="#3-3-Integer-整数字面常量" class="headerlink" title="3.3 Integer 整数字面常量"></a>3.3 Integer 整数字面常量</h2><h3 id="3-3-1-常量中用-增加可读性"><a href="#3-3-1-常量中用-增加可读性" class="headerlink" title="3.3.1 常量中用_增加可读性"></a>3.3.1 常量中用<code>_</code>增加可读性</h3><p>为了提高可读性可以在数字之间加上下划线。 例如，十进制 <code>123_000</code>，十六进制 <code>0x2eff_abde</code>，科学十进制表示 <code>1_2e12</code> 都是有效的。</p>
<p>需要注意以下几点：</p>
<ul>
<li>下划线仅允许在两位数之间，并且不允许下划线连续出现。</li>
<li>添加到数字文字中下划线没有额外的语义，仅仅只是为了可读性.</li>
<li>下划线会被编译器忽略。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo&#123;</span><br><span class="line">    uint public count1 = 123_456_789; // 23503 gas</span><br><span class="line">    uint public count2 = 123_456_789; // 23493 gas</span><br><span class="line">    uint public count3 = 123456789; // 23537 gas</span><br><span class="line">    int public count4 = -123456789; // 23559 gas</span><br><span class="line">    int public count5 = -123_456_789; // 23471 gas</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过测试发现，带有<code>_</code>数字的变量，读取时候花费 gas 更少</p>
<h3 id="3-3-2-字面常量支持任意精度"><a href="#3-3-2-字面常量支持任意精度" class="headerlink" title="3.3.2 字面常量支持任意精度"></a>3.3.2 字面常量支持任意精度</h3><p>数值字面常量表达式本身支持任意精度，直到被转换成了非常量类型（例如，在常量变量表达式之外有运算，或发生了显示转换）。 这意味着在数值常量表达式中, 计算不会溢出而除法也不会截断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint8 public a = (2**800 + 1) - 2**800;</span><br><span class="line">    uint8 public b = 0.5 * 8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>(2**800 + 1) - 2**800</code> 的结果是字面常量 1 （属于 uint8 类型），尽管计算的中间结果已经超过了 以太坊虚拟机的机器字长度。 此外， <code>0.5 * 8</code> 的结果是整型 <code>4</code> （尽管有非整型参与了计算）。</p>
<p>⚠️: 数 值字面常量表达式只要在非字面常量表达式中使用就会转换成非字面常量类型。 在下面的例子中，尽管我们知道 b 的值是一个整数，但 <code>2.5 + a</code> 这部分表达式并不进行类型检查，因此编译不能通过。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint128 a = 1;</span><br><span class="line">uint128 b = 2.5 + a + 0.5;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3-除法截断"><a href="#3-3-3-除法截断" class="headerlink" title="3.3.3 除法截断"></a>3.3.3 除法截断</h3><p>注意除法截断: 在智能合约中，在 字面常量 会保留精度（保留小数位）。</p>
<p>整数的除法会被截断（例如：<code>1/4</code> 结果为 0）,但是使用字面量的方式不会被截断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract IntegerTest &#123;</span><br><span class="line">    function test1() public pure returns (uint256, uint256) &#123;</span><br><span class="line">        uint256 a = 1;</span><br><span class="line">        uint256 b = 4;</span><br><span class="line">        uint256 c1 = (1 / 4) * 4; // 1 =&gt; 未截断</span><br><span class="line">        uint256 c2 = (a / b) * b; // 0 =&gt; 截断</span><br><span class="line">        return (c1, c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释: 表达式 <code>type(int).min / (-1)</code> 是仅有的整除会发生向上溢出的情况。 在算术检查模式下，这会触发一个失败异常，在截断模式下，表达式的值将是 <code>type(int).min</code> 。</p>
<h3 id="3-3-4-优先使用较小类型计算"><a href="#3-3-4-优先使用较小类型计算" class="headerlink" title="3.3.4 优先使用较小类型计算"></a>3.3.4 优先使用较小类型计算</h3><p>虽然大多数运算符在字面常量运算时都会产生一个字面常量表达式，但有一些运算符并不遵循这种模式：</p>
<ul>
<li>三元运算符 <code>(... ? ... : ...)</code>,</li>
<li>数组下标访问 (<code>&lt;array&gt;[&lt;index&gt;]</code>).</li>
</ul>
<p>你可能认为像<code>255 + (true ? 1 : 0)</code> 或 <code>255 + [1, 2, 3][0]</code> 这样的表达式等同于直接使用 256 字面常量。 但事实上，它们是在 <code>uint8</code> 类型中计算的，会溢出。</p>
<h2 id="3-4-Fixed-定长浮点型"><a href="#3-4-Fixed-定长浮点型" class="headerlink" title="3.4 Fixed 定长浮点型"></a>3.4 Fixed 定长浮点型</h2><p>Solidity 还没有完全支持定长浮点型，可以声明定长浮点型的变量，但不能给它们赋值或把它们赋值给其他变量。。</p>
<p>可以通过用户定义的值类型的 wrap &#x2F; unwrap 来模拟出来，后面介绍用户自定义类型时候会介绍。</p>
<p><code>fixed / ufixed</code>：表示各种大小的有符号和无符号的定长浮点型。 在关键字 <code>ufixedMxN</code> 和 <code>fixedMxN</code> 中，<code>M</code> 表示该类型占用的位数，<code>N</code> 表示可用的小数位数。 <code>M</code> 必须能整除 8，即 8 到 256 位。 <code>N</code> 则可以是从 0 到 80 之间的任意数。</p>
<h2 id="3-5-BytesN-定长字节数组"><a href="#3-5-BytesN-定长字节数组" class="headerlink" title="3.5 BytesN 定长字节数组"></a>3.5 BytesN 定长字节数组</h2><p>定义方式 <code>bytesN</code>，其中 N 可取 <code>1~32</code> 中的任意整数;</p>
<p>bytes1 代表只能存储一个字节。</p>
<p>⚠ 注意：一旦声明，其内部的字节长度不可修改，内部字节不可修改。</p>
<p><code>bytesN</code>: 是定长的字节数组，是值类型</p>
<p><code>bytes</code>: 是变长字节数组，是引用类型。</p>
<h3 id="3-5-1-属性"><a href="#3-5-1-属性" class="headerlink" title="3.5.1 属性"></a>3.5.1 属性</h3><ul>
<li><pre><code class="solidity">length
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  （只读）返回字节个数，可以通过索引读取对应索引的字节。</span><br><span class="line"></span><br><span class="line">- 索引访问:</span><br><span class="line"></span><br><span class="line">  ```solidity</span><br><span class="line">  bytesN[index]</span><br></pre></td></tr></table></figure>

- index 取值范围`[0, N]`，其中 N 表示长度。
</code></pre>
</li>
<li><p>如果 <code>x</code> 是 <code>bytesI</code> 类型，那么 <code>x[k]</code> （其中 0 &lt;&#x3D; k &lt; I）返回第 k 个字节（只读）。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    // 固定长度的字节数组</span><br><span class="line">    bytes1 public a1 = 0x61;</span><br><span class="line">    bytes2 public a2 = 0x6100;</span><br><span class="line"></span><br><span class="line">    // length</span><br><span class="line">    uint256 public n1 = a1.length;</span><br><span class="line">    uint256 public n2 = a2.length;</span><br><span class="line"></span><br><span class="line">    // 索引</span><br><span class="line">    function getIndex(uint8 index_) public view returns(bytes1)&#123;</span><br><span class="line">        return a2[index_];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 不修可以修改,编译会报错</span><br><span class="line">    //function setIndex(uint8 index_,bytes1 value_) public view&#123;</span><br><span class="line">    //     a2[index_] = value_;</span><br><span class="line">    //&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-字符串字面常量及类型"><a href="#3-6-字符串字面常量及类型" class="headerlink" title="3.6 字符串字面常量及类型"></a>3.6 字符串字面常量及类型</h2><p>字符串字面常量只能包含可打印的 ASCII 字符，这意味着他是介于 0x20 和 0x7E 之间的字符。</p>
<p>字符串字面常量是指由双引号或单引号引起来的字符串（ <code>&quot;foo&quot;</code> 或者 <code>&#39;bar&#39;</code>）;</p>
<h3 id="3-6-1-字符串字面量"><a href="#3-6-1-字符串字面量" class="headerlink" title="3.6.1 字符串字面量"></a>3.6.1 字符串字面量</h3><p>转换: 和整数字面常量一样，字符串字面常量的类型也可以发生改变，它们可以隐式地转换成<code>bytes1</code>，……， <code>bytes32</code>，如果合适的话，还可以转换成 <code>bytes</code> 以及 <code>string</code>。</p>
<p>比如 <code>bytes1 public a8 = &quot;a&quot;;</code> 和 <code>bytes2 public b2 = &quot;a&quot;;</code>。字符串字面常量在赋值给 <code>bytesN</code> 时被解释为<strong>原始的字节形式</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    bytes1 public b1 = &quot;a&quot;;</span><br><span class="line">    string public b2 = &quot;a&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-2-转义字符"><a href="#3-6-2-转义字符" class="headerlink" title="3.6.2 转义字符"></a>3.6.2 转义字符</h3><p>但是我们写特殊字符串时候遇到一个问题，比如我想输出一个 <code>fo&quot;o</code>和<code>fo&#39;o</code> 的字符串就很难弄，因为莫认为<code>&quot;</code>和<code>&#39;</code> 是字符串的结尾。如果想要输出这种特殊的字符串，就需要转义字符了。</p>
<p>此外，字符串字面常量支持下面的转义字符：</p>
<ul>
<li><code>\&#39;</code> (单引号)</li>
<li><code>\&quot;</code> (双引号)</li>
<li><code>\\</code> (反斜杠)</li>
<li><code>\&lt;newline&gt;</code> (转义实际换行)</li>
<li><code>\b</code> (退格)</li>
<li><code>\f</code> (换页)</li>
<li><code>\n</code> (换行符)</li>
<li><code>\r</code> (回车)</li>
<li><code>\t</code> (标签 tab)</li>
<li><code>\v</code> (垂直标签)</li>
<li><code>\xNN</code> (十六进制转义，见下文)</li>
<li><code>\uNNNN</code> (unicode 转义，见下文)</li>
</ul>
<p><code>\xNN</code> 表示一个 16 进制值，最终转换成合适的字节，而 <code>\uNNNN</code> 表示 Unicode 编码值，最终会转换为 UTF-8 的序列。</p>
<p>问答题:下面字符串长度为多少字节？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    string public a1 = &quot;\n\&quot;&#x27;\\abc\def&quot;;</span><br><span class="line">    bytes32 public a2 = &quot;\n\&quot;&#x27;\\abc\def&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串长度为十个字节，它以换行符开头，后跟双引号，单引号，反斜杠字符，以及（没有分隔符）字符序列 <code>&quot;&#39;\abcdef</code> 。</p>
<h3 id="3-6-3-用空格分开的字符串"><a href="#3-6-3-用空格分开的字符串" class="headerlink" title="3.6.3 用空格分开的字符串"></a>3.6.3 用空格分开的字符串</h3><p>用空格分开的 <code>&quot;foo&quot; &quot;bar&quot;</code> 等效于 <code>&quot;foobar&quot;</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    string public a = &quot;a&quot; &quot;b&quot;;//ab</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-7-Unicode-字面常量"><a href="#3-7-Unicode-字面常量" class="headerlink" title="3.7 Unicode 字面常量"></a>3.7 Unicode 字面常量</h2><p>常规字符串文字只能包含 ASCII，而 Unicode 文字（以关键字 unicode 为前缀）可以包含任何有效的 UTF-8 序列。 它们还支持与转义序列完全相同的字符作为常规字符串文字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    string  public a = unicode&quot;同志们好&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-8-十六进制字面常量"><a href="#3-8-十六进制字面常量" class="headerlink" title="3.8 十六进制字面常量"></a>3.8 十六进制字面常量</h2><p>十六进制字面常量以关键字 <code>hex</code> 打头，后面紧跟着用单引号或双引号引起来的字符串（例如，<code>hex&quot;001122FF&quot;</code> ）。 字符串的内容必须是一个十六进制的字符串，它们的值将使用二进制表示。</p>
<h3 id="3-8-1-基本用法"><a href="#3-8-1-基本用法" class="headerlink" title="3.8.1 基本用法"></a>3.8.1 基本用法</h3><p>它们的内容必须是十六进制数字，可以选择使用单个下划线作为字节边界分隔符。 <strong>字面常量的值将是十六进制序列的二进制表示形式</strong>。</p>
<p>用空格分隔的多个十六进制字面常量被合并为一个字面常量： <code>hex&quot;61&quot; hex&quot;61&quot;</code> 等同于 <code>hex&quot;6161&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    bytes1 public a3 = 0x61;</span><br><span class="line">    bytes1 public a4 = hex&quot;61&quot;;</span><br><span class="line">    bytes2 public a = hex&quot;61&quot; hex&quot;61&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-9-Enum-枚举"><a href="#3-9-Enum-枚举" class="headerlink" title="3.9 Enum:枚举"></a>3.9 Enum:枚举</h2><p><code>enum</code> 是一种用户自定义类型，用于表示多种状态，枚举可用来创建由一定数量的“常量值”构成的自定义类型。主要作用是用于限制某个事务的有限选择。比如将咖啡的容量大小限制为：大、中、小，这将确保任何人不能购买其他容量的咖啡，只能在这里选择。</p>
<p>枚举默认值是第一个成员，所以<strong>枚举类型至少需要一个成员，枚举不能多于 256 个成员</strong>。枚举默认的类型为 <code>uint8</code>，当枚举数足够多时，它会自动变成 <code>uint16</code>..等变大。可以通过 remix 部署后，函数的输入值内查看类型 <code>uint8</code> &#x2F; <code>uint16</code></p>
<ul>
<li>枚举类型，返回值是索引，默认值是 0;</li>
<li>枚举类型的默认值是第一个值。<ul>
<li>枚举类型 enum 至少应该有一名成员。</li>
</ul>
</li>
<li>设置的时候，可以设置为索引，也可以对应的枚举名称;</li>
<li>枚举类型 enum 可以与整数进行显式转换，但不能进行隐式转换。<ul>
<li>显示转换会在运行时检查数值范围，如果不匹配，将会引起异常。</li>
</ul>
</li>
</ul>
<p><strong>例子</strong>:考虑一个限制，将交易的状态限制为：<code>None</code>&#x2F;<code>Pending</code>&#x2F;<code>Shiped</code>&#x2F;<code>Completed</code>&#x2F;<code>Rejected</code>&#x2F;<code>Canceled</code> 这几种。这将确保交易状态仅在列出的状态内。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Enum &#123;</span><br><span class="line">    // 枚举类型的默认值是第一个值。</span><br><span class="line">    // 结构</span><br><span class="line">    enum Status &#123;</span><br><span class="line">        None, // 0</span><br><span class="line">        Pending, // 1</span><br><span class="line">        Shiped,// 2</span><br><span class="line">        Completed,</span><br><span class="line">        Rejected,</span><br><span class="line">        Canceled</span><br><span class="line">    &#125;</span><br><span class="line">    // 变量</span><br><span class="line">    Status public status;</span><br><span class="line"></span><br><span class="line">    // 设置索引值</span><br><span class="line">    function set(Status _status) external &#123;</span><br><span class="line">        status = _status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 由于枚举类型不属于 |ABI| 的一部分，因此对于所有来自 Solidity 外部的调用，</span><br><span class="line">    // &quot;getStatus&quot; 的签名会自动被改成 &quot;getStatus() returns (uint8)&quot;。</span><br><span class="line">    function getStatus() public view returns (Status) &#123;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getDefaultStatus() public view returns (uint256) &#123;</span><br><span class="line">        return uint256(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置</span><br><span class="line">    function ship() external &#123;</span><br><span class="line">        status = Status.Shiped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 恢复为0</span><br><span class="line">    function reset() external &#123;</span><br><span class="line">        delete status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多人感觉 enum 很少用，一是因为应用场景确实比较窄，二是因为可以被其他数据类型所代替；但按照编码规范，限制选择范围场景，除了 bool 以外的，推荐使用 enum 类型来定义。</p>
<p>枚举是显示所有整型相互转换，但不允许隐式转换。从整型显式转换枚举，会在运行时检查整数时候在枚举范围内，否则会导致异常（ Panic 异常 ）。</p>
<p>枚举还可以在合约或库定义之外的文件级别上声明。</p>
<h3 id="3-9-1-方法"><a href="#3-9-1-方法" class="headerlink" title="3.9.1 方法"></a>3.9.1 方法</h3><ul>
<li><code>type(NameOfEnum).min</code></li>
<li><code>type(NameOfEnum).max</code></li>
</ul>
<p>使用 <code>type(NameOfEnum).min</code> 和 <code>type(NameOfEnum).max</code> 你可以得到给定枚举的最小值和最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Enum &#123;</span><br><span class="line">    // 枚举类型的默认值是第一个值。</span><br><span class="line">    enum Status &#123;</span><br><span class="line">        None,//0</span><br><span class="line">        Pending,//1</span><br><span class="line">        Shiped,//2</span><br><span class="line">        Completed,//3</span><br><span class="line">        Rejected,//4</span><br><span class="line">        Canceled// 5</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getLargestValue() public pure returns (Status) &#123;</span><br><span class="line">        return type(Status).max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getSmallestValue() public pure returns (Status) &#123;</span><br><span class="line">        return type(Status).min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-10-用户定义的值类型"><a href="#3-10-用户定义的值类型" class="headerlink" title="3.10 用户定义的值类型"></a>3.10 用户定义的值类型</h2><p>Solidity 允许在一个基本的值类型上创建一个零成本的抽象。这类似于一个别名，但有更严格的类型要求。</p>
<p>用户定义值类型使用 <code>type UserType is DefaultType</code> 来定义。</p>
<p>其中 <code>UserType</code> 是新引入的类型的名称， <code>DefaultType</code> 必须是内置的<strong>值类型</strong>（”底层类型”）。自定义类型的值的数据表示则继承自底层类型，并且 <strong>ABI 中也使用底层类型。</strong></p>
<p>⚠️: 用户定义的类型 <code>UserType</code> 没有任何运算符或绑定成员函数。即使是操作符 <code>==</code> 也没有定义。也不允许与其他类型进行显式和隐式转换。</p>
<h3 id="3-10-1-方法"><a href="#3-10-1-方法" class="headerlink" title="3.10.1  方法"></a>3.10.1  方法</h3><ul>
<li><code>UserType.wrap()</code>: 用来从底层类型转换到自定义类型</li>
<li><code>UserType.unwrap()</code>: 从自定义类型转换到底层类型。</li>
</ul>
<p>案例：一个 18 位小数、256 bit 的浮点类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 使用用户定义的值类型表示 18 位小数、256 bit的浮点类型。</span><br><span class="line">type UFixed256x18 is uint256;</span><br><span class="line"></span><br><span class="line">/// 在 UFixed256x18 上进行浮点操作的精简库。</span><br><span class="line">library FixedMath &#123;</span><br><span class="line">    uint constant multiplier = 10**18;</span><br><span class="line"></span><br><span class="line">    /// 两个 UFixed256x18 数相加，</span><br><span class="line">    /// 溢出时恢复，依赖于 uint256 上的检查算术</span><br><span class="line">     function add(UFixed256x18 a, UFixed256x18 b) internal pure returns (UFixed256x18) &#123;</span><br><span class="line">        return UFixed256x18.wrap(UFixed256x18.unwrap(a) + UFixed256x18.unwrap(b));</span><br><span class="line">    &#125;</span><br><span class="line">    /// 将 UFixed256x18 和 uint256 相乘.</span><br><span class="line">    /// 溢出时恢复，依赖于 uint256 上的检查算术</span><br><span class="line">     function mul(UFixed256x18 a, uint256 b) internal pure returns (UFixed256x18) &#123;</span><br><span class="line">        return UFixed256x18.wrap(UFixed256x18.unwrap(a) * b);</span><br><span class="line">    &#125;</span><br><span class="line">    ///  UFixed256x18 向下取整.</span><br><span class="line">    /// @return 不超过 `a` 的最大整数。</span><br><span class="line">    function floor(UFixed256x18 a) internal pure returns (uint256) &#123;</span><br><span class="line">        return UFixed256x18.unwrap(a) / multiplier;</span><br><span class="line">    &#125;</span><br><span class="line">    /// 将 uint256 转换为相同值的 UFixed256x18。</span><br><span class="line">    /// 如果整数太大，则还原。</span><br><span class="line">    function toUFixed256x18(uint256 a) internal pure returns (UFixed256x18) &#123;</span><br><span class="line">        return UFixed256x18.wrap(a * multiplier);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    uint256 a = 1;</span><br><span class="line">    uint256 b = 2;</span><br><span class="line"></span><br><span class="line">    function testAdd() external view returns (UFixed256x18) &#123;</span><br><span class="line">        return FixedMath.add(FixedMath.toUFixed256x18(a), FixedMath.toUFixed256x18(b));</span><br><span class="line">    &#125;</span><br><span class="line">    function testMul() external view returns (UFixed256x18) &#123;</span><br><span class="line">        return FixedMath.mul(FixedMath.toUFixed256x18(a),b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>UFixed256x18.wrap</code> 和 <code>FixedMath.toUFixed256x18</code> 的签名相同，但执行的是两个完全不同的操作：</p>
<ul>
<li><code>UFixed256x18.wrap</code> 函数返回一个与输入的数据表示相同的自定义值类型（<code>UFixed256x18</code>）。</li>
<li><code>FixedMath.toUFixed256x18</code>则返回一个具有相同数值的 <code>UFixed256x18</code> 。</li>
</ul>
<h1 id="值类型-地址类型"><a href="#值类型-地址类型" class="headerlink" title="值类型:地址类型"></a>值类型:地址类型</h1><p>地址分为外部地址和合约地址，每个地址都有<strong>一块持久化内存区</strong>称为存储。</p>
<p>地址类型也是值类型，因为比较特殊，所以单独拿出来讲。地址类型是 Solidity 语言独有的数据类型，表示以太坊的地址类型。用 address 表示地址，长度是 20 个字节</p>
<h2 id="4-1-地址字面常量"><a href="#4-1-地址字面常量" class="headerlink" title="4.1 地址字面常量"></a>4.1 地址字面常量</h2><p>通常的地址类型是 <code>0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac</code> 。 而没有通过校验测试, 长度在 39 到 41 个数字之间的十六进制字面常量，会产生一个错误, 比如 <code>0XFFD0D80C48F6C3C5387B7CFA7AA03970BDB926AC</code> 就是一个错误 address 类型，会提示正确的地址</p>
<h2 id="4-2-address-uint160-bytes32-之间的转换"><a href="#4-2-address-uint160-bytes32-之间的转换" class="headerlink" title="4.2 address&#x2F;uint160&#x2F;bytes32 之间的转换"></a>4.2 address&#x2F;uint160&#x2F;bytes32 之间的转换</h2><ul>
<li><p>1 字节 8 位，一个 address 是 20 个字节，是 160 位，所以 <strong>address 可以用 uint160 表示</strong>。</p>
</li>
<li><p>1 字节可以表示为两个连续的十六进制数字，所以 <strong>address 可以用连续的 40 个十六进制数字表示</strong>。</p>
</li>
<li><p>address 不允许任何算数操作</p>
<p>如果将使用较大字节数组类型转换为 <code>address</code> ，例如 <code>bytes32</code> ，那么 <code>address</code> 将被截断。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    bytes32 public a =</span><br><span class="line">        0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC;</span><br><span class="line"></span><br><span class="line">    // 0x111122223333444455556666777788889999aAaa</span><br><span class="line">    address public b = address(uint160(bytes20(a)));</span><br><span class="line"></span><br><span class="line">    // 0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc</span><br><span class="line">    address public c = address(uint160(uint256(a)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️：为了减少转换歧义，我们在转换中显式截断处理。 以 32bytes 值 <code>0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC</code> 为例， 如果使用 <code>address(uint160(bytes20(b)))</code> 结果是 <code>0x111122223333444455556666777788889999aAaa</code>， 而使用 <code>address(uint160(uint256(b)))</code> 结果是 <code>0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc</code> 。</p>
<h2 id="4-3-两种形式的地址"><a href="#4-3-两种形式的地址" class="headerlink" title="4.3 两种形式的地址"></a>4.3 两种形式的地址</h2><ul>
<li><code>address</code>：保存一个 20 字节的值（以太坊地址的大小）。</li>
<li><code>address payable</code> ：可支付地址，与 <code>address</code> 相同，不过有成员函数 <code>transfer</code> 和 <code>send</code> 。</li>
</ul>
<p>如果你需要 <code>address</code> 类型的变量，并计划发送以太币给这个地址，那么声明类型为 <code>address payable</code> 可以明确表达出你的需求。 同样，尽量更早对他们进行区分或转换。</p>
<p>这种区别背后的思想是 <code>address payable</code> 可以向其发送以太币，而不能向一个普通的 <code>address</code> 发送以太币。比如，它可能是一个智能合约地址，并且不支持接收以太币。</p>
<h3 id="两种形式的地址转换"><a href="#两种形式的地址转换" class="headerlink" title="两种形式的地址转换"></a>两种形式的地址转换</h3><p>允许从 <code>address payable</code> 到 <code>address</code> 的隐式转换，而从 <code>address</code> 到 <code>address payable</code> 必须显示的 通过 <code>payable(&lt;address&gt;)</code> 进行转换。也只能通过 <code>payable(...)</code> 表达式把 <code>address</code> 类型和合约类型转换为 <code>address payable</code>。</p>
<p>在介绍地址 payable 方法时候会具体介绍，转换的时候注意下面两个点：</p>
<ol>
<li>只有能接收以太币的合约类型，才能够进行此转换，合约要么有 receive 或可支付的回退函数。</li>
<li><code>payable(0)</code> 是有效的，这是此规则的例外。</li>
</ol>
<h2 id="4-4-地址属性"><a href="#4-4-地址属性" class="headerlink" title="4.4 地址属性"></a>4.4 地址属性</h2><p>address 拥有如下属性；</p>
<ol>
<li><p>.balance : 以 Wei 为单位的余额。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.balance    returns(uint256)</span><br></pre></td></tr></table></figure>
</li>
<li><p>.code : 地址上的代码(可以为空)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.code        returns(bytes memory)</span><br></pre></td></tr></table></figure>
</li>
<li><p>.codehash : 地址的 codehash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.codehash    returns(bytes32)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-4-1-balance-属性"><a href="#4-4-1-balance-属性" class="headerlink" title="4.4.1 balance 属性"></a>4.4.1 balance 属性</h3><p>获取地址的余额，wei 单位。如下例子是获取指定地址的 ETH 余额，和当前调用者的余额。（基于当前使用的网络）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function getBalance1(address addr) public view returns (uint256) &#123;</span><br><span class="line">        return addr.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    function getBalance2() external view returns (uint256) &#123;</span><br><span class="line">        return address(msg.sender).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>address(this).balance</code> 查询当前合约的余额，获取合约本身的 ETH 余额如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function getBalance() external view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️: 在版本 0.5.0 之前，Solidity 允许通过合约实例来访问地址的成员，例如 <code>this.balance</code> ，不过现在禁止这样做，必须显式转换为地址后访问，如： <code>address(this).balance</code> 。</p>
<h3 id="4-4-2-code-属性"><a href="#4-4-2-code-属性" class="headerlink" title="4.4.2 code 属性"></a>4.4.2 code 属性</h3><p>可以查询任何智能合约的部署代码。使用 <code>.code</code> 来获取 EVM 的字节码，其返回 <code>bytes memory</code> ，值可能是空。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function getCode() public view returns (bytes memory) &#123;</span><br><span class="line">        return address(this).code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 外部地址 code 内容是空，</span><br><span class="line">    // 可以通过这个来判断地址是否为合约</span><br><span class="line">    function getAdsCode(address a_) public view returns (bytes memory) &#123;</span><br><span class="line">        return address(a_).code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:合约没有完全创建，也就是 constructor 没有完全执行完的时候，code 也是空。</p>
<h3 id="4-4-3-codehash-属性"><a href="#4-4-3-codehash-属性" class="headerlink" title="4.4.3 codehash 属性"></a>4.4.3 codehash 属性</h3><p>使用 <code>.codehash</code> 获得合约代码的 <code>Keccak-256 哈希值</code> (为 bytes32 )。</p>
<p>注意， <code>addr.codehash</code> 比使用 <code>keccak256(addr.code)</code> 更便宜。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function getCode() public view returns (bytes memory) &#123;</span><br><span class="line">        return address(this).code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getCodeByKeccak256() public view returns (bytes32) &#123;</span><br><span class="line">        return keccak256(address(this).code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getCodehash() public view returns (bytes32) &#123;</span><br><span class="line">        return address(this).codehash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-地址方法"><a href="#4-5-地址方法" class="headerlink" title="4.5 地址方法"></a>4.5 地址方法</h2><p>address 拥有如下方法；</p>
<ol>
<li><code>address()</code>: 可以将地址转换到地址类型。</li>
<li><code>payable()</code>: 将普通地址转为可支付地址。</li>
<li><code>.transfer(uint256 amount)</code>: 将余额转到当前地址（合约地址转账）</li>
<li><code>.send(uint256 amount)</code>: 将余额转到当前地址，并<strong>返回交易成功状态</strong>（合约地址转账）</li>
<li><code>.call(bytes memory)</code>: 用给定的有效载荷（payload）发出低级 <code>CALL</code> 调用，并<strong>返回交易成功状态和返回数据</strong>（调用合约的方法并转账）</li>
<li><code>.delegatecall(bytes memory)</code>: 用给定有效载荷（payload）发出低级 <code>DELEGATECALL</code> 调用，返回交易成功状态和返回数据**（调用合约的方法并转账）</li>
<li><code>staticcall(bytes memory)</code>: 用给定的有效载荷（payload）发出低级 <code>STATICCALL</code> 调用，并<strong>返回交易成功状态和返回数据</strong>（调用合约的方法并转账）</li>
</ol>
<h3 id="4-5-1-address"><a href="#4-5-1-address" class="headerlink" title="4.5.1 address()"></a>4.5.1 address()</h3><p><strong>1.获取当前合约地址:address(this)</strong></p>
<p><strong>2.uint 值转换成地址</strong></p>
<h3 id="4-5-2-payable"><a href="#4-5-2-payable" class="headerlink" title="4.5.2 payable()"></a>4.5.2 payable()</h3><p>注意：支付的时候，地址必须 <code>payable</code> 类型！从 <code>address</code> 到 <code>address payable</code> 的转换。可以通过 <code>payable(x)</code> 进行 ，其中 <code>x</code> 必须是 <code>address</code> 类型。</p>
<p>让普通地址为 payable 有两种方式</p>
<ul>
<li><p>方式一: 参数中 地址标注 address payable ,并且函数状态可变性标为payable</p>
<ul>
<li>这种更省 gas (<strong>推荐</strong>)</li>
</ul>
</li>
<li><p>方式二: 仅在内部进行 <code>payable(address)</code> 显示转换</p>
</li>
</ul>
<h3 id="4-5-3-transfer"><a href="#4-5-3-transfer" class="headerlink" title="4.5.3 transfer()"></a>4.5.3 transfer()</h3><p>将余额转到当前地址（合约地址转账）,语法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address payable&gt;.transfer(uint256 amount)</span><br></pre></td></tr></table></figure>

<ol>
<li>需要 payable address</li>
<li>使用固定（不可调节）的 2300 gas 的矿工费，错误会 reverts （回滚所有状态）<ol>
<li>2300 gas 足够转账，但是如果接收合约内的 <code>fallback</code> 和 <code>receive</code> 函数有恶意代码，复杂代码。容易导致 gas 耗尽的错误。</li>
</ol>
</li>
<li>失败时抛出异常<ol>
<li>如果当前合约的余额不够多，则 <code>transfer</code> 函数会执行失败，或者如果以太转移被接收帐户拒绝， <code>transfer</code> 函数同样会失败而进行回退。</li>
</ol>
</li>
<li>如果目标地址是一个合约，那么目标合约内部的 receive&#x2F;fallback 函数会随着调用 <code>transfer</code>函数一起执行，这是 EVM 的特性，没办法阻止。</li>
</ol>
<h3 id="4-5-4-send"><a href="#4-5-4-send" class="headerlink" title="4.5.4 send()"></a>4.5.4 send()</h3><p>将余额转到当前地址，并<strong>返回交易成功状态</strong>（合约地址转账）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;address payable&gt;.send(uint256 amount) returns (bool)</span><br><span class="line">send` 是 `transfer` 的低级版本。如果执行失败，当前的合约不会因为异常而终止。`transfer` 等价于`require(send())</span><br></pre></td></tr></table></figure>

<ol>
<li><p>需要 payable address</p>
</li>
<li><p>使用固定（不可调节）的 2300 gas 的矿工费。</p>
<ol>
<li>gas 同<code>transfer</code>一样的是 2300 gas ；足够转账，但是如果接收合约内的 <code>fallback</code> 和 <code>receive</code> 函数有恶意代码，复杂代码。容易导致 gas 耗尽的错误。</li>
</ol>
</li>
<li><p>失败时仅会返回false,不会终止执行（合约地址转账）;</p>
<ol>
<li><code>send()</code> 执行有一些风险：为了保证安全，必须检查 send 的返回值，如果交易失败，会回退以太币。</li>
</ol>
</li>
<li><p>补充：send 与 transfer 对应，但 <strong>send 更底层</strong>。如果执行失败，transfer 会因异常停止，而 send 会返回 false,transfer 相对 send 较安全</p>
</li>
</ol>
<h3 id="4-5-5-call-delegatecall-staticcall"><a href="#4-5-5-call-delegatecall-staticcall" class="headerlink" title="4.5.5 call&#x2F;delegatecall&#x2F;staticcall"></a>4.5.5 call&#x2F;delegatecall&#x2F;staticcall</h3><p>为了与不知道 ABI 的合约进行交互，Solidity 提供了函数 <code>call</code>&#x2F;<code>delegatecall</code>&#x2F;<code>staticcall</code> 直接控制编码。它们都带有一个 <code>bytes memory</code> 参数和返回执行<strong>成功状态</strong>（bool）和<strong>数据</strong>（bytes memory）。</p>
<p>函数 <code>abi.encode</code>，<code>abi.encodePacked</code>，<code>abi.encodeWithSelector</code> 和 <code>abi.encodeWithSignature</code> 可用于编码结构化数据。</p>
<p><strong>它们可以接受任意类型，任意数量的参数</strong>。这些参数会被打包到以 32 字节为单位的连续区域中存放。其中一个<strong>例外是当第一个参数被编码成正好 4 个字节的情况</strong>。 在这种情况下，这个参数后边不会填充后续参数编码，以允许使用函数签名。</p>
<p>下面具体的介绍三种 call。</p>
<h4 id="4-5-5-1-call"><a href="#4-5-5-1-call" class="headerlink" title="4.5.5.1 call()"></a>4.5.5.1 call()</h4><p>用给定的有效载荷（payload）发出低级 <code>CALL</code> 调用，并<strong>返回交易成功状态和返回数据</strong>（调用合约的方法并转账）, 格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.call(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>低级CALL调用：不需要 payable address, 普通地址即可</p>
<ol>
<li>注意: 调用 <code>call</code> 的时候，地址可以不具备 payable 属性</li>
</ol>
</li>
<li><p>返回两个参数，一个 <code>bool</code> 值代表成功或者失败，另外一个是可能存在的 <code>data</code></p>
</li>
<li><p>发送所有可用 gas，也可以自己调节 gas。</p>
<ol>
<li>如果 <code>fallback</code> 和 <code>receive</code> 内的代码相对复杂也可以，但是如果是恶意代码，需要考虑消耗的 gas 是否值得执行。</li>
<li><code>_ads.call&#123;value: msg.value,gas:2300&#125;(data)</code></li>
</ol>
</li>
<li><p>当合约调用合约时，不知道对方源码和 ABI 时候，可以使用 call 调用对方合约</p>
</li>
<li><p>推荐使用 call 转账 ETH，但是不推荐使用 call 来调用其他合约。</p>
<ol>
<li>原因是: call 调用的时候，将合约控制权交给对方，如果碰到恶意代码，或者不安全的代码就很容易凉凉。</li>
</ol>
</li>
<li><p>当调用不存在的合约方法时候，会触发对方合约内的fallback或receive</p>
<ol>
<li>我们的合约也可以在 <code>fallback</code> &#x2F; <code>receive</code> 这两个方法内抛出事件，查看是否有人对其做了什么操作。</li>
</ol>
</li>
<li><p>三种方法都提供 <code>gas</code> 选项，而 <code>value</code> 选项仅 <code>call</code> 支持 。三种 call 里只有 <code>call</code> 可以进行 ETH 转账，其他两种不可以进行转账。</p>
</li>
</ol>
<p><strong>例子 （重要）：调用其他合约方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test1 &#123;</span><br><span class="line">    string public name;</span><br><span class="line">    uint256 public age;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function setNameAndAge(string memory name_, uint256 age_)</span><br><span class="line">        external</span><br><span class="line">        payable</span><br><span class="line">        returns (string memory __name, uint256 __age)</span><br><span class="line">    &#123;</span><br><span class="line">        name = name_;</span><br><span class="line">        age = age_;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        return (name_, age_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CallTest &#123;</span><br><span class="line">    // 需要一个网页，动态的解析 _bys</span><br><span class="line">    bytes public bys;</span><br><span class="line"></span><br><span class="line">    function call_Test1_setNameAndAge(</span><br><span class="line">        address ads_,</span><br><span class="line">        string memory name_,</span><br><span class="line">        uint256 age_</span><br><span class="line">    ) external payable &#123;</span><br><span class="line">        bytes memory data = abi.encodeWithSignature(</span><br><span class="line">            &quot;setNameAndAge(string,uint256)&quot;,</span><br><span class="line">            name_,</span><br><span class="line">            age_</span><br><span class="line">        );</span><br><span class="line">        (bool success, bytes memory _bys) = ads_.call&#123;value: msg.value&#125;(data);</span><br><span class="line">        require(success, &quot;Call Failed&quot;);</span><br><span class="line">        bys = _bys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说下这个例子的原理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    普通调用:用户A 调用 CallTest 合约, 发送 100 wei ; </span><br><span class="line">    CallTest 调用 Test1, 发送 50 wei此时在 Test1 合约内部</span><br><span class="line">        msg.sender = CallTest</span><br><span class="line">        msg.value = 50</span><br><span class="line">        Test1 内部如果有状态变量修改，则会被修改</span><br><span class="line">        发送到 Test1 内的ETH主币也会被留在Test1内</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h4 id="4-5-5-2-delegatecall-委托调用"><a href="#4-5-5-2-delegatecall-委托调用" class="headerlink" title="4.5.5.2 delegatecall() 委托调用"></a>4.5.5.2 delegatecall() 委托调用</h4><p>发出低级函数 <code>DELEGATECALL</code>，失败时返回 false，发送所有可用 gas，也可以自己调节 gas。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.delegatecall(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure>

<p><code>delegatecall</code> 使用方法和 <code>call</code> 完全一样。区别在于，<code>delegatecall</code> 只调用给定地址的代码（函数），其他状态属性如（存储，余额 …）都来自当前合约。<code>delegatecall</code> 的目的是使用另一个合约中的库代码。</p>
<p>委托调用是：<strong>委托对方调用自己数据的</strong>。类似授权转账，比如我部署一个 Bank 合约， 授权 ContractA 使用 Bank 地址内的资金，ContractA 只拥有控制权，但是没有拥有权。</p>
<ul>
<li>委托调用后，所有变量修改都是发生在委托合约内部，并不会保存在被委托合约中。<ul>
<li>利用这个特性，可以通过更换被委托合约，来升级委托合约。</li>
</ul>
</li>
<li>委托调用合约内部，需要和被委托合约的内部参数完全一样，否则容易导致数据混乱<ul>
<li>可以通过顺序来避免这个问题，但是推荐完全一样</li>
</ul>
</li>
</ul>
<p><strong>例子 1（重要）</strong></p>
<p>代码如下:</p>
<ul>
<li><code>DelegateCall</code> 是委托合约</li>
<li><code>TestVersion1</code> 是第 1 次被委托合约</li>
<li><code>TestVersion2</code> 是第 2 次被委托合约</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 合约版本 V.1</span><br><span class="line">contract TestVersion1 &#123;</span><br><span class="line">    address public sender;</span><br><span class="line">    uint256 public value;</span><br><span class="line">    uint256 public num;</span><br><span class="line"></span><br><span class="line">    function set(uint256 num_) external payable &#123;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">        value = msg.value;</span><br><span class="line">        num = num_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 合约版本 V.2</span><br><span class="line">contract TestVersion2 &#123;</span><br><span class="line">    address public sender;</span><br><span class="line">    uint256 public value;</span><br><span class="line">    uint256 public num;</span><br><span class="line"></span><br><span class="line">    function set(uint256 num_) external payable &#123;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">        value = msg.value;</span><br><span class="line">        num = num_ * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 委托调用测试</span><br><span class="line">contract DelegateCall &#123;</span><br><span class="line">    address public sender;</span><br><span class="line">    uint256 public value;</span><br><span class="line">    uint256 public num;</span><br><span class="line"></span><br><span class="line">    function set(address _ads, uint256 num_) external payable &#123;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">        value = msg.value;</span><br><span class="line">        num = num_;</span><br><span class="line">        // 第1种 encode</span><br><span class="line">        // 不需知道合约名字，函数完全自定义</span><br><span class="line">        bytes memory data1 = abi.encodeWithSignature(&quot;set(uint256)&quot;, num_);</span><br><span class="line">        // 第2种 encode</span><br><span class="line">        // 需要合约名字，可以避免函数和参数写错</span><br><span class="line">        bytes memory data2 = abi.encodeWithSelector(TestVersion1.set.selector, num_);</span><br><span class="line"></span><br><span class="line">        (bool success, bytes memory _data) = _ads.delegatecall(data2);</span><br><span class="line"></span><br><span class="line">        require(success, &quot;DelegateCall set failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说下这个例子的原理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    委托调用</span><br><span class="line">    用户A 调用 DelegateCall 合约, 发送 100 wei ; DelegateCall 委托调用 Test1</span><br><span class="line">    此时在 Test1 合约内部</span><br><span class="line">        msg.sender = A</span><br><span class="line">        msg.value = 100</span><br><span class="line">        Test1 内部如果有状态变量修改，也不会被修改，会在DelegateCallB 内改变</span><br><span class="line">        发送到 Test1 内的ETH主币，会被留在 DelegateCallB 内，不会在Test1 内</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h4 id="4-5-5-3-staticcall-静态调用"><a href="#4-5-5-3-staticcall-静态调用" class="headerlink" title="4.5.5.3 staticcall() 静态调用"></a>4.5.5.3 staticcall() 静态调用</h4><p>用给定的有效载荷（payload）发出低级 <code>STATICCALL</code> 调用，并<strong>返回交易成功状态和返回数据</strong>（调用合约的方法并转账）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.staticcall(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure>

<p>它与 call 基本相同，发送所有可用 gas，也可以自己调节 gas，<strong>但如果被调用的函数以任何方式修改状态变量，都将回退</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 被调用的合约</span><br><span class="line">contract Hello1 &#123;</span><br><span class="line">    function echo() external pure returns (string memory) &#123;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hello2 &#123;</span><br><span class="line">    uint8 public a;</span><br><span class="line">    function echo() external returns (string memory) &#123;</span><br><span class="line">        a = 1;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用者合约</span><br><span class="line">contract SoldityTest &#123;</span><br><span class="line">    function callHello(address ads_) external view returns (string memory) &#123;</span><br><span class="line">        // 编码被调用者的方法签名</span><br><span class="line">        bytes4 methodId = bytes4(keccak256(&quot;echo()&quot;));</span><br><span class="line"></span><br><span class="line">        // 调用合约</span><br><span class="line">        (bool success, bytes memory data) = ads_.staticcall(</span><br><span class="line">            abi.encodeWithSelector(methodId)</span><br><span class="line">        );</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            return abi.decode(data, (string));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;error&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-三种-call-的总结"><a href="#4-6-三种-call-的总结" class="headerlink" title="4.6 三种 call 的总结"></a>4.6 三种 call 的总结</h3><ol>
<li><code>call</code> ， <code>delegatecall</code> 和 <code>staticcall</code> 都是非常低级的函数，应该只把它们当作最后一招来使用，它们破坏了 Solidity 的类型安全性。</li>
<li>三种方法都提供 <code>gas</code> 选项，而 <code>value</code> 选项仅 <code>call</code> 支持 。所以三种 call 里只有 <code>call</code> 可以进行 ETH 转账，其他两种不可以进行转账。</li>
<li>不管是读取状态还是写入状态，最好避免在合约代码中硬编码使用的 gas 值。这可能会引入<strong>错误</strong>，而且 gas 的消耗也是动态改变的。</li>
<li>如果在通过低级函数 <code>delegatecall</code> 发起调用时需要访问存储中的变量，那么这两个合约的存储布局需要一致，以便被调用的合约代码可以正确地通过变量名访问合约的存储变量。 这不是指在库函数调用（高级的调用方式）时所传递的存储变量指针需要满足那样情况。</li>
</ol>
<blockquote>
<p>⚠️ 注意: 在 0.5.0 版本以前, <code>.call</code>, <code>.delegatecall</code> and <code>.staticcall</code> 仅仅返回成功状态，没有返回值。</p>
</blockquote>
<blockquote>
<p>⚠️ 在 0.5.0 版本以前, 还有一个 <code>callcode</code> 函数，现在已经去除。</p>
</blockquote>
<h3 id="4-7-transfer-send-call-三种转账的总结"><a href="#4-7-transfer-send-call-三种转账的总结" class="headerlink" title="4.7 transfer &#x2F; send &#x2F; call 三种转账的总结"></a>4.7 transfer &#x2F; send &#x2F; call 三种转账的总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function byTransfer() public &#123;</span><br><span class="line">        payable(msg.sender).transfer(100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bySend() public &#123;</span><br><span class="line">        bool success = payable(msg.sender).send(100);</span><br><span class="line">        require(success, &quot;Send Fail&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果使用 transfer 或 send 函数必须添加fallback回退函数</span><br><span class="line">    fallback() external &#123;&#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>低级CALL调用<strong>不需要<code>payable address</code></strong>,transfer 和 send <strong>只能是 <code>payable address</code></strong></p>
<p>call的 gas 可以动态调整,transfer 和 send 只能是固定制 <code>2300</code></p>
<p>call除了可以转账外，可以还可以调用不知道 ABI 的方法，还可以调用的时候转账</p>
<ul>
<li>当调用不存在的合约方法时候，会触发对方合约内的 <code>fallback</code> 或者 <code>receive</code>。</li>
<li>如果使用 <code>_to.call&#123;value: 100&#125;(data)</code>，那么<code>data</code>中被调用的方法必须添加 <code>payable</code> 修饰符，否则转账失败！</li>
<li>因为可以调用方法，所以 call 有两个参数，除了一个 <code>bool</code> 值代表成功或者失败，另外一个是可能存在的 <code>data</code>，比如创建合约时候得到部署的地址，调用函数时候得到的函数放回值</li>
</ul>
<h3 id="4-8-注意事项"><a href="#4-8-注意事项" class="headerlink" title="4.8 注意事项"></a>4.8 注意事项</h3><p>使用 send 有很多危险：如果调用栈深度已经达到 1024（这总是可以由调用者所强制指定），转账会失败；并且如果接收者用光了 gas，转账同样会失败。为了保证以太币转账安全，总是检查 send 的返回值，利用 transfer 或者下面更好的方式： 用这种接收者取回钱的模式。</p>
<p><strong>call</strong>:在执行另一个合约函数时，应该尽可能避免使用 .call() ，因为它绕过了类型检查，函数存在检查和参数打包。</p>
<p>由于 EVM 会把对一个不存在的合约的调用作为是成功的。 Solidity 会在执行外部调用时使用 extcodesize 操作码进行额外检查。 这确保了即将被调用的合约要么实际存在（它包含代码）或者触发一个异常。低级调用不 包括这个检查，<strong>这使得它们在 GAS 方面更便宜，但也更不安全</strong>。</p>
<p>上面的这三个 call 方法都是底层的消息传递调用，最好仅在万不得已才进行使用，因为他们破坏了 Solidity 的类型安全。</p>
<h1 id="值类型-合约类型"><a href="#值类型-合约类型" class="headerlink" title="值类型:合约类型"></a>值类型:合约类型</h1><p>⚠️ 注意：合约不支持任何运算符。</p>
<h2 id="5-1-合约的属性"><a href="#5-1-合约的属性" class="headerlink" title="5.1 合约的属性"></a>5.1 合约的属性</h2><p>合约类型的成员是合约的外部函数及 public 的 状态变量。</p>
<p>对于合约 C 可以使用 type(C) 获取合约的类型信息，获得合约名</p>
<ul>
<li><pre><code class="solidity">type(C).name
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```solidity</span><br><span class="line">  type(C).creationCode</span><br></pre></td></tr></table></figure>

- 获得包含创建合约字节码的内存字节数组。
- 该值和合约内使用 `address(this).code;` 结果一样。
- 它可以在内联汇编中构建自定义创建例程，尤其是使用 `create2` 操作码。
- 不能在合约本身或派生的合约访问此属性。 因为会引起循环引用。
</code></pre>
</li>
<li><pre><code class="solidity">type(C).runtimeCode
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 获得合约的运行时字节码的内存字节数组。这是通常由 `C` 的构造函数部署的代码。</span><br><span class="line">  - 如果 `C` 有一个使用内联汇编的构造函数，那么可能与实际部署的字节码不同。</span><br><span class="line">  - 还要注意库在部署时修改其运行时字节码以防范定期调用（guard against regular calls）。 与 `.creationCode` 有相同的限制，不能在合约本身或派生的合约访问此属性。 因为会引起循环引用。</span><br><span class="line"></span><br><span class="line"># 引用类型的额外注解:数据位置</span><br><span class="line"></span><br><span class="line">在讲引用类型之前，先介绍数据位置。这是因为在 Solidity 中，引用类型是由简单数据类型组合而成，相比于简单的值类型，这些类型通常通过名称引用。这些类型涉及到的数据量较大，复制它们可能要消耗大量 Gas，所以我们在使用引用数据类型时，必须考虑存储位置。我们需要仔细考虑数据是保存在内存中，还是在 EVM 存储区中。这就是线介绍数据位置的原因。</span><br><span class="line"></span><br><span class="line">**注意：所有的引用类型，都有数据位置这个额外的注解来指定存储在哪里，所以一定要掌握好。**</span><br><span class="line"></span><br><span class="line">## 6.1 数据位置的基础介绍</span><br><span class="line"></span><br><span class="line">在合约中声明和使用的变量都有一个数据位置，合约变量的数据位置将会影响 Gas 消耗量。</span><br><span class="line"></span><br><span class="line">Solidity 提供的有三种如下数据位置。</span><br><span class="line"></span><br><span class="line">- 存储 storage : 状态变量保存的位置，只要合约存在就一直存储．</span><br><span class="line">- 内存 memory : 即数据在内存中，因此数据仅在其生命周期内（函数调用期间）有效。不能用于外部调用。</span><br><span class="line">- 调用数据 calldata : 用来保存函数参数的特殊数据位置，是一个**只读位置**。</span><br><span class="line">  - 调用数据 calldata 是不可修改的、非持久的函数参数存储区域，效果大多类似 内存 memory 。</span><br><span class="line">  - 主要用于外部函数的参数，但也可用于其他变量，无论外部内部函数都可以使用。</span><br><span class="line"></span><br><span class="line">核心：更改数据位置或类型转换将始终产生自动进行一份拷贝，而在同一数据位置内（对于 存储 storage 来说）的复制仅在某些情况下进行拷贝。</span><br><span class="line"></span><br><span class="line">### 6.1.1 storage</span><br><span class="line"></span><br><span class="line">```solidity</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract DataLocation &#123;</span><br><span class="line">    // storage</span><br><span class="line">    uint256 stateVariable = 1;</span><br><span class="line">    uint256[] stateArray = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">    // uint storage stateVariable; // Expected identifier but got &#x27;storage&#x27;</span><br><span class="line">    // uint[] memory stateArray; // Expected identifier but got &#x27;memory&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>该存储位置存储永久数据，这意味着该数据可以被合约中的所有函数访问。可以把它视为计算机的硬盘数据，所有数据都永久存储。保存在存储区(storage)中的变量，以智能合约的状态存储，并且在函数调用之间保持持久性。与其他数据位置相比，存储区数据位置的成本较高。</p>
<p>storage 是永久存储在以太坊区块链中，更具体地说存储在存储 Merkle Patricia 树中，<strong>形成帐户状态信息的一部分</strong>。一旦使用这个类型，数据将永远存在。</p>
<p><strong>重点:状态变量总是存储在存储区(storage)中,并且不能显式地标记状态变量的位置。</strong>。状态变量是强制为 storage。</p>
<h3 id="6-1-2-memory"><a href="#6-1-2-memory" class="headerlink" title="6.1.2  memory"></a>6.1.2  memory</h3><p>内存位置是临时数据，比存储位置便宜。它只能在函数中访问。通常，内存数据用于保存临时变量，以便在函数执行期间进行计算。一旦函数执行完毕，它的内容就会被丢弃。你可以把它想象成每个单独函数的内存(RAM)。</p>
<p>memory：<strong>存储在内存中，即分配、即使用，越过作用域则不可访问，等待被回收</strong>。</p>
<h5 id="重点-1-函数参数-包括返回参数-都存储在内存中。"><a href="#重点-1-函数参数-包括返回参数-都存储在内存中。" class="headerlink" title="重点 1:函数参数(包括返回参数)都存储在内存中。"></a><strong>重点 1:函数参数(包括返回参数)都存储在内存中。</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract DataLocation &#123;</span><br><span class="line">    function add(uint256 num1, uint256 num2)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256 result)</span><br><span class="line">    &#123;</span><br><span class="line">        return num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中: 函数参数 <code>uint num1</code> 与 <code>uint num2</code>，返回值 <code>uint result</code> 都存储在内存中。</p>
<h5 id="重点-2-引用类型的局部变量，需要显式指定数据位置-storage-memory"><a href="#重点-2-引用类型的局部变量，需要显式指定数据位置-storage-memory" class="headerlink" title="重点 2:引用类型的局部变量，需要显式指定数据位置(storage&#x2F;memory)"></a><strong>重点 2:引用类型的局部变量，需要显式指定数据位置(storage&#x2F;memory)</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Locations &#123;</span><br><span class="line">    struct Book &#123;</span><br><span class="line">        string title;</span><br><span class="line">        string author;</span><br><span class="line">        uint256 book_id;</span><br><span class="line">    &#125;</span><br><span class="line">    Book public java; // 一本 java 书</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function test() public &#123;</span><br><span class="line">        /* 此处都是局部变量  */</span><br><span class="line">        // 值类型:所以它们被存储在内存中</span><br><span class="line">        bool flag = true;</span><br><span class="line">        uint256 number = 1;</span><br><span class="line">        address account = 0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac;</span><br><span class="line">        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff)));</span><br><span class="line"></span><br><span class="line">        // Data location can only be specified for array, struct or mapping types,</span><br><span class="line">        // but &quot;memory&quot; was given.</span><br><span class="line">        // bool memory flag2; // 错误:值类型的数据不能标示 memory</span><br><span class="line"></span><br><span class="line">        // 引用类型:需要显示指定数据位置，此处指定为内存</span><br><span class="line">        uint256[] memory localArray; // array</span><br><span class="line">        // uint8[] memory nums = [1, 2, 3]; // 内存中不能创建动态数组</span><br><span class="line">        uint8[3] memory numsFixed = [1, 2, 3];</span><br><span class="line">        uint256[] memory a = new uint256[](5); // 推荐</span><br><span class="line">        a[1] = 1;</span><br><span class="line">        a[2] = 2;</span><br><span class="line">        a[3] = 3;</span><br><span class="line">        a[4] = 4;</span><br><span class="line"></span><br><span class="line">        string memory myStr = &quot;hello&quot;; // string</span><br><span class="line"></span><br><span class="line">        // 映射不能在函数中动态创建，您必须从状态变量中分配它们。</span><br><span class="line">        // mapping(address =&gt; bool) memory myMapping;</span><br><span class="line">        mapping(address =&gt; uint256) storage ref = balances; // mapping</span><br><span class="line">        java = Book(&#123;title: &quot;Solidity&quot;, author: &quot;Anbang&quot;, book_id: 1&#125;); // struct</span><br><span class="line">        bytes memory bc = bytes(&quot;!&quot;); //</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>mapping 和 struct 类型，不能在函数中动态创建，必须从状态变量中分配它们。</li>
<li>内存中不能创建动态数组</li>
</ul>
<h5 id="重点-3-函数的输入和输出参数如果是数组-使用-memory"><a href="#重点-3-函数的输入和输出参数如果是数组-使用-memory" class="headerlink" title="重点 3:函数的输入和输出参数如果是数组,使用 memory"></a><strong>重点 3:函数的输入和输出参数如果是数组,使用 memory</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract DataLocations &#123;</span><br><span class="line">    // name_ 是 string ，所以使用 memory</span><br><span class="line">    // mm_ 是 uint256[] ，所以使用 memory</span><br><span class="line">    // 输出相同，也是使用 memory</span><br><span class="line">    function examples2(string memory name_, uint256[] memory mm_)</span><br><span class="line">        external</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256[] memory memArr, string memory myName)</span><br><span class="line">    &#123;</span><br><span class="line">        memArr = new uint256[](mm_.length);</span><br><span class="line">        myName = name_;</span><br><span class="line">        for (uint256 index = 0; index &lt; mm_.length; index++) &#123;</span><br><span class="line">            memArr[index] = mm_[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="重点-4-引用类型的局部变量-指定-storage-和-memory-的区别"><a href="#重点-4-引用类型的局部变量-指定-storage-和-memory-的区别" class="headerlink" title="重点 4:引用类型的局部变量:指定 storage 和 memory 的区别"></a><strong>重点 4:引用类型的局部变量:指定 storage 和 memory 的区别</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract DataLocations &#123;</span><br><span class="line">    struct MyStruct &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint256 age;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(address =&gt; MyStruct) public myStructs;</span><br><span class="line"></span><br><span class="line">    function test1() external returns (MyStruct memory) &#123;</span><br><span class="line">        myStructs[msg.sender] = MyStruct(&#123;name: &quot;Anbang1&quot;, age: 18&#125;);</span><br><span class="line"></span><br><span class="line">        // storage 会修改状态变量</span><br><span class="line">        MyStruct storage myStruct1 = myStructs[msg.sender];</span><br><span class="line">        myStruct1.age++;</span><br><span class="line">        return myStruct1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test2() external returns (MyStruct memory) &#123;</span><br><span class="line">        myStructs[msg.sender] = MyStruct(&#123;name: &quot;Anbang2&quot;, age: 18&#125;);</span><br><span class="line"></span><br><span class="line">        // memory 函数运行完后即消失，修改的值也不会储存在状态变量中</span><br><span class="line">        MyStruct memory myStruct2 = myStructs[msg.sender];</span><br><span class="line">        myStruct2.age++;</span><br><span class="line">        return myStruct2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>storage</code>修改引用数据: 会修改状态变量</li>
<li><code>memory</code>修改引用数据: 函数运行完后即消失，修改的值也不会储存在状态变量中</li>
</ul>
<h3 id="6-1-3-calldata"><a href="#6-1-3-calldata" class="headerlink" title="6.1.3  calldata"></a>6.1.3  calldata</h3><p>calldata 是不可修改的非持久性数据位置，所有传递给函数的值，都存储在这里。此外，<code>calldata</code> 是外部函数(external function)的参数的默认位置。外部函数(external function)的参数存储在 calldata 中。函数的返回值中也可以使用 calldata 数据位置的数组和结构，但是无法给其分配空间。</p>
<ul>
<li><strong>要点: calldata 只能用在函数的输入和输出参数中</strong></li>
<li><strong>要点: calldata 用在输入参数中，比 memorg 更省 gas</strong></li>
<li><strong>要点: calldata 的参数不允许修改，但是 memorg 参数允许修改</strong></li>
</ul>
<p>存储函数参数，它是只读的，不会永久存储的一个数据位置。外部函数(external function)的参数被强制指定为 calldata，效果与 memory 类似。</p>
<blockquote>
<p>注解: 如果可以的话，请尽量使用 calldata 作为数据位置，因为它将避免复制，并确保不能修改数据。</p>
</blockquote>
<h3 id="6-1-4-stack"><a href="#6-1-4-stack" class="headerlink" title="6.1.4 stack"></a>6.1.4 stack</h3><p>堆栈是由 EVM (Ethereum 虚拟机)维护的非持久性数据。EVM 使用堆栈数据位置在执行期间加载变量。堆栈位置最多有 1024 个级别的限制。</p>
<h3 id="6-1-5-小结"><a href="#6-1-5-小结" class="headerlink" title="6.1.5 小结"></a>6.1.5 小结</h3><p>按照关键字:</p>
<ul>
<li>storage: 存储区: 状态变量总是储存在<strong>存储区</strong>上</li>
<li>memory: 内存区: 局部变量使用，只在内存中生效。<ul>
<li>值类型的局部变量，存储在<strong>内存</strong>中。</li>
<li><strong>引用类型局部变量，需要显式地指定数据位置</strong>。</li>
<li>函数的输入参数如果是数组或者 string，必须是 <code>memory</code> 或 <code>calldata</code></li>
<li>内存中的数组必须是定长数组（不能使用 push 赋值），动态数组只能储存在状态变量中。</li>
</ul>
</li>
<li>calldata<ul>
<li>和 memory 类似，但是 calldata 只能用在函数的输入参数中。</li>
<li>相比使用 memory ,合约输入参数如果使用 calldata, 可以节约 gas</li>
</ul>
</li>
</ul>
<p>按照函数参数:</p>
<ul>
<li>内部函数参数: (包括返回参数)都存储在<strong>memory（内存）</strong>中。</li>
<li>外部函数参数: (不包括返回参数)存储在 <code>calldata</code> 中。</li>
</ul>
<h2 id="6-2-不同数据位置之间的赋值规则"><a href="#6-2-不同数据位置之间的赋值规则" class="headerlink" title="6.2 不同数据位置之间的赋值规则"></a>6.2 不同数据位置之间的赋值规则</h2><p>本小节总结如下:</p>
<ol>
<li><p>将存储变量赋值给存储变量</p>
<ul>
<li><code>值 类 型</code>: 创建一个新副本。</li>
<li><code>引用类型</code>: 创建一个新副本。</li>
</ul>
</li>
<li><p>将内存变量赋值给存储变量</p>
<ul>
<li><code>值 类 型</code>: 创建一个新副本。</li>
<li><code>引用类型</code>: 创建一个新副本。</li>
</ul>
</li>
<li><p>将存储变量赋值给内存变量</p>
<ul>
<li><code>值 类 型</code>: 创建一个新副本。</li>
<li><code>引用类型</code>: 创建一个新副本。</li>
</ul>
</li>
<li><p>将内存变量赋值给内存变量 (同类型)</p>
<ul>
<li><p><code>值 类 型</code>: 创建一个新副本。</p>
</li>
<li><p><code>引用类型</code>: 不会创建副本。(<strong>重要</strong>)</p>
</li>
</ul>
</li>
</ol>
<h2 id="6-3-calldata-和-memeory-区别"><a href="#6-3-calldata-和-memeory-区别" class="headerlink" title="6.3 calldata 和 memeory 区别"></a>6.3 calldata 和 memeory 区别</h2><p><strong>函数调用函数时的区别</strong>: <code>calldata可以隐式转换为memory</code></p>
<ul>
<li>calldata 参数可以隐式转换为 memory</li>
<li>memory 参数不可以隐式转换为 calldata</li>
</ul>
<h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><ul>
<li><p>array</p>
<ul>
<li>基本类型组成的数组集合。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint256[5] public T1 = [1, 2, 3, 4, 5];</span><br><span class="line">address[5] public A = [0xff...6ac];</span><br><span class="line">byte[5] public A = [0xff...6ac];</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串与 bytes 是特殊的数组，所以也是引用类型</li>
</ul>
</li>
<li><p>string: 是一个动态尺寸的 utf-8 编码字符串</p>
<ul>
<li>他其实是一个特殊的可变字节数组，同时其也是一个引用类型</li>
</ul>
</li>
<li><p>bytes: 动态十六进制字节数组</p>
<ul>
<li>bytes 类似于 <code>byte[]</code>，但它在 calldata 中被紧密地打包。因此，相比于 <code>byte[]</code>，bytes 应该优先使用，因为更便宜。</li>
<li>string 等价于 bytes，但不允许长度或索引访问。</li>
</ul>
</li>
<li><p>mapping</p>
</li>
<li><p>struct：为了允许 evm 的优化，请确保 storage 中的变量和 <code>struct</code> 成员的书写顺序允许它们被紧密地打包。例如，应该按照 <code>uint128，uint128，uint256</code> 的顺序来声明状态变量，而不是使用 <code>uint128，uint256，uint128</code>，因为前者只占用两个存储插槽，而后者将占用三个。</p>
</li>
</ul>
<h2 id="7-1-array-数组"><a href="#7-1-array-数组" class="headerlink" title="7.1 array 数组"></a>7.1 array 数组</h2><p>数组是存储<strong>同类元素的有序集合</strong>。数组声明时可以是固定大小的，也可以是动态调整长度。</p>
<p>下面是 array 的总结:</p>
<ul>
<li><p>声明和初始化数组</p>
<ul>
<li>数组元素可以是任何类型，包括映射或结构体。对类型的限制是映射只能存储在存储 storage 中，并且公开访问函数的参数需要是 ABI 类型。</li>
</ul>
</li>
<li><p>访问和修改数组元素</p>
<ul>
<li><pre><code class="solidity">arr[_index]
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 通过索引进行获取特定元素</span><br><span class="line"></span><br><span class="line">  - 可以通过索引修改值</span><br><span class="line"></span><br><span class="line">  - 状态变量标记 `public` 的数组，Solidity 创建一个 `getter函数` 。 下标的索引数字就是 `getter函数` 的参数。</span><br><span class="line"></span><br><span class="line">  - 访问超出数组长度的元素会导致异常（assert 类型异常 ）。 可以使用 .push() 方法在末尾追加一个新元素，其中 .push() 追加一个零初始化的元素并返回对它的引用。</span><br><span class="line"></span><br><span class="line">- 函数中返回数组</span><br><span class="line"></span><br><span class="line">  - 如果想把数组全部返回，需要通过函数进行操作。在函数中返回数组</span><br><span class="line"></span><br><span class="line">- 动态数组和定长数组</span><br><span class="line"></span><br><span class="line">  - 动态数组只能存在于状态变量中</span><br><span class="line">  - 内存中只能创建定长数组</span><br><span class="line"></span><br><span class="line">- 创建内存数组</span><br><span class="line"></span><br><span class="line">  - 对于 storage 数组，元素可以是任意类型(其他数组、映射或结构)。</span><br><span class="line">  - 对于 memory 数组，元素类型不能是映射类型，如果它是一个 public 函数的参数，那么元素类型必须是 ABI 类型。</span><br><span class="line"></span><br><span class="line">- 数组的属性</span><br><span class="line"></span><br><span class="line">  - `length`: 获取数组的长度</span><br><span class="line"></span><br><span class="line">- 数组的方法</span><br><span class="line"></span><br><span class="line">  - push : 只有动态数组可以使用，只能用在动态数组上</span><br><span class="line">  - pop: 删除最后一个长度，只能用在动态数组上</span><br><span class="line">  - delete: 清空对应的索引；清空不是删除，并不会改变长度，索引位置的值会改为默认值。</span><br><span class="line">  - 数组切片: `x[start:end]`</span><br><span class="line"></span><br><span class="line">### 7.1.1 数组的创建</span><br><span class="line"></span><br><span class="line">数组长度上分为 **固定长度数组** 和 **可变长度数组**，类型上分为**一维数组**和**多维数组**；</span><br><span class="line"></span><br><span class="line">一个元素类型为 `T`，固定长度为 `k` 的数组可以声明为 `T[k]`，而动态数组声明为 `T[]`。</span><br><span class="line"></span><br><span class="line">```solidity</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    // 固定长度数组</span><br><span class="line">    address[5] public A =   [0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac];</span><br><span class="line">    uint256[10] public arr1 = [0, 1, 2]; // 赋值的数组长度不超过10都可以</span><br><span class="line">    uint256[10] public arr2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br><span class="line">    </span><br><span class="line">    //先声明再赋值</span><br><span class="line">    uint256[10] public arr1;</span><br><span class="line">    function test() external &#123;</span><br><span class="line">        arr1[0] = 1;</span><br><span class="line">        arr1[1] = 10;</span><br><span class="line">        arr1[2] = 100;</span><br><span class="line">        arr1[9] = 900;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 可变长度数组</span><br><span class="line">    /*</span><br><span class="line">         用方式 2 创建数组时，若数组为成员变量, 则默认为 storage 类型；</span><br><span class="line">         若为局部变量默认为 `memory` 类型，`memory` 类型的数组，必须声明长度，并且长度创建后不可变。</span><br><span class="line">         `push` 方法不能用在 `memeory` 的数组上,只能逐个索引的赋值。</span><br><span class="line">     */</span><br><span class="line">    uint256[] public T1 = [1, 2, 3, 4, 5]; // 方式 1</span><br><span class="line">    uint256[] public T2 = new uint256[](5); // 方式 2</span><br><span class="line">    </span><br><span class="line">    //二维数组:创建（注意这里跟其它语言比，数组长度的声明位置是反的）</span><br><span class="line">    uint256[2][3] public T = [[1, 2], [3, 4], [5, 6]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>如果能使用定长数组，就使用定长数组，因为它很便宜。</strong></p>
<h3 id="7-1-2-数组常量"><a href="#7-1-2-数组常量" class="headerlink" title="7.1.2 数组常量"></a>7.1.2 数组常量</h3><p>正常看到下方代码应该没什么问题，但是注意:函数 s 中数组类型是<code>uint256</code>，而函数 t 中输入的数组类型是<code>uint8</code>, 这里需要将 uint8 转换一下<code>s([uint256(1), uint256(2)]);</code>;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract T &#123;</span><br><span class="line">    function s(uint256[2] memory _arr) public &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function t() public &#123;</span><br><span class="line">        // s([1, 2]); // 默认这么写不行的 ❌</span><br><span class="line">        s([uint256(1), uint256(2)]); // ✅</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能转成小的类型，就不会转成大的，这是数组常量的<strong>懒惰性</strong>。如下是一个比较经典的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract T &#123;</span><br><span class="line">    int8[2] public a = [1, -1];</span><br><span class="line">    // int8[2] public a = [int8(1), -1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组常量 <code>[1, -1]</code> 是无效的，因为第一个表达式类型是 <code>uint8</code> 而第二个类似是 <code>int8</code> 他们不可以隐式的相互转换。 为了确保可以运行，你是可以使用例如： <code>[int8(1), -1]</code> 。</p>
<p>由于不同类型的固定大小的内存数组不能相互转换(尽管基础类型可以)，如果你想使用二维数组常量，你必须显式地指定一个基础类型:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function f() public pure returns (uint24[2][4] memory) &#123;</span><br><span class="line">        // 下面代码无法工作，因为没有匹配内部类型</span><br><span class="line">        // uint[2][4] memory x = [[0x1, 1], [0xffffff, 2], [0xff, 3], [0xffff, 4]];</span><br><span class="line"></span><br><span class="line">        uint24[2][4] memory x = [</span><br><span class="line">            [uint24(0x1), 1],</span><br><span class="line">            [0xffffff, 2],</span><br><span class="line">            [uint24(0xff), 3],</span><br><span class="line">            [uint24(0xffff), 4]</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-1-2-数组的属性"><a href="#7-1-2-数组的属性" class="headerlink" title="7.1.2 数组的属性"></a>7.1.2 数组的属性</h3><h5 id="length数组有-length-属性表示当前数组的长度。-一经创建，内存-memory-数组的大小就是固定的（但却是动态的，也就是说，它可以根据运行时的参数创建）。"><a href="#length数组有-length-属性表示当前数组的长度。-一经创建，内存-memory-数组的大小就是固定的（但却是动态的，也就是说，它可以根据运行时的参数创建）。" class="headerlink" title="length数组有 length 属性表示当前数组的长度。 一经创建，内存 memory 数组的大小就是固定的（但却是动态的，也就是说，它可以根据运行时的参数创建）。"></a>length数组有 <code>length</code> 属性表示当前数组的长度。 一经创建，内存 memory 数组的大小就是固定的（但却是动态的，也就是说，它可以根据运行时的参数创建）。</h5><p><strong>通过 <code>arr.length</code> 获取数组的长度</strong></p>
<p><strong>不能通过设置 <code>arr.length</code> 来调整动态数组的长度。</strong></p>
<h3 id="7-1-3-数组的方法"><a href="#7-1-3-数组的方法" class="headerlink" title="7.1.3 数组的方法"></a>7.1.3 数组的方法</h3><ul>
<li><p>push : 只有动态数组可以使用，动态的 storage 数组以及bytes类型可以用，string类型不可以</p>
<ul>
<li><code>push()</code>: 它用来添加新的零初始化元素到数组末尾，并返回元素引用.因此可以这样：<code>x.push().t = 2</code> 或 <code>x.push() = b</code>.</li>
<li><code>push(x)</code>: 用来在数组末尾添加一个给定的元素，这个函数没有返回值．</li>
</ul>
</li>
<li><p><code>pop:</code> 删除最后一个长度</p>
<ul>
<li>它用来从数组末尾删除元素。 同样的会在移除的元素上隐含调用 delete 。</li>
</ul>
</li>
<li><p><code>delete</code>: 删除对应的索引；删除并不会改变长度，索引位置的值会改为默认值。</p>
</li>
<li><p><code>x[start:end]</code>: 数组切片，仅可使用于 <code>calldata</code> 数组.</p>
</li>
</ul>
<h2 id="7-2-bytes"><a href="#7-2-bytes" class="headerlink" title="7.2.bytes"></a>7.2.bytes</h2><p><code>string</code> 和 <code>bytes</code> 类型的变量是特殊的数组。 <code>bytes</code> 可以通过索引或者<code>.length</code>来访问数据。string 与 bytes 相同，但不允许用<code>.length</code>或索引来访问数据。</p>
<ul>
<li>对任意长度的原始字节数据使用 <code>bytes</code>，对任意长度字符串（UTF-8）数据使用 <code>string</code> 。</li>
<li>如果使用一个长度限制的字节数组，应该使用一个 <code>bytes1</code> 到 <code>bytes32</code> 的具体类型，因为它们便宜得多。</li>
<li><code>bytesN[]</code> 和 <code>bytes</code> 可以转换: bytes1 是值类型，比如 <code>0x61</code>; <code>bytes</code>是可变字节数组,如果 bytes1 想要借用 bytes 的方法，就需要转换成 bytes;</li>
</ul>
<h3 id="7-2-1-创建"><a href="#7-2-1-创建" class="headerlink" title="7.2.1 创建"></a>7.2.1 创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    bytes public welcome = bytes(&quot;1.Welcome&quot;);</span><br><span class="line">    bytes public temp1 = new bytes(2); // 可变字节数组创建方式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-2-bytes-和-bytes32-区别"><a href="#7-2-2-bytes-和-bytes32-区别" class="headerlink" title="7.2.2 bytes 和 bytes32[] 区别"></a>7.2.2 bytes 和 bytes32[] 区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// bytes / bytes32 / bytes32[] 区别</span><br><span class="line">// bytes:可变字节数组 ： 引用类型</span><br><span class="line">// bytes32: 固定长度的字节数组 ： 值类型</span><br><span class="line">// bytes32[]: 由“固定长度的字节数组” 组成的 数组类型</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    bytes public welcome1 = bytes(&quot;1.Welcome&quot;);</span><br><span class="line">    bytes32 public welcome2 = &quot;a&quot;;</span><br><span class="line">    bytes32[] public welcome3 = [bytes32(&quot;a&quot;)];</span><br><span class="line"></span><br><span class="line">    bytes32[] public abcArray = [bytes1(&quot;a&quot;), bytes1(&quot;b&quot;), bytes1(&quot;c&quot;)];</span><br><span class="line"></span><br><span class="line">    // 0x616263</span><br><span class="line">    bytes public abcBytes = bytes(&quot;abc&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>abcBytes</code> 的值是: <code>0x616263</code>;</p>
<p><code>abcArray</code> 的值是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    0x6100000000000000000000000000000000000000000000000000000000000000,</span><br><span class="line">    0x6200000000000000000000000000000000000000000000000000000000000000,</span><br><span class="line">    0x6300000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><code>bytes</code> 有点类似于 <code>bytes1[]</code>的紧打包，我们可以把上面例子中 bytes32 改为 bytes1 类型进行对比。</p>
<p>我们更多时候应该使用 <code>bytes</code> 而不是 <code>bytes32[]</code>这种数组类型 ，因为 Gas 费用更低;</p>
<ul>
<li><code>bytes32[]</code> 会在元素之间添加 31 个填充字节。</li>
<li><code>bytes</code> 由于紧密包装，这没有填充字节。</li>
</ul>
<h3 id="7-2-3-属性"><a href="#7-2-3-属性" class="headerlink" title="7.2.3  属性"></a>7.2.3  属性</h3><ul>
<li><p>获取 bytes 长度</p>
<ul>
<li>bytesVar.length:以字节长度表示字符串的长度</li>
</ul>
</li>
<li><p>获取指定索引的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes1 temp1 = bytes(welcome)[_index]; // 返回固定长度的 bytes1</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-2-4-方法"><a href="#7-2-4-方法" class="headerlink" title="7.2.4 方法"></a>7.2.4 方法</h3><h4 id="bytes-concat-拼接"><a href="#bytes-concat-拼接" class="headerlink" title="bytes.concat 拼接"></a>bytes.concat 拼接</h4><ul>
<li><code>bytes.concat(...) returns (bytes memory)</code></li>
<li><code>bytes.concat( )</code>返回空数组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    bytes public concatBytes = bytes.concat();</span><br><span class="line">    bytes public welcome = bytes(&quot;a&quot;);</span><br><span class="line">    bytes public concatBytes = bytes.concat(welcome, bytes(&quot;b&quot;), bytes1(&quot;c&quot;),&quot;a&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="push-方法"><a href="#push-方法" class="headerlink" title="push 方法"></a>push 方法</h4><p>注意： push 是单个字节，是 <code>bytes1</code>的固定长度,而不是 <code>bytes</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    bytes public welcome1 = bytes(&quot;Welcome&quot;);</span><br><span class="line">    bytes public welcome2 = new bytes(10);</span><br><span class="line"></span><br><span class="line">    function testPush() public &#123;</span><br><span class="line">        welcome1.push(bytes(&quot;A&quot;)[0]);</span><br><span class="line">        welcome2.push(bytes1(&quot;B&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pop-方法"><a href="#pop-方法" class="headerlink" title="pop 方法"></a>pop 方法</h4><p>删除数组的最后一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    bytes public welcome1 = bytes(&quot;Welcome&quot;);</span><br><span class="line">    bytes public welcome2 = new bytes(10);</span><br><span class="line"></span><br><span class="line">    function testPop() public &#123;</span><br><span class="line">        welcome1.pop();</span><br><span class="line">        welcome2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="delete-清空字节数组"><a href="#delete-清空字节数组" class="headerlink" title="delete 清空字节数组"></a>delete 清空字节数组</h4><p>使用 <code>delete</code> 全局关键字;</p>
<ul>
<li><code>delete bytesName</code></li>
<li><code>delete bytesName[index]</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    bytes public welcome1 = bytes(&quot;Welcome&quot;);</span><br><span class="line"></span><br><span class="line">    function deleteAll() public &#123;</span><br><span class="line">        delete welcome1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deleteIndex(uint256 index_) public &#123;</span><br><span class="line">        delete welcome1[index_];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="x-start-end-数组切片"><a href="#x-start-end-数组切片" class="headerlink" title="x[start:end]:数组切片"></a><code>x[start:end]</code>:数组切片</h4><p>注意：数组切片只能用在 calldata 类型上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Proxy &#123;</span><br><span class="line">    bytes public welcome1 = bytes(&quot;Welcome&quot;);</span><br><span class="line">    bytes4 public temp1 = bytes4(welcome1); // 0x57656c63</span><br><span class="line"></span><br><span class="line">    // 把 welcome1 的值传入参数</span><br><span class="line">    function forward(bytes calldata payload)</span><br><span class="line">        external pure</span><br><span class="line">        returns(bytes memory temp2,bytes4 temp3)</span><br><span class="line">    &#123;</span><br><span class="line">        // 切片方法只能用在 calldata 上。</span><br><span class="line">        temp2 = payload[:4];</span><br><span class="line">        temp3 = bytes4(payload[:4]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-5-字符串-到-bytes-的转换"><a href="#7-2-5-字符串-到-bytes-的转换" class="headerlink" title="7.2.5 字符串 到 bytes 的转换"></a>7.2.5 字符串 到 bytes 的转换</h3><p>转换方法: 可以使用 <code>bytes()</code> 构造函数将字符串转换为 <code>bytes</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function trans(string memory _str) external pure returns (bytes memory) &#123;</span><br><span class="line">        return bytes(_str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-6-bytes-到-字符串-的转换"><a href="#7-2-6-bytes-到-字符串-的转换" class="headerlink" title="7.2.6 bytes 到 字符串 的转换"></a>7.2.6 bytes 到 字符串 的转换</h3><p>转换方法: 可以使用 <code>string()</code> 构造函数将 <code>bytes</code> 转换为字符串。</p>
<p>注意: 字节数组分为动态大小和固定大小的。如果是固定大小字节数组，需要先转为动态大小字节数组。</p>
<ul>
<li><code>动态大小字节数组</code> —&gt; <code>string</code></li>
<li><code>固定大小字节数组</code> —&gt; <code>动态大小字节数组</code> —&gt; <code>string</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    string public data1;</span><br><span class="line">    string public data2;</span><br><span class="line"></span><br><span class="line">    // `动态大小字节数组` —&gt; `string`</span><br><span class="line">    function trans1() external &#123;</span><br><span class="line">        bytes memory bstr = new bytes(2);</span><br><span class="line">        bstr[0] = &quot;a&quot;;</span><br><span class="line">        bstr[1] = &quot;b&quot;;</span><br><span class="line">        data1 = string(bstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // `固定大小字节数组` —&gt; `动态大小字节数组` —&gt; `string`</span><br><span class="line">    function trans2() external &#123;</span><br><span class="line">        // 固定大小字节数组</span><br><span class="line">        bytes2 ab = 0x6162;</span><br><span class="line"></span><br><span class="line">        // `固定大小字节数组` —&gt; `动态大小字节数组`</span><br><span class="line">        bytes memory temp = new bytes(ab.length); // 可变字节数组创建方式</span><br><span class="line">        for (uint256 i = 0; i &lt; ab.length; i++) &#123;</span><br><span class="line">            temp[i] = ab[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // `动态大小字节数组` —&gt; `string`</span><br><span class="line">        data2 = string(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-string"><a href="#7-3-string" class="headerlink" title="7.3 string"></a>7.3 string</h2><p>Solidity 中，字符串值使用双引号(<code>&quot;&quot;</code>)或单引号(<code>&#39;&#39;</code>)包括，字符串类型用 string 表示。<code>string</code> 和 <code>bytes</code> 类型的变量是特殊的数组，是引用类型。</p>
<h3 id="7-3-1-格式"><a href="#7-3-1-格式" class="headerlink" title="7.3.1 格式"></a>7.3.1 格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract For &#123;</span><br><span class="line">    string public a = &quot;a&quot; &quot;b&quot; &quot;c&quot;;</span><br><span class="line">    string public b = &quot;abc&quot;;</span><br><span class="line">    string public c = &#x27;x&#x27; &#x27;y&#x27; &#x27;z&#x27;;</span><br><span class="line">    string public d = &#x27;xyz&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-2-属性"><a href="#7-3-2-属性" class="headerlink" title="7.3.2 属性"></a>7.3.2 属性</h3><p>string 并没有获取其字符串长度的 length 属性; 也没提供获取某个索引字节码的索引属性。</p>
<p>我们可以通过把 string 转换成 <code>bytes</code>，借助<code>bytes</code> 的属性。</p>
<p>例子: 下面是使用 <code>getLength()</code> 获取长度，使用<code>modi()</code>修改字符串，使用 <code>getIndexValue()</code> 获取字符串的指定索引的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    string public welcome = &quot;1.Welcome&quot;;</span><br><span class="line"></span><br><span class="line">    function getLength() public view returns (uint256 welcomeLength) &#123;</span><br><span class="line">        welcomeLength = bytes(welcome).length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getIndexValue(uint256 _index) public view returns (string memory) &#123;</span><br><span class="line">        bytes1 temp1 = bytes(welcome)[_index]; // 返回固定长度的 bytes1</span><br><span class="line">        bytes memory temp2 = new bytes(1); // 可变字节数组创建方式</span><br><span class="line">        temp2[0] = temp1;</span><br><span class="line">        return string(temp2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function modi() public &#123;</span><br><span class="line">        bytes(welcome)[0] = bytes1(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-3-方法"><a href="#7-3-3-方法" class="headerlink" title="7.3.3 方法"></a>7.3.3 方法</h3><p>Solidity string 本身并没有操作函数，需要借助全局的函数</p>
<ul>
<li>字符串拼接<ul>
<li><code>string.concat()</code></li>
<li>如果不使用参数调用 string.concat 将返回空数组。</li>
</ul>
</li>
<li>将 bytes 转换到字符串<ul>
<li><code>string()</code></li>
</ul>
</li>
<li>将 字符串 转换到 bytes<ul>
<li><code>bytes()</code></li>
</ul>
</li>
<li>比较两个字符串<ul>
<li><code>keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))</code></li>
<li><code>keccak256(bytes(s1)) == keccak256(bytes(s2))</code>:更省 gas</li>
</ul>
</li>
</ul>
<p><strong>string.concat</strong>:可以使用 <code>string.concat</code> 连接任意数量的 string 字符串。 该函数返回一个 <code>string memory</code> ，包含所有参数的内容，无填充方式拼接在一起。 如果你想使用不能隐式转换为 string 的其他类型作为参数，你需要先把它们转换为 string。</p>
<p>输入字符串，输出拼接后的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    string public welcome = &quot;Welcome&quot;;</span><br><span class="line"></span><br><span class="line">    // 写一个 welcome username 的小方法</span><br><span class="line">    // Welcome Anbang!</span><br><span class="line">    function test(string memory name_)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns(string memory concatString)&#123;</span><br><span class="line">            bytes memory bs = bytes(&quot;!&quot;);</span><br><span class="line">            // welcome + name_ + bs</span><br><span class="line">            // 内部是使用字符串，如果是bytes，需要转换为 string 类型</span><br><span class="line">            concatString = string.concat(</span><br><span class="line">                welcome,</span><br><span class="line">                name_,</span><br><span class="line">                string(bs)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你不使用参数调用 <code>string.concat</code> 或 <code>bytes.concat</code> 将返回空数组。</p>
<h2 id="7-4-mapping-映射"><a href="#7-4-mapping-映射" class="headerlink" title="7.4 mapping 映射"></a>7.4 mapping 映射</h2><p>mapping 可以看作一个哈希表，会执行虚拟化初始化，使所有可能的值都是该类型的默认值。其实 mapping 并不是一个哈希表，没有 key 集合，也没有 value 集合，所以 mapping 没办法遍历&#x2F;迭代。</p>
<p>数组中找某一个值需要循环遍历，这是很消耗 Gas 的，而使用 mapping 就可以很好的解决这个问题。映射可以很方便的获取某个值。映射并没有做迭代的方法。</p>
<h3 id="7-4-1本节重点"><a href="#7-4-1本节重点" class="headerlink" title="7.4.1本节重点"></a>7.4.1本节重点</h3><p>声明映射类型的语法：<code>mapping(_KeyType =&gt; _ValueType)</code></p>
<p><code>_KeyType</code>：可以是任何内置类型，或者 bytes 和 字符串,键是唯一的，其赋值方式为：<code>map[a]=test</code>; 意思是键为 a,值为 test；</p>
<p><code>_ValueType</code>： 可以是任何类型，用户自定义类型也可以。</p>
<p>mapping 支持嵌套,映射的数据位置(data location)只能是 <code>storage</code>，通常用于状态变量,mapping不能用于public</p>
<p>函数的参数或返回结果</p>
<ul>
<li>映射只能是 storage 的数据位置，因此只允许作为状态变量 或 作为函数内的 storage 引用 或 作为库函数的参数。它们不能用<strong>合约公有函数的参数或返回值</strong>。</li>
<li>这些限制同样适用于包含映射的数组和结构体。</li>
</ul>
<p><strong>问答题：为什么映射不能像哈希表一样遍历？</strong></p>
<p>映射与哈希表不同的地方：<strong>在映射中,并不存储 key，而是存储它的 <code>keccak256</code> 哈希值，从而便于查询实际的值</strong>。正因为如此，映射是没有长度的，也没有 <code>key 的集合</code>或 <code>value 的集合</code>的概念。映射只能是存储的数据位置，因此只允许作为状态变量或作为函数内的存储引用 或 作为库函数的参数。</p>
<h3 id="7-4-2-创建格式"><a href="#7-4-2-创建格式" class="headerlink" title="7.4.2 创建格式"></a>7.4.2 创建格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Mapping &#123;</span><br><span class="line">    // 普通</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line">    // 嵌套</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; bool)) public friends;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-3-如何获取-设置-删除"><a href="#7-4-3-如何获取-设置-删除" class="headerlink" title="7.4.3 如何获取-设置-删除"></a>7.4.3 如何获取-设置-删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Mapping &#123;</span><br><span class="line">    // 普通</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    // 嵌套</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; bool)) public friends;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        balances[msg.sender] = 100;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function blanceGet() external view returns (uint256) &#123;</span><br><span class="line">        // 获取</span><br><span class="line">        return balances[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function blanceSet(uint256 amount) external &#123;</span><br><span class="line">        // 设置</span><br><span class="line">        balances[msg.sender] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function blanceDelete() external &#123;</span><br><span class="line">        // 删除</span><br><span class="line">        delete balances[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function friendGet() external view returns (bool) &#123;</span><br><span class="line">        // 获取</span><br><span class="line">        return friends[msg.sender][address(0)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function friendSet() external &#123;</span><br><span class="line">        // 设置</span><br><span class="line">        friends[msg.sender][address(0)] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function friendDelete() external &#123;</span><br><span class="line">        // 删除</span><br><span class="line">        delete friends[msg.sender][address(0)];</span><br><span class="line">        // delete friends[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-4-作为局部变量的使用"><a href="#7-4-4-作为局部变量的使用" class="headerlink" title="7.4.4 作为局部变量的使用"></a>7.4.4 作为局部变量的使用</h3><p><code>mapping</code> 类型可以用做局部变量，但只能引用状态变量，而且存储位置为 storage。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 作为局部变量的使用</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // 普通 mapping</span><br><span class="line">    mapping(address =&gt; uint256) public balances; // 普通mapping</span><br><span class="line"></span><br><span class="line">    // storage: 改变内部 ref，会影响 balances 的值</span><br><span class="line">    // 不能声明为 memory</span><br><span class="line">    function updataBalance() public returns(uint256)&#123;</span><br><span class="line">        // mapping(address=&gt;uint256) memory ref = balances; // ❌</span><br><span class="line">        mapping(address=&gt;uint256) storage ref = balances;</span><br><span class="line">        ref[msg.sender] += 3;</span><br><span class="line">        return ref[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-5-在-ERC20-token-中的用法"><a href="#7-4-5-在-ERC20-token-中的用法" class="headerlink" title="7.4.5 在 ERC20 token 中的用法"></a>7.4.5 在 ERC20 token 中的用法</h3><p>下面的例子是ERC20 token的简单版本 <code>._allowances</code> 是一个嵌套 mapping 的例子 <code>._allowances</code> 用来记录其他的账号，可以允许从其账号使用多少数量的币．</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// mapping 在 ERC20 token 中的用法</span><br><span class="line">contract MappingExample &#123;</span><br><span class="line">    // 余额</span><br><span class="line">    mapping(address =&gt; uint256) private _balances;</span><br><span class="line">    // 授权:</span><br><span class="line">    // 授权人 - 代理人 - 授权金额</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line">    event Approval(</span><br><span class="line">        address indexed owner,</span><br><span class="line">        address indexed spender,</span><br><span class="line">        uint256 value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 获取：授权金额</span><br><span class="line">    function allowance(address owner, address spender)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        return _allowances[owner][spender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查：授权金额大于等于需要操作的金额</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address sender,</span><br><span class="line">        address recipient,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) public returns (bool) &#123;</span><br><span class="line">        require(</span><br><span class="line">            _allowances[sender][msg.sender] &gt;= amount,</span><br><span class="line">            &quot;ERC20: Allowance not high enough.&quot;</span><br><span class="line">        );</span><br><span class="line">        _allowances[sender][msg.sender] -= amount; // 设置额度</span><br><span class="line">        _transfer(sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置：</span><br><span class="line">    function approve(address spender, uint256 amount) public returns (bool) &#123;</span><br><span class="line">        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">        _allowances[msg.sender][spender] = amount;</span><br><span class="line">        emit Approval(msg.sender, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _transfer(</span><br><span class="line">        address sender,</span><br><span class="line">        address recipient,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) internal &#123;</span><br><span class="line">        require(sender != address(0), &quot;ERC20: transfer from the zero address&quot;);</span><br><span class="line">        require(recipient != address(0), &quot;ERC20: transfer to the zero address&quot;);</span><br><span class="line">        require(_balances[sender] &gt;= amount, &quot;ERC20: Not enough funds.&quot;);</span><br><span class="line"></span><br><span class="line">        _balances[sender] -= amount;</span><br><span class="line">        _balances[recipient] += amount;</span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-6-可迭代映射"><a href="#7-4-6-可迭代映射" class="headerlink" title="7.4.6 可迭代映射"></a>7.4.6 可迭代映射</h3><p>遍历所有 Mapping 内的数据，（Mapping 配合 array ）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line">    // 用于检查:地址是否已经存在于 balancesKey</span><br><span class="line">    mapping(address =&gt; bool) public balancesInserted;</span><br><span class="line">    address[] public balancesKey; // 所有地址</span><br><span class="line"></span><br><span class="line">    // 设置</span><br><span class="line">    function set(address ads_,uint256 amount_) external&#123;</span><br><span class="line">        balances[ads_] = amount_;</span><br><span class="line">        // 1.检查</span><br><span class="line">        if(!balancesInserted[ads_])&#123;</span><br><span class="line">            // 2.修改检查条件</span><br><span class="line">            balancesInserted[ads_] = true;</span><br><span class="line">            // 3.正在的操作</span><br><span class="line">            balancesKey.push(ads_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取</span><br><span class="line">    function get(uint256 index_) external view returns(uint256)&#123;</span><br><span class="line">        require(index_&lt;balancesKey.length,&quot;index_ error&quot;);</span><br><span class="line">        return balances[balancesKey[index_]];</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取所有</span><br><span class="line">    function totalAddress() external view returns(uint256)&#123;</span><br><span class="line">        return balancesKey.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取第一个值</span><br><span class="line">    function first() external view returns(uint256)&#123;</span><br><span class="line">        return balances[balancesKey[0]];</span><br><span class="line">    &#125;</span><br><span class="line">    // 最后一个值</span><br><span class="line">    function latest() external view returns(uint256)&#123;</span><br><span class="line">        return balances[balancesKey[balancesKey.length-1]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>更完善的实现: <a target="_blank" rel="noopener" href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol">https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol</a></li>
<li>更新的实现: <a target="_blank" rel="noopener" href="https://learnblockchain.cn/docs/solidity/types.html#iterable-mappings">https://learnblockchain.cn/docs/solidity/types.html#iterable-mappings</a></li>
</ul>
<h2 id="7-5-struct-结构体"><a href="#7-5-struct-结构体" class="headerlink" title="7.5 struct 结构体"></a>7.5 struct 结构体</h2><h3 id="7-5-1-创建语法"><a href="#7-5-1-创建语法" class="headerlink" title="7.5.1 创建语法"></a>7.5.1 创建语法</h3><p>要定义结构体，使用 <code>struct</code> 关键字。<code>struct</code> 关键字定义了一个新的数据类型，包含多个成员。结构体是可以将多个变量进行编组的自定义类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    struct Book &#123;</span><br><span class="line">        string title;</span><br><span class="line">        string author;</span><br><span class="line">        uint256 book_id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-2-三种创建方法"><a href="#7-5-2-三种创建方法" class="headerlink" title="7.5.2 三种创建方法"></a>7.5.2 三种创建方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 第 1 种生成</span><br><span class="line">Book memory solidity1 = Book(unicode&quot;Solidity 高级程序设计&quot;, &quot;Anbang&quot;, ++bookId);</span><br><span class="line"></span><br><span class="line">// 第 2 种生成</span><br><span class="line">Book memory solidity2 = Book(&#123;</span><br><span class="line">    title: unicode&quot;Solidity 高级程序设计&quot;,</span><br><span class="line">    author: &quot;Anbang&quot;,</span><br><span class="line">    book_id: ++bookId,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 第 3 种生成</span><br><span class="line">Book memory temp;</span><br><span class="line">temp.title = unicode&quot;Solidity 高级程序设计&quot;;</span><br><span class="line">temp.author = &quot;Anbang&quot;;</span><br><span class="line">temp.book_id = ++bookId;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-3-读取"><a href="#7-5-3-读取" class="headerlink" title="7.5.3 读取"></a>7.5.3 读取</h3><p>函数内仅读取结构体，使用 memory 和 storage 区别:</p>
<ol>
<li>函数内读取并返回,如果使用 memory 变量接收:<ol>
<li>从状态变量拷贝到内存中，然后内存中的变量拷贝到返回值。两次拷贝，消耗 gas 多</li>
<li><code>Book memory _book = book;</code></li>
</ol>
</li>
<li>函数内读取并返回，如果使用 storage 变量接收:<ol>
<li>直接从状态变量读取，状态变量拷贝到返回值。1 次拷贝，消耗 gas 小</li>
</ol>
</li>
<li>总结: 读取时候推荐使用 <code>storage</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 读取</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    struct Book &#123;</span><br><span class="line">        string title;</span><br><span class="line">        string author;</span><br><span class="line">        uint256 book_id;</span><br><span class="line">    &#125;</span><br><span class="line">    Book public book = Book(&quot;Solidity&quot;, &quot;Anbang&quot;, 1);</span><br><span class="line"></span><br><span class="line">    // memory  30029 gas</span><br><span class="line">    // 函数内读取并返回：使用 memory 变量接收</span><br><span class="line">    //  两次拷贝，所以消耗的 gas 多</span><br><span class="line">    function get1() external view</span><br><span class="line">        returns(</span><br><span class="line">            string memory,</span><br><span class="line">            string memory,</span><br><span class="line">            uint256</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">         // 从状态变量拷贝到内存中</span><br><span class="line">        Book memory _book = book;</span><br><span class="line">        // 内存中的变量拷贝到返回值；2次拷贝</span><br><span class="line">        return (_book.title,_book.author,_book.book_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // storage 29983 gas</span><br><span class="line">    // 函数内读取并返回：使用 storage 变量接收</span><br><span class="line">    function get2() external view</span><br><span class="line">        returns(</span><br><span class="line">            string memory,</span><br><span class="line">            string memory,</span><br><span class="line">            uint256</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        // 从状态变量读取，没有拷贝的行为</span><br><span class="line">        Book storage _book = book;</span><br><span class="line"></span><br><span class="line">        // 状态变量拷贝到返回值。1次拷贝</span><br><span class="line">        return (_book.title,_book.author,_book.book_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-4-修改"><a href="#7-5-4-修改" class="headerlink" title="7.5.4 修改"></a>7.5.4 修改</h3><p>函数内读取时，标记 <code>memory</code> &#x2F; <code>storage</code>,会产生完全不同的结果；</p>
<p>特别注意：**如果结构体内包含 <code>mapping</code> 类型，则必须使用 <code>storage</code>，不可以使用 memeory.**，否则报错</p>
<p>函数内获取并修改结构体：</p>
<ul>
<li>因为要修改状态变量，所以使用 storage</li>
<li>函数内直接修改变量; 在修改一个属性时比较省 Gas 费用</li>
<li>函数内先获取存储到 storage 再修改:修改多个属性的时候比较省 Gas 费用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Structs &#123;</span><br><span class="line">    struct Book &#123;</span><br><span class="line">        string title;</span><br><span class="line">        string author;</span><br><span class="line">        uint256 book_id;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 private bookId;</span><br><span class="line">    Book public book1; // Book类型</span><br><span class="line">    Book public book2; // Book类型</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; Book) public students; // mapping 类型</span><br><span class="line"></span><br><span class="line">    // 设置 book1</span><br><span class="line">    function setBook1() external &#123;</span><br><span class="line">        Book memory temp;</span><br><span class="line">        temp.title = unicode&quot;Solidity 高级程序设计&quot;;</span><br><span class="line">        temp.author = &quot;Yaoqi&quot;;</span><br><span class="line">        temp.book_id = ++bookId;</span><br><span class="line">        book1 = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置 book2</span><br><span class="line">    // ✅ 最优方案，推荐:直接修改</span><br><span class="line">    function setBook2() external &#123;</span><br><span class="line">        book2.title = unicode&quot;Solidity 高级程序设计&quot;;</span><br><span class="line">        book2.author = &quot;Yaoqi&quot;;</span><br><span class="line">        book2.book_id = ++bookId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ✅ 最优方案，推荐:直接修改</span><br><span class="line">    function set1Student() external &#123;</span><br><span class="line">        Book storage temp = students[msg.sender];</span><br><span class="line">        temp.title = unicode&quot;Solidity 高级程序设计&quot;;</span><br><span class="line">        temp.author = &quot;Anbang&quot;;</span><br><span class="line">        temp.book_id = ++bookId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function set2Student() external &#123;</span><br><span class="line">        Book memory temp;</span><br><span class="line">        temp.title = unicode&quot;Solidity 高级程序设计&quot;;</span><br><span class="line">        temp.author = &quot;Anbang&quot;;</span><br><span class="line">        temp.book_id = ++bookId;</span><br><span class="line">        students[msg.sender] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-5-删除"><a href="#7-5-5-删除" class="headerlink" title="7.5.5 删除"></a>7.5.5 删除</h3><p>删除结构体的变量，仅仅是重置数据，并不是完全的删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    struct Book &#123;</span><br><span class="line">        string title;</span><br><span class="line">        string author;</span><br><span class="line">        uint256 book_id;</span><br><span class="line">    &#125;</span><br><span class="line">    Book public book = Book(&quot;Solidity&quot;, &quot;Anbang&quot;, 1);</span><br><span class="line"></span><br><span class="line">    function del() external</span><br><span class="line">    &#123;</span><br><span class="line">        delete book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>Solidity 允许类型之间进行隐式转换和显式转换。</p>
<p><strong>前文回顾</strong>: <code>bytes1</code> 对应 <code>uint8</code>，对应两位连续的十六进制数字 <code>0xXX</code>。</p>
<h2 id="8-1-隐式转换"><a href="#8-1-隐式转换" class="headerlink" title="8.1 隐式转换"></a>8.1 隐式转换</h2><h3 id="8-1-1-发生场景"><a href="#8-1-1-发生场景" class="headerlink" title="8.1.1 发生场景"></a>8.1.1 发生场景</h3><p>在<strong>赋值</strong>, <strong>函数参数传递</strong>以及应用运算符时，会发生隐式转换。</p>
<h3 id="8-1-2-转换的标准"><a href="#8-1-2-转换的标准" class="headerlink" title="8.1.2  转换的标准"></a>8.1.2  转换的标准</h3><ol>
<li>值类型</li>
<li>源类型必须是目标类型的子集。</li>
</ol>
<p>例如，<code>uint8</code> 可以转换为 <code>uint16</code>&#x2F;<code>uint24</code>..&#x2F;<code>uint256</code>，因为<code>uint8</code>是<code>uint16</code>这些类型的子集。</p>
<p>但是 <code>int8</code> 不可以转换为 <code>uint256</code>，因为 <code>int8</code> 可以包含 <code>uint256</code> 中不允许的负值，比如 <code>-1</code>。</p>
<h3 id="8-1-3-相交集合的类型，不能隐式转换。"><a href="#8-1-3-相交集合的类型，不能隐式转换。" class="headerlink" title="8.1.3  相交集合的类型，不能隐式转换。"></a>8.1.3  相交集合的类型，不能隐式转换。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    int8 public a1 = 3;</span><br><span class="line"></span><br><span class="line">    // Type int8 is not implicitly convertible to expected type uint16.</span><br><span class="line">    // uint16 public a2 = a1;</span><br><span class="line"></span><br><span class="line">    uint8 public b1 = 3;</span><br><span class="line">    uint16 public b2 = b1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-1-4-把整数字面量赋值给整型时，不能超出范围而发生截断，否则会报错。"><a href="#8-1-4-把整数字面量赋值给整型时，不能超出范围而发生截断，否则会报错。" class="headerlink" title="8.1.4 把整数字面量赋值给整型时，不能超出范围而发生截断，否则会报错。"></a>8.1.4 把整数字面量赋值给整型时，不能超出范围而发生截断，否则会报错。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo1 &#123;</span><br><span class="line">    uint8 public a = 12; // no error</span><br><span class="line">    uint32 public b = 1234; // no error</span><br><span class="line">    uint16 public c = 0x01;</span><br><span class="line"></span><br><span class="line">    // Type int_const 123456 is not implicitly convertible</span><br><span class="line">    // to expected type uint8. Literal is too large to fit in uint8.</span><br><span class="line">    // uint8 d = 123456;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-1-4-函数参数传递"><a href="#8-1-4-函数参数传递" class="headerlink" title="8.1.4 函数参数传递"></a>8.1.4 函数参数传递</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 函数的传参</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint256 public a;</span><br><span class="line"></span><br><span class="line">    function test1(uint256 u_) public &#123;</span><br><span class="line">        a = u_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test2() external &#123;</span><br><span class="line">        uint8 temp = 3;</span><br><span class="line">        test1(temp); //</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 函数的传参</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint256 public a;</span><br><span class="line"></span><br><span class="line">    function test1(uint256[3] memory u_) public &#123;</span><br><span class="line">        a = u_[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 禁止的：</span><br><span class="line">    function test2() external &#123;</span><br><span class="line">        // function call. Invalid implicit conversion from uint8[3]</span><br><span class="line">        // memory to uint256[3] memory requested.</span><br><span class="line">        // test1([1,2,3]);</span><br><span class="line">        test1([uint256(1),uint256(2),uint256(3)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-1-5-运算符应用"><a href="#8-1-5-运算符应用" class="headerlink" title="8.1.5 运算符应用"></a>8.1.5 运算符应用</h3><p>则编译器将尝试将<strong>其中一个操作数</strong>隐式转换为<strong>另一个操作数的类型</strong>（赋值也是如此）。 这意味着操作始终以操作数之一的类型执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 运算符</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint8 public  x = 1;</span><br><span class="line">    uint16 public  y = 2;</span><br><span class="line"></span><br><span class="line">    // uint8 + uint16 =&gt; uint16 + uint16 = uint16</span><br><span class="line">    // uint16 =&gt; uint32</span><br><span class="line">    uint32 public  z = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，加法的操作数 x 和 y 没有相同的类型，uint8 可以被隐式转换为 uint16，相反却不可以。 因此在执行加法之前，将 uint8 转换为 uint16 的类型，结果类型是 uint16。因为它被赋值给 uint32 类型的变量，又进行了另一个类似逻辑的隐式转换.</p>
<h2 id="8-2-显式转换"><a href="#8-2-显式转换" class="headerlink" title="8.2 显式转换"></a>8.2 显式转换</h2><p>可以使用类型关键字，显式地将数据类型转换为另一种类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // uint8 =&gt; uint16</span><br><span class="line">    uint8 public a1 = 3;</span><br><span class="line">    uint16 public a2 = uint16(a1);</span><br><span class="line"></span><br><span class="line">    int8 public b1 = 3;</span><br><span class="line">    //Explicit type conversion not allowed from &quot;int8&quot; to &quot;uint256&quot;.</span><br><span class="line">    // uint256 b2 = uint256(b1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-1-int-uint-整型转换"><a href="#8-2-1-int-uint-整型转换" class="headerlink" title="8.2.1 int&#x2F;uint 整型转换"></a>8.2.1 int&#x2F;uint 整型转换</h3><p>整型加大数据位置是从左侧增加，减小数据位置也是从左侧移除；（<strong>整型是右对齐</strong>）</p>
<ul>
<li>整型转换成更大的类型，从左侧添加填充位。</li>
<li>整型转换成更小的类型，会丢失左侧数据。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // 整型转换成更大的类型，从左侧添加填充位。</span><br><span class="line">    // uint16 =&gt; uint32</span><br><span class="line">    uint16 public a1 = 22136;       // 等于 0x5678</span><br><span class="line">    uint32 public a2 = uint32(a1); // a2 = 22136</span><br><span class="line"></span><br><span class="line">    // uint16 =&gt; uint8</span><br><span class="line">    uint8 public a3 = uint8(a1); // a4 = 0x78</span><br><span class="line">    uint8 public a4 = 0x78;</span><br><span class="line"></span><br><span class="line">    // 整型转换成更小的类型，会丢失左侧数据。</span><br><span class="line">    // uint32 =&gt; uint16</span><br><span class="line">    uint32 public b1 = 0x12345678; // 0x12345678</span><br><span class="line">    uint16 public b2 = uint16(b1); // 0x5678 | b2 = 22136</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>整数显式转换为更大的类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint16 a = 0x1234;</span><br><span class="line">uint32 b = uint32(a); // b 为 0x00001234 now</span><br></pre></td></tr></table></figure>

<p><strong>整数显式转换成更小的类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint32 a = 0x12345678;</span><br><span class="line">uint16 b = uint16(a); // 此时 b 的值是 0x5678</span><br></pre></td></tr></table></figure>

<h3 id="8-2-1-bytes-字节类型转换"><a href="#8-2-1-bytes-字节类型转换" class="headerlink" title="8.2.1 bytes 字节类型转换"></a>8.2.1 bytes 字节类型转换</h3><p>字节加大数据位置是从右侧增加，减小数据位置也是从右侧移除；（<strong>字节是左对齐</strong>）</p>
<ul>
<li>字节转换为更大的类型时，从右侧添加填充位。</li>
<li>字节转换到更小的类型时，丢失右侧数据。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // 字节转换为更大的类型时，从右侧添加填充位。</span><br><span class="line">    // bytes2 =&gt;bytes4</span><br><span class="line">    bytes2 public a1 = 0x5678;</span><br><span class="line">    bytes4 public a2 = bytes4(a1); // a2 = 0x56780000</span><br><span class="line"></span><br><span class="line">    // 字节转换到更小的类型时，丢失右侧数据。</span><br><span class="line">    // bytes4 =&gt; bytes2</span><br><span class="line">    bytes4 public b1 = 0x12345678;</span><br><span class="line">    bytes2 public b2 = bytes2(b1); // b2 = 0x1234</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>bytes 显式转换成更小的类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bytes2 a = 0x1234;</span><br><span class="line">bytes1 b = bytes1(a); // b 为 0x12</span><br></pre></td></tr></table></figure>

<p><strong>bytes 显式转换成更大的类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bytes2 a = 0x1234;</span><br><span class="line">bytes4 b = bytes4(a); // b 为 0x12340000</span><br></pre></td></tr></table></figure>

<h3 id="8-2-3-bytes-与-uint-转换"><a href="#8-2-3-bytes-与-uint-转换" class="headerlink" title="8.2.3 bytes 与 uint 转换"></a>8.2.3 bytes 与 uint 转换</h3><p>只有当字节类型和整数类型大小相同时，才可以进行转换。</p>
<p>因为整数和定长字节数组在截断（或填充）时行为是不同的，如果要在不同的大小的整数和定长字节数组之间进行转换，<strong>必须使用一个中间类型来明确进行所需截断和填充的规则</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bytes2 a = 0x1234;</span><br><span class="line">uint32 b = uint16(a);           // b 为 0x00001234</span><br><span class="line">uint32 c = uint32(bytes4(a));   // c 为 0x12340000</span><br><span class="line"></span><br><span class="line">uint8  d = uint8(uint16(a));    // d 为 0x34</span><br><span class="line">uint8  e = uint8(bytes1(a));    // e 为 0x12</span><br></pre></td></tr></table></figure>

<p><strong>1.bytes 转换成 uint</strong>: <strong>先转类型，再转大小</strong></p>
<ul>
<li>推荐先把 bytes 显示转换成数字类型后，再转换成更大或更小的数字</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// - `uint8`  等于两位连续的十六进制数字 `0xXX`</span><br><span class="line">// - `bytes1` 等于两位连续的十六进制数字 `0xXX`</span><br><span class="line">// - `bytes1` 等于 `uint8`</span><br><span class="line">contract Demo1 &#123;</span><br><span class="line">    // bytes =&gt; uint</span><br><span class="line">    bytes2 public a1 = 0x5678; // : 十进制数字 = 22136</span><br><span class="line">    bytes4 public a2 = bytes4(a1); // a2 = 0x56780000 : 十进制数字 = 1450704896</span><br><span class="line">    bytes1 public a3 = bytes1(a1); // a3 = 0x56 : 十进制数字 = 86</span><br><span class="line"></span><br><span class="line">    // -- 增大</span><br><span class="line">    // bytes 显示转换成数字后，显示转换更大的数字 (这里也可以隐式完成)</span><br><span class="line">    uint32 public a4 = uint32(uint16(a1)); // ✅ a4 = 0x00005678 : 十进制 = 22136</span><br><span class="line">    // bytes 显示转换成更大数字对应的的bytes，然后bytes显示转换成匹配的数字</span><br><span class="line">    uint32 public a5 = uint32(bytes4(a1)); // ❌ a5 = 0x56780000 : 十进制 = 1450704896</span><br><span class="line"></span><br><span class="line">    // -- 减小</span><br><span class="line">    // bytes 显示转换成数字后，显示转换成更小的数字</span><br><span class="line">    uint8 public a6 = uint8(uint16(a1)); // ✅ a6 = 0x78 : 十进制 = 120</span><br><span class="line">    // bytes 显示转换成更小数字对应的的bytes，然后bytes显示转换成匹配的数字</span><br><span class="line">    uint8 public a7 = uint8(bytes1(a1)); // ❌ a7 = 0x56 : 十进制 = 86</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.uint 转换成 bytes</strong>: <strong>先转大小，再转类型</strong></p>
<ul>
<li>推荐先把 uint 显示转换成更大 bytes 对应的 uint，然后 uint 再显示转换成匹配的 bytes</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo2 &#123;</span><br><span class="line">    // uint =&gt; bytes</span><br><span class="line">    uint16 public b1 = 0x5678; // 0x5678 : 十进制 = 22136</span><br><span class="line">    uint32 public b2 = uint32(b1); // b2 = 0x00005678 : 十进制 = 22136</span><br><span class="line">    uint8 public b3 = uint8(b1); // b3 = 0x78 : 十进制 = 120</span><br><span class="line">    // -- 增大</span><br><span class="line">    // uint 显示转换成bytes类型后，再显示转换成更大或更小的bytes</span><br><span class="line">    bytes4 public b4 = bytes4(bytes2(b1)); // ❌ b4 = 0x56780000</span><br><span class="line">    // uint 显示转换成更大bytes对应的uint，然后uint再显示转换成匹配的bytes</span><br><span class="line">    bytes4 public b5 = bytes4(uint32(b1)); //  ✅ b5 = 0x00005678</span><br><span class="line"></span><br><span class="line">    // -- 减小</span><br><span class="line">    // uint 显示转换成bytes类型后，再显示转换成更大或更小的bytes</span><br><span class="line">    bytes1 public b6 = bytes1(bytes2(b1)); // ❌ b4 = 0x56</span><br><span class="line">    // uint 显示转换成更大bytes对应的uint，然后uint再显示转换成匹配的bytes</span><br><span class="line">    bytes1 public b7 = bytes1(uint8(b1)); // ✅ b4 = 0x78</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-4-bytes-和-bytesN-之间转换"><a href="#8-2-4-bytes-和-bytesN-之间转换" class="headerlink" title="8.2.4 bytes 和 bytesN 之间转换"></a>8.2.4 bytes 和 bytesN 之间转换</h3><p><code>bytes</code> 数组和 <code>bytes calldata</code> 切片可以显示转换为固定长度的 bytes 类型(<code>bytes1...bytes32</code>).</p>
<ul>
<li>如果数组比固定长度的 bytes 类型长，则在末尾处会发生截断。</li>
<li>如果数组比目标类型短，它将在末尾用零填充。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    // 0x6162636465666768</span><br><span class="line">    bytes public bts = &quot;abcdefgh&quot;;</span><br><span class="line">    bytes3 public b1 = bytes3(bts);</span><br><span class="line">    bytes8 public b2 = bytes8(bts);</span><br><span class="line">    bytes16 public b3 = bytes16(bts);</span><br><span class="line">    bytes32 public b4 = bytes32(bts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充</strong>：使用切片也可以把数据从 bytes 转为 bytesN。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    // 0x6162636465666768</span><br><span class="line">    bytes public bts = &quot;abcdefgh&quot;;</span><br><span class="line"></span><br><span class="line">    function f(bytes calldata bts_)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes3,bytes16)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        bytes3 b1 = bytes3(bts_);</span><br><span class="line">        bytes16 b2 = bytes16(bts_[:8]);</span><br><span class="line">        return (b1, b2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-5-bytes-与-address-转换"><a href="#8-2-5-bytes-与-address-转换" class="headerlink" title="8.2.5 bytes 与 address 转换"></a>8.2.5 bytes 与 address 转换</h3><p>address 的格式是 <code>0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac</code>，是一个 <strong>bytes20</strong> 的数据。</p>
<p>地址是取 <code>bytes32</code> 数据中的后 20 位。如果想删除前面的 12 位数据，可以使用 solidity assembly (内联汇编) 来截取，也可以借助 <code>uint</code> 转换成更小的类型，会丢失左侧数据的特性来完成。</p>
<p>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // 获取即将部署的地址</span><br><span class="line">    function getAddress(bytes memory bytecode, uint256 _salt)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (address)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes32 hash = keccak256(</span><br><span class="line">            abi.encodePacked(</span><br><span class="line">                bytes1(0xff), // 固定字符串</span><br><span class="line">                address(this), // 当前工厂合约地址</span><br><span class="line">                _salt, // salt</span><br><span class="line">                keccak256(bytecode) //部署合约的 bytecode</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        // bytes 转换成 uint: 先转类型，再转大小</span><br><span class="line">        //      bytes32 =&gt; uint256 =&gt; uint160</span><br><span class="line">        // uint160 转 address</span><br><span class="line">        //      uint160 =&gt; address</span><br><span class="line">        return address(uint160(uint256(hash)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前文介绍过编码的方式: <code>keccak256(abi.encodePacked())</code>，返回的是 <code>bytes32</code> 类型。</p>
<p>这个小例子是<strong>合约部署合约</strong>那章节中 create2 代码的一部分，相关的更多演示请查看 create2 创建。</p>
<h2 id="8-3-数字转换成字符串"><a href="#8-3-数字转换成字符串" class="headerlink" title="8.3 数字转换成字符串"></a>8.3 数字转换成字符串</h2><h3 id="8-3-1-直接借助-bytes-和-string（未完成）"><a href="#8-3-1-直接借助-bytes-和-string（未完成）" class="headerlink" title="8.3.1 直接借助 bytes 和 string（未完成）"></a>8.3.1 直接借助 bytes 和 string（未完成）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // `固定大小字节数组` —&gt; `动态大小字节数组` —&gt; `string`</span><br><span class="line">    function test(uint8 num_) public pure returns (bytes1 ab,string memory data) &#123;</span><br><span class="line">        // 固定大小字节数组</span><br><span class="line">        ab = bytes1(num_);</span><br><span class="line"></span><br><span class="line">        // `固定大小字节数组` —&gt; `动态大小字节数组`</span><br><span class="line">        bytes memory temp = new bytes(ab.length); // 可变字节数组创建方式</span><br><span class="line">        for (uint8 i = 0; i &lt; ab.length; i++) &#123;</span><br><span class="line">            temp[i] = ab[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // `动态大小字节数组` —&gt; `string`</span><br><span class="line">        data = string(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-2-借助单个数字转换（推荐）"><a href="#8-3-2-借助单个数字转换（推荐）" class="headerlink" title="8.3.2 借助单个数字转换（推荐）"></a>8.3.2 借助单个数字转换（推荐）</h3><p>这种方法是借助将 0-9 的数字进行转换，然后超过十位的数字，通过 <code>%</code> 来得到，并且拼接在一起。<br>推荐方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function uintToString(uint256 _uint)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (string memory str)</span><br><span class="line">    &#123;</span><br><span class="line">        if (_uint == 0) return &quot;0&quot;;</span><br><span class="line">        while (_uint != 0) &#123;</span><br><span class="line">            //取模</span><br><span class="line">            uint256 remainder = _uint % 10;</span><br><span class="line">            //每取一位就移动一位，个位、十位、百位、千位……</span><br><span class="line">            _uint = _uint / 10;</span><br><span class="line">            //将字符拼接，注意字符位置</span><br><span class="line">            str =  string.concat(toStr(remainder), str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function toStr(uint256 num_) internal pure returns (string memory) &#123;</span><br><span class="line">        require(num_ &lt; 10,&quot;error&quot;);</span><br><span class="line">        bytes memory alphabet = &quot;0123456789&quot;;</span><br><span class="line">        bytes memory str = new bytes(1);</span><br><span class="line">        str[0] = alphabet[num_];</span><br><span class="line">        return string(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    
    
    
      <div>
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">-------------本文结束感谢您的阅读-------------</div>
    
</div>
      </div>
    
        <div class="reward-container">
  <div>原创技术分享，您的支持将鼓励我继续创作.</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    点击打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="幺柒YQ 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="幺柒YQ 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>幺柒YQ
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://kongpengyq.com/2022/06/15/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/02-%E6%95%B0%E6%8D%AE/" title="02-数据">https://kongpengyq.com/2022/06/15/区块链/Solidity0.8/02-数据/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

            <div class="social-item">
              <a target="_blank" class="social-link" href="https://twitter.com/qiyao666">
                <span class="icon">
                  <i class="fa fa-twitter"></i>
                </span>

                <span class="label">Twitter</span>
              </a>
            </div>

            <div class="social-item">
              <a target="_blank" class="social-link" href="/images/wechat.jpg">
                <span class="icon">
                  <i class="fa fa-wechat"></i>
                </span>

                <span class="label">Wechat</span>
              </a>
            </div>

            <div class="social-item">
              <a target="_blank" class="social-link" href="/atom.xml">
                <span class="icon">
                  <i class="fa fa-rss"></i>
                </span>

                <span class="label">RSS</span>
              </a>
            </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag"># 区块链</a>
              <a href="/tags/Solidity0-8-17/" rel="tag"># Solidity0.8.17</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/06/09/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/01-%E5%88%9D%E8%AF%86/" rel="prev" title="01-初识">
      <i class="fa fa-chevron-left"></i> 01-初识
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/06/20/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/03-%E5%8F%98%E9%87%8F/" rel="next" title="03-变量">
      03-变量 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81OTA3NC8zNTUzNg=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%8F%98%E9%87%8F"><span class="nav-text">数据与变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-text">隐式转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-text">两种类型的数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-text">值类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-Boolean-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.1 Boolean 布尔类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-%E4%BD%BF%E7%94%A8%E7%9F%AD%E8%B7%AF%E8%A7%84%E5%88%99%E8%8A%82%E7%9C%81-gas"><span class="nav-text">3.1.1 使用短路规则节省 gas</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-Integer-%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.2 Integer 整数类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E5%B1%9E%E6%80%A7"><span class="nav-text">3.2.1 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-uint-%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.2.2 uint 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-int-%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.2.3 int 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-checked-%E6%A8%A1%E5%BC%8F"><span class="nav-text">3.2.4 checked 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-5-unchecked-%E9%9D%9E%E6%A3%80%E6%9F%A5%E6%A8%A1%E5%BC%8F"><span class="nav-text">3.2.5 unchecked 非检查模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-Integer-%E6%95%B4%E6%95%B0%E5%AD%97%E9%9D%A2%E5%B8%B8%E9%87%8F"><span class="nav-text">3.3 Integer 整数字面常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E5%B8%B8%E9%87%8F%E4%B8%AD%E7%94%A8-%E5%A2%9E%E5%8A%A0%E5%8F%AF%E8%AF%BB%E6%80%A7"><span class="nav-text">3.3.1 常量中用_增加可读性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-%E5%AD%97%E9%9D%A2%E5%B8%B8%E9%87%8F%E6%94%AF%E6%8C%81%E4%BB%BB%E6%84%8F%E7%B2%BE%E5%BA%A6"><span class="nav-text">3.3.2 字面常量支持任意精度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-%E9%99%A4%E6%B3%95%E6%88%AA%E6%96%AD"><span class="nav-text">3.3.3 除法截断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E8%BE%83%E5%B0%8F%E7%B1%BB%E5%9E%8B%E8%AE%A1%E7%AE%97"><span class="nav-text">3.3.4 优先使用较小类型计算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-Fixed-%E5%AE%9A%E9%95%BF%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="nav-text">3.4 Fixed 定长浮点型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-BytesN-%E5%AE%9A%E9%95%BF%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84"><span class="nav-text">3.5 BytesN 定长字节数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-%E5%B1%9E%E6%80%A7"><span class="nav-text">3.5.1 属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%B8%B8%E9%87%8F%E5%8F%8A%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.6 字符串字面常量及类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-text">3.6.1 字符串字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="nav-text">3.6.2 转义字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-3-%E7%94%A8%E7%A9%BA%E6%A0%BC%E5%88%86%E5%BC%80%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">3.6.3 用空格分开的字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-Unicode-%E5%AD%97%E9%9D%A2%E5%B8%B8%E9%87%8F"><span class="nav-text">3.7 Unicode 字面常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%AD%97%E9%9D%A2%E5%B8%B8%E9%87%8F"><span class="nav-text">3.8 十六进制字面常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-text">3.8.1 基本用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-9-Enum-%E6%9E%9A%E4%B8%BE"><span class="nav-text">3.9 Enum:枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-1-%E6%96%B9%E6%B3%95"><span class="nav-text">3.9.1 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-10-%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.10 用户定义的值类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-10-1-%E6%96%B9%E6%B3%95"><span class="nav-text">3.10.1  方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B-%E5%9C%B0%E5%9D%80%E7%B1%BB%E5%9E%8B"><span class="nav-text">值类型:地址类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E5%9C%B0%E5%9D%80%E5%AD%97%E9%9D%A2%E5%B8%B8%E9%87%8F"><span class="nav-text">4.1 地址字面常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-address-uint160-bytes32-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">4.2 address&#x2F;uint160&#x2F;bytes32 之间的转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E4%B8%A4%E7%A7%8D%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="nav-text">4.3 两种形式的地址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-text">两种形式的地址转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E5%9C%B0%E5%9D%80%E5%B1%9E%E6%80%A7"><span class="nav-text">4.4 地址属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1-balance-%E5%B1%9E%E6%80%A7"><span class="nav-text">4.4.1 balance 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2-code-%E5%B1%9E%E6%80%A7"><span class="nav-text">4.4.2 code 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-3-codehash-%E5%B1%9E%E6%80%A7"><span class="nav-text">4.4.3 codehash 属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-%E5%9C%B0%E5%9D%80%E6%96%B9%E6%B3%95"><span class="nav-text">4.5 地址方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-1-address"><span class="nav-text">4.5.1 address()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-2-payable"><span class="nav-text">4.5.2 payable()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-3-transfer"><span class="nav-text">4.5.3 transfer()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-4-send"><span class="nav-text">4.5.4 send()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-5-call-delegatecall-staticcall"><span class="nav-text">4.5.5 call&#x2F;delegatecall&#x2F;staticcall</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-5-1-call"><span class="nav-text">4.5.5.1 call()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-5-2-delegatecall-%E5%A7%94%E6%89%98%E8%B0%83%E7%94%A8"><span class="nav-text">4.5.5.2 delegatecall() 委托调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-5-3-staticcall-%E9%9D%99%E6%80%81%E8%B0%83%E7%94%A8"><span class="nav-text">4.5.5.3 staticcall() 静态调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E4%B8%89%E7%A7%8D-call-%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-text">4.6 三种 call 的总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-transfer-send-call-%E4%B8%89%E7%A7%8D%E8%BD%AC%E8%B4%A6%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-text">4.7 transfer &#x2F; send &#x2F; call 三种转账的总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">4.8 注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B-%E5%90%88%E7%BA%A6%E7%B1%BB%E5%9E%8B"><span class="nav-text">值类型:合约类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E5%90%88%E7%BA%A6%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-text">5.1 合约的属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-memory"><span class="nav-text">6.1.2  memory</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E7%82%B9-1-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-%E5%8C%85%E6%8B%AC%E8%BF%94%E5%9B%9E%E5%8F%82%E6%95%B0-%E9%83%BD%E5%AD%98%E5%82%A8%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E3%80%82"><span class="nav-text">重点 1:函数参数(包括返回参数)都存储在内存中。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E7%82%B9-2-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%8C%E9%9C%80%E8%A6%81%E6%98%BE%E5%BC%8F%E6%8C%87%E5%AE%9A%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE-storage-memory"><span class="nav-text">重点 2:引用类型的局部变量，需要显式指定数据位置(storage&#x2F;memory)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E7%82%B9-3-%E5%87%BD%E6%95%B0%E7%9A%84%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0%E5%A6%82%E6%9E%9C%E6%98%AF%E6%95%B0%E7%BB%84-%E4%BD%BF%E7%94%A8-memory"><span class="nav-text">重点 3:函数的输入和输出参数如果是数组,使用 memory</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E7%82%B9-4-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E6%8C%87%E5%AE%9A-storage-%E5%92%8C-memory-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">重点 4:引用类型的局部变量:指定 storage 和 memory 的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-3-calldata"><span class="nav-text">6.1.3  calldata</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-4-stack"><span class="nav-text">6.1.4 stack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-5-%E5%B0%8F%E7%BB%93"><span class="nav-text">6.1.5 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B5%8B%E5%80%BC%E8%A7%84%E5%88%99"><span class="nav-text">6.2 不同数据位置之间的赋值规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-calldata-%E5%92%8C-memeory-%E5%8C%BA%E5%88%AB"><span class="nav-text">6.3 calldata 和 memeory 区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-text">引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-array-%E6%95%B0%E7%BB%84"><span class="nav-text">7.1 array 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-2-%E6%95%B0%E7%BB%84%E5%B8%B8%E9%87%8F"><span class="nav-text">7.1.2 数组常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-2-%E6%95%B0%E7%BB%84%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-text">7.1.2 数组的属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#length%E6%95%B0%E7%BB%84%E6%9C%89-length-%E5%B1%9E%E6%80%A7%E8%A1%A8%E7%A4%BA%E5%BD%93%E5%89%8D%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6%E3%80%82-%E4%B8%80%E7%BB%8F%E5%88%9B%E5%BB%BA%EF%BC%8C%E5%86%85%E5%AD%98-memory-%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%B0%B1%E6%98%AF%E5%9B%BA%E5%AE%9A%E7%9A%84%EF%BC%88%E4%BD%86%E5%8D%B4%E6%98%AF%E5%8A%A8%E6%80%81%E7%9A%84%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E5%AE%83%E5%8F%AF%E4%BB%A5%E6%A0%B9%E6%8D%AE%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%8F%82%E6%95%B0%E5%88%9B%E5%BB%BA%EF%BC%89%E3%80%82"><span class="nav-text">length数组有 length 属性表示当前数组的长度。 一经创建，内存 memory 数组的大小就是固定的（但却是动态的，也就是说，它可以根据运行时的参数创建）。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-3-%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">7.1.3 数组的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-bytes"><span class="nav-text">7.2.bytes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-%E5%88%9B%E5%BB%BA"><span class="nav-text">7.2.1 创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-bytes-%E5%92%8C-bytes32-%E5%8C%BA%E5%88%AB"><span class="nav-text">7.2.2 bytes 和 bytes32[] 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-3-%E5%B1%9E%E6%80%A7"><span class="nav-text">7.2.3  属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-4-%E6%96%B9%E6%B3%95"><span class="nav-text">7.2.4 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bytes-concat-%E6%8B%BC%E6%8E%A5"><span class="nav-text">bytes.concat 拼接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#push-%E6%96%B9%E6%B3%95"><span class="nav-text">push 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pop-%E6%96%B9%E6%B3%95"><span class="nav-text">pop 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#delete-%E6%B8%85%E7%A9%BA%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84"><span class="nav-text">delete 清空字节数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#x-start-end-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87"><span class="nav-text">x[start:end]:数组切片</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-5-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%88%B0-bytes-%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">7.2.5 字符串 到 bytes 的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-6-bytes-%E5%88%B0-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">7.2.6 bytes 到 字符串 的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-string"><span class="nav-text">7.3 string</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-1-%E6%A0%BC%E5%BC%8F"><span class="nav-text">7.3.1 格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-2-%E5%B1%9E%E6%80%A7"><span class="nav-text">7.3.2 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-3-%E6%96%B9%E6%B3%95"><span class="nav-text">7.3.3 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-mapping-%E6%98%A0%E5%B0%84"><span class="nav-text">7.4 mapping 映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-1%E6%9C%AC%E8%8A%82%E9%87%8D%E7%82%B9"><span class="nav-text">7.4.1本节重点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-2-%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F"><span class="nav-text">7.4.2 创建格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-3-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96-%E8%AE%BE%E7%BD%AE-%E5%88%A0%E9%99%A4"><span class="nav-text">7.4.3 如何获取-设置-删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-4-%E4%BD%9C%E4%B8%BA%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">7.4.4 作为局部变量的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-5-%E5%9C%A8-ERC20-token-%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-text">7.4.5 在 ERC20 token 中的用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-6-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E6%98%A0%E5%B0%84"><span class="nav-text">7.4.6 可迭代映射</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-struct-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">7.5 struct 结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-1-%E5%88%9B%E5%BB%BA%E8%AF%AD%E6%B3%95"><span class="nav-text">7.5.1 创建语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-2-%E4%B8%89%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="nav-text">7.5.2 三种创建方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-3-%E8%AF%BB%E5%8F%96"><span class="nav-text">7.5.3 读取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-4-%E4%BF%AE%E6%94%B9"><span class="nav-text">7.5.4 修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-5-%E5%88%A0%E9%99%A4"><span class="nav-text">7.5.5 删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-text">8.1 隐式转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-1-%E5%8F%91%E7%94%9F%E5%9C%BA%E6%99%AF"><span class="nav-text">8.1.1 发生场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-2-%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%A0%87%E5%87%86"><span class="nav-text">8.1.2  转换的标准</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-3-%E7%9B%B8%E4%BA%A4%E9%9B%86%E5%90%88%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B8%8D%E8%83%BD%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E3%80%82"><span class="nav-text">8.1.3  相交集合的类型，不能隐式转换。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-4-%E6%8A%8A%E6%95%B4%E6%95%B0%E5%AD%97%E9%9D%A2%E9%87%8F%E8%B5%8B%E5%80%BC%E7%BB%99%E6%95%B4%E5%9E%8B%E6%97%B6%EF%BC%8C%E4%B8%8D%E8%83%BD%E8%B6%85%E5%87%BA%E8%8C%83%E5%9B%B4%E8%80%8C%E5%8F%91%E7%94%9F%E6%88%AA%E6%96%AD%EF%BC%8C%E5%90%A6%E5%88%99%E4%BC%9A%E6%8A%A5%E9%94%99%E3%80%82"><span class="nav-text">8.1.4 把整数字面量赋值给整型时，不能超出范围而发生截断，否则会报错。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-4-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-text">8.1.4 函数参数传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-5-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%BA%94%E7%94%A8"><span class="nav-text">8.1.5 运算符应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-text">8.2 显式转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-1-int-uint-%E6%95%B4%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">8.2.1 int&#x2F;uint 整型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-1-bytes-%E5%AD%97%E8%8A%82%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">8.2.1 bytes 字节类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-3-bytes-%E4%B8%8E-uint-%E8%BD%AC%E6%8D%A2"><span class="nav-text">8.2.3 bytes 与 uint 转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-4-bytes-%E5%92%8C-bytesN-%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2"><span class="nav-text">8.2.4 bytes 和 bytesN 之间转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-5-bytes-%E4%B8%8E-address-%E8%BD%AC%E6%8D%A2"><span class="nav-text">8.2.5 bytes 与 address 转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">8.3 数字转换成字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-1-%E7%9B%B4%E6%8E%A5%E5%80%9F%E5%8A%A9-bytes-%E5%92%8C-string%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89"><span class="nav-text">8.3.1 直接借助 bytes 和 string（未完成）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-2-%E5%80%9F%E5%8A%A9%E5%8D%95%E4%B8%AA%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="nav-text">8.3.2 借助单个数字转换（推荐）</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="幺柒YQ"
      src="/images/avater.png">
  <p class="site-author-name" itemprop="name">幺柒YQ</p>
  <div class="site-description" itemprop="description">努力坚持就会有希望</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">232</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kpyaoqi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kpyaoqi" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:18312386077@163.com" title="E-Mail → mailto:18312386077@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat.jpg" title="WeChat → images&#x2F;wechat.jpg"><i class="fa fa-fw fa-wechat"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/qq.jpg" title="QQ → images&#x2F;qq.jpg"><i class="fa fa-fw fa-qq"></i>QQ</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://stackoverflow.com/" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;" rel="noopener" target="_blank">Stackoverflow</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2021-11 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">幺柒YQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">899k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:37</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共379.4k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
