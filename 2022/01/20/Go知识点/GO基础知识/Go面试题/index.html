<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://kongpengyq.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="基础部分golang 中 make 和 new 的区别？（基本必问）共同点：给变量分配内存 不同点： 1）作用变量类型不同，new给string,int和数组分配内存，make给切片，map，channel分配内存； 2）返回类型不一样，new返回指向变量的指针，make返回变量本身； 3）new 分配的空间被清零。make 分配空间后，会进行初始化； \4) 字节的面试官还说了另外一个区别，就是">
<meta property="og:type" content="article">
<meta property="og:title" content="Go面试题">
<meta property="og:url" content="https://kongpengyq.com/2022/01/20/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="YQ &amp; 博客">
<meta property="og:description" content="基础部分golang 中 make 和 new 的区别？（基本必问）共同点：给变量分配内存 不同点： 1）作用变量类型不同，new给string,int和数组分配内存，make给切片，map，channel分配内存； 2）返回类型不一样，new返回指向变量的指针，make返回变量本身； 3）new 分配的空间被清零。make 分配空间后，会进行初始化； \4) 字节的面试官还说了另外一个区别，就是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kongpengyq.com/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-5bf5e213ce315a16d0b7e65ef41cc685_720w.webp">
<meta property="og:image" content="https://kongpengyq.com/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-15a9656d176cfcc16d4116bbc9d2a24d_720w.webp">
<meta property="og:image" content="https://kongpengyq.com/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-1107961e741b834eb5fc071ff68da831_720w.webp">
<meta property="og:image" content="https://kongpengyq.com/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-f99ed061ef6ea995743cda6d332861e3_720w.webp">
<meta property="og:image" content="https://kongpengyq.com/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-e287f5861392d5de73d8956974acdbbd_720w.webp">
<meta property="og:image" content="https://kongpengyq.com/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-9452c08ff058590cea1b40a39fd8c70f_720w.webp">
<meta property="og:image" content="https://kongpengyq.com/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-8e12b7eb664280346ec96bcc4fe1db2c_720w.webp">
<meta property="og:image" content="https://kongpengyq.com/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-d2a3f2aa5c85b94df49430c21a53a2d9_720w.webp">
<meta property="og:image" content="https://kongpengyq.com/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-69e0e2f1409a17ec2987e4b63e6210da_720w.webp">
<meta property="article:published_time" content="2022-01-19T16:00:00.000Z">
<meta property="article:modified_time" content="2023-11-09T02:01:34.859Z">
<meta property="article:author" content="幺柒YQ">
<meta property="article:tag" content="Go知识点">
<meta property="article:tag" content="GO基础知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kongpengyq.com/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-5bf5e213ce315a16d0b7e65ef41cc685_720w.webp">

<link rel="canonical" href="https://kongpengyq.com/2022/01/20/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E9%9D%A2%E8%AF%95%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Go面试题 | YQ & 博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="YQ & 博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YQ & 博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/01/20/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go面试题
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-20 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-20T00:00:00+08:00">2022-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-09 10:01:34" itemprop="dateModified" datetime="2023-11-09T10:01:34+08:00">2023-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index">
                    <span itemprop="name">GO基础知识</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a><strong>基础部分</strong></h2><h3 id="golang-中-make-和-new-的区别？（基本必问）"><a href="#golang-中-make-和-new-的区别？（基本必问）" class="headerlink" title="golang 中 make 和 new 的区别？（基本必问）"></a><strong>golang 中 make 和 new 的区别？（基本必问）</strong></h3><p><strong>共同点：</strong>给变量分配内存</p>
<p><strong>不同点：</strong></p>
<p>1）作用变量类型不同，new给string,int和数组分配内存，make给切片，map，channel分配内存；</p>
<p>2）返回类型不一样，new返回指向变量的指针，make返回变量本身；</p>
<p>3）new 分配的空间被清零。make 分配空间后，会进行初始化；</p>
<p>\4) 字节的面试官还说了另外一个区别，就是分配的位置，在堆上还是在栈上？这块我比较模糊，大家可以自己探究下，我搜索出来的答案是golang会弱化分配的位置的概念，因为编译的时候会自动内存逃逸处理，懂的大佬帮忙补充下：make、new内存分配是在堆上还是在栈上？</p>
<h3 id="数组和切片的区别-（基本必问）"><a href="#数组和切片的区别-（基本必问）" class="headerlink" title="数组和切片的区别 （基本必问）"></a><strong>数组和切片的区别 （基本必问）</strong></h3><p><strong>相同点：</strong></p>
<p>1)只能存储一组相同类型的数据结构</p>
<p>2)都是通过下标来访问，并且有容量长度，长度通过 len 获取，容量通过 cap 获取</p>
<p><strong>区别：</strong></p>
<p>1）数组是定长，访问和复制不能超过数组定义的长度，否则就会下标越界，切片长度和容量可以自动扩容</p>
<p>2）数组是值类型，切片是引用类型，每个切片都引用了一个底层数组，切片本身不能存储任何数据，都是这底层数组存储数据，所以修改切片的时候修改的是底层数组中的数据。切片一旦扩容，指向一个新的底层数组，内存地址也就随之改变</p>
<p><strong>简洁的回答：</strong></p>
<p>1）定义方式不一样 2）初始化方式不一样，数组需要指定大小，大小不改变 3）在函数传递中，数组切片都是值传递。</p>
<p><strong>数组的定义</strong></p>
<p>var a1 [3]int</p>
<p>var a2 […]int{1,2,3}</p>
<p><strong>切片的定义</strong></p>
<p>var a1 []int</p>
<p>var a2 :&#x3D;make([]int,3,5)</p>
<p><strong>数组的初始化</strong></p>
<p>a1 :&#x3D; […]int{1,2,3}</p>
<p>a2 :&#x3D; [5]int{1,2,3}</p>
<p><strong>切片的初始化</strong></p>
<p>b:&#x3D; make([]int,3,5)</p>
<h3 id="for-range-的时候它的地址会发生变化么？"><a href="#for-range-的时候它的地址会发生变化么？" class="headerlink" title="for range 的时候它的地址会发生变化么？"></a><strong>for range 的时候它的地址会发生变化么？</strong></h3><p>答：在 for a,b :&#x3D; range c 遍历中， a 和 b 在内存中只会存在一份，即之后每次循环时遍历到的数据都是以值覆盖的方式赋给 a 和 b，a，b 的内存地址始终不变。由于有这个特性，for 循环里面如果开协程，不要直接把 a 或者 b 的地址传给协程。解决办法：在每次循环时，创建一个临时变量。</p>
<h3 id="go-defer，多个-defer-的顺序，defer-在什么时机会修改返回值？"><a href="#go-defer，多个-defer-的顺序，defer-在什么时机会修改返回值？" class="headerlink" title="go defer，多个 defer 的顺序，defer 在什么时机会修改返回值？"></a><strong>go defer，多个 defer 的顺序，defer 在什么时机会修改返回值？</strong></h3><p>作用：defer延迟函数，释放资源，收尾工作；如释放锁，关闭文件，关闭链接；捕获panic;</p>
<p>避坑指南：defer函数紧跟在资源打开后面，否则defer可能得不到执行，导致内存泄露。</p>
<p>多个 defer 调用顺序是 LIFO（后入先出），defer后的操作可以理解为压入栈中</p>
<p>defer，return，return value（函数返回值） 执行顺序：首先return，其次return value，最后defer。defer可以修改函数最终返回值，修改时机：<strong>有名返回值或者函数返回指针</strong> 参考：</p>
<p><strong>有名返回值</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> (i <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(<span class="string">&quot;defer2:&quot;</span>, i)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(<span class="string">&quot;defer1:&quot;</span>, i)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> i <span class="comment">//或者直接写成return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;return:&quot;</span>, b())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p>
<p><strong>函数返回指针</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func c() *int &#123;</span><br><span class="line">	var i int</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(&quot;defer2:&quot;, i)</span><br><span class="line">	&#125;()</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(&quot;defer1:&quot;, i)</span><br><span class="line">	&#125;()</span><br><span class="line">	return &amp;i</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(&quot;return:&quot;, *(c()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uint-类型溢出问题"><a href="#uint-类型溢出问题" class="headerlink" title="uint 类型溢出问题"></a><strong>uint 类型溢出问题</strong></h3><p>超过最大存储值如uint8最大是255</p>
<p>var a uint8 &#x3D;255</p>
<p>var b uint8 &#x3D;1</p>
<p>a+b &#x3D; 0总之类型溢出会出现难以意料的事</p>
<p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-5bf5e213ce315a16d0b7e65ef41cc685_720w.webp" alt="img"></p>
<h3 id="能介绍下-rune-类型吗？"><a href="#能介绍下-rune-类型吗？" class="headerlink" title="能介绍下 rune 类型吗？"></a><strong>能介绍下 rune 类型吗？</strong></h3><p>相当int32</p>
<p>golang中的字符串底层实现是通过byte数组的，中文字符在unicode下占2个字节，在utf-8编码下占3个字节，而golang默认编码正好是utf-8</p>
<p>byte 等同于int8，常用来处理ascii字符</p>
<p>rune 等同于int32,常用来处理unicode或utf-8字符</p>
<p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-15a9656d176cfcc16d4116bbc9d2a24d_720w.webp" alt="img"></p>
<h3 id="调用函数传入结构体时，应该传值还是指针？-（Golang-都是传值）"><a href="#调用函数传入结构体时，应该传值还是指针？-（Golang-都是传值）" class="headerlink" title="调用函数传入结构体时，应该传值还是指针？ （Golang 都是传值）"></a><strong>调用函数传入结构体时，应该传值还是指针？ （Golang 都是传值）</strong></h3><p>Go 的函数参数传递都是值传递。所谓值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。参数传递还有引用传递，所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数</p>
<p>因为 Go 里面的 map，slice，chan 是引用类型。变量区分值类型和引用类型。所谓值类型：变量和变量的值存在同一个位置。所谓引用类型：变量和变量的值是不同的位置，变量的值存储的是对值的引用。但并不是 map，slice，chan 的所有的变量在函数内都能被修改，不同数据类型的底层存储结构和实现可能不太一样，情况也就不一样。</p>
<h3 id="讲讲-Go-的-slice-底层数据结构和一些特性？"><a href="#讲讲-Go-的-slice-底层数据结构和一些特性？" class="headerlink" title="讲讲 Go 的 slice 底层数据结构和一些特性？"></a><strong>讲讲 Go 的 slice 底层数据结构和一些特性？</strong></h3><p>答：Go 的 slice 底层数据结构是由一个 array 指针指向底层数组，len 表示切片长度，cap 表示切片容量。slice 的主要实现是扩容。对于 append 向 slice 添加元素时，假如 slice 容量够用，则追加新元素进去，slice.len++，返回原来的 slice。当原容量不够，则 slice 先扩容，扩容之后 slice 得到新的 slice，将元素追加进新的 slice，slice.len++，返回新的 slice。对于切片的扩容规则：当切片比较小时（容量小于 1024），则采用较大的扩容倍速进行扩容（新的扩容会是原来的 2 倍），避免频繁扩容，从而减少内存分配的次数和数据拷贝的代价。当切片较大的时（原来的 slice 的容量大于或者等于 1024），采用较小的扩容倍速（新的扩容将扩大大于或者等于原来 1.25 倍），主要避免空间浪费，网上其实很多总结的是 1.25 倍，那是在不考虑内存对齐的情况下，实际上还要考虑内存对齐，扩容是大于或者等于 1.25 倍。</p>
<p>（关于刚才问的 slice 为什么传到函数内可能被修改，如果 slice 在函数内没有出现扩容，函数外和函数内 slice 变量指向是同一个数组，则函数内复制的 slice 变量值出现更改，函数外这个 slice 变量值也会被修改。如果 slice 在函数内出现扩容，则函数内变量的值会新生成一个数组（也就是新的 slice，而函数外的 slice 指向的还是原来的 slice，则函数内的修改不会影响函数外的 slice。）</p>
<h3 id="讲讲-Go-的-select-底层数据结构和一些特性？（难点，没有项目经常可能说不清，面试一般会问你项目中怎么使用select）"><a href="#讲讲-Go-的-select-底层数据结构和一些特性？（难点，没有项目经常可能说不清，面试一般会问你项目中怎么使用select）" class="headerlink" title="讲讲 Go 的 select 底层数据结构和一些特性？（难点，没有项目经常可能说不清，面试一般会问你项目中怎么使用select）"></a><strong>讲讲 Go 的 select 底层数据结构和一些特性？（难点，没有项目经常可能说不清，面试一般会问你项目中怎么使用select）</strong></h3><p>答：go 的 select 为 golang 提供了多路 IO 复用机制，和其他 IO 复用一样，用于检测是否有读写事件是否 ready。linux 的系统 IO 模型有 select，poll，epoll，go 的 select 和 linux 系统 select 非常相似。</p>
<p>select 结构组成主要是由 case 语句和执行的函数组成 select 实现的多路复用是：每个线程或者进程都先到注册和接受的 channel（装置）注册，然后阻塞，然后只有一个线程在运输，当注册的线程和进程准备好数据后，装置会根据注册的信息得到相应的数据。</p>
<p><strong>select 的特性</strong></p>
<p>1）select 操作至少要有一个 case 语句，出现读写 nil 的 channel 该分支会忽略，在 nil 的 channel 上操作则会报错。</p>
<p>2）select 仅支持管道，而且是单协程操作。</p>
<p>3）每个 case 语句仅能处理一个管道，要么读要么写。</p>
<p>4）多个 case 语句的执行顺序是随机的。</p>
<p>5）存在 default 语句，select 将不会阻塞，但是存在 default 会影响性能。</p>
<h3 id="讲讲-Go-的-defer-底层数据结构和一些特性？"><a href="#讲讲-Go-的-defer-底层数据结构和一些特性？" class="headerlink" title="讲讲 Go 的 defer 底层数据结构和一些特性？"></a><strong>讲讲 Go 的 defer 底层数据结构和一些特性？</strong></h3><p>答：每个 defer 语句都对应一个_defer 实例，多个实例使用指针连接起来形成一个单连表，保存在 gotoutine 数据结构中，每次插入_defer 实例，均插入到链表的头部，函数结束再一次从头部取出，从而形成后进先出的效果。</p>
<p><strong>defer 的规则总结</strong>：</p>
<p>延迟函数的参数是 defer 语句出现的时候就已经确定了的。</p>
<p>延迟函数执行按照后进先出的顺序执行，即先出现的 defer 最后执行。</p>
<p>延迟函数可能操作主函数的返回值。</p>
<p>申请资源后立即使用 defer 关闭资源是个好习惯。</p>
<h3 id="单引号，双引号，反引号的区别？"><a href="#单引号，双引号，反引号的区别？" class="headerlink" title="单引号，双引号，反引号的区别？"></a><strong>单引号，双引号，反引号的区别？</strong></h3><p>单引号，表示byte类型或rune类型，对应 uint8和int32类型，默认是 rune 类型。byte用来强调数据是raw data，而不是数字；而rune用来表示Unicode的code point。</p>
<p>双引号，才是字符串，实际上是字符数组。可以用索引号访问某字节，也可以用len()函数来获取字符串所占的字节长度。</p>
<p>反引号，表示字符串字面量，但不支持任何转义序列。字面量 raw literal string 的意思是，你定义时写的啥样，它就啥样，你有换行，它就换行。你写转义字符，它也就展示转义字符。</p>
<h2 id="map相关"><a href="#map相关" class="headerlink" title="map相关"></a><strong>map相关</strong></h2><h3 id="map-使用注意的点，是否并发安全？"><a href="#map-使用注意的点，是否并发安全？" class="headerlink" title="map 使用注意的点，是否并发安全？"></a>map 使用注意的点，是否并发安全？</h3><p>map的类型是map[key]，key类型的ke必须是可比较的，通常情况，会选择内建的基本类型，比如整数、字符串做key的类型。如果要使用struct作为key，要保证struct对象在逻辑上是不可变的。在Go语言中，map[key]函数返回结果可以是一个值，也可以是两个值。map是无序的，如果我们想要保证遍历map时元素有序，可以使用辅助的数据结构，例如orderedmap。</p>
<p><strong>第一，</strong>一定要先初始化，否则panic</p>
<p><strong>第二，</strong>map类型是容易发生并发访问问题的。不注意就容易发生程序运行时并发读写导致的panic。 Go语言内建的map对象不是线程安全的，并发读写的时候运行时会有检查，遇到并发问题就会导致panic。</p>
<h3 id="map-循环是有序的还是无序的？"><a href="#map-循环是有序的还是无序的？" class="headerlink" title="map 循环是有序的还是无序的？"></a>map 循环是有序的还是无序的？</h3><p>无序的, map 因扩张⽽重新哈希时，各键值项存储位置都可能会发生改变，顺序自然也没法保证了，所以官方避免大家依赖顺序，直接打乱处理。就是 for range map 在开始处理循环逻辑的时候，就做了随机播种</p>
<h3 id="map-中删除一个-key，它的内存会释放么？（常问）"><a href="#map-中删除一个-key，它的内存会释放么？（常问）" class="headerlink" title="map 中删除一个 key，它的内存会释放么？（常问）"></a>map 中删除一个 key，它的内存会释放么？（常问）</h3><p>如果删除的元素是值类型，如int，float，bool，string以及数组和struct，map的内存不会自动释放</p>
<p>如果删除的元素是引用类型，如指针，slice，map，chan等，map的内存会自动释放，但释放的内存是子元素应用类型的内存占用</p>
<p>将map设置为nil后，内存被回收。</p>
<p><strong>这个问题还需要大家去搜索下答案，我记得有不一样的说法，谨慎采用本题答案。</strong></p>
<h3 id="怎么处理对-map-进行并发访问？有没有其他方案？-区别是什么？"><a href="#怎么处理对-map-进行并发访问？有没有其他方案？-区别是什么？" class="headerlink" title="怎么处理对 map 进行并发访问？有没有其他方案？ 区别是什么？"></a>怎么处理对 map 进行并发访问？有没有其他方案？ 区别是什么？</h3><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-1107961e741b834eb5fc071ff68da831_720w.webp" alt="img"></p>
<p><strong>方式一、使用内置sync.Map，详细参考</strong></p>
<p><a href="https://link.zhihu.com/?target=https://mbd.baidu.com/ma/s/7Hwd9yMc">https://mbd.baidu.com/ma/s/7Hwd9yMcmbd.baidu.com/ma/s/7Hwd9yMc</a></p>
<p><strong>方式二、使用读写锁实现并发安全map</strong></p>
<p><a href="https://link.zhihu.com/?target=https://mbd.baidu.com/ma/s/qO7b0VQU">https://mbd.baidu.com/ma/s/qO7b0VQUmbd.baidu.com/ma/s/qO7b0VQU</a></p>
<h3 id="nil-map-和空-map-有何不同？"><a href="#nil-map-和空-map-有何不同？" class="headerlink" title="nil map 和空 map 有何不同？"></a>nil map 和空 map 有何不同？</h3><p>1）可以对未初始化的map进行取值，但取出来的东西是空：</p>
<p>var m1 map[string]string</p>
<p>fmt.Println(m1[“1”])</p>
<p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p>
<p>2）不能对未初始化的map进行赋值，这样将会抛出一个异常：</p>
<p>var m1 map[string]string</p>
<p>m1[“1”] &#x3D; “1”</p>
<p>panic: assignment to entry in nil map</p>
<p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p>
<p>\3) 通过fmt打印map时，空map和nil map结果是一样的，都为map[]。所以，这个时候别断定map是空还是nil，而应该通过map &#x3D;&#x3D; nil来判断。</p>
<p><strong>nil map 未初始化，空map是长度为空</strong></p>
<h3 id="map-的数据结构是什么？是怎么实现扩容？"><a href="#map-的数据结构是什么？是怎么实现扩容？" class="headerlink" title="map 的数据结构是什么？是怎么实现扩容？"></a>map 的数据结构是什么？是怎么实现扩容？</h3><p>答：golang 中 map 是一个 kv 对集合。底层使用 hash table，用链表来解决冲突 ，出现冲突时，不是每一个 key 都申请一个结构通过链表串起来，而是以 bmap 为最小粒度挂载，一个 bmap 可以放 8 个 kv。在哈希函数的选择上，会在程序启动时，检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。每个 map 的底层结构是 hmap，是有若干个结构为 bmap 的 bucket 组成的数组。每个 bucket 底层都采用链表结构。</p>
<p><strong>hmap 的结构如下：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type hmap struct &#123;</span><br><span class="line">    count     int                  // 元素个数</span><br><span class="line">    flags     uint8</span><br><span class="line">    B         uint8                // 扩容常量相关字段B是buckets数组的长度的对数 2^B</span><br><span class="line">    noverflow uint16               // 溢出的bucket个数</span><br><span class="line">    hash0     uint32               // hash seed</span><br><span class="line">    buckets    unsafe.Pointer      // buckets 数组指针</span><br><span class="line">    oldbuckets unsafe.Pointer      // 结构扩容的时候用于赋值的buckets数组</span><br><span class="line">    nevacuate  uintptr             // 搬迁进度</span><br><span class="line">    extra *mapextra                // 用于扩容的指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>map 的容量大小</strong></p>
<p>底层调用 makemap 函数，计算得到合适的 B，map 容量最多可容纳 6.52^B 个元素，6.5 为装载因子阈值常量。装载因子的计算公式是：装载因子&#x3D;填入表中的元素个数&#x2F;散列表的长度，装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。底层调用 makemap 函数，计算得到合适的 B，map 容量最多可容纳 6.52^B 个元素，6.5 为装载因子阈值常量。装载因子的计算公式是：装载因子&#x3D;填入表中的元素个数&#x2F;散列表的长度，装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p>
<p><strong>触发 map 扩容的条件</strong></p>
<p>1）装载因子超过阈值，源码里定义的阈值是 6.5。</p>
<p>2）overflow 的 bucket 数量过多 map 的 bucket 定位和 key 的定位高八位用于定位 bucket，低八位用于定位 key，快速试错后再进行完整对比</p>
<p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-f99ed061ef6ea995743cda6d332861e3_720w.webp" alt="img"></p>
<h3 id="slices能作为map类型的key吗？"><a href="#slices能作为map类型的key吗？" class="headerlink" title="slices能作为map类型的key吗？"></a>slices能作为map类型的key吗？</h3><p>当时被问的一脸懵逼，其实是这个问题的变种：golang 哪些类型可以作为map key？</p>
<p>答案是：<strong>在golang规范中，可比较的类型都可以作为map key；</strong>这个问题又延伸到在：golang规范中，哪些数据类型可以比较？</p>
<p><strong>不能作为map key 的类型包括：</strong></p>
<ul>
<li>slices</li>
<li>maps</li>
<li>functions</li>
</ul>
<h2 id="context相关"><a href="#context相关" class="headerlink" title="context相关**"></a>context相关**</h2><h3 id="context-结构是什么样的？context-使用场景和用途？"><a href="#context-结构是什么样的？context-使用场景和用途？" class="headerlink" title="context 结构是什么样的？context 使用场景和用途？"></a><strong>context 结构是什么样的？context 使用场景和用途？</strong></h3><p><strong>（难，也常常问你项目中怎么用，光靠记答案很难让面试官满意，反正有各种结合实际的问题）</strong></p>
<p><strong>参考链接：</strong></p>
<p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/juanmaofeifei/p/14439957.html">go context详解 - 卷毛狒狒 - 博客园www.cnblogs.com/juanmaofeifei/p/14439957.html</a></p>
<p>答：Go 的 Context 的数据结构包含 Deadline，Done，Err，Value，Deadline 方法返回一个 time.Time，表示当前 Context 应该结束的时间，ok 则表示有结束时间，Done 方法当 Context 被取消或者超时时候返回的一个 close 的 channel，告诉给 context 相关的函数要停止当前工作然后返回了，Err 表示 context 被取消的原因，Value 方法表示 context 实现共享数据存储的地方，是协程安全的。context 在业务中是经常被使用的，</p>
<p><strong>其主要的应用 ：</strong></p>
<p>1：上下文控制，2：多个 goroutine 之间的数据交互等，3：超时控制：到某个时间点超时，过多久超时。</p>
<h2 id="channel相关"><a href="#channel相关" class="headerlink" title="channel相关"></a><strong>channel相关</strong></h2><h3 id="channel-是否线程安全？锁用在什么地方？"><a href="#channel-是否线程安全？锁用在什么地方？" class="headerlink" title="channel 是否线程安全？锁用在什么地方？"></a><strong>channel 是否线程安全？锁用在什么地方？</strong></h3><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-e287f5861392d5de73d8956974acdbbd_720w.webp" alt="img"></p>
<p>就着图片里面的答案看看吧。</p>
<h3 id="go-channel-的底层实现原理-（数据结构）"><a href="#go-channel-的底层实现原理-（数据结构）" class="headerlink" title="go channel 的底层实现原理 （数据结构）"></a><strong>go channel 的底层实现原理 （数据结构）</strong></h3><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-9452c08ff058590cea1b40a39fd8c70f_720w.webp" alt="img"></p>
<p>底层结构需要描述出来，这个简单，buf，发送队列，接收队列，lock。</p>
<h3 id="nil、关闭的-channel、有数据的-channel，再进行读、写、关闭会怎么样？（各类变种题型，重要）"><a href="#nil、关闭的-channel、有数据的-channel，再进行读、写、关闭会怎么样？（各类变种题型，重要）" class="headerlink" title="nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？（各类变种题型，重要）"></a><strong>nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？（各类变种题型，重要）</strong></h3><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-8e12b7eb664280346ec96bcc4fe1db2c_720w.webp" alt="img"></p>
<p>还要去了解一下单向channel,如只读或者只写通道常见的异常问题，这块还需要大家自己总结总结，有懂得大佬也可以评论发送答案。</p>
<h3 id="向-channel-发送数据和从-channel-读数据的流程是什么样的？"><a href="#向-channel-发送数据和从-channel-读数据的流程是什么样的？" class="headerlink" title="向 channel 发送数据和从 channel 读数据的流程是什么样的？"></a><strong>向 channel 发送数据和从 channel 读数据的流程是什么样的？</strong></h3><p><strong>发送流程：</strong></p>
<p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-d2a3f2aa5c85b94df49430c21a53a2d9_720w.webp" alt="img"></p>
<p><strong>接收流程：</strong></p>
<p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-69e0e2f1409a17ec2987e4b63e6210da_720w.webp" alt="img"></p>
<p>这个没啥好说的，底层原理，1、2、3描述出来，保证面试官满意。具体的文字描述下面一题有，channel的概念多且复杂，脑海中有个总分的概念，否则你说的再多，面试官也抓不住你说的重点，等于白说。问题5已经为大家总结好了。</p>
<h3 id="讲讲-Go-的-chan-底层数据结构和主要使用场景"><a href="#讲讲-Go-的-chan-底层数据结构和主要使用场景" class="headerlink" title="讲讲 Go 的 chan 底层数据结构和主要使用场景"></a><strong>讲讲 Go 的 chan 底层数据结构和主要使用场景</strong></h3><p>答：channel 的数据结构包含 qccount 当前队列中剩余元素个数，dataqsiz 环形队列长度，即可以存放的元素个数，buf 环形队列指针，elemsize 每个元素的大小，closed 标识关闭状态，elemtype 元素类型，sendx 队列下表，指示元素写入时存放到队列中的位置，recv 队列下表，指示元素从队列的该位置读出。recvq 等待读消息的 goroutine 队列，sendq 等待写消息的 goroutine 队列，lock 互斥锁，chan 不允许并发读写。</p>
<p><strong>无缓冲和有缓冲区别：</strong> 管道没有缓冲区，从管道读数据会阻塞，直到有协程向管道中写入数据。同样，向管道写入数据也会阻塞，直到有协程从管道读取数据。管道有缓冲区但缓冲区没有数据，从管道读取数据也会阻塞，直到协程写入数据，如果管道满了，写数据也会阻塞，直到协程从缓冲区读取数据。</p>
<p><strong>channel 的一些特点</strong> 1）、读写值 nil 管道会永久阻塞 2）、关闭的管道读数据仍然可以读数据 3）、往关闭的管道写数据会 panic 4）、关闭为 nil 的管道 panic 5）、关闭已经关闭的管道 panic</p>
<p><strong>向 channel 写数据的流程：</strong> 如果等待接收队列 recvq 不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从 recvq 取出 G,并把数据写入，最后把该 G 唤醒，结束发送过程； 如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程； 如果缓冲区中没有空余位置，将待发送数据写入 G，将当前 G 加入 sendq，进入睡眠，等待被读 goroutine 唤醒；</p>
<p><strong>向 channel 读数据的流程：</strong> 如果等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G，把 G 中数据读出，最后把 G 唤醒，结束读取过程； 如果等待发送队列 sendq 不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程； 如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；将当前 goroutine 加入 recvq，进入睡眠，等待被写 goroutine 唤醒；</p>
<p><strong>使用场景：</strong> 消息传递、消息过滤，信号广播，事件订阅与广播，请求、响应转发，任务分发，结果汇总，并发控制，限流，同步与异步</p>
<h2 id="GMP相关"><a href="#GMP相关" class="headerlink" title="GMP相关"></a><strong>GMP相关</strong></h2><h3 id="什么是-GMP？（必问）"><a href="#什么是-GMP？（必问）" class="headerlink" title="什么是 GMP？（必问）"></a>什么是 GMP？（必问）</h3><p>答：G 代表着 goroutine，P 代表着上下文处理器，M 代表 thread 线程，在 GPM 模型，有一个全局队列（Global Queue）：存放等待运行的 G，还有一个 P 的本地队列：也是存放等待运行的 G，但数量有限，不超过 256 个。GPM 的调度流程从 go func()开始创建一个 goroutine，新建的 goroutine 优先保存在 P 的本地队列中，如果 P 的本地队列已经满了，则会保存到全局队列中。M 会从 P 的队列中取一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会从其他的 MP 组合偷取一个可执行的 G 来执行，当 M 执行某一个 G 时候发生系统调用或者阻塞，M 阻塞，如果这个时候 G 在执行，runtime 会把这个线程 M 从 P 中摘除，然后创建一个新的操作系统线程来服务于这个 P，当 M 系统调用结束时，这个 G 会尝试获取一个空闲的 P 来执行，并放入到这个 P 的本地队列，如果这个线程 M 变成休眠状态，加入到空闲线程中，然后整个 G 就会被放入到全局队列中。</p>
<p>关于 G,P,M 的个数问题，G 的个数理论上是无限制的，但是受内存限制，P 的数量一般建议是逻辑 CPU 数量的 2 倍，M 的数据默认启动的时候是 10000，内核很难支持这么多线程数，所以整个限制客户忽略，M 一般不做设置，设置好 P，M 一般都是要大于 P。</p>
<h3 id="进程、线程、协程有什么区别？（必问）"><a href="#进程、线程、协程有什么区别？（必问）" class="headerlink" title="进程、线程、协程有什么区别？（必问）"></a>进程、线程、协程有什么区别？（必问）</h3><p>进程：是应用程序的启动实例，每个进程都有独立的内存空间，不同的进程通过进程间的通信方式来通信。</p>
<p>线程：从属于进程，每个进程至少包含一个线程，线程是 CPU 调度的基本单位，多个线程之间可以共享进程的资源并通过共享内存等线程间的通信方式来通信。</p>
<p>协程：为轻量级线程，与线程相比，协程不受操作系统的调度，协程的调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行</p>
<h3 id="抢占式调度是如何抢占的？"><a href="#抢占式调度是如何抢占的？" class="headerlink" title="抢占式调度是如何抢占的？"></a><strong>抢占式调度是如何抢占的？</strong></h3><p><strong>基于协作式抢占</strong></p>
<p><strong>基于信号量抢占</strong></p>
<p>就像操作系统要负责线程的调度一样，Go的runtime要负责goroutine的调度。现代操作系统调度线程都是抢占式的，我们不能依赖用户代码主动让出CPU，或者因为IO、锁等待而让出，这样会造成调度的不公平。基于经典的时间片算法，当线程的时间片用完之后，会被时钟中断给打断，调度器会将当前线程的执行上下文进行保存，然后恢复下一个线程的上下文，分配新的时间片令其开始执行。这种抢占对于线程本身是无感知的，系统底层支持，不需要开发人员特殊处理。</p>
<p>基于时间片的抢占式调度有个明显的优点，能够避免CPU资源持续被少数线程占用，从而使其他线程长时间处于饥饿状态。goroutine的调度器也用到了时间片算法，但是和操作系统的线程调度还是有些区别的，因为整个Go程序都是运行在用户态的，所以不能像操作系统那样利用时钟中断来打断运行中的goroutine。也得益于完全在用户态实现，goroutine的调度切换更加轻量。</p>
<p><strong>上面这两段文字只是对调度的一个概括，具体的协作式调度、信号量调度大家还需要去详细了解，这偏底层了，大厂或者中高级开发会问。（字节就问了）</strong></p>
<h3 id="M-和-P-的数量问题？"><a href="#M-和-P-的数量问题？" class="headerlink" title="M 和 P 的数量问题？"></a>M 和 P 的数量问题？</h3><p>p默认cpu内核数</p>
<p>M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来</p>
<p>【Go语言调度模型G、M、P的数量多少合适？】</p>
<p>详细参考这篇文章</p>
<p><a href="https://link.zhihu.com/?target=https://mbd.baidu.com/ma/s/ZMOKQATr">https://mbd.baidu.com/ma/s/ZMOKQATrmbd.baidu.com/ma/s/ZMOKQATr</a></p>
<p>GMP数量这一块，结论很好记，没用项目经验的话，问了项目中怎么用可能容易卡壳。</p>
<h2 id="锁相关"><a href="#锁相关" class="headerlink" title="锁相关"></a>锁相关</h2><h3 id="除了-mutex-以外还有那些方式安全读写共享变量？"><a href="#除了-mutex-以外还有那些方式安全读写共享变量？" class="headerlink" title="除了 mutex 以外还有那些方式安全读写共享变量？"></a>除了 mutex 以外还有那些方式安全读写共享变量？</h3><p>* 将共享变量的读写放到一个 goroutine 中，其它 goroutine 通过 channel 进行读写操作。</p>
<p>* 可以用个数为 1 的信号量（semaphore）实现互斥</p>
<p>* 通过 Mutex 锁实现</p>
<h3 id="Go-如何实现原子操作？"><a href="#Go-如何实现原子操作？" class="headerlink" title="Go 如何实现原子操作？"></a>Go 如何实现原子操作？</h3><p>答：原子操作就是不可中断的操作，外界是看不到原子操作的中间状态，要么看到原子操作已经完成，要么看到原子操作已经结束。在某个值的原子操作执行的过程中，CPU 绝对不会再去执行其他针对该值的操作，那么其他操作也是原子操作。</p>
<p>Go 语言的标准库代码包 sync&#x2F;atomic 提供了原子的读取（Load 为前缀的函数）或写入（Store 为前缀的函数）某个值（这里细节还要多去查查资料）。</p>
<p><strong>原子操作与互斥锁的区别</strong></p>
<p>1）、互斥锁是一种数据结构，用来让一个线程执行程序的关键部分，完成互斥的多个操作。</p>
<p>2）、原子操作是针对某个值的单个互斥操作。</p>
<h3 id="Mutex-是悲观锁还是乐观锁？悲观锁、乐观锁是什么？"><a href="#Mutex-是悲观锁还是乐观锁？悲观锁、乐观锁是什么？" class="headerlink" title="Mutex 是悲观锁还是乐观锁？悲观锁、乐观锁是什么？"></a>Mutex 是悲观锁还是乐观锁？悲观锁、乐观锁是什么？</h3><p><strong>悲观锁</strong></p>
<p>悲观锁：当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。</p>
<p><strong>乐观锁</strong></p>
<p>乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量</p>
<h3 id="Mutex-有几种模式？"><a href="#Mutex-有几种模式？" class="headerlink" title="Mutex 有几种模式？"></a>Mutex 有几种模式？</h3><p><strong>1）正常模式</strong></p>
<ol>
<li>当前的mutex只有一个goruntine来获取，那么没有竞争，直接返回。</li>
<li>新的goruntine进来，如果当前mutex已经被获取了，则该goruntine进入一个先入先出的waiter队列，在mutex被释放后，waiter按照先进先出的方式获取锁。该goruntine会处于自旋状态(不挂起，继续占有cpu)。</li>
<li>新的goruntine进来，mutex处于空闲状态，将参与竞争。新来的 goroutine 有先天的优势，它们正在 CPU 中运行，可能它们的数量还不少，所以，在高并发情况下，被唤醒的 waiter 可能比较悲剧地获取不到锁，这时，它会被插入到队列的前面。如果 waiter 获取不到锁的时间超过阈值 1 毫秒，那么，这个 Mutex 就进入到了饥饿模式。</li>
</ol>
<p><strong>2）饥饿模式</strong></p>
<p>在饥饿模式下，Mutex 的拥有者将直接把锁交给队列最前面的 waiter。新来的 goroutine 不会尝试获取锁，即使看起来锁没有被持有，它也不会去抢，也不会 spin（自旋），它会乖乖地加入到等待队列的尾部。 如果拥有 Mutex 的 waiter 发现下面两种情况的其中之一，它就会把这个 Mutex 转换成正常模式:</p>
<ol>
<li>此 waiter 已经是队列中的最后一个 waiter 了，没有其它的等待锁的 goroutine 了；</li>
<li>此 waiter 的等待时间小于 1 毫秒。</li>
</ol>
<h3 id="goroutine-的自旋占用资源如何解决"><a href="#goroutine-的自旋占用资源如何解决" class="headerlink" title="goroutine 的自旋占用资源如何解决"></a>goroutine 的自旋占用资源如何解决</h3><p>自旋锁是指当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断地判断是否能够被成功获取，直到获取到锁才会退出循环。</p>
<p><strong>自旋的条件如下：</strong></p>
<p>1）还没自旋超过 4 次,</p>
<p>2）多核处理器，</p>
<p>3）GOMAXPROCS &gt; 1，</p>
<p>4）p 上本地 goroutine 队列为空。</p>
<p>mutex 会让当前的 goroutine 去空转 CPU，在空转完后再次调用 CAS 方法去尝试性的占有锁资源，直到不满足自旋条件，则最终会加入到等待队列里。</p>
<h2 id="并发相关"><a href="#并发相关" class="headerlink" title="并发相关"></a><strong>并发相关</strong></h2><h3 id="怎么控制并发数？"><a href="#怎么控制并发数？" class="headerlink" title="怎么控制并发数？"></a>怎么控制并发数？</h3><p><strong>第一，有缓冲通道</strong></p>
<p>根据通道中没有数据时读取操作陷入阻塞和通道已满时继续写入操作陷入阻塞的特性，正好实现控制并发数量。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	count := 10 // 最大支持并发</span><br><span class="line">	sum := 100 // 任务总数</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125; //控制主协程等待所有子协程执行完之后再退出。</span><br><span class="line"></span><br><span class="line">	c := make(chan struct&#123;&#125;, count) // 控制任务并发的chan</span><br><span class="line">	defer close(c)</span><br><span class="line"></span><br><span class="line">	for i:=0; i&lt;sum;i++&#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		c &lt;- struct&#123;&#125;&#123;&#125; // 作用类似于waitgroup.Add(1)</span><br><span class="line">		go func(j int) &#123;</span><br><span class="line">			defer wg.Done()</span><br><span class="line">			fmt.Println(j)</span><br><span class="line">			&lt;- c // 执行完毕，释放资源</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二，三方库实现的协程池</strong></p>
<p>panjf2000&#x2F;ants（比较火）</p>
<p>Jeffail&#x2F;tunny</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line"></span><br><span class="line">	&quot;github.com/Jeffail/tunny&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">	pool := tunny.NewFunc(10, func(i interface&#123;&#125;) interface&#123;&#125; &#123;</span><br><span class="line">		log.Println(i)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		return nil</span><br><span class="line">	&#125;)</span><br><span class="line">	defer pool.Close()</span><br><span class="line"></span><br><span class="line">	for i := 0; i &lt; 500; i++ &#123;</span><br><span class="line">		go pool.Process(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second * 4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多个-goroutine-对同一个-map-写会-panic，异常是否可以用-defer-捕获？"><a href="#多个-goroutine-对同一个-map-写会-panic，异常是否可以用-defer-捕获？" class="headerlink" title="多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 捕获？"></a>多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 捕获？</h3><p>可以捕获异常，但是只能捕获一次，Go语言，可以使用多值返回来返回错误。不要用异常代替错误，更不要用来控制流程。在极个别的情况下，才使用Go中引入的Exception处理：defer, panic, recover Go中，对异常处理的原则是：多用error包，少用panic</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">defer func() &#123;</span><br><span class="line">		if err := recover(); err != nil &#123;</span><br><span class="line">			// 打印异常，关闭资源，退出此函数</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br></pre></td></tr></table></figure>

<h3 id="如何优雅的实现一个-goroutine-池"><a href="#如何优雅的实现一个-goroutine-池" class="headerlink" title="如何优雅的实现一个 goroutine 池"></a>如何优雅的实现一个 goroutine 池</h3><p>（百度、手写代码，本人面传音控股被问道：请求数大于消费能力怎么设计协程池）</p>
<p>这一块能啃下来，offer满天飞，这应该是保证高并发系统稳定性、高可用的核心部分之一。</p>
<p><strong>建议参考：</strong></p>
<p><strong>这篇文章的目录是：</strong></p>
<p>\1. 为什么需要协程池？</p>
<p>\2. 简单的协程池</p>
<p>\3. go-playground&#x2F;pool</p>
<p>\4. ants（推荐）</p>
<p><strong>所以直接研究ants底层吧，省的造轮子。</strong></p>
<h2 id="GC相关"><a href="#GC相关" class="headerlink" title="GC相关"></a><strong>GC相关</strong></h2><h3 id="go-gc-是怎么实现的？（必问）"><a href="#go-gc-是怎么实现的？（必问）" class="headerlink" title="go gc 是怎么实现的？（必问）"></a>go gc 是怎么实现的？（必问）</h3><p>答：</p>
<p><strong>细分常见的三个问题：1、GC机制随着golang版本变化如何变化的？2、三色标记法的流程？3、插入屏障、删除屏障，混合写屏障（具体的实现比较难描述，但你要知道屏障的作用：避免程序运行过程中，变量被误回收；减少STW的时间）4、虾皮还问了个开放性的题目：你觉得以后GC机制会怎么优化？</strong></p>
<p>Go 的 GC 回收有三次演进过程，Go V1.3 之前普通标记清除（mark and sweep）方法，整体过程需要启动 STW，效率极低。GoV1.5 三色标记法，堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要 STW)，效率普通。GoV1.8 三色标记法，混合写屏障机制：栈空间不启动（全部标记成黑色），堆空间启用写屏障，整个过程不要 STW，效率高。</p>
<p>Go1.3 之前的版本所谓标记清除是先启动 STW 暂停，然后执行标记，再执行数据回收，最后停止 STW。Go1.3 版本标记清除做了点优化，流程是：先启动 STW 暂停，然后执行标记，停止 STW，最后再执行数据回收。</p>
<p>Go1.5 三色标记主要是插入屏障和删除屏障，写入屏障的流程：程序开始，全部标记为白色，1）所有的对象放到白色集合，2）遍历一次根节点，得到灰色节点，3）遍历灰色节点，将可达的对象，从白色标记灰色，遍历之后的灰色标记成黑色，4）由于并发特性，此刻外界向在堆中的对象发生添加对象，以及在栈中的对象添加对象，在堆中的对象会触发插入屏障机制，栈中的对象不触发，5）由于堆中对象插入屏障，则会把堆中黑色对象添加的白色对象改成灰色，栈中的黑色对象添加的白色对象依然是白色，6）循环第 5 步，直到没有灰色节点，7）在准备回收白色前，重新遍历扫描一次栈空间，加上 STW 暂停保护栈，防止外界干扰（有新的白色会被添加成黑色）在 STW 中，将栈中的对象一次三色标记，直到没有灰色，8）停止 STW，清除白色。至于删除写屏障，则是遍历灰色节点的时候出现可达的节点被删除，这个时候触发删除写屏障，这个可达的被删除的节点也是灰色，等循环三色标记之后，直到没有灰色节点，然后清理白色，删除写屏障会造成一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮 GC 中被清理掉。</p>
<p>GoV1.8 混合写屏障规则是：</p>
<p>1）GC 开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需 STW)，2）GC 期间，任何在栈上创建的新对象，均为黑色。3）被删除的对象标记为灰色。4）被添加的对象标记为灰色。</p>
<h3 id="go-是-gc-算法是怎么实现的？-（得物，出现频率低）"><a href="#go-是-gc-算法是怎么实现的？-（得物，出现频率低）" class="headerlink" title="go 是 gc 算法是怎么实现的？ （得物，出现频率低）"></a>go 是 gc 算法是怎么实现的？ （得物，出现频率低）</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func GC() &#123;</span><br><span class="line">	n := atomic.Load(&amp;amp;work.cycles)</span><br><span class="line">	gcWaitOnMark(n)</span><br><span class="line"></span><br><span class="line">	gcStart(gcTrigger&#123;kind: gcTriggerCycle, n: n + 1&#125;)</span><br><span class="line">	gcWaitOnMark(n + 1)</span><br><span class="line"></span><br><span class="line">	for atomic.Load(&amp;amp;work.cycles) == n+1 &amp;amp;&amp;amp; sweepone() != ^uintptr(0) &#123;</span><br><span class="line">		sweep.nbgsweep++</span><br><span class="line">		Gosched()</span><br><span class="line">	&#125;</span><br><span class="line">	for atomic.Load(&amp;amp;work.cycles) == n+1 &amp;amp;&amp;amp; atomic.Load(&amp;amp;mheap_.sweepers) != 0 &#123;</span><br><span class="line">		Gosched()</span><br><span class="line">	&#125;</span><br><span class="line">	mp := acquirem()</span><br><span class="line">	cycle := atomic.Load(&amp;amp;work.cycles)</span><br><span class="line">	if cycle == n+1 || (gcphase == _GCmark &amp;amp;&amp;amp; cycle == n+2) &#123;</span><br><span class="line">		mProf_PostSweep()</span><br><span class="line">	&#125;</span><br><span class="line">	releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层原理了，可能大厂，中高级才会问，参考：</p>
<h3 id="GC-中-stw-时机，各个阶段是如何解决的？-（百度）"><a href="#GC-中-stw-时机，各个阶段是如何解决的？-（百度）" class="headerlink" title="GC 中 stw 时机，各个阶段是如何解决的？ （百度）"></a>GC 中 stw 时机，各个阶段是如何解决的？ （百度）</h3><p><strong>底层原理，自行百度一下，我等渣渣简历都过不了BAT，字节，虾皮，特使拉以及一些国Q还能收到面试邀约</strong>。</p>
<p>1）在开始新的一轮 GC 周期前，需要调用 gcWaitOnMark 方法上一轮 GC 的标记结束（含扫描终止、标记、或标记终止等）。</p>
<p>2）开始新的一轮 GC 周期，调用 gcStart 方法触发 GC 行为，开始扫描标记阶段。</p>
<p>3）需要调用 gcWaitOnMark 方法等待，直到当前 GC 周期的扫描、标记、标记终止完成。</p>
<p>4）需要调用 sweepone 方法，扫描未扫除的堆跨度，并持续扫除，保证清理完成。在等待扫除完毕前的阻塞时间，会调用 Gosched 让出。</p>
<p>5）在本轮 GC 已经基本完成后，会调用 mProf_PostSweep 方法。以此记录最后一次标记终止时的堆配置文件快照。</p>
<p>6）结束，释放 M。</p>
<h3 id="GC-的触发时机？"><a href="#GC-的触发时机？" class="headerlink" title="GC 的触发时机？"></a>GC 的触发时机？</h3><p>初级必问，分为系统触发和主动触发。</p>
<p>1）gcTriggerHeap：当所分配的堆大小达到阈值（由控制器计算的触发堆的大小）时，将会触发。</p>
<p>2）gcTriggerTime：当距离上一个 GC 周期的时间超过一定时间时，将会触发。时间周期以runtime.forcegcperiod 变量为准，默认 2 分钟。</p>
<p>3）gcTriggerCycle：如果没有开启 GC，则启动 GC。</p>
<p>4）手动触发的 runtime.GC 方法。</p>
<h2 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a><strong>内存相关</strong></h2><h3 id="谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？"><a href="#谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？" class="headerlink" title="谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？"></a>谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？</h3><p>答：go 中的内存泄漏一般都是 goroutine 泄漏，就是 goroutine 没有被关闭，或者没有添加超时控制，让 goroutine 一只处于阻塞状态，不能被 GC。</p>
<p><strong>内存泄露有下面一些情况</strong></p>
<p>1）如果 goroutine 在执行时被阻塞而无法退出，就会导致 goroutine 的内存泄漏，一个 goroutine 的最低栈大小为 2KB，在高并发的场景下，对内存的消耗也是非常恐怖的。</p>
<p>2）互斥锁未释放或者造成死锁会造成内存泄漏</p>
<p>3）time.Ticker 是每隔指定的时间就会向通道内写数据。作为循环触发器，必须调用 stop 方法才会停止，从而被 GC 掉，否则会一直占用内存空间。</p>
<p>4）字符串的截取引发临时性的内存泄漏</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	var str0 = &quot;12345678901234567890&quot;</span><br><span class="line">	str1 := str0[:10]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5）切片截取引起子切片内存泄漏</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	var s0 = []int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br><span class="line">	s1 := s0[:3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6）函数数组传参引发内存泄漏【如果我们在函数传参的时候用到了数组传参，且这个数组够大（我们假设数组大小为 100 万，64 位机上消耗的内存约为 800w 字节，即 8MB 内存），或者该函数短时间内被调用 N 次，那么可想而知，会消耗大量内存，对性能产生极大的影响，如果短时间内分配大量内存，而又来不及 GC，那么就会产生临时性的内存泄漏，对于高并发场景相当可怕。】</p>
<p><strong>排查方式：</strong></p>
<p>一般通过 pprof 是 Go 的性能分析工具，在程序运行过程中，可以记录程序的运行信息，可以是 CPU 使用情况、内存使用情况、goroutine 运行情况等，当需要性能调优或者定位 Bug 时候，这些记录的信息是相当重要。</p>
<p><strong>当然你能说说具体的分析指标更加分咯，有的面试官就喜欢他问什么，你简洁的回答什么，不喜欢巴拉巴拉详细解释一通，比如虾P面试官，不过他考察的内容特别多，可能是为了节约时间。</strong></p>
<h3 id="知道-golang-的内存逃逸吗？什么情况下会发生内存逃逸？（必问）"><a href="#知道-golang-的内存逃逸吗？什么情况下会发生内存逃逸？（必问）" class="headerlink" title="知道 golang 的内存逃逸吗？什么情况下会发生内存逃逸？（必问）"></a>知道 golang 的内存逃逸吗？什么情况下会发生内存逃逸？（必问）</h3><p>答：1)本该分配到栈上的变量，跑到了堆上，这就导致了内存逃逸。2)栈是高地址到低地址，栈上的变量，函数结束后变量会跟着回收掉，不会有额外性能的开销。3)变量从栈逃逸到堆上，如果要回收掉，需要进行 gc，那么 gc 一定会带来额外的性能开销。编程语言不断优化 gc 算法，主要目的都是为了减少 gc 带来的额外性能开销，变量一旦逃逸会导致性能开销变大。</p>
<p><strong>内存逃逸的情况如下：</strong></p>
<p>1）方法内返回局部变量指针。</p>
<p>2）向 channel 发送指针数据。</p>
<p>3）在闭包中引用包外的值。</p>
<p>4）在 slice 或 map 中存储指针。</p>
<p>5）切片（扩容后）长度太大。</p>
<p>6）在 interface 类型上调用方法。</p>
<h3 id="请简述-Go-是如何分配内存的？"><a href="#请简述-Go-是如何分配内存的？" class="headerlink" title="请简述 Go 是如何分配内存的？"></a>请简述 Go 是如何分配内存的？</h3><p>mcache mcentral mheap mspan</p>
<p>Go 程序启动的时候申请一大块内存，并且划分 spans，bitmap，areana 区域；arena 区域按照页划分成一个个小块，span 管理一个或者多个页，mcentral 管理多个 span 供现场申请使用；mcache 作为线程私有资源，来源于 mcentral。</p>
<p><strong>这里描述的比较简单，你可以自己再去搜索下更简洁完整的答案。</strong></p>
<h3 id="Channel-分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？"><a href="#Channel-分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？" class="headerlink" title="Channel 分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？"></a>Channel 分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？</h3><p>Channel 被设计用来实现协程间通信的组件，其作用域和生命周期不可能仅限于某个函数内部，所以 golang 直接将其分配在堆上</p>
<p>准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。</p>
<p>知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。然而，如果编译器不能确保变量在函数 return 之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。</p>
<p>当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上,然而，还要对这些变量做逃逸分析，如果函数 return 之后，变量不再被引用，则将其分配到栈上。</p>
<h3 id="介绍一下大对象小对象，为什么小对象多了会造成-gc-压力？"><a href="#介绍一下大对象小对象，为什么小对象多了会造成-gc-压力？" class="headerlink" title="介绍一下大对象小对象，为什么小对象多了会造成 gc 压力？"></a>介绍一下大对象小对象，为什么小对象多了会造成 gc 压力？</h3><p>小于等于 32k 的对象就是小对象，其它都是大对象。一般小对象通过 mspan 分配内存；大对象则直接由 mheap 分配内存。通常小对象过多会导致 GC 三色法消耗过多的 CPU。优化思路是，减少对象分配。</p>
<p>小对象：如果申请小对象时，发现当前内存空间不存在空闲跨度时，将会需要调用 nextFree 方法获取新的可用的对象，可能会触发 GC 行为。</p>
<p>大对象：如果申请大于 32k 以上的大对象时，可能会触发 GC 行为。</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="Go-多返回值怎么实现的？"><a href="#Go-多返回值怎么实现的？" class="headerlink" title="Go 多返回值怎么实现的？"></a>Go 多返回值怎么实现的？</h3><p>答：Go 传参和返回值是通过 FP+offset 实现，并且存储在调用函数的栈帧中。FP 栈底寄存器，指向一个函数栈的顶部;PC 程序计数器，指向下一条执行指令;SB 指向静态数据的基指针，全局符号;SP 栈顶寄存器。</p>
<h3 id="讲讲-Go-中主协程如何等待其余协程退出"><a href="#讲讲-Go-中主协程如何等待其余协程退出" class="headerlink" title="讲讲 Go 中主协程如何等待其余协程退出?"></a>讲讲 Go 中主协程如何等待其余协程退出?</h3><p>答：Go 的 sync.WaitGroup 是等待一组协程结束，sync.WaitGroup 只有 3 个方法，Add()是添加计数，Done()减去一个计数，Wait()阻塞直到所有的任务完成。Go 里面还能通过有缓冲的 channel 实现其阻塞等待一组协程结束，这个不能保证一组 goroutine 按照顺序执行，可以并发执行协程。Go 里面能通过无缓冲的 channel 实现其阻塞等待一组协程结束，这个能保证一组 goroutine 按照顺序执行，但是不能并发执行。</p>
<p><strong>啰嗦一句：</strong>循环智能二面，手写代码部分时，三个协程按交替顺序打印数字，最后题目做出来了，问我代码中Add()是什么意思，我回答的不是很清晰，这家公司就没有然后了。Add()表示协程计数，可以一次Add多个，如Add(3),可以多次Add(1);然后每个子协程必须调用done（）,这样才能保证所有子协程结束，主协程才能结束。</p>
<h3 id="Go-语言中不同的类型如何比较是否相等？"><a href="#Go-语言中不同的类型如何比较是否相等？" class="headerlink" title="Go 语言中不同的类型如何比较是否相等？"></a>Go 语言中不同的类型如何比较是否相等？</h3><p>答：像 string，int，float interface 等可以通过 reflect.DeepEqual 和等于号进行比较，像 slice，struct，map 则一般使用 reflect.DeepEqual 来检测是否相等。</p>
<h3 id="Go-中-init-函数的特征"><a href="#Go-中-init-函数的特征" class="headerlink" title="Go 中 init 函数的特征?"></a>Go 中 init 函数的特征?</h3><p>答：一个包下可以有多个 init 函数，每个文件也可以有多个 init 函数。多个 init 函数按照它们的文件名顺序逐个初始化。应用初始化时初始化工作的顺序是，从被导入的最深层包开始进行初始化，层层递出最后到 main 包。不管包被导入多少次，包内的 init 函数只会执行一次。应用初始化时初始化工作的顺序是，从被导入的最深层包开始进行初始化，层层递出最后到 main 包。但包级别变量的初始化先于包内 init 函数的执行。</p>
<h3 id="Go-中-uintptr-和-unsafe-Pointer-的区别？"><a href="#Go-中-uintptr-和-unsafe-Pointer-的区别？" class="headerlink" title="Go 中 uintptr 和 unsafe.Pointer 的区别？"></a>Go 中 uintptr 和 unsafe.Pointer 的区别？</h3><p>答：unsafe.Pointer 是通用指针类型，它不能参与计算，任何类型的指针都可以转化成 unsafe.Pointer，unsafe.Pointer 可以转化成任何类型的指针，uintptr 可以转换为 unsafe.Pointer，unsafe.Pointer 可以转换为 uintptr。uintptr 是指针运算的工具，但是它不能持有指针对象（意思就是它跟指针对象不能互相转换），unsafe.Pointer 是指针对象进行运算（也就是 uintptr）的桥梁。</p>
<h3 id="golang共享内存（互斥锁）方法实现发送多个get请求"><a href="#golang共享内存（互斥锁）方法实现发送多个get请求" class="headerlink" title="golang共享内存（互斥锁）方法实现发送多个get请求"></a>golang共享内存（互斥锁）方法实现发送多个get请求</h3><p>待补充</p>
<h3 id="从数组中取一个相同大小的slice有成本吗？"><a href="#从数组中取一个相同大小的slice有成本吗？" class="headerlink" title="从数组中取一个相同大小的slice有成本吗？"></a>从数组中取一个相同大小的slice有成本吗？</h3><p>或者这么问：从切片中取一个相同大小的数组有成本吗？</p>
<p>这是爱立信的二面题目，这个问题我至今还没搞懂，不知道从什么切入点去分析，欢迎指教。</p>
<p>PS：爱立信面试都要英文自我介绍，以及问答，如果英文回答不上来，会直接切换成中文。</p>

    </div>

    
    
    
    
    
      <div>
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">-------------本文结束感谢您的阅读-------------</div>
    
</div>
      </div>
    
        <div class="reward-container">
  <div>原创技术分享，您的支持将鼓励我继续创作.</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    点击打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="幺柒YQ 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="幺柒YQ 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>幺柒YQ
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://kongpengyq.com/2022/01/20/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Go面试题">https://kongpengyq.com/2022/01/20/Go知识点/GO基础知识/Go面试题/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

            <div class="social-item">
              <a target="_blank" class="social-link" href="https://twitter.com/qiyao666">
                <span class="icon">
                  <i class="fa fa-twitter"></i>
                </span>

                <span class="label">Twitter</span>
              </a>
            </div>

            <div class="social-item">
              <a target="_blank" class="social-link" href="/images/wechat.jpg">
                <span class="icon">
                  <i class="fa fa-wechat"></i>
                </span>

                <span class="label">Wechat</span>
              </a>
            </div>

            <div class="social-item">
              <a target="_blank" class="social-link" href="/atom.xml">
                <span class="icon">
                  <i class="fa fa-rss"></i>
                </span>

                <span class="label">RSS</span>
              </a>
            </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Go%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag"># Go知识点</a>
              <a href="/tags/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag"># GO基础知识</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/14/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E8%AF%AD%E8%A8%80%E9%9D%A2%E7%BB%8F/" rel="prev" title="Go语言面经">
      <i class="fa fa-chevron-left"></i> Go语言面经
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/26/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/" rel="next" title="随便写写">
      随便写写 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81OTA3NC8zNTUzNg=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86"><span class="nav-text">基础部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#golang-%E4%B8%AD-make-%E5%92%8C-new-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%BF%85%E9%97%AE%EF%BC%89"><span class="nav-text">golang 中 make 和 new 的区别？（基本必问）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E7%9A%84%E5%8C%BA%E5%88%AB-%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%BF%85%E9%97%AE%EF%BC%89"><span class="nav-text">数组和切片的区别 （基本必问）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-range-%E7%9A%84%E6%97%B6%E5%80%99%E5%AE%83%E7%9A%84%E5%9C%B0%E5%9D%80%E4%BC%9A%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E4%B9%88%EF%BC%9F"><span class="nav-text">for range 的时候它的地址会发生变化么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go-defer%EF%BC%8C%E5%A4%9A%E4%B8%AA-defer-%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%8Cdefer-%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E6%9C%BA%E4%BC%9A%E4%BF%AE%E6%94%B9%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9F"><span class="nav-text">go defer，多个 defer 的顺序，defer 在什么时机会修改返回值？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uint-%E7%B1%BB%E5%9E%8B%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98"><span class="nav-text">uint 类型溢出问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%BD%E4%BB%8B%E7%BB%8D%E4%B8%8B-rune-%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F"><span class="nav-text">能介绍下 rune 类型吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E4%BC%A0%E5%85%A5%E7%BB%93%E6%9E%84%E4%BD%93%E6%97%B6%EF%BC%8C%E5%BA%94%E8%AF%A5%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E6%8C%87%E9%92%88%EF%BC%9F-%EF%BC%88Golang-%E9%83%BD%E6%98%AF%E4%BC%A0%E5%80%BC%EF%BC%89"><span class="nav-text">调用函数传入结构体时，应该传值还是指针？ （Golang 都是传值）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E8%AE%B2-Go-%E7%9A%84-slice-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="nav-text">讲讲 Go 的 slice 底层数据结构和一些特性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E8%AE%B2-Go-%E7%9A%84-select-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F%EF%BC%88%E9%9A%BE%E7%82%B9%EF%BC%8C%E6%B2%A1%E6%9C%89%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%B8%B8%E5%8F%AF%E8%83%BD%E8%AF%B4%E4%B8%8D%E6%B8%85%EF%BC%8C%E9%9D%A2%E8%AF%95%E4%B8%80%E8%88%AC%E4%BC%9A%E9%97%AE%E4%BD%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8select%EF%BC%89"><span class="nav-text">讲讲 Go 的 select 底层数据结构和一些特性？（难点，没有项目经常可能说不清，面试一般会问你项目中怎么使用select）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E8%AE%B2-Go-%E7%9A%84-defer-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="nav-text">讲讲 Go 的 defer 底层数据结构和一些特性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%BC%95%E5%8F%B7%EF%BC%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%EF%BC%8C%E5%8F%8D%E5%BC%95%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">单引号，双引号，反引号的区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map%E7%9B%B8%E5%85%B3"><span class="nav-text">map相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9%EF%BC%8C%E6%98%AF%E5%90%A6%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-text">map 使用注意的点，是否并发安全？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-%E5%BE%AA%E7%8E%AF%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E8%BF%98%E6%98%AF%E6%97%A0%E5%BA%8F%E7%9A%84%EF%BC%9F"><span class="nav-text">map 循环是有序的还是无序的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-%E4%B8%AD%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA-key%EF%BC%8C%E5%AE%83%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%9A%E9%87%8A%E6%94%BE%E4%B9%88%EF%BC%9F%EF%BC%88%E5%B8%B8%E9%97%AE%EF%BC%89"><span class="nav-text">map 中删除一个 key，它的内存会释放么？（常问）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%AF%B9-map-%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%EF%BC%9F%E6%9C%89%E6%B2%A1%E6%9C%89%E5%85%B6%E4%BB%96%E6%96%B9%E6%A1%88%EF%BC%9F-%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">怎么处理对 map 进行并发访问？有没有其他方案？ 区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nil-map-%E5%92%8C%E7%A9%BA-map-%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-text">nil map 和空 map 有何不同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%AE%B9%EF%BC%9F"><span class="nav-text">map 的数据结构是什么？是怎么实现扩容？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slices%E8%83%BD%E4%BD%9C%E4%B8%BAmap%E7%B1%BB%E5%9E%8B%E7%9A%84key%E5%90%97%EF%BC%9F"><span class="nav-text">slices能作为map类型的key吗？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#context%E7%9B%B8%E5%85%B3"><span class="nav-text">context相关**</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#context-%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9Fcontext-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E7%94%A8%E9%80%94%EF%BC%9F"><span class="nav-text">context 结构是什么样的？context 使用场景和用途？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#channel%E7%9B%B8%E5%85%B3"><span class="nav-text">channel相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#channel-%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F%E9%94%81%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="nav-text">channel 是否线程安全？锁用在什么地方？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go-channel-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">go channel 的底层实现原理 （数据结构）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nil%E3%80%81%E5%85%B3%E9%97%AD%E7%9A%84-channel%E3%80%81%E6%9C%89%E6%95%B0%E6%8D%AE%E7%9A%84-channel%EF%BC%8C%E5%86%8D%E8%BF%9B%E8%A1%8C%E8%AF%BB%E3%80%81%E5%86%99%E3%80%81%E5%85%B3%E9%97%AD%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F%EF%BC%88%E5%90%84%E7%B1%BB%E5%8F%98%E7%A7%8D%E9%A2%98%E5%9E%8B%EF%BC%8C%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-text">nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？（各类变种题型，重要）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91-channel-%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%92%8C%E4%BB%8E-channel-%E8%AF%BB%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-text">向 channel 发送数据和从 channel 读数据的流程是什么样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E8%AE%B2-Go-%E7%9A%84-chan-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">讲讲 Go 的 chan 底层数据结构和主要使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GMP%E7%9B%B8%E5%85%B3"><span class="nav-text">GMP相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-GMP%EF%BC%9F%EF%BC%88%E5%BF%85%E9%97%AE%EF%BC%89"><span class="nav-text">什么是 GMP？（必问）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E5%BF%85%E9%97%AE%EF%BC%89"><span class="nav-text">进程、线程、协程有什么区别？（必问）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E6%98%AF%E5%A6%82%E4%BD%95%E6%8A%A2%E5%8D%A0%E7%9A%84%EF%BC%9F"><span class="nav-text">抢占式调度是如何抢占的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#M-%E5%92%8C-P-%E7%9A%84%E6%95%B0%E9%87%8F%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">M 和 P 的数量问题？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E7%9B%B8%E5%85%B3"><span class="nav-text">锁相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%A4%E4%BA%86-mutex-%E4%BB%A5%E5%A4%96%E8%BF%98%E6%9C%89%E9%82%A3%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%AE%89%E5%85%A8%E8%AF%BB%E5%86%99%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="nav-text">除了 mutex 以外还有那些方式安全读写共享变量？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-text">Go 如何实现原子操作？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mutex-%E6%98%AF%E6%82%B2%E8%A7%82%E9%94%81%E8%BF%98%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9F%E6%82%B2%E8%A7%82%E9%94%81%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">Mutex 是悲观锁还是乐观锁？悲观锁、乐观锁是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mutex-%E6%9C%89%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">Mutex 有几种模式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#goroutine-%E7%9A%84%E8%87%AA%E6%97%8B%E5%8D%A0%E7%94%A8%E8%B5%84%E6%BA%90%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-text">goroutine 的自旋占用资源如何解决</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3"><span class="nav-text">并发相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0%EF%BC%9F"><span class="nav-text">怎么控制并发数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA-goroutine-%E5%AF%B9%E5%90%8C%E4%B8%80%E4%B8%AA-map-%E5%86%99%E4%BC%9A-panic%EF%BC%8C%E5%BC%82%E5%B8%B8%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%94%A8-defer-%E6%8D%95%E8%8E%B7%EF%BC%9F"><span class="nav-text">多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 捕获？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-goroutine-%E6%B1%A0"><span class="nav-text">如何优雅的实现一个 goroutine 池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC%E7%9B%B8%E5%85%B3"><span class="nav-text">GC相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#go-gc-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%EF%BC%88%E5%BF%85%E9%97%AE%EF%BC%89"><span class="nav-text">go gc 是怎么实现的？（必问）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go-%E6%98%AF-gc-%E7%AE%97%E6%B3%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F-%EF%BC%88%E5%BE%97%E7%89%A9%EF%BC%8C%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E4%BD%8E%EF%BC%89"><span class="nav-text">go 是 gc 算法是怎么实现的？ （得物，出现频率低）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-%E4%B8%AD-stw-%E6%97%B6%E6%9C%BA%EF%BC%8C%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F-%EF%BC%88%E7%99%BE%E5%BA%A6%EF%BC%89"><span class="nav-text">GC 中 stw 时机，各个阶段是如何解决的？ （百度）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-%E7%9A%84%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA%EF%BC%9F"><span class="nav-text">GC 的触发时机？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3"><span class="nav-text">内存相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%86%85%E5%AD%98%E4%BC%9A%E6%B3%84%E9%9C%B2%EF%BC%9F%E6%80%8E%E4%B9%88%E5%AE%9A%E4%BD%8D%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A5%E9%81%93-golang-%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F%EF%BC%88%E5%BF%85%E9%97%AE%EF%BC%89"><span class="nav-text">知道 golang 的内存逃逸吗？什么情况下会发生内存逃逸？（必问）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E7%AE%80%E8%BF%B0-Go-%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%EF%BC%9F"><span class="nav-text">请简述 Go 是如何分配内存的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel-%E5%88%86%E9%85%8D%E5%9C%A8%E6%A0%88%E4%B8%8A%E8%BF%98%E6%98%AF%E5%A0%86%E4%B8%8A%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%9C%A8%E5%A0%86%E4%B8%8A%EF%BC%8C%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%9C%A8%E6%A0%88%E4%B8%8A%EF%BC%9F"><span class="nav-text">Channel 分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%B0%8F%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%8F%E5%AF%B9%E8%B1%A1%E5%A4%9A%E4%BA%86%E4%BC%9A%E9%80%A0%E6%88%90-gc-%E5%8E%8B%E5%8A%9B%EF%BC%9F"><span class="nav-text">介绍一下大对象小对象，为什么小对象多了会造成 gc 压力？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="nav-text">其他问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-text">Go 多返回值怎么实现的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E8%AE%B2-Go-%E4%B8%AD%E4%B8%BB%E5%8D%8F%E7%A8%8B%E5%A6%82%E4%BD%95%E7%AD%89%E5%BE%85%E5%85%B6%E4%BD%99%E5%8D%8F%E7%A8%8B%E9%80%80%E5%87%BA"><span class="nav-text">讲讲 Go 中主协程如何等待其余协程退出?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="nav-text">Go 语言中不同的类型如何比较是否相等？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-%E4%B8%AD-init-%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-text">Go 中 init 函数的特征?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-%E4%B8%AD-uintptr-%E5%92%8C-unsafe-Pointer-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">Go 中 uintptr 和 unsafe.Pointer 的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#golang%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%88%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%89%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E5%A4%9A%E4%B8%AAget%E8%AF%B7%E6%B1%82"><span class="nav-text">golang共享内存（互斥锁）方法实现发送多个get请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%96%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%90%8C%E5%A4%A7%E5%B0%8F%E7%9A%84slice%E6%9C%89%E6%88%90%E6%9C%AC%E5%90%97%EF%BC%9F"><span class="nav-text">从数组中取一个相同大小的slice有成本吗？</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="幺柒YQ"
      src="/images/avater.png">
  <p class="site-author-name" itemprop="name">幺柒YQ</p>
  <div class="site-description" itemprop="description">努力坚持就会有希望</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">232</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kpyaoqi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kpyaoqi" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:18312386077@163.com" title="E-Mail → mailto:18312386077@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat.jpg" title="WeChat → images&#x2F;wechat.jpg"><i class="fa fa-fw fa-wechat"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/qq.jpg" title="QQ → images&#x2F;qq.jpg"><i class="fa fa-fw fa-qq"></i>QQ</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://stackoverflow.com/" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;" rel="noopener" target="_blank">Stackoverflow</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2021-11 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">幺柒YQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">899k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:37</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共379.4k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
