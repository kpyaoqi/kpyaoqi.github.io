<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://kongpengyq.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="努力坚持就会有希望">
<meta property="og:type" content="website">
<meta property="og:title" content="YQ &amp; 博客">
<meta property="og:url" content="https://kongpengyq.com/page/17/index.html">
<meta property="og:site_name" content="YQ &amp; 博客">
<meta property="og:description" content="努力坚持就会有希望">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="幺柒YQ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://kongpengyq.com/page/17/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>YQ & 博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="YQ & 博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YQ & 博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/06/30/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/07-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/30/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/07-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">07-流程控制</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-30 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-30T00:00:00+08:00">2022-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h1><h2 id="1-1-if"><a href="#1-1-if" class="headerlink" title="1.1 if"></a>1.1 if</h2><p><strong>语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式) &#123;</span><br><span class="line">   被执行语句(如果条件为真)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Solidity 中<strong>非布尔类型数值</strong>不能转换为布尔类型，因此 <code>if (1) &#123; ... &#125;</code> 的写法在 Solidity 中 无效 。</p>
<p><strong>例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function greaterThan10(uint256 _x) external pure returns (bool) &#123;</span><br><span class="line">        if (_x &gt; 10) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-if-else"><a href="#1-2-if-else" class="headerlink" title="1.2 if else"></a>1.2 if else</h2><p><strong>语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式) &#123;</span><br><span class="line">   被执行语句(如果条件为真)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   被执行语句(如果条件为假)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function greaterThan10(uint256 _x) external pure returns (bool) &#123;</span><br><span class="line">        if (_x &gt; 10) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-if…else-if…else"><a href="#1-3-if…else-if…else" class="headerlink" title="1.3 if…else if…else"></a>1.3 if…else if…else</h2><p><strong>语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式 1) &#123;</span><br><span class="line">   被执行语句(如果条件 1 为真)</span><br><span class="line">&#125; else if (条件表达式 2) &#123;</span><br><span class="line">   被执行语句(如果条件 2 为真)</span><br><span class="line">&#125; else if (条件表达式 3) &#123;</span><br><span class="line">   被执行语句(如果条件 3 为真)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   被执行语句(如果所有条件为假)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function example(uint256 _x) external pure returns (uint256) &#123;</span><br><span class="line">        if (_x &lt; 10) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else if (_x &lt; 20) &#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return 3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-if…else-if"><a href="#1-4-if…else-if" class="headerlink" title="1.4 if…else if"></a>1.4 if…else if</h2><p><strong>语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式 1) &#123;</span><br><span class="line">   被执行语句(如果条件 1 为真)</span><br><span class="line">&#125; else if (条件表达式 2) &#123;</span><br><span class="line">   被执行语句(如果条件 2 为真)</span><br><span class="line">&#125; else if (条件表达式 3) &#123;</span><br><span class="line">   被执行语句(如果条件 3 为真)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   被执行语句(如果所有条件为假)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function example(uint256 _x) external pure returns (uint256) &#123;</span><br><span class="line">        if (_x &lt; 10) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else if (_x &lt; 20) &#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125; else if (_x &lt; 30) &#123;</span><br><span class="line">            return 3;</span><br><span class="line">        &#125;</span><br><span class="line">        return 999;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h1><p>之前有介绍过三元运算符，这个相当于是 if else 的简洁版。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract IfElse&#123;</span><br><span class="line">    function example2 (uint _x) external pure returns (uint)&#123;</span><br><span class="line">        return _x&lt;10 ? 1 : 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/06/30/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/08-%E5%BE%AA%E7%8E%AF%E4%B8%8E%E8%BF%AD%E4%BB%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/30/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/08-%E5%BE%AA%E7%8E%AF%E4%B8%8E%E8%BF%AD%E4%BB%A3/" class="post-title-link" itemprop="url">08-循环与迭代</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-30 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-30T00:00:00+08:00">2022-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h1><h2 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (初始化; 测试条件; 迭代语句) &#123;</span><br><span class="line">   // 如果表达式的结果为真，就循环执行以下语句</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract For &#123;</span><br><span class="line">    // 输入5    输出15</span><br><span class="line">    function test1(uint256 _x) external pure returns (uint256 temp) &#123;</span><br><span class="line">        for (uint256 i = 1; i &lt;= _x; i++) &#123;</span><br><span class="line">            temp += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-循环控制"><a href="#1-2-循环控制" class="headerlink" title="1.2 循环控制"></a>1.2 循环控制</h2><ul>
<li><pre><code>continue
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  退出当前迭代</span><br><span class="line"></span><br><span class="line">  - 语句可以用来继续执行（跳过代码块的剩余部分并进入下一循环）。</span><br><span class="line"></span><br><span class="line">- `break` 终止循环</span><br><span class="line"></span><br><span class="line">```solidity</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract For &#123;</span><br><span class="line">    // 输入5    输出15</span><br><span class="line">    function test1(uint256 _x) external pure returns (uint256 temp) &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt;= _x; i++) &#123;</span><br><span class="line">            temp += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输入5    输出7</span><br><span class="line">    function test2(uint256 _x) external pure returns (uint256 temp) &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt;= _x; i++) &#123;</span><br><span class="line">            if (i == 3) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i == 5) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h2 id="1-3-使用-i-可以省-gas"><a href="#1-3-使用-i-可以省-gas" class="headerlink" title="1.3 使用 ++i 可以省 gas"></a>1.3 使用 ++i 可以省 gas</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract For &#123;</span><br><span class="line">    function test1(uint256 _x) external pure returns (uint256 temp) &#123;</span><br><span class="line">        for (uint256 i = 1; i &lt;= _x; i++) &#123;</span><br><span class="line">            temp += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function test2(uint256 _x) external pure returns (uint256 temp) &#123;</span><br><span class="line">        for (uint256 i = 1; i &lt;= _x; ++i) &#123;</span><br><span class="line">            temp += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>运行 test1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 输入 5    : 23658 gas</span><br><span class="line">// 输入 100  : 58713 gas</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行 test2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 输入 5    : 23655 gas</span><br><span class="line">// 输入 100  : 58235 gas</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h1><h3 id="2-1-语法"><a href="#2-1-语法" class="headerlink" title="2.1 语法"></a>2.1 语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (表达式) &#123;</span><br><span class="line">   // 如果表达式的结果为真，就循环执行以下语句</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract For &#123;</span><br><span class="line">    function test1(uint256 _x) external pure returns (uint256 temp) &#123;</span><br><span class="line">        uint256 i = 0;</span><br><span class="line">        while (i &lt;= _x) &#123;</span><br><span class="line">            temp += i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h1><h2 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">   // 如果表达式的结果为真，就循环执行以下语句</span><br><span class="line">   ......</span><br><span class="line">&#125; while (表达式);</span><br></pre></td></tr></table></figure>

<p><strong>例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract For &#123;</span><br><span class="line">    function test1(uint256 _x) external pure returns (uint256 temp) &#123;</span><br><span class="line">        uint256 i = 0;</span><br><span class="line">        while (i &lt;= _x) &#123;</span><br><span class="line">            temp += i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test2(uint256 _x) external pure returns (uint256 temp) &#123;</span><br><span class="line">        uint256 i = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">            temp += i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; while (i &lt;= _x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/06/27/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/06-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/27/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/06-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">06-错误处理</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-27 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-27T00:00:00+08:00">2022-06-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Solidity 如果遇到异常错误，是通过回退状态的方式来进行处理。发生异常时，会撤消当前调用和所有子调用改变的状态变量，同时给调用者返回一个错误标识。</p>
<p>调用者调用某个函数方法，要么成功修改了所有状态变量，要么遇到异常不修改任何状态变量，不存在成功修改部分变量的情况，</p>
<p>Solidity 提供了 <strong>require</strong> 、<strong>assert</strong> 和 <strong>revert</strong> 来处理异常。同时可以使用 <code>error</code> 关键字来实现错误。</p>
<p>跟用错误字符串相比， error 更便宜并且允许你编码额外的数据，还可以用 <code>NatSpec</code> 为用户去描述错误。</p>
<p>Solidity 使用状态恢复异常来处理错误。这种异常将撤消对当前调用（及其所有子调用）中的状态所做的所有更改，并且还向调用者标记错误。</p>
<p>如果异常在子调用发生，那么异常会自动冒泡到顶层（例如：异常会重新抛出），除非他们在 <code>try/catch</code> 语句中捕获了错误。 但是如果是在 <code>send</code> 和 低级 <code>call</code>, <code>delegatecall</code> 和 <code>staticcall</code> 的调用里发生异常时， 他们会返回 <code>false</code> （第一个返回值） 而不是冒泡异常。</p>
<p>警告注意：根据 EVM 的设计，如果被调用的地址不存在，低级别函数 <code>call</code>, <code>delegatecall</code> 和 <code>staticcall</code> 第一个返回值同样是 <code>true</code>。 如果需要，请在调用之前检查账号的存在性。</p>
<p>异常可以包含错误数据，以 error 示例 的形式传回给调用者。 内置的错误 <code>Error(string)</code> 和 <code>Panic(uint256)</code> 被作为特殊函数使用，下面将解释。 <code>Error</code> 用于 “常规” 错误条件，而 <code>Panic</code> 用于在（无 bug）代码中不应该出现的错误。</p>
<p>函数 assert 和 require 可用于检查条件并在条件不满足时抛出异常。</p>
<h1 id="require"><a href="#require" class="headerlink" title="require"></a>require</h1><p>require 用来严查某些条件，如果不满足这些雕件，就会回退所有状态的变化。</p>
<h2 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(condition[, &#x27;Something bad happened&#x27;])</span><br></pre></td></tr></table></figure>

<p>如果条件不满足则撤销状态更改 ，用于检查由输入或者外部组件引起的错误。可以同时提供一个错误消息。</p>
<ul>
<li>require 函数常常用来检查输入变量或状态变量是否满足条件，以及验证调用外部合约的返回值。</li>
<li>require 可以有返回值，例如：<code>require(condition, &#39;Something bad happened&#39;);</code>。</li>
<li>require 的返回值不宜过长，因为返回信息需要消耗 gas。<ul>
<li>并没有证明长度越长，消耗的 gas 越多。</li>
</ul>
</li>
</ul>
<p><strong>注解</strong> <code>require</code> 是一个像其他函数一样可被执行的函数。意味着，所有的参数在函数被执行之前就都会被执行。 尤其，在<br><code>require(condition, f())</code> 里，函数 <code>f</code> 会被执行，即便 <code>condition</code> 为 True .</p>
<h2 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h2><ul>
<li>验证用户输入，例如：<code>require(input_var&gt;100)</code></li>
<li>验证外部合约的调用结果，例如：<code>require(external.send(amount))</code></li>
<li>在执行状态更改操作之前验证状态条件，例如：<code>require(block.number &gt; 49999)</code> 或 <code>require(balance[msg.sender]&gt;=amount)</code></li>
<li>require() 语句的失败报错，应该被看作一个正常的判断语句流程不能通过的事件。</li>
</ul>
<p>一般来说，使用 <code>require()</code> 的频率更多，通常应用于函数的开头和函数修改器内。</p>
<p>一句话: <strong>require() 函数用于检测输入变量或状态变量是否满足条件，以及验证调用外部合约的返回值。</strong></p>
<h1 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h1><h2 id="2-1-语法"><a href="#2-1-语法" class="headerlink" title="2.1 语法"></a>2.1 语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(bool condition)</span><br></pre></td></tr></table></figure>

<p>如果不满足条件，则会导致 Panic 错误，则撤销状态更改 - 用于检查内部错误。</p>
<p><code>assert()</code>与 <code>require()</code> 语句都需要满足括号中的条件，才能进行后续操作，若不满足则抛出错误。</p>
<ul>
<li>assert：断言，不能包括报错信息的。</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint256 public amount = 0;</span><br><span class="line"></span><br><span class="line">    function test1(uint256 _x) external &#123;</span><br><span class="line">        require(_x &lt; 10, &quot;My error info 1&quot;); // _x &gt;= 10 时候会报错</span><br><span class="line">        amount = _x;</span><br><span class="line">        assert(amount == _x); // 必须等于_x，否则抛出错误</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-使用场景"><a href="#2-2-使用场景" class="headerlink" title="2.2 使用场景"></a>2.2 使用场景</h2><ul>
<li>检查溢出</li>
<li>检查不变量</li>
<li>更改后验证状态</li>
<li>预防永远不会发生的情况</li>
<li>assert()语句的失败报错，意味着发生了代码层面的错误事件，很大可能是合约中有一个 bug 需要修复。</li>
<li>也可以智能合约写测试。</li>
</ul>
<p>一般来说，使用 <code>assert()</code>的频率较少，通常用于函数的结尾。基本上，<code>require()</code> 应该用于检查条件，而 <code>assert()</code> 只是为了防止发生任何非常糟糕的事情。</p>
<h2 id="2-3-扩展"><a href="#2-3-扩展" class="headerlink" title="2. 3 扩展"></a>2. 3 扩展</h2><p>assert 函数会创建一个 <code>Panic(uint256)</code> 类型的错误。同样的错误在以下列出的特定情形会被编译器创建。</p>
<p>assert 函数应该只用于测试内部错误，检查不变量，正常的函数代码永远不会产生 Panic, 甚至是基于一个无效的外部输入时。 如果发生了，那就说明出现了一个需要你修复的 bug。如果使用得当，语言分析工具可以识别出那些会导致 Panic 的 assert 条件和函数调用。</p>
<p>下列情况将会产生一个 Panic 异常： 错误数据会提供的错误码编号，用来指示 Panic 的类型：</p>
<ol>
<li>0x00: 用于常规编译器插入的 Panic。</li>
<li>0x01: 如果你调用 <code>assert</code> 的参数（表达式）结果为 false 。</li>
<li>0x11: 在 <code>unchecked &#123; ... &#125;</code> 外，如果算术运算结果向上或向下溢出。</li>
<li>0x12; 如果你用零当除数做除法或模运算（例如 <code>5 / 0</code> 或 <code>23 % 0</code> ）。</li>
<li>0x21: 如果你将一个太大的数或负数值转换为一个枚举类型。</li>
<li>0x22: 如果你访问一个没有正确编码的存储 byte 数组.</li>
<li>0x31: 如果在空数组上 <code>.pop()</code> 。</li>
<li>0x32: 如果你访问 <code>bytesN</code> 数组（或切片）的索引太大或为负数。(例如：<br><code>x[i]</code> 而 <code>i &gt;= x.length</code> 或 <code>i &lt; 0</code>).</li>
<li>0x41: 如果你分配了太多的内内存或创建了太大的数组。</li>
<li>0x51: 如果你调用了零初始化内部函数类型变量。</li>
</ol>
<h1 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h1><p>语法: <code>revert([string memory reason])</code></p>
<ul>
<li><p>使用 revert：抛出错误,它使用圆括号接受一个字符串：语句将一个自定义的错误作为直接参数，没有括号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">revert();</span><br><span class="line">revert(&quot;description&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>revert()</code> 会触发一个没有任何错误数据的回退，而 <code>revert(&quot;description&quot;)</code> 会产生一个 <code>Error(string)</code> 错误。</p>
</li>
<li><p>使用 revert：触发自定义错误 ·</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revert CustomError(arg1, arg2);</span><br></pre></td></tr></table></figure>

<ul>
<li>可以接收参数，方便判断。比如可以传入 <code>msg.sender</code> &#x2F; 函数参数 等</li>
</ul>
</li>
</ul>
<p>终止运行并撤销状态更改。可以同时提供一个解释性的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract ErrorDemo &#123;</span><br><span class="line">    // 自定义错误</span><br><span class="line">    error MyError(address call, uint256 _i);</span><br><span class="line"></span><br><span class="line">    function testCustomError(uint256 _x) external view &#123;</span><br><span class="line">        if (_x &gt; 10) &#123;</span><br><span class="line">            revert MyError(msg.sender, _x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要参数没有额外的附加效果，使用 <code>if (!condition) revert(...);</code> 和 <code>require(condition, ...);</code> 是等价的，例如当参数是字符串的情况。</p>
<h1 id="三种方式的总结"><a href="#三种方式的总结" class="headerlink" title="三种方式的总结"></a>三种方式的总结</h1><h2 id="4-1-require、assert-不同点"><a href="#4-1-require、assert-不同点" class="headerlink" title="4.1 require、assert 不同点"></a>4.1 require、assert 不同点</h2><ul>
<li><code>require(false)</code> 编译为 <code>0xfd</code>，这是 <code>revert()</code> 的操作码，<strong>所以会退还所有剩余的 gas，同时可以返回一个自定义的报错信息</strong>。</li>
<li><code>assert(false)</code> 编译为 <code>0xfe</code>，这是一个无效的操作码，<strong>所以会消耗掉所有剩余的 gas，并恢复所有的操作</strong>。</li>
<li><code>require</code> 的 gas 消耗要小于 <code>assert</code>，而且可以有返回值，使用更为灵活。</li>
</ul>
<p>错误信息：<code>require</code> 函数可以创建无错误提示的错误，也可以创建一个 <code>Error(string)</code>类型的错误。 <code>require</code>函数应该用于确认条件有效性，例如输入变量，或合约状态变量是否满足条件，或验证外部合约调用返回的值。</p>
<p>当前不可以使用混合使用 require 和自定义错误，而是需要使用 <code>if (!condition) revert CustomError();</code> 。</p>
<p>下列情况将会产生一个 <code>Error(string)</code>（或无错误提示）的错误：</p>
<ol>
<li>如果你调用 <code>require(x)</code> ，而 <code>x</code> 结果为 <code>false</code> 。</li>
<li>如果你使用 <code>revert()</code> 或者 <code>revert(&quot;description&quot;)</code> 。</li>
<li>如果你在不包含代码的合约上执行外部函数调用。</li>
<li>如果你通过合约接收以太币，而又没有 <code>payable</code>修饰符的公有函数（包括构造函数和 fallback 函数）。</li>
<li>如果你的合约通过公有 getter 函数接收 Ether 。</li>
</ol>
<p>在下面的情况下，来自外部调用的错误数据（如果提供的话）被转发，这意味可能<code>Error</code> 或 <code>Panic</code> 都有可能触发。</p>
<ol>
<li>如果 <code>.transfer()</code> 失败。</li>
<li>如果你通过消息调用调用某个函数，但该函数没有正确结束（例如, 它耗尽了gas，没有匹配函数，或者本身抛出一个异常），不包括使用低级别 <code>call</code>， <code>send</code> ， <code>delegatecall</code> ， <code>callcode</code> 或 <code>staticcall</code><br>的函数调用。低级操作不会抛出异常，而通过返回 <code>false</code> 来指示失败。</li>
<li>如果你使用 <code>new</code> 关键字创建合约，但合约创建没有正确结束。</li>
</ol>
<p>你可以选择给 <code>require</code> 提供一个消息字符串，但 <code>assert</code> 不行。</p>
<p>如果你没有为 <code>require</code> 提供一个字符串参数，它会用空错误数据进行 revert， 甚至不包括错误选择器。</p>
<p>在下例中，你可以看到如何轻松使用 <code>require</code> 检查输入条件以及如何使用<code>assert</code> 检查内部错误.</p>
<p>在内部， Solidity 对异常执行回退操作（指令 <code>0xfd</code> ），从而让 EVM 回退对状态所做的所有更改。回退的原因是无法安全地继续执行，因为无法达到预期的结果。 因为我们想要保持交易的原子性，最安全的动作是回退所有的更改，并让整个交易（或至少调用）没有任何新影响。</p>
<p>在这两种情况下，调用者都可以使用 <code>try</code>&#x2F; <code>catch</code>来应对此类失败，但是被调用函数的更改将始终被还原。</p>
<h2 id="4-2-require、assert、revert-共同点"><a href="#4-2-require、assert、revert-共同点" class="headerlink" title="4.2 require、assert、revert 共同点"></a>4.2 require、assert、revert 共同点</h2><p>以下三个语句的功能完全相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// revert</span><br><span class="line">if(msg.sender != owner) &#123;</span><br><span class="line">   revert();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">// require</span><br><span class="line">require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">// assert</span><br><span class="line">assert(msg.sender == owner);</span><br></pre></td></tr></table></figure>

<h1 id="自定义-Error"><a href="#自定义-Error" class="headerlink" title="自定义 Error"></a>自定义 Error</h1><p>Solidity 中的错误（关键字 error）提供了一种方便且省 gas 的方式来向用户解释为什么一个操作会失败。它们可以被定义在合约（包括接口和库）内部和外部。</p>
<ul>
<li><strong><code>error</code> 只能通过 <code>revert</code> 触发</strong></li>
<li>使用自定义 error 抛出错误，向调用者描述错误信息。</li>
<li>开发者可以在任何时候，任何条件下触发自定义 Error</li>
<li>error 花费更少的 gas。</li>
<li><code>error</code> 可以定义在 contract 之外。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 自定义错误</span><br><span class="line">error MyError1(address call, uint256 _i);</span><br><span class="line"></span><br><span class="line">contract ErrorDemo &#123;</span><br><span class="line">    // 自定义错误</span><br><span class="line">    error MyError2(address call, uint256 _i);</span><br><span class="line"></span><br><span class="line">    function testCustom1(uint256 _x) external view &#123;</span><br><span class="line">        if (_x &gt; 10) &#123;</span><br><span class="line">            revert MyError1(msg.sender, _x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误必须与 revert 语句 一起使用。它会还原当前调用中的发生的所有变化，并将错误数据传回给调用者。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">/// 转账时，没有足够的余额。</span><br><span class="line">/// @param available balance available.</span><br><span class="line">/// @param required requested amount to transfer.</span><br><span class="line">error InsufficientBalance(uint256 available, uint256 required);</span><br><span class="line"></span><br><span class="line">contract TestToken &#123;</span><br><span class="line">    mapping(address =&gt; uint) balance;</span><br><span class="line">    function transfer(address to, uint256 amount) public &#123;</span><br><span class="line">        if (amount &gt; balance[msg.sender])</span><br><span class="line">            revert InsufficientBalance(&#123;</span><br><span class="line">                available: balance[msg.sender],</span><br><span class="line">                required: amount</span><br><span class="line">            &#125;);</span><br><span class="line">        balance[msg.sender] -= amount;</span><br><span class="line">        balance[to] += amount;</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误不能被重写或覆盖，但是可以继承。只要作用域不同，同一个错误可以在多个地方定义。只能使用 <code>revert</code> 语句创建错误实例。</p>
<p>错误产生的数据，会通过 revert 操作传递给调用者，可以交由链外组件处理或在 try&#x2F;catch 语句 中捕获它。</p>
<p>注意，只有外部调用的错误才能被捕获。发生在内部调用或同一函数内的 revert 不能被捕获。</p>
<h1 id="Natspec-Error"><a href="#Natspec-Error" class="headerlink" title="Natspec Error"></a>Natspec Error</h1><p>使用一个自定义的错误实例通常会比字符串描述便宜得多。因为你可以使用错误名来描述它，它只被编码为四个字节。更长的描述可以通过 NatSpec 提供，这不会产生任何费用。</p>
<p>通过三个斜杠 <code>///</code> 定义的错误，它比<code>require</code>更省 gas。推荐代替 require 使用。</p>
<p>如果错误没有任何参数，错误只需要四个字节的数据，你可以使用 NatSpec，来进一步解释错误背后的原因，NatSpec 不会存储在链上。这个方式使得它同时也是一个非常便宜和方便的错误报告功能。</p>
<p>更具体地说，一个错误实例的 ABI 编码方式与调用相同名称和类型的函数的方式相同，它作为<code>revert</code> 操作码的返回数据使用。 这意味着错误数据由一个 4 字节的选择器和 ABI-encoded 数据组成。选择器是错误的签名的 keccak256 哈希的前四个字节组成。</p>
<p>代码结构如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// this is netspec error info</span><br><span class="line">error MyError1();</span><br></pre></td></tr></table></figure>

<p>例子如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract ErrorDemo &#123;</span><br><span class="line">    // netspec error</span><br><span class="line">    /// this is netspec error info,this is netspec error info,this is netspec error info,this is netspec error info</span><br><span class="line">    error MyError1();</span><br><span class="line"></span><br><span class="line">    /// 这是一个错误！老铁，你的输入参数错啦，必须要大于10的数字才可以通过！</span><br><span class="line">    error MyError2();</span><br><span class="line"></span><br><span class="line">    // 21647 gas</span><br><span class="line">    function test1(uint256 _x) external pure &#123;</span><br><span class="line">        if (_x &lt; 10) &#123;</span><br><span class="line">            revert MyError1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 21691 gas</span><br><span class="line">    function test2(uint256 _x) external pure &#123;</span><br><span class="line">        if (_x &lt; 10) &#123;</span><br><span class="line">            revert MyError2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 22036 gas</span><br><span class="line">    function test3(uint256 _x) external pure &#123;</span><br><span class="line">        require(</span><br><span class="line">            _x &gt; 10,</span><br><span class="line">            &quot;this is netspec error info,this is netspec error info,this is netspec error info,this is netspec error info&quot;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 21974 gas</span><br><span class="line">    function test4(uint256 _x) external pure &#123;</span><br><span class="line">        require(</span><br><span class="line">            _x &gt; 10,</span><br><span class="line">            unicode&quot;这是一个错误！老铁，你的输入参数错啦，必须要大于10的数字才可以通过！&quot;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h1><p>在当前合约发起对外部合约的调用，如果外部合约调用执行失败被 revert，外部合约状态会被回滚，当前合约状态也会被回滚。这是正常的逻辑。</p>
<p>但有时候我们并不想这样，要是能够捕获外部合约调用异常，然后根据情况做自己的处理会更好吗！所以，这种场景下适应于使用 <code>try...catch</code> 语句。</p>
<p><code>try catch</code>仅用于外部函数调用和合约创建调用。</p>
<ul>
<li>外部函数调用</li>
<li>合约创建调用</li>
</ul>
<h2 id="7-1-语法"><a href="#7-1-语法" class="headerlink" title="7.1 语法"></a>7.1 语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try this.count() &#123;</span><br><span class="line">    // 成功逻辑</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125; catch Error(string memory reason) &#123;</span><br><span class="line">    // 失败的逻辑: require / revert</span><br><span class="line">    // 调用 count() 失败时执行，通常是不满足 require 语句条件或触发 revert 语句时所引起的调用失败</span><br><span class="line">    return reason;</span><br><span class="line">&#125; catch (bytes memory) &#123;</span><br><span class="line">    // 失败逻辑</span><br><span class="line">    // 调用 count() 异常时执行，通常是触发 assert 语句或除 0 等比较严重错误时会执行</span><br><span class="line">    return &quot;assert error&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的逻辑也可以简写如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try this.count() &#123;</span><br><span class="line">    // 成功逻辑</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125; catch (bytes memory) &#123;</span><br><span class="line">    // 失败逻辑: require / revert / assert</span><br><span class="line">     return &quot;assert error&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Manager &#123;</span><br><span class="line">    function count() public pure returns (int256) &#123;</span><br><span class="line">         require(1 == 2, &quot;require error&quot;);</span><br><span class="line">         return 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function count() public pure returns (int256) &#123;</span><br><span class="line">        assert(1 == 2);</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test() public view returns (string memory) &#123;</span><br><span class="line">        // this 代表当前函数</span><br><span class="line">        try this.count() &#123;</span><br><span class="line">            return &quot;success&quot;;</span><br><span class="line">        &#125; catch Error(string memory reason) &#123;</span><br><span class="line">            // reason 是出错原因</span><br><span class="line">            // 调用 count() 失败时执行，通常是不满足 require 语句条件</span><br><span class="line">            // 或触发 revert 语句时所引起的调用失败</span><br><span class="line">            return reason;</span><br><span class="line">        &#125; catch (bytes memory) &#123;</span><br><span class="line">            // 调用 count() 异常时执行，通常是触发 assert 语句或除 0 等比较严重错误时会执行</span><br><span class="line">            return &quot;assert error&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部调用的失败，可以通过 try&#x2F;catch 语句来捕获，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> // SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.8.1;</span><br><span class="line"></span><br><span class="line">interface DataFeed &#123; function getData(address token) external returns (uint value); &#125;</span><br><span class="line"></span><br><span class="line">contract FeedConsumer &#123;</span><br><span class="line">    DataFeed feed;</span><br><span class="line">    uint errorCount;</span><br><span class="line">    function rate(address token) public returns (uint value, bool success) &#123;</span><br><span class="line">        // 如果错误超过 10 次，永久关闭这个机制</span><br><span class="line">        require(errorCount &lt; 10);</span><br><span class="line">        try feed.getData(token) returns (uint v) &#123;</span><br><span class="line">            return (v, true);</span><br><span class="line">        &#125; catch Error(string memory reason) &#123;</span><br><span class="line">            // This is executed in case</span><br><span class="line">            // revert was called inside getData</span><br><span class="line">            // and a reason string was provided.</span><br><span class="line">            errorCount++;</span><br><span class="line">            return (0, false);</span><br><span class="line">        &#125;  catch Panic(uint errorCode) &#123;</span><br><span class="line">            // This is executed in case of a panic,</span><br><span class="line">            // i.e. a serious error like division by zero</span><br><span class="line">            // or overflow. The error code can be used</span><br><span class="line">            // to determine the kind of error.</span><br><span class="line">            errorCount++;</span><br><span class="line">            return (0, false);</span><br><span class="line">        &#125; catch (bytes memory lowLevelData) &#123;</span><br><span class="line">            // This is executed in case revert() was used。</span><br><span class="line">            errorCount++;</span><br><span class="line">            return (0, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Solidity 根据错误的类型，支持不同种类的捕获代码块：</p>
<ul>
<li><code>catch Error(string memory reason) &#123; ... &#125;</code>: 如果错误是由 <code>revert(&quot;reasonString&quot;)</code> 或 <code>require(false, &quot;reasonString&quot;)</code>（或导致这种异常的内部错误）引起的，则执行这个 catch 子句。</li>
<li><code>catch Panic(uint errorCode) &#123; ... &#125;</code>: 如果错误是由 panic 引起的（如： <code>assert</code> 失败，除以 0，无效的数组访问，算术溢出等），将执行这个 catch 子句。</li>
<li><code>catch (bytes memory lowLevelData) &#123; ... &#125;</code>: 如果错误签名不符合任何其他子句，如果在解码错误信息时出现了错误，或者如果异常没有一起提供错误数据。在这种情况下，子句声明的变量提供了对低级错误数据的访问。</li>
<li><code>catch &#123; ... &#125;</code>: 如果你对错误数据不感兴趣，你可以直接使用 <code>catch &#123; ... &#125;</code> (甚至是作为唯一的 catch 子句) 而不是前面几个 catch 子句。</li>
</ul>
<p>有计划在未来支持其他类型的错误数据。 <code>Error</code> 和 <code>Panic</code> 字符串目前是按原样解析的，不作为标识符处理。</p>
<p>为了捕捉所有的错误情况，你至少要有子句 <code>catch &#123; ... &#125;</code> 或 <code>catch (bytes memory lowLevelData) &#123; ... &#125;</code>.</p>
<p>在 <code>returns</code> 和 <code>catch</code> 子句中声明的变量只在后面的块的范围内有效。</p>
<p><strong>注解</strong>: 如果在 try&#x2F;catch 语句内部返回的数据解码过程中发生错误，这将导致当前执行的合约出现异常，如此，它不会在 catch 子句中被捕获到。如果在 <code>catch Error(string memory reason)</code> 的解码过程中出现错误，并且有一个低级的 catch 子句，那么这个错误就会在低级 catch 子句被捕获。</p>
<p><strong>注解</strong>: 如果执行到一个 catch 子句，那么外部调用的状态改变已经被回退了。如果执行到了成功块，那么外部调用的状态改变是有效的。如果状态改变已经被回退，那么要么在 catch 块中继续执行，要么是 try&#x2F;catch 语句的执行本身被回退（例如由于上面提到的解码失败或由于没有提供低级别的 catch 子句时）。</p>
<p><strong>注解</strong>:调用失败背后的原因可能是多方面的。请不要认为错误信息是直接来自被调用的合约。错误可能发生在调用链的更深处，而被调用的合约只是转发了（冒泡）错误。<br>另外，这可能是由于 out-of-gas 情况，而不是一个逻辑错误状况：调用者总是在调用中保留至少 1&#x2F;64 的 gas，这样即使被调合约 gas 用完，调用方仍有一些 gas 预留（处理剩余逻辑）</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/06/24/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/05-%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/24/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/05-%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C%E7%AC%A6/" class="post-title-link" itemprop="url">05-运算操作符</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-24 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-24T00:00:00+08:00">2022-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h1><ul>
<li><code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>(取余,取模)，</li>
<li><code>++</code>(递增),<code>--</code>(递减),<code>+=</code>(加法赋值),<code>-=</code>(减法赋值)</li>
<li><code>**</code>（次方）</li>
</ul>
<h2 id="1-1-unchecked"><a href="#1-1-unchecked" class="headerlink" title="1.1 unchecked"></a>1.1 unchecked</h2><p>默认情况下，算术运算都会进行溢出检查，但是也可以禁用检查，可以通过 <code>unchecked block</code> 来禁用检查，此时会返回截断的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function f(uint a, uint b) pure public returns (uint) &#123;</span><br><span class="line">    // 减法溢出会返回“截断”的结果</span><br><span class="line">    unchecked &#123; return a - b; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>溢出的检查功能是在 <code>0.8.0</code> 版本加入的，在此版本之前，请使用 <strong>OpenZepplin SafeMath</strong> 库。</p>
<h2 id="1-2-一元运算负"><a href="#1-2-一元运算负" class="headerlink" title="1.2 一元运算负 -"></a>1.2 一元运算负 <code>-</code></h2><p>表达式 <code>-x</code> 相当于 <code>(T(0) - x)</code> 这里 <code>T</code> 是指 <code>x</code> 的类型。 <code>-x</code> 只能应用在有符号型的整数上。 如果 <code>x</code> 为负数， <code>-x</code> 为正数。</p>
<p>由于使用两进制补码表示数据，你还需要小心:如果有 <code>int x = type(int).min;</code>， 那 <code>-x</code> 将不在正数取值的范围内。 这意味着这个检测 </p>
<p><code>unchecked &#123; assert(-x == x); &#125;</code> 是可以通过的（即这种情况下，不能假设它的负数会是正数），如果是 checked 模式，则会触发异常。</p>
<h2 id="1-3-除法运算"><a href="#1-3-除法运算" class="headerlink" title="1.3 除法运算"></a>1.3 除法运算</h2><p>除法运算结果的类型始终是其中一个操作数的类型，整数除法总是产生整数。在 Solidity 中，分数会取零。 这意味着 <code>int256(-5) / int256(2) == int256(-2)</code> 。</p>
<h2 id="1-4-模运算（取余）"><a href="#1-4-模运算（取余）" class="headerlink" title="1.4 模运算（取余）"></a>1.4 模运算（取余）</h2><p>模运算 <code>a％n</code> 是在操作数 <code>a</code> 的除以 <code>n</code> 之后产生余数 <code>r</code> ，其中 <code>q = int(a / n)</code> 和 <code>r = a - (n * q)</code> 。 这意味着模运算结果与左操作数相同的符号相同（或零）。 对于 负数的 a : <code>a % n == -(-a % n)</code>， 几个例子：</p>
<ul>
<li><code>int256(5) % int256(2) == int256(1)</code></li>
<li><code>int256(5) % int256(-2) == int256(1)</code></li>
<li><code>int256(-5) % int256(2) == int256(-1)</code></li>
<li><code>int256(-5) % int256(-2) == int256(-1)</code></li>
</ul>
<p>对 0 取模会发生错误 <code>Panic</code> 错误，该检查不能通过<code>unchecked &#123; … &#125;</code> 。</p>
<h2 id="1-5-幂运算"><a href="#1-5-幂运算" class="headerlink" title="1.5 幂运算"></a>1.5 幂运算</h2><p>幂运算仅适用于无符号类型。 结果的类型总是等于基数的类型. 请注意类型足够大以能够容纳幂运算的结果，要么发生潜在的 assert 异常或者使用截断模式。</p>
<p>在 <code>checked</code> 模式下，幂运算仅会为小基数使用相对便宜的 <code>exp</code> 操作码。 例如 <code>x**3</code> 的例子，表达式 <code>x*x*x</code> 也许更便宜。 在任何情况下，都建议进行 <code>gas</code> 消耗测试和使用优化器。</p>
<p>注意 <code>0**0</code> 在 EVM 中定义为 1 。</p>
<h2 id="1-6-i-和-i-区别"><a href="#1-6-i-和-i-区别" class="headerlink" title="1.6 i++ 和 ++i 区别"></a>1.6 i++ 和 ++i 区别</h2><ul>
<li><code>a = i++</code>: 先把 i 的值赋予 a，然后在执行 i&#x3D;i+1；</li>
<li><code>a = ++i</code>: 先执行 i&#x3D;i+1，然后在把 i 的值赋予 a；</li>
</ul>
<h2 id="1-7-for-循环中，-i-更省钱"><a href="#1-7-for-循环中，-i-更省钱" class="headerlink" title="1.7 for 循环中，++i 更省钱"></a>1.7 for 循环中，++i 更省钱</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    // 25153 gas</span><br><span class="line">    function test1() public pure returns (uint256 temp) &#123;</span><br><span class="line">        for (uint256 index = 0; index &lt; 10; index++) &#123;</span><br><span class="line">            temp += index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 25081 gas</span><br><span class="line">    function test2() public pure returns (uint256 temp) &#123;</span><br><span class="line">        for (uint256 index = 0; index &lt; 10; ++index) &#123;</span><br><span class="line">            temp += index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-8-赋值运算符"><a href="#1-8-赋值运算符" class="headerlink" title="1.8 赋值运算符"></a>1.8 赋值运算符</h2><ul>
<li><code>= </code>(简单赋值)</li>
<li><code>+=</code> (相加赋值)</li>
<li><code>−=</code> (相减赋值)</li>
<li><code>*=</code> (相乘赋值)</li>
<li><code>/=</code> (相除赋值)</li>
<li><code>%=</code> (取模赋值)</li>
</ul>
<p>注意： 同样的逻辑也适用于位运算符，因此它们将变成 <code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&gt;&gt;=</code>、<code>&amp;=</code>、<code>|=</code>和<code>^=</code>。</p>
<p><code>a += e</code> 等同于 <code>a = a + e</code>。其它运算符如 <code>-=</code>， <code>*=</code>， <code>/=</code>， <code>%=</code>， <code>|=</code>， <code>&amp;=</code> ， <code>^=</code> ， <code>&lt;&lt;=</code> 和 <code>&gt;&gt;=</code> 都是如此定义的。</p>
<ul>
<li><code>a++</code> 和 <code>a--</code> 分别等同于 <code>a += 1</code> 和 <code>a -= 1</code>，但表达式本身的值等于 <code>a</code> 在计算之前的值。</li>
<li>与之相反， <code>--a</code> 和 <code>++a</code> 虽然最终 <code>a</code> 的结果与之前的表达式相同，但表达式的返回值是计算之后的值。</li>
</ul>
<h1 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h1><p>关系运算符一共有六种：分别为： 大于 、小于 、 大于等于 、 小于等于 、 等于 和 不等于 。</p>
<ul>
<li><code>&gt;</code> (大于)</li>
<li><code>&lt;</code> (小于)</li>
<li><code>&gt;=</code> (大于等于)</li>
<li><code>&lt;=</code> (小于等于)</li>
<li><code>==</code> (等于)</li>
<li><code>!=</code> (不等于)</li>
</ul>
<p><strong>返回的结果是一个布尔值；</strong></p>
<h2 id="2-1-布尔类型-支持的运算符"><a href="#2-1-布尔类型-支持的运算符" class="headerlink" title="2.1 布尔类型 支持的运算符"></a>2.1 布尔类型 支持的运算符</h2><ul>
<li><p>包括：<code>!</code>逻辑非</p>
</li>
<li><p><code>==</code>等于，<code>!=</code> 不等于</p>
</li>
<li><p>&amp;&amp;逻辑与，||逻辑或</p>
<ul>
<li><code>&amp;&amp;</code>，<code>||</code> 为短路运算符</li>
</ul>
</li>
</ul>
<h2 id="2-2-定长字节数组支持的运算符"><a href="#2-2-定长字节数组支持的运算符" class="headerlink" title="2.2 定长字节数组支持的运算符"></a>2.2 定长字节数组支持的运算符</h2><ul>
<li>比较运算符： <code>&lt;=</code>， <code>&lt;</code>， <code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code> （返回布尔型）</li>
<li>位运算符： <code>&amp;</code>， <code>|</code>， <code>^</code> （按位异或）， <code>~</code> （按位取反）</li>
<li>移位运算符： <code>&lt;&lt;</code> （左移位）， <code>&gt;&gt;</code> （右移位）</li>
<li>索引访问：如果 <code>x</code> 是 <code>bytesI</code> 类型，那么 <code>x[k]</code> （其中 0 &lt;&#x3D; k &lt; I）返回第 k 个字节（只读）。</li>
</ul>
<p>该类型可以和作为右操作数的无符号整数类型进行移位运算（但返回结果的类型和左操作数类型相同），右操作数表示需要移动的位数。 进行有符号整数位移运算会引发运行时异常。</p>
<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><h2 id="3-1-基础用法"><a href="#3-1-基础用法" class="headerlink" title="3.1 基础用法"></a>3.1 基础用法</h2><ul>
<li>&amp;&amp; (逻辑与)<ul>
<li>如果两个操作数都是 true ，则条件为真。</li>
</ul>
</li>
<li>|| (逻辑或)<ul>
<li>如果两个操作数有一个为 true ，则条件为真。</li>
</ul>
</li>
<li>! (逻辑非)<ul>
<li>反转操作数的逻辑状态。如果条件为真，则逻辑非操作将使其为假。</li>
</ul>
</li>
</ul>
<h2 id="3-2-和-的短路用法"><a href="#3-2-和-的短路用法" class="headerlink" title="3.2 &amp;&amp; 和 || 的短路用法"></a>3.2 <code>&amp;&amp;</code> 和 <code>||</code> 的短路用法</h2><p>原理:</p>
<ul>
<li><code>A &amp;&amp; B</code>,如果 A 为 false，B 就不执行了</li>
<li><code>A || B</code>,如果 A 为 true，B 就不执行了</li>
</ul>
<p>合理的使用短路操作，可以省一些 gas 费。</p>
<h1 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h1><p>三元运算符是一个表达是形式： <code>&lt;expression&gt; ? &lt;trueExpression&gt; : &lt;falseExpression&gt;</code> 。 它根据 <code>&lt;expression&gt;</code> 的执行结果，选择后两个给定表达式中的一个。 如果 <code>&lt;expression&gt;</code> 执行结果 true ，那么 <code>&lt;trueExpression&gt;</code> 将被执行，否则 <code>&lt;falseExpression&gt;</code> 被执行。</p>
<p>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    uint256 public a = 20;</span><br><span class="line">    uint256 public b = 10;</span><br><span class="line"></span><br><span class="line">    function test1() public view returns (bool) &#123;</span><br><span class="line">        uint256 temp = a + b;</span><br><span class="line">        return temp &gt; 25 ? true : false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test2() public view returns (bool) &#123;</span><br><span class="line">        uint256 temp = a + b;</span><br><span class="line">        return temp &lt; 25 ? true : false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三元运算符的结果类型是由两个操作数的类型决定的，方法与上面一样，如果需要的话，首先转换为它们的最小可容纳类型（mobile type ）。</p>
<p>因此， <code>255 + (true ? 1 : 0)</code> 将由于算术溢出而被回退。 原因是 <code>(true ? 1 : 0)</code> 是 uint8 类型，这迫使加法也要在 <code>uint8</code> 中执行。 而 <code>256</code> 超出了这个类型所允许的范围。</p>
<p>另一个结果是，像 <code>1.5 + 1.5</code> 这样的表达式是有效的，但 <code>1.5 + (true ? 1.5 : 2.5)</code> 则无效。 这是因为前者是以无限精度来进行有理表达式运算，只有它的最终结果值才是重要的。 后者涉及到将小数有理数转换为整数，这在目前是不允许的。</p>
<h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>位运算在数字的二进制补码表示上执行。 这意味着： <code>~int256(0)== int256(-1)</code>。</p>
<p>假设 A 等于 2；B 等于 3。</p>
<ul>
<li><p>&amp;(位与): 对其整数参数的每个位执行位与操作。</p>
<ul>
<li>例: (A &amp; B) 为 2.</li>
</ul>
</li>
<li><p>|(位或): 对其整数参数的每个位执行位或操作。</p>
<ul>
<li>例: (A | B) 为 3.</li>
</ul>
</li>
<li><p>^(位异或): 对其整数参数的每个位执行位异或操作。</p>
<ul>
<li>例: (A ^ B) 为 1.</li>
</ul>
</li>
<li><p>~(位非): 一元操作符，反转操作数中的所有位。</p>
<ul>
<li>例: (~B) 为 -4.</li>
</ul>
</li>
<li><p>&lt;&lt;(左移位)): 将第一个操作数中的所有位向左移动，移动的位置数由第二个操作数指定，新的位由 0 填充。将一个值向左移动一个位置相当于乘以 2，移动两个位置相当于乘以 4，以此类推。</p>
<ul>
<li>例: (A « 1) 为 4.</li>
</ul>
</li>
<li><p><code>&gt;&gt;</code>(右移位): 左操作数的值向右移动，移动位置数量由右操作数指定</p>
<ul>
<li>例: (A » 1) 为 1.</li>
</ul>
</li>
</ul>
<p>如果两个中的任一个数是小数，则不允许进行位运算。如果指数是小数的话，也不支持幂运算（因为这样可能会得到一个无理数）。</p>
<h1 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h1><p><code>delete a</code> 的结果是将 <code>a</code> 类型初始值赋值给<code>a</code>。换句话说，在 <code>delete a</code> 之后 <code>a</code> 的值与在没有赋值的情况下声明 <code>a</code> 的情况相同。</p>
<p><code>delete</code> 适用于整型，数组，结构体映射。</p>
<ul>
<li>对于整型变量：相当于 <code>a = 0</code>。</li>
<li>对于动态数组：是将重置为数组长度为 0 的数组</li>
<li>对于静态数组：是将数组中的所有元素重置为初始值。</li>
<li>对于数组而言：<code>delete a[x]</code> 仅删除数组索引 <code>x</code> 处的元素，其他的元素和长度不变，这为数组留出了一个空位。如果打算删除项，映射可能是更好的选择。</li>
<li>对于结构体：则将结构体中的所有属性(成员)重置。</li>
<li>mapping : 是将所选择的 key 重置为初始值。</li>
</ul>
<p>需要注意以下几点：</p>
<p><code>delete</code> 对整个映射是无效的（因为映射的键可以是任意的，通常也是未知的）。因此在你删除一个结构体时，结果将重置所有的非映射属性（成员），这个过程是递归进行的，除非它们是映射。然而，单个的键及其映射的值是可以被删除的。</p>
<p>理解 <code>delete a</code> 的效果就像是给 <code>a</code> 赋值很重要，换句话说，这相当于在 <code>a</code>中存储了一个新的对象。</p>
<p>当 <code>a</code> 是应用变量时，我们可以看到这个区别， <code>delete a</code> 它只会重置 <code>a</code> 本身，而不是更改它之前引用的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract DeleteLBC &#123;</span><br><span class="line">    uint256 data;</span><br><span class="line">    uint256[] dataArray;</span><br><span class="line"></span><br><span class="line">    function f() public &#123;</span><br><span class="line">        uint256 x = data;</span><br><span class="line">        delete x; // 将 x 设为 0，并不影响数据</span><br><span class="line">        delete data; // 将 data 设为 0，并不影响 x，因为它仍然有个副本</span><br><span class="line">        uint256[] storage y = dataArray;</span><br><span class="line">        delete dataArray;</span><br><span class="line">        // 将 dataArray.length 设为 0，但由于 uint[] 是一个复杂的对象，y 也将受到影响，</span><br><span class="line">        // 因为它是一个存储位置是 storage 的对象的别名。</span><br><span class="line">        // 另一方面：&quot;delete y&quot; 是非法的，引用了 storage 对象的局部变量只能由已有的 storage 对象赋值。</span><br><span class="line">        assert(y.length == 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/06/21/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/04-%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/21/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/04-%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">04-函数</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-21 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-21T00:00:00+08:00">2022-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h1><p>函数由关键字 <code>function</code> 声明，后面跟<strong>函数名</strong>、<strong>参数</strong>、<strong>可视范围</strong>、<strong>状态可变性</strong>、<strong>返回值</strong>的定义。函数可以定义在合约内部，也可以定义在合约外部。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fnName(&lt;parameter list&gt;)</span><br><span class="line">    &lt;visibility&gt;</span><br><span class="line">    &lt;state mutability&gt;</span><br><span class="line">    [returns(&lt;return type&gt;)] &#123;</span><br><span class="line">    //语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fnName(&lt;parameter types&gt;)</span><br><span class="line">    &#123;internal|external&#125;</span><br><span class="line">    [pure|view|payable]</span><br><span class="line">    [returns (&lt;return types&gt;)]&#123;</span><br><span class="line">        //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>function</code>: 声明函数的固定关键字</li>
<li><code>fnName</code> : 函数名，推荐小驼峰写法,更多参考</li>
<li><code>&lt;parameter list&gt;</code> : 参数列表(参数类型 + 参数名字)</li>
<li><code>&lt;visibility&gt;</code>: 可见性，public、external、internal、private</li>
<li><code>&lt;state mutability&gt;</code>: 状态可变性，pure、view、payable，不写 <code>pure/view/payable</code> 中任何一个，代表，函数既可以读取也可以写入状态变量。</li>
<li><code>returns (&lt;return types&gt;)</code>:返回值和返回参数类型</li>
</ul>
<h2 id="1-1-合约函数"><a href="#1-1-合约函数" class="headerlink" title="1.1 合约函数"></a>1.1 合约函数</h2><p>注意：可以在合约内部或外部定义函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Fun &#123;</span><br><span class="line">	//合约内的函数</span><br><span class="line">    function add(uint256 x, uint256 y) external pure returns (uint256) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//合约之外的函数（也称为“自由函数”）始终具有隐式的 `internal` 可见性。 它们的代码包含在所有调用它们合约中，类似于内部库函数</span><br><span class="line">function sum(uint256[] memory arr) pure returns (uint256 s) &#123;</span><br><span class="line">    for (uint256 i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        s += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在合约之外定义的函数仍然在合约的上下文内执行。他们仍然可以访问变量 <code>this</code> ，也可以调用其他合约，将其发送以太币或销毁调用它们合约等其他事情。</p>
<p>与在合约中定义的函数的主要区别为：自由函数不能直接访问存储变量和不在他们的作用域范围内函数。</p>
<h2 id="1-2-函数的输入参数"><a href="#1-2-函数的输入参数" class="headerlink" title="1.2 函数的输入参数"></a>1.2 函数的输入参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    uint256 sum;</span><br><span class="line">	</span><br><span class="line">	// 普通用法</span><br><span class="line">    function add(uint256 a, uint256 b) public &#123;</span><br><span class="line">        sum = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function demo(uint256 _a) public pure returns (uint256) &#123;</span><br><span class="line">    	//函数参数可用在等号左边被赋值</span><br><span class="line">        _a = 22;</span><br><span class="line">        return _a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //使用数组作为函数参数</span><br><span class="line">    function demo(uint256[] memory _a) public returns (uint256[] memory) &#123;</span><br><span class="line">        a = _a;</span><br><span class="line">        return _a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>构造函数关键字 <code>constructor</code>，Solidity 构造函数是一个特殊函数，它仅能在智能合约部署的时候调用一次，创建之后就不能再次被调用。</p>
<p>构造函数是可选的，只允许有一个构造函数，这意味着不支持重载。</p>
<p><strong>用处</strong>: <strong>Solidity 构造函数常用来进行状态变量的初始化工作。</strong></p>
<ul>
<li>比如设置合约的 owner 权限</li>
<li>设置状态变量的初始值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract ErrorModifier&#123;</span><br><span class="line">     address public owner;</span><br><span class="line">    uint public count = 0;</span><br><span class="line"></span><br><span class="line">     constructor(uint _x)&#123;</span><br><span class="line">         owner = msg.sender;</span><br><span class="line">         count = _x;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：在合约创建的过程中，它的代码还是空的，所以直到构造函数执行结束，我们都不应该在其中调用合约自己的函数。(我们可以调用，但是不推荐调用)</p>
<p><strong>请注意</strong>：不可以在构造函数中通过 this 来调用函数，因为此时真实的合约实例还没有被创建。</p>
<h1 id="mutability-状态可变性"><a href="#mutability-状态可变性" class="headerlink" title="mutability:状态可变性"></a>mutability:状态可变性</h1><ul>
<li><p>pure: 既<strong>不读取也不修改状态变量</strong></p>
<ul>
<li>这种函数被称为<strong>纯函数</strong></li>
</ul>
</li>
<li><p>view: 读取状态变量，但是不修改状态变量</p>
<ul>
<li>这种函数被称为<strong>视图函数</strong></li>
<li>状态变量的 Getter 方法默认是 view 函数。</li>
</ul>
</li>
<li><p>payable：用 payable 声明的函数可以接受发送给合约的以太币.</p>
<ul>
<li>如果未指定，该函数将自动拒绝所有发送给它的以太币</li>
</ul>
</li>
</ul>
<h2 id="3-1-pure-不允许的操作"><a href="#3-1-pure-不允许的操作" class="headerlink" title="3.1 pure 不允许的操作"></a>3.1 pure 不允许的操作</h2><p>声明为 pure 函数，可以在函数声明里，添加 pure 关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint256 a, uint256 b) public pure returns (uint256) &#123;</span><br><span class="line">        return a * (b + 42);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数中存在以下语句，则被视为读取状态，编译器将抛出警告。</p>
<ul>
<li><strong>读取状态变量。</strong><ul>
<li><strong>这也意味着读取 <code>immutable</code> 变量也不是一个 <code>pure</code> 操作。</strong></li>
</ul>
</li>
<li><strong>访问 <code>address(this).balance</code> 或 <code>&lt;address&gt;.balance</code></strong></li>
<li><strong>访问 <code>block</code>，<code>tx</code>， <code>msg</code> 中任意成员 （除 <code>msg.sig</code> 和 <code>msg.data</code> 之外）。</strong></li>
<li><strong>调用任何未标记为 <code>pure</code> 的函数。</strong></li>
<li><strong>使用包含特定操作码的内联汇编。</strong><ul>
<li><strong><code>TODO:</code> 这个不了解，需要用例子加深印象。</strong></li>
</ul>
</li>
<li><strong>使用操作码 <code>STATICCALL</code> , 这并不保证状态未被读取, 但至少不被修改。</strong></li>
</ul>
<p>如果发生错误，<code>pure</code> 函数可以使用 <code>revert()</code>和 <code>require()</code> 函数来还原潜在的状态更改。还原状态更改不被视为 <strong>状态修改</strong>, 因为它只还原以前在没有<code>view</code> 或 <code>pure</code> 限制的代码中所做的状态更改, 并且代码可以选择捕获 revert 并不传递还原。这种行为也符合 STATICCALL 操作码。</p>
<p><strong>警告</strong>:不可能在 EVM 级别阻止函数读取状态, 只能阻止它们写入状态 (即只能在 EVM 级别强制执行 <code>view</code> , 而 <code>pure</code> 不能强制)。</p>
<h2 id="3-2-view-不允许的操作"><a href="#3-2-view-不允许的操作" class="headerlink" title="3.2 view 不允许的操作"></a>3.2 view 不允许的操作</h2><p>可以将函数声明为 view 类型，这种情况下要保证不修改状态。声明为 view 图函数，可以在函数声明里，添加 view 关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint256 a, uint256 b) public view returns (uint256) &#123;</span><br><span class="line">        return a * (b + 42) + block.timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解</strong>: Getter 方法自动被标记为 view。</p>
<p>如果函数中存在以下语句，则被视为修改状态，编译器将抛出警告。</p>
<ul>
<li><strong>修改状态变量。</strong></li>
<li><strong>触发事件。</strong></li>
<li><strong>创建其它合约。</strong></li>
<li><strong>使用 <code>selfdestruct</code>。</strong></li>
<li><strong>通过调用发送以太币。</strong></li>
<li><strong>调用任何没有标记为 view 或者 pure 的函数。</strong></li>
<li><strong>使用底层调用</strong><ul>
<li><strong>(TODO:这里是 call 操作么？)</strong></li>
</ul>
</li>
<li><strong>使用包含某些操作码的内联程序集。</strong></li>
</ul>
<h2 id="3-3-payable"><a href="#3-3-payable" class="headerlink" title="3.3 payable"></a>3.3 payable</h2><h3 id="一个加和减的-DEMO"><a href="#一个加和减的-DEMO" class="headerlink" title="一个加和减的 DEMO"></a>一个加和减的 DEMO</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Counter&#123;</span><br><span class="line">    uint public count ;</span><br><span class="line"></span><br><span class="line">    function add() external &#123;</span><br><span class="line">        count+=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function minus() external &#123;</span><br><span class="line">        count-=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="状态可变性的类型转换"><a href="#状态可变性的类型转换" class="headerlink" title="状态可变性的类型转换"></a>状态可变性的类型转换</h3><p>如果满足下列条件，函数类型 A 可以隐式转换为函数类型:</p>
<ul>
<li>它们的参数类型相同，返回类型相同，它们的内部&#x2F;外部属性是相同的，并且 A 的状态可变性比 B 的状态可变性更具限制性</li>
</ul>
<p>比如：</p>
<ul>
<li>pure 函数可以转换为 view 和 non-payable 函数</li>
<li>view 函数可以转换为 non-payable 函数</li>
<li>payable 函数可以转换为 non-payable 函数</li>
<li>其他的转换则不可以。</li>
</ul>
<p>关于 <code>payable</code> 和 <code>non-payable</code> 的规则可能有点令人困惑，如果一个函数是 <code>payable</code> ，这意味着它也接受零以太的支付，因此它也是 <code>non-payable</code> 。 另一方面，<code>non-payable</code> 函数将拒绝发送给它的 以太币 Ether ， 所以 <code>non-payable</code> 函数不能转换为 <code>payable</code> 函数。</p>
<h1 id="函数的签名-函数标识符"><a href="#函数的签名-函数标识符" class="headerlink" title="函数的签名&#x2F;函数标识符"></a>函数的签名&#x2F;函数标识符</h1><p>在变量的全局变量那一章，我们介绍了 <code>msg.data</code> <code>msg.sig</code>,分别是调用合约的完整的 calldata，以及<strong>函数标识符</strong>（calldata 的前四个字节）</p>
<h3 id="查看-msg-data"><a href="#查看-msg-data" class="headerlink" title="查看 msg.data"></a>查看 msg.data</h3><p>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Receiver &#123;</span><br><span class="line">    event Log(bytes data1, bytes4 data2);</span><br><span class="line"></span><br><span class="line">    function transfer(address recipient, uint256 amount)</span><br><span class="line">        external</span><br><span class="line">        payable</span><br><span class="line">        returns (address, uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        emit Log(msg.data, msg.sig);</span><br><span class="line">        return (msg.sender, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>输入:</p>
<ul>
<li><code>0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</code></li>
<li><code>1</code></li>
</ul>
</li>
<li><p>logs 结果:</p>
<ul>
<li><p>data1</p>
<p> （为了方便阅读，我拆分成如下）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xa9059cbb</span><br><span class="line">0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000001</span><br></pre></td></tr></table></figure>
</li>
<li><p>data2</p>
<p> 结果如下</p>
<ul>
<li><code>0xa9059cbb</code></li>
</ul>
</li>
</ul>
</li>
<li><p>output 结果:</p>
<ul>
<li><code>0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</code></li>
</ul>
</li>
<li><p><code>0</code></p>
</li>
</ul>
<h3 id="msg-data-中函数标识符的实现逻辑"><a href="#msg-data-中函数标识符的实现逻辑" class="headerlink" title="msg.data 中函数标识符的实现逻辑"></a>msg.data 中<strong>函数标识符</strong>的实现逻辑</h3><p>核心: <code>bytes4(keccak256(bytes(&quot;transfer(address,uint256)&quot;)))</code></p>
<p>一个函数调用数据的前 4 字节，指定了要调用的函数。这就是某个函数签名的 Keccak 哈希的前 4 字节（bytes32 类型是从左取值）。</p>
<p>函数签名被定义为基础原型的规范表达，而基础原型是<strong>函数名称加上由括号括起来的参数类型列表，参数类型间由一个逗号分隔开，且没有空格。</strong>.</p>
<p>代码如下，获取 Hash 后的值，和截取后的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract FunctionSelector &#123;</span><br><span class="line">    function getSelector(string calldata _func)</span><br><span class="line">        external</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes32, bytes4)</span><br><span class="line">    &#123;</span><br><span class="line">        // _func 字符串通过 bytes 转为 bytes</span><br><span class="line">        // 使用 keccak256 进行 Hash值运算</span><br><span class="line">        // 使用 bytes4 截取 keccak256 返回的32位数据</span><br><span class="line">        return (keccak256(bytes(_func)), bytes4(keccak256(bytes(_func))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试：</strong></p>
<ol>
<li>部署</li>
<li>输入 <code>&quot;transfer(address,uint256)&quot;</code></li>
<li>获取结构<ol>
<li><code>0xa9059cbb2ab09eb219583f4a59a5d0623ade346d962bcd4e46b11da047c9049b</code></li>
<li><code>0xa9059cbb</code></li>
</ol>
</li>
</ol>
<p>注意：以上仅仅是背后的原理展示，如果想要获取值，可以通过<code>.selector</code> 返回 ABI 函数选择器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">library L &#123;</span><br><span class="line">    function f(uint256) external &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function g() public pure returns (bytes4) &#123;</span><br><span class="line">        return L.f.selector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管可以对 public 或 external 的库函数进行外部调用，但此类调用会被视为 Solidity 的内部调用，与常规的 contract ABI 规则不同。外部库函数比外部合约函数支持更多的参数类型，例如递归结构和指向存储的指针。</p>
<p>因此，计算用于计算 4 字节选择器的函数签名遵循内部命名模式以及可对合约 ABI 中不支持的类型的参数使用内部编码。</p>
<p>以下标识符可以作为函数签名中的类型：</p>
<ul>
<li>值类型, 非存储的（non-storage） <code>string</code> 及非存储的 <code>bytes</code>使用和合约 ABI 中同样的标识符。</li>
<li>非存储的数组类型遵循合约 ABI 中同样的规则，例如 <code>&lt;type&gt;[]</code>为动态数组以及 <code>&lt;type&gt;[M]</code> 为 <code>M</code> 个元素的动态数组。</li>
<li>非存储的结构体使用完整的命名引用，例如 <code>C.S</code> 用于<code>contract C &#123; struct S &#123; ... &#125; &#125;</code>.</li>
<li>存储的映射指针使用 <code>mapping(&lt;keyType&gt; =&gt; &lt;valueType&gt;) storage</code> 当<code>&lt;keyType&gt;</code> 和 <code>&lt;valueType&gt;</code> 是映射的键和值类型。</li>
<li>其他的存储的指针类型使用其对应的非存储类型的类型标识符，但在其后面附加一个空格及<code>storage</code> 。</li>
</ul>
<h1 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h1><p>Solidity 的函数重载，是指同一个作用域内，相同函数名可以定义多个函数。</p>
<p><strong>这些相同函数名的函数，参数(参数类型或参数数量)必须不一样。</strong>，因为只有这样上一节介绍的函数签名中，才能签出来不同的函数选择器。</p>
<p>合约可以具有多个不同参数的同名函数，称为”重载”（overloading），这也适用于继承函数。</p>
<h4 id="选择重载函数-参数匹配"><a href="#选择重载函数-参数匹配" class="headerlink" title="选择重载函数 &amp; 参数匹配"></a>选择重载函数 &amp; 参数匹配</h4><p>选择重载函数：通过将当前范围内的函数声明与函数调用中提供的参数相匹配，这样就可以选择重载函数。</p>
<p>如果所有参数都可以隐式地转换为预期类型，则该函数作为重载候选项。如果一个匹配的都没有，解析失败。</p>
<p>⚠️：返回参数不作为重载解析的依据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function f(uint8 val) public pure returns (uint8 out) &#123;</span><br><span class="line">        out = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f(uint256 val) public pure returns (uint256 out) &#123;</span><br><span class="line">        out = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    A a;</span><br><span class="line"></span><br><span class="line">    // Member &quot;f&quot; not unique after argument-dependent lookup in contract A.</span><br><span class="line">    // function test1() public view returns (uint256) &#123;</span><br><span class="line">    //     uint256 tar = a.f(8);</span><br><span class="line">    //     return tar;</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    function test2() public view returns (uint256) &#123;</span><br><span class="line">        uint256 tar = a.f(256);</span><br><span class="line">        return tar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Remix 里,部署 A 合约，会将两个方法都渲染出来，调用 <code>f(50)</code>&#x2F;<code>f(256)</code> 都可以。</p>
<p>但是实际调用里，在其他合约内调用 <code>f(50)</code> 会导致类型错误，因为 <code>50</code> 既可以被隐式转换为 <code>uint8</code>也可以被隐式转换为 <code>uint256</code>。 另一方面，调用 <code>f(256)</code> 则会解析为<code>f(uint256)</code> 重载，因为 <code>256</code> 不能隐式转换为 <code>uint8</code>。</p>
<h1 id="modifier-函数修改器"><a href="#modifier-函数修改器" class="headerlink" title="modifier:函数修改器"></a>modifier:函数修改器</h1><p>Solidity 中关键字 <code>modifier</code> 用于声明一个函数修改器。</p>
<ul>
<li><p><strong>意义</strong>:我们可以将一些通用的操作提取出来，包装为函数修改器，来提高代码的复用性，改善编码效率。是函数高内聚，低耦合的延伸。</p>
</li>
<li><p>作用: 常用于在函数执行前检查某种前置条件。</p>
<ul>
<li>比如地址对不对，余额是否充足，参数值是否允许等</li>
<li>修改器内可以写逻辑</li>
</ul>
</li>
<li><p>特点:是一种合约属性，可被继承，同时还可被派生的合约重写(override)。（修改器 modifier 是合约的可继承属性，并可能被派生合约覆盖 , 但前提是它们被标记为 virtual）。</p>
<ul>
<li><code>_</code> 符号可以在修改器中出现多次，每处都会替换为函数体。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract ErrorModifier&#123;</span><br><span class="line">     address public owner;</span><br><span class="line">    uint public count = 0;</span><br><span class="line">    </span><br><span class="line">     constructor()&#123;</span><br><span class="line">         owner = msg.sender;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     function add() external&#123;</span><br><span class="line">     	//普通判断,非常的啰嗦</span><br><span class="line">         require(msg.sender==owner,&quot;must owner address&quot;);</span><br><span class="line">         count++;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     // 下面就是函数修改器</span><br><span class="line">     modifier onlyOwner()&#123;</span><br><span class="line">         require(msg.sender==owner,&quot;must owner address&quot;);</span><br><span class="line">         _;</span><br><span class="line">     &#125;</span><br><span class="line">     function add() external onlyOwner&#123;</span><br><span class="line">         count++;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     // 函数修改器:带参数</span><br><span class="line">      modifier greaterThan(uint _x)&#123;</span><br><span class="line">         require(_x &gt; 10,&quot;must be greater than 10&quot;);</span><br><span class="line">         _;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     function fnA(uint _x) external onlyOwner greaterThan( _x)&#123;</span><br><span class="line">         count=_x;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     //防重载的函数修改器，这种使用方法，在低版本的 solidity 中可以防止重入攻击。</span><br><span class="line">      modifier noReentrant() &#123;</span><br><span class="line">        require(!locked, &quot;no reentrant&quot;);</span><br><span class="line">        locked = true;</span><br><span class="line">        _;</span><br><span class="line">        locked = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想访问定义在合约 C 的 修改器 modifier m ， 可以使用 C.m 去引用它，而不需要使用虚拟表查找。</p>
<p>只能使用在当前合约或在基类合约中定义的 修改器 modifier , 修改器 modifier 也可以定义在库里面，但是他们被限定在库函数使用。</p>
<p>如果同一个函数有多个 修改器 modifier，它们之间以空格隔开，修改器 modifier 会依次检查执行。</p>
<p>修改器不能隐式地访问或改变它们所修饰的函数的参数和返回值。 这些值只能在调用时明确地以参数传递。</p>
<p>修改器 modifier 或函数体中显式的 return 语句仅仅跳出当前的 修改器 modifier 和函数体。 返回变量会被赋值，但整个执行逻辑会从前一个 修改器 modifier 中的定义的 <code>_</code> 之后继续执行。</p>
<p>警告:在早期的 Solidity 版本中，有 修改器 modifier 的函数， return 语句的行为表现不同。用 <code>return</code>; 从修改器中显式返回并不影响函数返回值。 然而，修改器可以选择完全不执行函数体，在这种情况下，返回的变量被设置为默认值，就像该函数是空函数体一样。</p>
<p><code>_</code> 符号可以在修改器中出现多次，每处都会替换为函数体。</p>
<p>修改器 modifier 的参数可以是任意表达式，在此上下文中，所有在函数中可见的符号，在 修改器 modifier 中均可见。 在 修改器 modifier 中引入的符号在函数中不可见（可能被重载改变）。</p>
<h1 id="全局：数学和密码学函数"><a href="#全局：数学和密码学函数" class="headerlink" title="全局：数学和密码学函数"></a>全局：数学和密码学函数</h1><p>在全局命名空间中已经预设了一些特殊的变量和函数，他们主要用来提供关于区块链的信息或一些通用的工具函数。后续会详细介绍，这里简单的介绍几个全局函数</p>
<h2 id="7-1-数学和密码学函数"><a href="#7-1-数学和密码学函数" class="headerlink" title="7.1 数学和密码学函数"></a>7.1 数学和密码学函数</h2><p>Solidity 也提供了内置的数学和密码学函数：</p>
<p>数学函数：</p>
<ul>
<li><pre><code>addmod(uint x, uint y, uint k) returns (uint)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 计算 `(x + y) % k`，加法会在任意精度下执行，并且加法的结果即使超过 `2**256` 也不会被截取。从 0.5.0 版本的编译器开始会加入对 `k != 0` 的校验（assert）。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  mulmod(uint x, uint y, uint k) returns (uint)</span><br></pre></td></tr></table></figure>

- 计算 `(x * y) % k`，乘法会在任意精度下执行，并且乘法的结果即使超过 `2**256` 也不会被截取。从 0.5.0 版本的编译器开始会加入对 `k != 0` 的校验（assert）。
</code></pre>
</li>
</ul>
<p>密码学函数：</p>
<ul>
<li><pre><code>keccak256((bytes memory) returns (bytes32)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 计算 Keccak-256 哈希，之前 keccak256 的别名函数 **sha3** 在 **0.5.0** 中已经移除。。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  sha256(bytes memory) returns (bytes32)</span><br></pre></td></tr></table></figure>

- 计算参数的 SHA-256 哈希。
</code></pre>
</li>
<li><pre><code>ripemd160(bytes memory) returns (bytes20)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 计算参数的 RIPEMD-160 哈希。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</span><br></pre></td></tr></table></figure>

- 利用椭圆曲线签名恢复与公钥相关的地址，错误返回零值。
- 函数参数对应于 ECDSA 签名的值:
  - r = 签名的前 32 字节
  - s = 签名的第 2 个 32 字节
  - v = 签名的最后一个字节
- ecrecover 返回一个 address, 而不是 address payable。
- `ecrecover` 的[使用案例](https://ethereum.stackexchange.com/questions/1777/workflow-on-signing-a-string-with-private-key-followed-by-signature-verificatio)
</code></pre>
</li>
</ul>
<h2 id="7-2-密码学函数"><a href="#7-2-密码学函数" class="headerlink" title="7.2 密码学函数"></a>7.2 密码学函数</h2><h3 id="密码学-keccak256-和-encodePacked-encode"><a href="#密码学-keccak256-和-encodePacked-encode" class="headerlink" title="密码学 keccak256 和 encodePacked&#x2F;encode"></a>密码学 keccak256 和 encodePacked&#x2F;encode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keccak256((bytes memory) returns (bytes32)</span><br></pre></td></tr></table></figure>

<p><strong>keccak256</strong>: 返回结果是 bytes32</p>
<p>这些编码函数可以用来构造函数调用数据，而不用实际进行调用。此外，<code>keccak256(abi.encodePacked(a, b))</code> 是一种计算结构化数据的哈希值（尽管我们也应该关注到：使用不同的函数参数类型也有可能会引起“哈希冲突” ）的方式，不推荐使用的 <code>keccak256(a, b)</code> 。</p>
<p>如果是多个参数，推荐使用 <code>encode</code>；<code>encodePacked</code> 因为哈希碰撞，容易导致参数不同，结果相同</p>
<blockquote>
<p>[AAA,BB] 和 [AA,ABB] 通过 encodePacked 得到的结果相同</p>
</blockquote>
<h3 id="密码学-ecrecover"><a href="#密码学-ecrecover" class="headerlink" title="密码学: ecrecover"></a>密码学: ecrecover</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</span><br></pre></td></tr></table></figure>

<p>利用椭圆曲线签名恢复与公钥相关的地址，错误返回零值。</p>
<p>函数参数对应于 ECDSA 签名的值:</p>
<ul>
<li>r &#x3D; 签名的前 32 字节</li>
<li>s &#x3D; 签名的第 2 个 32 字节</li>
<li>v &#x3D; 签名的最后一个字节</li>
</ul>
<p><code>ecrecover</code> 返回一个 address, 而不是 <code>address payable</code> 。他们之前的转换参考 <code>address payable</code> ，如果需要转移资金到恢复的地址。<a target="_blank" rel="noopener" href="https://ethereum.stackexchange.com/questions/1777/workflow-on-signing-a-string-with-private-key-followed-by-signature-verificatio">参考案例</a></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果你使用 <code>ecrecover</code> ，需要了解，在不需要知道相应的私钥下，签名也可以转换为另一个有效签名（可能是另外一个数据的签名）。在 Homestead 硬分叉，这个问题对于 <em>transaction</em> 签名已经解决了(查阅 EIP-2)。 不过 <code>ecrecover</code> 没有更改。</p>
<p>除非需要签名是唯一的，否则这通常不是问题，或者是用它们来识别物品。 OpenZeppelin 有一个 <a target="_blank" rel="noopener" href="https://docs.openzeppelin.com/contracts/2.x/api/cryptography#ECDSA">ECDSA</a> 助手库 ，可以将其用作 <code>ecrecover</code> 的”包装“，而不会出现此问题。</p>
<p>在一个私链上，你很有可能碰到由于 sha256、ripemd160 或者 ecrecover 引起的 <strong>Out-of-Gas</strong>。这个原因就是他们被当做所谓的预编译合约而执行，并且在第一次收到消息后这些合约才真正存在（尽管合约代码是硬代码）。发送到不存在的合约的消息非常昂贵，所以实际的执行会导致 Out-of-Gas 错误。在你的合约中实际使用它们之前，给每个合约发送一点儿以太币，比如 1 Wei。这在官方网络或测试网络上不是问题。</p>
<p><strong>ecrecover</strong>:这个比较复杂，请在下面的 <strong>通过智能合约验证签名</strong> 例子详细查看；</p>
<h3 id="案例-1-通过智能合约验证签名"><a href="#案例-1-通过智能合约验证签名" class="headerlink" title="案例 1:通过智能合约验证签名"></a>案例 1:通过智能合约验证签名</h3><p>做一个 DEMO：链上对任意消息进行加密，加密消息在链下使用私钥再次加密，然后对再次加密的信息进行校验。</p>
<ol>
<li><p>获取消息的 Hash 值</p>
<ul>
<li><code>hash = msgHash(_message);</code></li>
</ul>
</li>
<li><p>在【链下】将 hash 使用 MetaMask 进行私钥签名;</p>
<ul>
<li><code>_signature = metaMaskSignHash(hash,addressPrivateKey)</code></li>
<li>这里相当于在 Metamask 对 hash 做第二次的 <strong>keccak256 Hash</strong> 转换，转换时添加了<code>&quot;\x19Ethereum Signed Message:\n32&quot;</code></li>
</ul>
</li>
<li><p>使用ecrecover方法恢复签名地址</p>
<ul>
<li><code>ecrecoverAddress = recoverAds(hash,_signature)</code></li>
<li>这里可以恢复 MetaMask 签名时候使用的地址</li>
</ul>
</li>
<li><p>校验签名结果是否正确<br>ecrecoverAddress &#x3D;&#x3D; addressPublicKey ? “验证成功” : “验证失败”;</p>
</li>
</ol>
<h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract VerifySig &#123;</span><br><span class="line">    /**</span><br><span class="line">    功能:校验签名结果是否正确</span><br><span class="line">    注意 _signature 是 bytes 类型的</span><br><span class="line">     */</span><br><span class="line">    function verify(</span><br><span class="line">        address addressPublicKey,</span><br><span class="line">        string calldata _message,</span><br><span class="line">        bytes calldata _signature</span><br><span class="line">    ) external pure returns (bool) &#123;</span><br><span class="line">        bytes32 hash = msgHash(_message);</span><br><span class="line">        // bytes32 _signature = metaMaskSignHash(hash,addressPrivateKey); // 这是在链下操作</span><br><span class="line">        address ecrecoverAddress = recoverAds(hash, _signature);</span><br><span class="line">        return ecrecoverAddress == addressPublicKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function msgHash(string calldata _message)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes32 keccakFirst)</span><br><span class="line">    &#123;</span><br><span class="line">        keccakFirst = keccak256(abi.encodePacked(_message));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function msgHash2(bytes32 _msgHash)</span><br><span class="line">        internal</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes32 keccakSecond)</span><br><span class="line">    &#123;</span><br><span class="line">        // 两次2次签名，据说是数学层面上1次签名有被破解的可能。[我没有亲自验证过]</span><br><span class="line">        keccakSecond = keccak256(</span><br><span class="line">            abi.encodePacked(&quot;\x19Ethereum Signed Message:\n32&quot;, _msgHash)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function recoverAds(bytes32 _msgHash, bytes calldata _signature)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (address)</span><br><span class="line">    &#123;</span><br><span class="line">        // metamsk 签名会在原有消息上添加  &quot;\x19Ethereum Signed Message:\n32&quot;，所以需要处理一下</span><br><span class="line">        bytes32 metamaskInputHash = msgHash2(_msgHash);</span><br><span class="line">        // r为点的x坐标，s为点的y坐标，v是坐标的奇偶检验标识符</span><br><span class="line">        // v是用于说明那个点才是真正符合结果的点</span><br><span class="line">        // https://www.cnblogs.com/wanghui-garcia/p/9662140.html</span><br><span class="line">        // https://www.jianshu.com/p/090f605f1842/</span><br><span class="line">        (bytes32 r, bytes32 s, uint8 v) = _split(_signature);</span><br><span class="line"></span><br><span class="line">        address ecrecoverAddress = ecrecover(metamaskInputHash, v, r, s);</span><br><span class="line">        return ecrecoverAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _split(bytes memory _signature)</span><br><span class="line">        internal</span><br><span class="line">        pure</span><br><span class="line">        returns (</span><br><span class="line">            bytes32 r,</span><br><span class="line">            bytes32 s,</span><br><span class="line">            uint8 v</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        // 需要内联汇编进行分割，合约没有别的方法</span><br><span class="line">        require(_signature.length == 65, &quot;invalid signature length&quot;);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r := mload(add(_signature, 32))</span><br><span class="line">            s := mload(add(_signature, 64))</span><br><span class="line">            // v := mload(add(_signature, 96))</span><br><span class="line">            // 因为 v 不是 bytes32，是 uint8数字，uint8数字只占1位，所以使用 byte(0)转换</span><br><span class="line">            v := byte(0, mload(add(_signature, 96)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链下签名和-Remix-验证"><a href="#链下签名和-Remix-验证" class="headerlink" title="链下签名和 Remix 验证"></a>链下签名和 Remix 验证</h4><p>使用浏览器控制台进行签名，需要安装 MateMask</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 1.打开 ethereum</span><br><span class="line">ethereum.enable()</span><br><span class="line"></span><br><span class="line">// 2.赋值地址。这里的地址是 MateMask 的默认地址</span><br><span class="line">const address = &quot;0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac&quot;;</span><br><span class="line"></span><br><span class="line">// 3.赋值Hash。 使用 msgHash1 方法，输入 &quot;ABC&quot; 获取到的结果</span><br><span class="line">const hash = &quot;0xe1629b9dda060bb30c7908346f6af189c16773fa148d3366701fbaa35d54f3c8&quot;</span><br><span class="line"></span><br><span class="line">// 4. 呼起 MataMask 签名</span><br><span class="line">ethereum.request(&#123;method:&quot;personal_sign&quot;,params:[address,hash]&#125;);</span><br><span class="line"></span><br><span class="line">// 5. 打开返回的 Promise &#123;&lt;pending&gt;&#125;，拷贝 PromiseResult 值</span><br><span class="line">0x66029be70a055a4abc293072c76550ffaecb2adb9fc3be2366d78bc498e008d06b6ddbfef97392a27a58737c33b059e09bb069261bdc41f9f0d8d1bc6e0b7ae31c</span><br><span class="line"></span><br><span class="line">// 6. 在 recoverAds 中验证恢复的地址是否为签名地址。</span><br><span class="line">上面的 PromiseResult 值是 _signature</span><br><span class="line">上面的 hash 值是 _msgHash</span><br><span class="line"></span><br><span class="line">// 7. 在 verify 中再次校验</span><br></pre></td></tr></table></figure>

<p>扩展阅读: 在线进行签名的网站: <a target="_blank" rel="noopener" href="https://metamask.github.io/test-dapp/">https://metamask.github.io/test-dapp/</a></p>
<h2 id="7-3-全局：ABI-编码及解码函数"><a href="#7-3-全局：ABI-编码及解码函数" class="headerlink" title="7.3 全局：ABI 编码及解码函数"></a>7.3 全局：ABI 编码及解码函数</h2><p>ABI 全名 Application Binary Interface。ABI 用于底层调用的辅助使用；在合约调用合约的时候使用，可以不知道对方的合约源码，只需要知道链上逻辑即可。</p>
<ul>
<li>ABI 编码<ul>
<li><code>abi.encode(...) returns (bytes)</code>： :ref:<code>ABI &lt;ABI&gt;</code> - 对给定参数进行编码</li>
<li><code>abi.encodePacked(...) returns (bytes)</code>：对给定参数执行 :ref:<code>紧打包编码 &lt;abi_packed_mode&gt;</code> ，注意，可以不明确打包编码。</li>
<li><code>abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)</code>： :ref:<code>ABI &lt;ABI&gt;</code> - 对给定第二个开始的参数进行编码，并以给定的函数选择器作为起始的 4 字节数据一起返回</li>
<li><code>abi.encodeWithSignature(string signature, ...) returns (bytes)</code>：等价于 <code>abi.encodeWithSelector(bytes4(keccak256(signature), ...)</code></li>
<li><code>abi.encodeCall(function functionPointer, (...)) returns (bytes memory)</code>: 使用 tuple 类型参数 ABI 编码调用 <code>functionPointer</code> 。执行完整的类型检查, 确保类型匹配函数签名。结果和 <code>abi.encodeWithSelector(functionPointer.selector, (...))</code> 一致。</li>
</ul>
</li>
<li>ABI 解码<ul>
<li><code>abi.decode(bytes memory encodedData, (...)) returns (...)</code>: 对给定的数据进行 ABI 解码，而数据的类型在括号中第二个参数给出 。 例如: <code>(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))</code></li>
</ul>
</li>
</ul>
<h3 id="7-3-1-encode-会补零"><a href="#7-3-1-encode-会补零" class="headerlink" title="7.3.1 encode: 会补零"></a>7.3.1 encode: 会补零</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract AbiDecode &#123;</span><br><span class="line">    function encode(string memory a, string memory b)</span><br><span class="line">        external</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes memory)</span><br><span class="line">    &#123;</span><br><span class="line">        return abi.encode(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">输入如下参数和返回结果</span><br><span class="line">1.AA,BB</span><br><span class="line">    0x</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000040</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000080</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">    4141000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">    4242000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">2.AAA,BB</span><br><span class="line">    0x</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000040</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000080</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000003</span><br><span class="line">    4141410000000000000000000000000000000000000000000000000000000000</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">    4242000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">3.AA,ABB</span><br><span class="line">    0x</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000040</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000080</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">    4141000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000003</span><br><span class="line">    4142420000000000000000000000000000000000000000000000000000000000</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="7-3-2-encodePacked不会补零"><a href="#7-3-2-encodePacked不会补零" class="headerlink" title="7.3.2 encodePacked不会补零"></a>7.3.2 encodePacked不会补零</h3><p>不补零，容易导致碰撞错误。（两个参数拼在一起，导致参数不同，结果相同）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract AbiDecode &#123;</span><br><span class="line">    function encodePacked(string memory a, string memory b)</span><br><span class="line">        external</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes memory)</span><br><span class="line">    &#123;</span><br><span class="line">        return abi.encodePacked(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">输入如下参数和返回结果</span><br><span class="line">1.AA,BB</span><br><span class="line">    0x41414242</span><br><span class="line">2.AAA,BB</span><br><span class="line">    0x4141414242</span><br><span class="line">3.AA,ABB</span><br><span class="line">    0x4141414242</span><br><span class="line">[AAA,BB] 和 [AA,ABB] 得到的结果相同</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h4 id="解决-encodePacked-的哈希碰撞问题"><a href="#解决-encodePacked-的哈希碰撞问题" class="headerlink" title="解决 encodePacked 的哈希碰撞问题"></a>解决 <code>encodePacked</code> 的哈希碰撞问题</h4><p>可以在要编码的数据中间加一个固定的值，如果</p>
<p><strong>代码如下:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract AbiDecode &#123;</span><br><span class="line">    function encodePacked(string calldata _test1, string calldata _test2)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes memory)</span><br><span class="line">    &#123;</span><br><span class="line">        uint256 x = 123;</span><br><span class="line">        return abi.encodePacked(_test1, x, _test2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果如下:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">输入如下参数和返回结果</span><br><span class="line">1.AA,BB</span><br><span class="line">    0x4141000000000000000000000000000000000000000000000000000000000000007b4242</span><br><span class="line">2.AAA,BB</span><br><span class="line">    0x414141000000000000000000000000000000000000000000000000000000000000007b4242</span><br><span class="line">3.AA,ABB</span><br><span class="line">    0x4141000000000000000000000000000000000000000000000000000000000000007b414242</span><br><span class="line">[AAA,BB] 和 [AA,ABB] 因为间隔了数据，所以得到的结果不相同</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>这些编码函数可以用来构造函数调用数据，而不用实际进行调用。此外，<code>keccak256(abi.encodePacked(a, b))</code> 是一种计算结构化数据的哈希值（尽管我们也应该关注到：使用不同的函数参数类型也有可能会引起“哈希冲突” ）的方式，不推荐使用的 <code>keccak256(a, b)</code> 。</p>
<h3 id="7-3-3-decode"><a href="#7-3-3-decode" class="headerlink" title="7.3.3 decode"></a>7.3.3 decode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract AbiDecode &#123;</span><br><span class="line">    struct MyStruct &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint256[2] nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function encode(</span><br><span class="line">        uint256 x,</span><br><span class="line">        address addr,</span><br><span class="line">        uint256[] calldata arr,</span><br><span class="line">        MyStruct calldata myStruct</span><br><span class="line">    ) external pure returns (bytes memory) &#123;</span><br><span class="line">        return abi.encode(x, addr, arr, myStruct);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function decode(bytes calldata data)</span><br><span class="line">        external</span><br><span class="line">        pure</span><br><span class="line">        returns (</span><br><span class="line">            uint256 x,</span><br><span class="line">            address addr,</span><br><span class="line">            uint256[] memory arr,</span><br><span class="line">            MyStruct memory myStruct</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        (x, addr, arr, myStruct) = abi.decode(</span><br><span class="line">            data,</span><br><span class="line">            (uint256, address, uint256[], MyStruct)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>合约测试</strong></p>
<ul>
<li><p>部署</p>
</li>
<li><pre><code>encode
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 参数如下:</span><br><span class="line">  - `1`</span><br><span class="line">  - `0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac`</span><br><span class="line">  - `[1,2,3]`</span><br><span class="line">  - `[&quot;Anbang&quot;,[2,3]]`</span><br><span class="line"></span><br><span class="line">- 得到的结果，进行 `decode`</span><br><span class="line"></span><br><span class="line">### 7.3.4 abi.encodeWithSelector</span><br><span class="line"></span><br><span class="line">这是获取函数签名使用的，第一个参数为函数选择，如下是第二章在介绍地址类型的时候，staticcall 静态调用 用法的参数，需要由 `abi.encodeWithSelector` 计算出来。函数的参数按照顺序写在函数名之后即可。</span><br><span class="line"></span><br><span class="line">```solidity</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 被调用的合约</span><br><span class="line">contract Hello &#123;</span><br><span class="line">    function echo() external pure returns (string memory) &#123;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用者合约</span><br><span class="line">contract SoldityTest &#123;</span><br><span class="line">    function callHello(address _ads) external view returns (string memory) &#123;</span><br><span class="line">        // 编码被调用者的方法签名</span><br><span class="line">        bytes4 methodId = bytes4(keccak256(&quot;echo()&quot;));</span><br><span class="line"></span><br><span class="line">        // 调用合约</span><br><span class="line">        (bool success, bytes memory data) = _ads.staticcall(</span><br><span class="line">            abi.encodeWithSelector(methodId)</span><br><span class="line">        );</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            return abi.decode(data, (string));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;error&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="7-3-5-abi-encodeWithSignature"><a href="#7-3-5-abi-encodeWithSignature" class="headerlink" title="7.3.5 abi.encodeWithSignature"></a>7.3.5 abi.encodeWithSignature</h3><p>这是获取函数签名使用的，第一个参数为函数的名字和参数类型，如下是第二章在介绍地址类型的时候，call 用法的参数，需要由 <code>abi.encodeWithSignature</code> 计算出来。函数的参数按照顺序写在函数名之后即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function call_Test1_setNameAndAge(</span><br><span class="line">    address _ads,</span><br><span class="line">    string memory _name,</span><br><span class="line">    uint256 _age</span><br><span class="line">) external payable &#123;</span><br><span class="line">    bytes memory data = abi.encodeWithSignature(</span><br><span class="line">        &quot;setNameAndAge(string,uint256)&quot;,</span><br><span class="line">        _name,</span><br><span class="line">        _age</span><br><span class="line">    );</span><br><span class="line">    (bool success, bytes memory _bys) = _ads.call&#123;value: msg.value&#125;(data);</span><br><span class="line">    require(success, &quot;Call Failed&quot;);</span><br><span class="line">    bys = _bys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/06/20/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/03-%E5%8F%98%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/20/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/03-%E5%8F%98%E9%87%8F/" class="post-title-link" itemprop="url">03-变量</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-20 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-20T00:00:00+08:00">2022-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="变量基础知识"><a href="#变量基础知识" class="headerlink" title="变量基础知识"></a>变量基础知识</h1><p>回顾一下前面两章提到的变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract DataTypes &#123;</span><br><span class="line">    string public myString = &quot;hello world&quot;;</span><br><span class="line">    bool public b = true;</span><br><span class="line">    uint256 public u = 123;</span><br><span class="line"></span><br><span class="line">    int256 public i = -123;</span><br><span class="line">    int256 public minInt = type(int256).min; // 获取最小值</span><br><span class="line">    int256 public maxInt = type(int256).max; // 获取最大值</span><br><span class="line">    address public ads = 0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac;</span><br><span class="line">    bytes32 public bys32 = &quot;abc&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-1-初始默认值"><a href="#1-1-初始默认值" class="headerlink" title="1.1 初始默认值"></a>1.1 初始默认值</h2><p><strong>Solidity 是一种静态类型语言</strong>，这意味着需要在声明期间指定变量类型。</p>
<p>在 Solidity 中没有 null 或者 undefined 的概念，但是新声明的变量总是有一个默认值，具体的默认值跟类型相关，比如 int 类型的默认值为 0。每个变量声明时，都有一个基于其类型的默认值。</p>
<h4 id="默认值总结"><a href="#默认值总结" class="headerlink" title="默认值总结"></a>默认值总结</h4><ul>
<li>string: <code>&quot;&quot;</code></li>
<li>bool: <code>false</code></li>
<li>int256: <code>0</code></li>
<li>uint256: <code>0</code></li>
<li>address: <code>0x0000000000000000000000000000000000000000</code></li>
<li>bytes32: <code>0x0000000000000000000000000000000000000000000000000000000000000000</code></li>
<li>enum: <code>0</code></li>
<li>动态数组: <code>[]</code></li>
<li>定长数组: 每个元素的默认值</li>
<li><code>mapping</code> &#x2F; <code>strucr</code> 均为所在类型的默认值</li>
</ul>
<h2 id="1-2-作用域和声明"><a href="#1-2-作用域和声明" class="headerlink" title="1.2 作用域和声明"></a>1.2 作用域和声明</h2><p>Solidity 中的作用域规则遵循了 C99：</p>
<h3 id="1-2-1-作用域的规则"><a href="#1-2-1-作用域的规则" class="headerlink" title="1.2.1 作用域的规则"></a>1.2.1 作用域的规则</h3><ul>
<li>变量将会从它们被声明之后可见，直到一对 <code>&#123;&#125;</code> 块的结束。</li>
<li>对于参数形式的变量（例如：函数参数、修饰器参数、catch 参数等等）在其后接着的代码块内有效。<ul>
<li>这些代码块是函数的实现，catch 语句块等。</li>
<li>有一个例外，在 for 循环语句中初始化的变量，其可见性仅维持到 <code>for</code> 循环的结束。</li>
</ul>
</li>
<li>那些定义在代码块之外的变量，比如函数、合约、自定义类型等等，并不会影响它们的作用域特性。<ul>
<li>意味着你可以在实际声明状态变量的语句之前就使用它们，并且递归地调用函数。</li>
</ul>
</li>
</ul>
<p>在 Solidity 中，如果在内部作用域中使用和外层相同的变量名，会收到警告信息。这种警告是告诉开发者<code>外层声明的变量被“覆盖”</code>了，谨慎检查下是不是期望的。</p>
<p>上面例子中的 f 函数的 return 值 可以改写为下面的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f() public pure returns (uint256 x) &#123;</span><br><span class="line">    x = 1;</span><br><span class="line">    &#123;</span><br><span class="line">        x = 2;</span><br><span class="line">        uint256 x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-必须先声明再赋值"><a href="#1-2-2-必须先声明再赋值" class="headerlink" title="1.2.2 必须先声明再赋值"></a>1.2.2 必须先声明再赋值</h3><p>在 Solidity 现在的版本中，变量必须先声明再赋值，顺序不能倒。</p>
<p>0.5.0 版本之前，一个变量声明在函数的任意位置，都可以使他在整个函数范围内可见。从 0.5.0 版本开始以后就不能这样了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    // ✅</span><br><span class="line">    function t() public pure returns (uint256) &#123;</span><br><span class="line">        uint256 x;</span><br><span class="line">        x = 2;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ❌</span><br><span class="line">    function f() public pure returns (uint256) &#123;</span><br><span class="line">        // DeclarationError: Undeclared identifier.</span><br><span class="line">        // &quot;x&quot; is not (or not yet) visible at this point.</span><br><span class="line">        x = 2;</span><br><span class="line">        uint256 x;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-合约外定义的类型和函数"><a href="#1-2-3-合约外定义的类型和函数" class="headerlink" title="1.2.3 合约外定义的类型和函数"></a>1.2.3 合约外定义的类型和函数</h3><ul>
<li>合约外面可以定义函数和数据结构<ul>
<li>定义在合约外面的函数，叫自由函数</li>
<li>定义在合约外面的类型，可以被多个合约使用</li>
</ul>
</li>
<li>不可以定义变量<ul>
<li>但是可以定义常量，常量那一节有介绍</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 结构:</span><br><span class="line">//      定义在合约外面</span><br><span class="line">//      可以被多个合约同时使用</span><br><span class="line">struct Book &#123;</span><br><span class="line">    string title;</span><br><span class="line">    string author;</span><br><span class="line">    uint256 book_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 自由函数:</span><br><span class="line">//      定义在合约外面</span><br><span class="line">//      没有可见性</span><br><span class="line">function getBalance() view returns (uint256) &#123;</span><br><span class="line">    return address(msg.sender).balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function add(uint256 a_, uint256 b_) pure returns (uint256) &#123;</span><br><span class="line">    return a_+b_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Demo1 &#123;</span><br><span class="line">    Book public book1 = Book(&quot;Solidity&quot;, &quot;Anbang&quot;, 1);</span><br><span class="line">    function f() public view returns (uint256) &#123;</span><br><span class="line">        return getBalance();</span><br><span class="line">    &#125;</span><br><span class="line">    function test() public pure returns (uint256) &#123;</span><br><span class="line">        return add(100,200);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Demo2 &#123;</span><br><span class="line">    Book public book2 = Book(&quot;Solidity 2&quot;, &quot;Anbang&quot;, 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-变量的三种状态"><a href="#1-3-变量的三种状态" class="headerlink" title="1.3 变量的三种状态"></a>1.3 变量的三种状态</h2><p>按作用域划分，状态可以分为下面三种状态：</p>
<ul>
<li>状态变量:<ul>
<li>变量值永久保存在智能合约存储空间中，相当于属于已经写入到区块链中，可以随时调用，除非该条链消失。</li>
<li>特点:定义在智能合约的存储空间中</li>
</ul>
</li>
<li>局部变量:<ul>
<li>变量值仅在函数执行过程中有效,供函数内部使用；调用函数时，在虚拟机的内存中；函数退出后，变量无效。类似”闭包”的特性。</li>
<li>特点: 定义在函数内部</li>
</ul>
</li>
<li>全局变量:<ul>
<li>保存在全局命名空间，用于获取区块链相关信息的特殊变量。</li>
<li>特点:存在于 EVM 虚拟机中，不用定义，直接获取即可。</li>
</ul>
</li>
</ul>
<h3 id="1-3-1-状态变量"><a href="#1-3-1-状态变量" class="headerlink" title="1.3.1 状态变量"></a>1.3.1 状态变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Var&#123;</span><br><span class="line">    uint256 public myUint = 123;</span><br><span class="line">    function changeMyUint (uint256 x) external returns (uint256 )&#123;</span><br><span class="line">        myUint = x;</span><br><span class="line">        return myUint;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-局部变量"><a href="#1-3-2-局部变量" class="headerlink" title="1.3.2 局部变量"></a>1.3.2 局部变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Var&#123;</span><br><span class="line">     function test() external pure returns (uint256)&#123;</span><br><span class="line">        uint256 local = 2;// 局部变量</span><br><span class="line">        return local;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-全局变量"><a href="#1-3-3-全局变量" class="headerlink" title="1.3.3 全局变量"></a>1.3.3 全局变量</h3><ul>
<li><code>msg.sender</code></li>
<li><code>msg.value</code></li>
<li><code>block.timestamp</code></li>
<li><code>block.number</code></li>
</ul>
<p>先简单了解下，后面会有一节进行详细介绍。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line">contract Demo1 &#123;</span><br><span class="line">    address public owner = msg.sender; // 在状态变量中使用</span><br><span class="line"></span><br><span class="line">    // 在函数内使用</span><br><span class="line">    function global() external view returns(address,uint256,uint256)&#123;</span><br><span class="line">        return(msg.sender,block.timestamp,block.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Constant-常量"><a href="#Constant-常量" class="headerlink" title="Constant 常量"></a>Constant 常量</h1><ul>
<li>普通变量与常量:普通的状态变量，添加 <code>constant</code> 关键词即可声明为常量</li>
<li>与常规状态变量相比，<strong>常量的 gas 要低很多</strong>。</li>
<li>常量名字一般使用<strong>全大写</strong>。</li>
<li>常量<strong>赋值后不可以修改</strong>。</li>
<li>常量必须<strong>声明和初始化一起完成</strong>，否则编译不通过。</li>
<li>常量的值储存原理<ul>
<li>常量的值在编译器确定，因为在编译器确定，所以<strong>不能定义在函数内</strong>。</li>
<li>编译器并不会为 <code>constant</code> 常量在 <code>storage</code> 上预留空间，它们的每次出现都会被替换为相应的常量表达式（它可能被优化器计算为实际的某个值）。</li>
<li>因为不是储存在<code>storage</code> 上，所以函数内读取常量不算<code>view</code>，可以使用 pure</li>
<li>因为不是储存在<code>storage</code> 上，所以可以在任意位置定义常量，比如在合约外面</li>
<li>也可以在文件级别定义 constant 变量（0.7.2 之后的特性）。</li>
</ul>
</li>
<li>引用类型只支持字符串<ul>
<li>不是所有的类型都支持常量，当前支持的仅有<strong>值类型（包括地址类型）&#x2F;字符串&#x2F;bytes</strong>。</li>
</ul>
</li>
<li>可以使用内建函数赋值常量</li>
</ul>
<h2 id="2-1-常见的赋值方式"><a href="#2-1-常见的赋值方式" class="headerlink" title="2.1 常见的赋值方式"></a>2.1 常见的赋值方式</h2><p>如果状态变量声明为 <code>constant</code>(常量)。在这种情况下，只能使用那些在编译时有确定值的表达式来给它们赋值。</p>
<ul>
<li>允许可能对内存分配产生 side effect（副作用）的表达式，但那些可能对其他内存对象产生副作用的表达式则不允许。<ul>
<li>内建（built-in）函数 <code>keccak256</code> ， <code>sha256</code> ， <code>ripemd160</code> ，<code>ecrecover</code> ， <code>addmod</code> 和 <code>mulmod</code>是允许的（即使他们确实会调用外部合约， <code>keccak256</code> 除外）。</li>
<li>允许内存分配器的副作用的原因是它可以构造复杂的对象，例如：查找表（lookup-table）。 此功能尚不完全可用。</li>
</ul>
</li>
</ul>
<h3 id="2-1-1-运算符赋值"><a href="#2-1-1-运算符赋值" class="headerlink" title="2.1.1 运算符赋值"></a>2.1.1 运算符赋值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo1 &#123;</span><br><span class="line">    uint256 public constant VERSION = 1+1;</span><br><span class="line"></span><br><span class="line">    // 100个ETH</span><br><span class="line">    // 100000000000000000000</span><br><span class="line">    uint256 public  constant VALUE = 100 * 10**18; // 运算符赋值</span><br><span class="line"></span><br><span class="line">    // 1小时</span><br><span class="line">    uint256 public  constant H = 60 * 60;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-密码学函数赋值"><a href="#2-1-2-密码学函数赋值" class="headerlink" title="2.1.2 密码学函数赋值"></a>2.1.2 密码学函数赋值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 public constant a = addmod(4, 5, 3);</span><br><span class="line">    uint256 public constant b = mulmod(4, 5, 3);</span><br><span class="line">    bytes32 public constant c1 = sha256(&quot;Hello&quot;);</span><br><span class="line">    bytes32 public constant c2 = ripemd160(&quot;Hello&quot;);</span><br><span class="line">    bytes32 public constant myBytes32 = keccak256(&quot;Hello&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-3-禁止的一些赋值"><a href="#2-1-3-禁止的一些赋值" class="headerlink" title="2.1.3  禁止的一些赋值"></a>2.1.3  禁止的一些赋值</h3><p>不允许使用状态变量&#x2F;区块链数据来赋值，也不允许外部合约调用来赋值。</p>
<p>任何通过访问 storage，区块链数据（例如 <code>block.timestamp</code>,<code>address(this).balance</code> 或者 <code>block.number</code>）或执行数据（ <code>msg.value</code> 或<code>gasleft()</code> ） 或对外部合约的调用来给它们赋值都是不允许的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    address public ads1 = msg.sender;</span><br><span class="line">    // address public constant ads2 = msg.sender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Immutable-不可变量"><a href="#Immutable-不可变量" class="headerlink" title="Immutable 不可变量"></a>Immutable 不可变量</h1><p>上一节我们学习了常量，常量的值是在编译器确定，因为在编译器确定，常量必须声明和初始化一起做掉，否则编译不通过。这就给很多只需要一次赋值，但是又必须需要动态赋值的场景带来了不变。比如合约的 owner 地址等场景。</p>
<p>然后上面的苦恼，可以通过不可变量来解决。如果我们想要一个变量，赋值后就不可以修改，而且值是部署时候动态赋值，那么可以使用不可变量的类型。通过 <code>immutable</code> 关键字可以声明为不可变量，不可变量的限制要比声明为常量(<code>constant</code>) 的变量的限制少：</p>
<p>不可变量<strong>可以声明和赋值一起做掉，也可以 storage 中声明</strong>，在合约的构造函数中赋值。无论在哪里赋值，只能赋值一次，也带来更多的安全性。</p>
<ul>
<li><p>原理: 在部署的时候确定变量的值，它是一个运行时赋值。</p>
</li>
<li><p>特点:它既有 constant 常量不可修改和 Gas 费用低的优势，又有变量动态赋值的优势。</p>
</li>
<li><p>原则:</p>
<ul>
<li><code>immutable</code> 可以声明和初始化一起做掉，也可以部署时在<code>constructor</code>中做掉。</li>
<li><code>immutable</code> 必须在<code>constructor</code>运行截止时就赋值</li>
<li><code>immutable</code>不能用在引用数据类型上</li>
</ul>
</li>
</ul>
<h2 id="3-1-部署后不可以修改"><a href="#3-1-部署后不可以修改" class="headerlink" title="3.1 部署后不可以修改"></a>3.1 部署后不可以修改</h2><p>注意点：不可变量只能赋值一次，以后就不能再次改变了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    address public immutable adsImmut;</span><br><span class="line">    address public immutable ads = address(0);</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        adsImmut = msg.sender;</span><br><span class="line"></span><br><span class="line">        // Immutable state variable already initialized.</span><br><span class="line">        // ads = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // immutable 部署后不可以修改，如果尝试修改immutable类型变量，会报错</span><br><span class="line">    // Cannot write to immutable here: Immutable variables can only</span><br><span class="line">    // be initialized inline or assigned directly in the constructor.</span><br><span class="line">    // function changeImmutable() external &#123;</span><br><span class="line">    //     adsImmut = msg.sender;</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-不可以在赋值前读取"><a href="#3-2-不可以在赋值前读取" class="headerlink" title="3.2 不可以在赋值前读取"></a>3.2 不可以在赋值前读取</h2><p>并且在赋值之后才可以读取 immutable 变量，如果赋值之前读取会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    address public immutable adsImmut;</span><br><span class="line">    address public ads;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        // Immutable variables cannot be read before they are initialized.</span><br><span class="line">        // ads = adsImmut;</span><br><span class="line"></span><br><span class="line">        adsImmut = msg.sender;</span><br><span class="line">        ads = adsImmut;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-不可以在-constructor-之外赋值其他不可变量"><a href="#3-3-不可以在-constructor-之外赋值其他不可变量" class="headerlink" title="3.3 不可以在 constructor 之外赋值其他不可变量"></a>3.3 不可以在 <code>constructor</code> 之外赋值其他不可变量</h2><p>不可变量可以在声明时赋值，不过只有在合约的构造函数执行时才被视为视为初始化。这意味着，你不能用一个依赖于不可变量的值初始化另一个不可变量。</p>
<p>因为不可变量在构造函数中才真正赋值，所以在合约的构造函数中这样做。这样的机制是为了防止对状态变量初始化和构造函数顺序的不同解释，特别是继承时，出现问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint256 public a1 = 1;</span><br><span class="line">    uint256 public a2 = a1;</span><br><span class="line"></span><br><span class="line">    uint256 public immutable b1 = 1;</span><br><span class="line">    // Immutable variables cannot be read before they are initialized.</span><br><span class="line">    // uint256 public b2 = b1;</span><br><span class="line">    uint256 public b2;</span><br><span class="line"></span><br><span class="line">    uint256 public immutable b3;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        b2 = b1;</span><br><span class="line">        b3 = b1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心：在部署的时候确定变量的值，它是一个运行时赋值。</p>
<h2 id="3-4constant-和-immutable-总结"><a href="#3-4constant-和-immutable-总结" class="headerlink" title="3.4constant 和 immutable 总结"></a>3.4constant 和 immutable 总结</h2><h4 id="值的确定时机不同"><a href="#值的确定时机不同" class="headerlink" title="值的确定时机不同"></a>值的确定时机不同</h4><p>状态变量声明为 constant (常量)或者 immutable （不可变量），在这两种情况下，合约一旦部署之后，变量将不在修改。</p>
<ul>
<li>对于 constant 常量, 他的值在编译器确定.</li>
<li>对于 immutable, 它的值在部署时确定。</li>
</ul>
<h4 id="gas-不同"><a href="#gas-不同" class="headerlink" title="gas 不同"></a>gas 不同</h4><p>与常规状态变量相比，常量和不可变量的 gas 成本要低得多。</p>
<ul>
<li>对于常量，赋值给它的表达式将复制到所有访问该常量的位置，并且每次都会对其进行重新求值。这样可以进行本地优化。</li>
<li>不可变变量在构造时进行一次求值，并将其值复制到代码中访问它们的所有位置。 对于这些值，将保留 32 个字节，即使它们适合较少的字节也是如此。很多时候常量的 gas 更低。</li>
</ul>
<p>如果可以使用常量的时候，推荐使用常量。</p>
<h4 id="支持的数据不同"><a href="#支持的数据不同" class="headerlink" title="支持的数据不同"></a>支持的数据不同</h4><p>不是所有类型的状态变量都支持用 <code>constant</code> 或 <code>immutable</code> 来修饰</p>
<ul>
<li>当前<code>constant</code>仅支持值类型和引用类型中的 string 和 bytes</li>
<li><code>immutable</code>仅支持值类型</li>
</ul>
<h1 id="变量名的命名规则"><a href="#变量名的命名规则" class="headerlink" title="变量名的命名规则"></a>变量名的命名规则</h1><p>在为变量命名时，请记住以下规则：</p>
<ul>
<li>禁止使用<strong>保留关键字</strong>作为变量名。</li>
<li>变量名首字母禁止使用数字，必须以字母或下划线开头。</li>
<li>变量名大小写敏感。</li>
</ul>
<h3 id="1-禁止使用保留关键字作为变量名"><a href="#1-禁止使用保留关键字作为变量名" class="headerlink" title="1.禁止使用保留关键字作为变量名"></a>1.禁止使用<strong>保留关键字</strong>作为变量名</h3><p>禁止使用<strong>保留关键字</strong>作为变量名。例如：<code>break</code> &#x2F; <code>boolean</code> &#x2F; <code>contract</code> 这些是无效的变量名。</p>
<ul>
<li>abstract</li>
<li>after</li>
<li>alias</li>
<li>apply</li>
<li>auto</li>
<li>case</li>
<li>catch</li>
<li>copyof</li>
<li>default</li>
<li>define</li>
<li>final</li>
<li>immutable</li>
<li>implements</li>
<li>in</li>
<li>inline</li>
<li>let</li>
<li>macro</li>
<li>match</li>
<li>mutable</li>
<li>null</li>
<li>of</li>
<li>override</li>
<li>partial</li>
<li>promise</li>
<li>reference</li>
<li>relocatable</li>
<li>sealed</li>
<li>sizeof</li>
<li>static</li>
<li>supports</li>
<li>switch</li>
<li>try</li>
<li>typedef</li>
<li>typeof</li>
<li>unchecked</li>
</ul>
<h3 id="2-变量名必须以字母或者下划线开头"><a href="#2-变量名必须以字母或者下划线开头" class="headerlink" title="2.变量名必须以字母或者下划线开头"></a>2.变量名必须以字母或者下划线开头</h3><p>禁止使用数字作为变量名的开始，例如：<code>123abc</code> 是一个无效的变量名，但是 <code>_123abc</code> 是一个有效的变量名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint8 public abc = 1;</span><br><span class="line">    uint8 public _123abc = 1;</span><br><span class="line"></span><br><span class="line">    // Expected identifier but got &#x27;ILLEGAL&#x27;</span><br><span class="line">    uint8 public 123abc = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-变量名大小写敏感"><a href="#3-变量名大小写敏感" class="headerlink" title="3.变量名大小写敏感"></a>3.变量名大小写敏感</h3><p>例如：Name 和 name 是两个不同的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    string public name = &quot;Anbang&quot;;</span><br><span class="line">    string public constant Name = &quot;Anbang&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="变量的可见性"><a href="#变量的可见性" class="headerlink" title="变量的可见性"></a>变量的可见性</h1><p>可见性仅存在于状态变量和函数中</p>
<ul>
<li>局部变量的可见性仅限于定义它们的函数，函数有四可见型，分别是 <code>private</code> &#x2F; <code>external</code> &#x2F; <code>internal</code> &#x2F; <code>public</code></li>
<li>状态变量可以有三种可见型，分别是 <code>private</code> &#x2F; <code>internal</code> &#x2F; <code>public</code></li>
</ul>
<p>我们这里重点介绍状态变量可见型。</p>
<p>internal 和 private 类型的变量不能被外部访问，而 public 变量能够被外部访问。</p>
<p>警告: 设置为 <code>private</code>或 <code>internal</code>，只能防止其他合约读取或修改信息，但它仍然可以在链外查看到。你不要想着通过设置可见型，让别人看不到你的代码。反编译可以得到大部分需要的逻辑。</p>
<h2 id="5-1-private"><a href="#5-1-private" class="headerlink" title="5.1 private"></a>5.1 private</h2><p><strong>private</strong>: 私有，仅在当前合约中可以访问</p>
<p>在继承的合约内不可访问，私有状态变量就像内部变量一样，但它们在派生合约中是不可见的。</p>
<h2 id="5-2-internal-默认"><a href="#5-2-internal-默认" class="headerlink" title="5.2 internal(默认)"></a>5.2 internal(默认)</h2><p><strong>internal</strong>: 内部可视(合约内部和被继承的子合约中都可视)</p>
<ul>
<li>状态变量如果不显示声明，<strong>默认是 internal 权限</strong></li>
<li>内部可见性状态变量只能在它们所定义的合约和派生合同中访问。 它们不能被外部访问。 这是状态变量的默认可见性。</li>
</ul>
<h2 id="5-3-external"><a href="#5-3-external" class="headerlink" title="5.3 external"></a>5.3 external</h2><p><strong>external</strong>: 外部可视(合约外部可视，在内部是不可见)</p>
<p><strong><code>external</code> 不能声明在状态变量上，只能标识在函数上</strong>,因为如果一个状态变量在合约自身如果没有办法读取的话，那就没有存在的必要了。</p>
<h2 id="5-4-public"><a href="#5-4-public" class="headerlink" title="5.4 public"></a>5.4 public</h2><p><strong>public</strong>: 公开可视(合约内部，被继承的，外部都可以调用)</p>
<h1 id="全局：时间单位"><a href="#全局：时间单位" class="headerlink" title="全局：时间单位"></a>全局：时间单位</h1><p>在做时间相关业务时候可以使用 分钟，小时，天，周的概念。</p>
<h2 id="6-1-基本用法"><a href="#6-1-基本用法" class="headerlink" title="6.1 基本用法"></a>6.1 基本用法</h2><p>秒是缺省时间单位,可以不写，在时间单位之间，数字后面带有 <code>seconds</code>、 <code>minutes</code>、 <code>hours</code>、 <code>days</code>、 <code>weeks</code> 可以进行换算，基本换算关系如下：</p>
<ul>
<li><code>1 == 1 seconds</code></li>
<li><code>1 minutes == 60 seconds</code></li>
<li><code>1 hours == 60 minutes</code></li>
<li><code>1 days == 24 hours</code></li>
<li><code>1 weeks == 7 days</code></li>
</ul>
<h2 id="6-2-两种时间逻辑"><a href="#6-2-两种时间逻辑" class="headerlink" title="6.2 两种时间逻辑"></a>6.2 两种时间逻辑</h2><p>注意：由于闰年造成的每年不都是 365 天、每天不都是 24 小时，所以<strong>如果你要使用这些单位计算日期和时间</strong>，请注意这个问题。因为是无法预测的，所以需要借助外部的预言机来对一个确定的日期代码库进行时间矫正。</p>
<p>时间在项目中有两种逻辑</p>
<ol>
<li>像之前众筹合约里介绍的那样，使用持续时间来代表时间。比如持续 2 两小时结束，常见于众筹&#x2F;拍卖合约</li>
<li>到某个时间点开始抢购活动，比如到 XX 年 XX 月 XX 日 XX 分 XX 秒，开启抢购，这种需要借助预言机才能正确完成</li>
</ol>
<p>请按照自己的业务需求选择合适的时间方式。</p>
<h1 id="全局：区块和交易属性"><a href="#全局：区块和交易属性" class="headerlink" title="全局：区块和交易属性"></a>全局：区块和交易属性</h1><p>分别是 <code>block</code> &#x2F; <code>msg</code> &#x2F; <code>tx</code> 三个全局变量，因为功能相似，我们把 <code>blockhash()</code> 和 <code>gasleft()</code> 这两个全局函数也一起介绍。</p>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><table>
<thead>
<tr>
<th>名称 (返回值)</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td>block.basefee (uint256)</td>
<td>当前区块的基本费用（ <a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-3198">EIP-3198</a> 和 <a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559</a>）</td>
</tr>
<tr>
<td>block.chainid (uint256)</td>
<td>当前链 id</td>
</tr>
<tr>
<td>block.difficulty (uint256)</td>
<td>当前区块的难度</td>
</tr>
<tr>
<td>block.gaslimit (uint256)</td>
<td>当前区块的 gaslimit</td>
</tr>
<tr>
<td>block.number (uint256)</td>
<td>当前区块的 number</td>
</tr>
<tr>
<td>block.timestamp (uint256)</td>
<td>当前区块的时间戳，为 unix 纪元以来的秒</td>
</tr>
<tr>
<td>block.coinbase (address payable)</td>
<td>当前区块矿工的地址</td>
</tr>
<tr>
<td>msg.sender (address)</td>
<td>消息发送者 (当前 caller)</td>
</tr>
<tr>
<td>msg.value (uint256)</td>
<td>当前消息的 wei 值</td>
</tr>
<tr>
<td>msg.data (bytes calldata)</td>
<td>完整的 calldata</td>
</tr>
<tr>
<td>msg.sig (bytes4)</td>
<td>calldata 的前四个字节 – (function identifier&#x2F;即函数标识符)</td>
</tr>
<tr>
<td>tx.gasprice (uint256)</td>
<td>交易的 gas 价格</td>
</tr>
<tr>
<td>tx.origin (address)</td>
<td>交易的发送方 （完整的调用链）</td>
</tr>
<tr>
<td>blockhash(uint256 blockNumber) returns (bytes32)</td>
<td>给定区块的哈希值 – 只适用于 256 最近区块, 不包含当前区块</td>
</tr>
<tr>
<td>gasleft() returns (uint256)</td>
<td>剩余 gas</td>
</tr>
<tr>
<td>blockhash() 获取给定区块的哈希值</td>
<td>给定区块的哈希值;在 0.5.0 版本中删除,现使用<code>blockhash()</code>获取</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/06/15/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/02-%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/15/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/02-%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">02-数据</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-15 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-15T00:00:00+08:00">2022-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>53k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>48 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据与变量"><a href="#数据与变量" class="headerlink" title="数据与变量"></a>数据与变量</h1><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>如果上面 <code>uint256 u = 123;</code> 改为 <code>uint256 u = &quot;Hello&quot;;</code>，将会收到错误 <code>Type literal_string &quot;Hello&quot; is not implicitly convertible to expected type uint256.</code>，因为这两种类型不能隐式转换的；</p>
<p>如果上面 <code>uint256 u = 123;</code> 改为 <code>uint256 u = uint8(123);</code>，就不会有问题，因为<code>uint8</code>类型可以隐式转换为<code>uint256</code>类型。后面介绍类型转换的时候会详细的介绍。</p>
<h1 id="两种类型的数据"><a href="#两种类型的数据" class="headerlink" title="两种类型的数据"></a>两种类型的数据</h1><p>Solidity 按照数据类型可以分为<strong>值类型</strong>和<strong>引用类型</strong>。</p>
<ul>
<li>值类型: 值类型传值时会将值拷贝一份，传递的是值本身，对其修改时并不会对原来值有影响。<ul>
<li>始终按值来传递，当被用作函数参数或者用在赋值语句中时，总会进行值拷贝。</li>
<li>值类型里有两个比较特殊的类型是函数和地址（包括合约），会分为单独的部分介绍。</li>
</ul>
</li>
<li>引用类型: 引用类型进行传递时，传递的是其指针，而引用类型进行传递时<strong>可以为值传递</strong>，<strong>也可以为引用传递</strong>。</li>
</ul>
<h1 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h1><ol>
<li>Boolean</li>
<li>Integer:uint&#x2F;int</li>
<li>定长字节数组(固定大小字节数组):bytes1-bytes32</li>
<li>Enum:枚举</li>
<li>地址（Address）</li>
<li>合约类型</li>
<li>函数（Function Types）</li>
</ol>
<h2 id="3-1-Boolean-布尔类型"><a href="#3-1-Boolean-布尔类型" class="headerlink" title="3.1 Boolean 布尔类型"></a>3.1 Boolean 布尔类型</h2><p>布尔型使用 <code>bool</code>表示，该类型只有两个值，分别是 <code>true</code>&#x2F;<code>false</code>。</p>
<p>布尔值除了赋值得到外，还可以通过<strong>运算符</strong>的计算结果得到。</p>
<p>支持的运算符:<code>!</code>逻辑非，<code>==</code>等于，<code>!=</code> 不等于,<code>&amp;&amp;</code>逻辑与 ,<code>||</code>逻辑或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo2 &#123;</span><br><span class="line">    bool public a = false;</span><br><span class="line">    bool public b = !a; // 仅用于布尔值</span><br><span class="line">    bool public c = a == b;</span><br><span class="line">    bool public d = a != b;</span><br><span class="line">    bool public e = a &amp;&amp; b;</span><br><span class="line">    bool public f = a || b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运算符 <code>||</code> 和 <code>&amp;&amp;</code> 都遵循同样的短路（ short-circuiting ）规则。就是说在表达式 <code>f(x) || g(y)</code> 中， 如果 <code>f(x)</code> 的值为 true ，那么 <code>g(y)</code> 就不会被执行，</p>
<h3 id="3-1-1-使用短路规则节省-gas"><a href="#3-1-1-使用短路规则节省-gas" class="headerlink" title="3.1.1 使用短路规则节省 gas"></a>3.1.1 使用短路规则节省 gas</h3><p>借助短路规则，可以让合约少执行一些逻辑。</p>
<ul>
<li><code>||</code> 如果第一个表达式是<code>true</code>，则第二个表达式不再执行。（因为两个表达式有一个为 true，结果就为 true，不需要计算第二个表达式就知道结果了）</li>
<li><code>&amp;&amp;</code> 如果第一个表达式是<code>false</code>，则第二个表达式不再执行。（两个表达式必须都为 true，结果才能 true，如果第一个为 false，不需要计算第二个表达式就知道结果了）</li>
</ul>
<h2 id="3-2-Integer-整数类型"><a href="#3-2-Integer-整数类型" class="headerlink" title="3.2 Integer 整数类型"></a>3.2 Integer 整数类型</h2><p>整数类型分为有符号整型，用 int 标示；和无符号整型，用 uint 标示；</p>
<ul>
<li>int 是有符号整型，支持 int8 到 int256。</li>
<li>uint 是无符号整型，支持从 uint8 到 uint256。</li>
<li><code>uint</code> 和 <code>int</code> 分别是 <code>uint256</code> 和 <code>int256</code> 的别名。</li>
</ul>
<h3 id="3-2-1-属性"><a href="#3-2-1-属性" class="headerlink" title="3.2.1 属性"></a>3.2.1 属性</h3><p>对于整型 T 有下面的全局属性可访问：</p>
<blockquote>
<p>获取整型 T 的最小值:type(T).min<br>获取整型 T 的最大值:type(T).max</p>
</blockquote>
<h3 id="3-2-2-uint-类型"><a href="#3-2-2-uint-类型" class="headerlink" title="3.2.2 uint 类型"></a>3.2.2 uint 类型</h3><p>uint 无符号整数，只能表示非负数；<code>包括数字0</code>；其中 uint256 与 uint 相同，推荐使用 uint256；支持 int8 到 int256，后面的数字是 8 的倍数。</p>
<ul>
<li><code>uint8</code>: 最小值是 0，最大值是 <code>2**8-1</code></li>
<li><code>uint256</code>:最小值是 0，最大值是 <code>2**256-1</code></li>
<li>可以使用 <code>type(uint8).max</code> 获取该类型的最大值</li>
<li>可以使用 <code>type(uint8).min</code> 获取该类型的最小值</li>
</ul>
<h3 id="3-2-3-int-类型"><a href="#3-2-3-int-类型" class="headerlink" title="3.2.3 int 类型"></a>3.2.3 int 类型</h3><p>int 是有符号整数，其中 int256 与 int 相同，推荐使用 int256； 8 位到 256 位的带符号整型数。8 的倍数。</p>
<ul>
<li><code>int8</code>: 最小值是 <code>-128</code>，最大值是 <code>127</code></li>
<li><code>int256</code>: 最小值是 <code>-(2**256/2)</code>，最大值是 <code>(2**256/2)-1</code></li>
<li>可以使用 <code>type(int8).max</code> 获取该类型的最大值</li>
<li>可以使用 <code>type(int8).min</code> 获取该类型的最小值。</li>
</ul>
<p>计算中最小一级的信息单位是 byte 和 bit: <strong>其中字节(Byte)为最小存储容量单位</strong>，<strong>位(bit)是最小储存信息的单位,也被称为最小的数据传输单位</strong>；一个位就代表一个 0 或 1（即二进制）；每 8 个 bit(简写为 b）组成一个字节 Byte（简写为 B）；所以 <code>uint256</code> 和 <code>bytes32</code> 可以转换</p>
<ul>
<li><code>bytes1 对应 uint8</code></li>
<li><code>bytes2 对应 uint16</code></li>
<li>…</li>
<li><code>bytes32 对应 uint256</code></li>
</ul>
<h3 id="3-2-4-checked-模式"><a href="#3-2-4-checked-模式" class="headerlink" title="3.2.4 checked 模式"></a>3.2.4 checked 模式</h3><p>⚠️: 在 Solidity 之前的版本中，当对无限制整数执行算术运算，其结果超出结果类型的范围，这是就发生了上溢出或下溢出。在 Solidity 0.8.0 之前，算术运算总是会在发生溢出的情况下进行“截断”，而不是抛出异常。这就会导致一些麻烦的事情，可能导致未知的错误，所以我们不得不靠引入额外检查库来解决这个问题（最常见的如 OpenZepplin 的 SafeMath）</p>
<p>而从 <code>Solidity 0.8.0</code> 开始，所有的算术运算默认就会进行溢出检查，额外引入库将不再必要。0.8.0 开始，算术运算有两种计算模式：一种是<code>checked</code>（检查）模式，另一种是 <code>unchecked</code>（不检查）模式。</p>
<p>默认情况下，算术运算在 <code>checked</code> 模式下，即都会进行溢出检查，如果结果落在取值范围之外，调用会通过 失败异常 回退。</p>
<h3 id="3-2-5-unchecked-非检查模式"><a href="#3-2-5-unchecked-非检查模式" class="headerlink" title="3.2.5 unchecked 非检查模式"></a>3.2.5 unchecked 非检查模式</h3><p>如果依然想要之前“截断”的效果，而不是抛出异常错误，那么可以使用 <code>unchecked&#123;&#125;</code> 代码块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 public a = type(uint256).max;</span><br><span class="line">    uint8 public b = 1;</span><br><span class="line"></span><br><span class="line">    function f1() public view returns (uint256) &#123;</span><br><span class="line">        // 减法溢出会返回“截断”的结果</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f2() public view returns (uint256) &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return a + 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g() public view returns (uint256) &#123;</span><br><span class="line">        // 溢出会抛出异常</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>g()</code> 会触发失败异常， 调用 <code>f1()/f2()</code> 分别是截断效果,</p>
<p>⚠️: <code>unchecked</code> 代码块可以在代码块中的任何位置使用，但不可以替代整个函数代码块，同样不可以嵌套。切此设置仅影响语法上位于 <code>unchecked</code> 块内的语句。 在块中调用的函数不会此影响。</p>
<p>⚠️: 为避免歧义，不能在 unchecked 块中使用 <code>_;</code>, 该表示方法仅用于函数修改器。</p>
<blockquote>
<p> 触发溢出检查的运算符:++<code>, </code>–<code>, </code>+<code>, </code>减 -<code>, </code>负 -<code>, </code><em><code>, </code>&#x2F;<code>, </code>%<code>, </code>**, +&#x3D;<code>,</code>-&#x3D;<code>, </code></em>&#x3D;<code>, </code>&#x2F;&#x3D;<code>, </code>%&#x3D;</p>
</blockquote>
<blockquote>
<p> 除 <code>0</code>（或<code>除 0取模</code>）的异常是不能被 <code>unchecked</code> 忽略的。会发生 <code>Panic</code> 错误。</p>
</blockquote>
<blockquote>
<p> 位运算不会执行上溢或下溢检查</p>
</blockquote>
<blockquote>
<p> -int 值需要注意:因为负数的范围比正整数的范围大 1。</p>
</blockquote>
<h2 id="3-3-Integer-整数字面常量"><a href="#3-3-Integer-整数字面常量" class="headerlink" title="3.3 Integer 整数字面常量"></a>3.3 Integer 整数字面常量</h2><h3 id="3-3-1-常量中用-增加可读性"><a href="#3-3-1-常量中用-增加可读性" class="headerlink" title="3.3.1 常量中用_增加可读性"></a>3.3.1 常量中用<code>_</code>增加可读性</h3><p>为了提高可读性可以在数字之间加上下划线。 例如，十进制 <code>123_000</code>，十六进制 <code>0x2eff_abde</code>，科学十进制表示 <code>1_2e12</code> 都是有效的。</p>
<p>需要注意以下几点：</p>
<ul>
<li>下划线仅允许在两位数之间，并且不允许下划线连续出现。</li>
<li>添加到数字文字中下划线没有额外的语义，仅仅只是为了可读性.</li>
<li>下划线会被编译器忽略。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo&#123;</span><br><span class="line">    uint public count1 = 123_456_789; // 23503 gas</span><br><span class="line">    uint public count2 = 123_456_789; // 23493 gas</span><br><span class="line">    uint public count3 = 123456789; // 23537 gas</span><br><span class="line">    int public count4 = -123456789; // 23559 gas</span><br><span class="line">    int public count5 = -123_456_789; // 23471 gas</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过测试发现，带有<code>_</code>数字的变量，读取时候花费 gas 更少</p>
<h3 id="3-3-2-字面常量支持任意精度"><a href="#3-3-2-字面常量支持任意精度" class="headerlink" title="3.3.2 字面常量支持任意精度"></a>3.3.2 字面常量支持任意精度</h3><p>数值字面常量表达式本身支持任意精度，直到被转换成了非常量类型（例如，在常量变量表达式之外有运算，或发生了显示转换）。 这意味着在数值常量表达式中, 计算不会溢出而除法也不会截断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint8 public a = (2**800 + 1) - 2**800;</span><br><span class="line">    uint8 public b = 0.5 * 8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>(2**800 + 1) - 2**800</code> 的结果是字面常量 1 （属于 uint8 类型），尽管计算的中间结果已经超过了 以太坊虚拟机的机器字长度。 此外， <code>0.5 * 8</code> 的结果是整型 <code>4</code> （尽管有非整型参与了计算）。</p>
<p>⚠️: 数 值字面常量表达式只要在非字面常量表达式中使用就会转换成非字面常量类型。 在下面的例子中，尽管我们知道 b 的值是一个整数，但 <code>2.5 + a</code> 这部分表达式并不进行类型检查，因此编译不能通过。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint128 a = 1;</span><br><span class="line">uint128 b = 2.5 + a + 0.5;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3-除法截断"><a href="#3-3-3-除法截断" class="headerlink" title="3.3.3 除法截断"></a>3.3.3 除法截断</h3><p>注意除法截断: 在智能合约中，在 字面常量 会保留精度（保留小数位）。</p>
<p>整数的除法会被截断（例如：<code>1/4</code> 结果为 0）,但是使用字面量的方式不会被截断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract IntegerTest &#123;</span><br><span class="line">    function test1() public pure returns (uint256, uint256) &#123;</span><br><span class="line">        uint256 a = 1;</span><br><span class="line">        uint256 b = 4;</span><br><span class="line">        uint256 c1 = (1 / 4) * 4; // 1 =&gt; 未截断</span><br><span class="line">        uint256 c2 = (a / b) * b; // 0 =&gt; 截断</span><br><span class="line">        return (c1, c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释: 表达式 <code>type(int).min / (-1)</code> 是仅有的整除会发生向上溢出的情况。 在算术检查模式下，这会触发一个失败异常，在截断模式下，表达式的值将是 <code>type(int).min</code> 。</p>
<h3 id="3-3-4-优先使用较小类型计算"><a href="#3-3-4-优先使用较小类型计算" class="headerlink" title="3.3.4 优先使用较小类型计算"></a>3.3.4 优先使用较小类型计算</h3><p>虽然大多数运算符在字面常量运算时都会产生一个字面常量表达式，但有一些运算符并不遵循这种模式：</p>
<ul>
<li>三元运算符 <code>(... ? ... : ...)</code>,</li>
<li>数组下标访问 (<code>&lt;array&gt;[&lt;index&gt;]</code>).</li>
</ul>
<p>你可能认为像<code>255 + (true ? 1 : 0)</code> 或 <code>255 + [1, 2, 3][0]</code> 这样的表达式等同于直接使用 256 字面常量。 但事实上，它们是在 <code>uint8</code> 类型中计算的，会溢出。</p>
<h2 id="3-4-Fixed-定长浮点型"><a href="#3-4-Fixed-定长浮点型" class="headerlink" title="3.4 Fixed 定长浮点型"></a>3.4 Fixed 定长浮点型</h2><p>Solidity 还没有完全支持定长浮点型，可以声明定长浮点型的变量，但不能给它们赋值或把它们赋值给其他变量。。</p>
<p>可以通过用户定义的值类型的 wrap &#x2F; unwrap 来模拟出来，后面介绍用户自定义类型时候会介绍。</p>
<p><code>fixed / ufixed</code>：表示各种大小的有符号和无符号的定长浮点型。 在关键字 <code>ufixedMxN</code> 和 <code>fixedMxN</code> 中，<code>M</code> 表示该类型占用的位数，<code>N</code> 表示可用的小数位数。 <code>M</code> 必须能整除 8，即 8 到 256 位。 <code>N</code> 则可以是从 0 到 80 之间的任意数。</p>
<h2 id="3-5-BytesN-定长字节数组"><a href="#3-5-BytesN-定长字节数组" class="headerlink" title="3.5 BytesN 定长字节数组"></a>3.5 BytesN 定长字节数组</h2><p>定义方式 <code>bytesN</code>，其中 N 可取 <code>1~32</code> 中的任意整数;</p>
<p>bytes1 代表只能存储一个字节。</p>
<p>⚠ 注意：一旦声明，其内部的字节长度不可修改，内部字节不可修改。</p>
<p><code>bytesN</code>: 是定长的字节数组，是值类型</p>
<p><code>bytes</code>: 是变长字节数组，是引用类型。</p>
<h3 id="3-5-1-属性"><a href="#3-5-1-属性" class="headerlink" title="3.5.1 属性"></a>3.5.1 属性</h3><ul>
<li><pre><code class="solidity">length
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  （只读）返回字节个数，可以通过索引读取对应索引的字节。</span><br><span class="line"></span><br><span class="line">- 索引访问:</span><br><span class="line"></span><br><span class="line">  ```solidity</span><br><span class="line">  bytesN[index]</span><br></pre></td></tr></table></figure>

- index 取值范围`[0, N]`，其中 N 表示长度。
</code></pre>
</li>
<li><p>如果 <code>x</code> 是 <code>bytesI</code> 类型，那么 <code>x[k]</code> （其中 0 &lt;&#x3D; k &lt; I）返回第 k 个字节（只读）。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    // 固定长度的字节数组</span><br><span class="line">    bytes1 public a1 = 0x61;</span><br><span class="line">    bytes2 public a2 = 0x6100;</span><br><span class="line"></span><br><span class="line">    // length</span><br><span class="line">    uint256 public n1 = a1.length;</span><br><span class="line">    uint256 public n2 = a2.length;</span><br><span class="line"></span><br><span class="line">    // 索引</span><br><span class="line">    function getIndex(uint8 index_) public view returns(bytes1)&#123;</span><br><span class="line">        return a2[index_];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 不修可以修改,编译会报错</span><br><span class="line">    //function setIndex(uint8 index_,bytes1 value_) public view&#123;</span><br><span class="line">    //     a2[index_] = value_;</span><br><span class="line">    //&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-字符串字面常量及类型"><a href="#3-6-字符串字面常量及类型" class="headerlink" title="3.6 字符串字面常量及类型"></a>3.6 字符串字面常量及类型</h2><p>字符串字面常量只能包含可打印的 ASCII 字符，这意味着他是介于 0x20 和 0x7E 之间的字符。</p>
<p>字符串字面常量是指由双引号或单引号引起来的字符串（ <code>&quot;foo&quot;</code> 或者 <code>&#39;bar&#39;</code>）;</p>
<h3 id="3-6-1-字符串字面量"><a href="#3-6-1-字符串字面量" class="headerlink" title="3.6.1 字符串字面量"></a>3.6.1 字符串字面量</h3><p>转换: 和整数字面常量一样，字符串字面常量的类型也可以发生改变，它们可以隐式地转换成<code>bytes1</code>，……， <code>bytes32</code>，如果合适的话，还可以转换成 <code>bytes</code> 以及 <code>string</code>。</p>
<p>比如 <code>bytes1 public a8 = &quot;a&quot;;</code> 和 <code>bytes2 public b2 = &quot;a&quot;;</code>。字符串字面常量在赋值给 <code>bytesN</code> 时被解释为<strong>原始的字节形式</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    bytes1 public b1 = &quot;a&quot;;</span><br><span class="line">    string public b2 = &quot;a&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-2-转义字符"><a href="#3-6-2-转义字符" class="headerlink" title="3.6.2 转义字符"></a>3.6.2 转义字符</h3><p>但是我们写特殊字符串时候遇到一个问题，比如我想输出一个 <code>fo&quot;o</code>和<code>fo&#39;o</code> 的字符串就很难弄，因为莫认为<code>&quot;</code>和<code>&#39;</code> 是字符串的结尾。如果想要输出这种特殊的字符串，就需要转义字符了。</p>
<p>此外，字符串字面常量支持下面的转义字符：</p>
<ul>
<li><code>\&#39;</code> (单引号)</li>
<li><code>\&quot;</code> (双引号)</li>
<li><code>\\</code> (反斜杠)</li>
<li><code>\&lt;newline&gt;</code> (转义实际换行)</li>
<li><code>\b</code> (退格)</li>
<li><code>\f</code> (换页)</li>
<li><code>\n</code> (换行符)</li>
<li><code>\r</code> (回车)</li>
<li><code>\t</code> (标签 tab)</li>
<li><code>\v</code> (垂直标签)</li>
<li><code>\xNN</code> (十六进制转义，见下文)</li>
<li><code>\uNNNN</code> (unicode 转义，见下文)</li>
</ul>
<p><code>\xNN</code> 表示一个 16 进制值，最终转换成合适的字节，而 <code>\uNNNN</code> 表示 Unicode 编码值，最终会转换为 UTF-8 的序列。</p>
<p>问答题:下面字符串长度为多少字节？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    string public a1 = &quot;\n\&quot;&#x27;\\abc\def&quot;;</span><br><span class="line">    bytes32 public a2 = &quot;\n\&quot;&#x27;\\abc\def&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串长度为十个字节，它以换行符开头，后跟双引号，单引号，反斜杠字符，以及（没有分隔符）字符序列 <code>&quot;&#39;\abcdef</code> 。</p>
<h3 id="3-6-3-用空格分开的字符串"><a href="#3-6-3-用空格分开的字符串" class="headerlink" title="3.6.3 用空格分开的字符串"></a>3.6.3 用空格分开的字符串</h3><p>用空格分开的 <code>&quot;foo&quot; &quot;bar&quot;</code> 等效于 <code>&quot;foobar&quot;</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    string public a = &quot;a&quot; &quot;b&quot;;//ab</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-7-Unicode-字面常量"><a href="#3-7-Unicode-字面常量" class="headerlink" title="3.7 Unicode 字面常量"></a>3.7 Unicode 字面常量</h2><p>常规字符串文字只能包含 ASCII，而 Unicode 文字（以关键字 unicode 为前缀）可以包含任何有效的 UTF-8 序列。 它们还支持与转义序列完全相同的字符作为常规字符串文字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    string  public a = unicode&quot;同志们好&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-8-十六进制字面常量"><a href="#3-8-十六进制字面常量" class="headerlink" title="3.8 十六进制字面常量"></a>3.8 十六进制字面常量</h2><p>十六进制字面常量以关键字 <code>hex</code> 打头，后面紧跟着用单引号或双引号引起来的字符串（例如，<code>hex&quot;001122FF&quot;</code> ）。 字符串的内容必须是一个十六进制的字符串，它们的值将使用二进制表示。</p>
<h3 id="3-8-1-基本用法"><a href="#3-8-1-基本用法" class="headerlink" title="3.8.1 基本用法"></a>3.8.1 基本用法</h3><p>它们的内容必须是十六进制数字，可以选择使用单个下划线作为字节边界分隔符。 <strong>字面常量的值将是十六进制序列的二进制表示形式</strong>。</p>
<p>用空格分隔的多个十六进制字面常量被合并为一个字面常量： <code>hex&quot;61&quot; hex&quot;61&quot;</code> 等同于 <code>hex&quot;6161&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    bytes1 public a3 = 0x61;</span><br><span class="line">    bytes1 public a4 = hex&quot;61&quot;;</span><br><span class="line">    bytes2 public a = hex&quot;61&quot; hex&quot;61&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-9-Enum-枚举"><a href="#3-9-Enum-枚举" class="headerlink" title="3.9 Enum:枚举"></a>3.9 Enum:枚举</h2><p><code>enum</code> 是一种用户自定义类型，用于表示多种状态，枚举可用来创建由一定数量的“常量值”构成的自定义类型。主要作用是用于限制某个事务的有限选择。比如将咖啡的容量大小限制为：大、中、小，这将确保任何人不能购买其他容量的咖啡，只能在这里选择。</p>
<p>枚举默认值是第一个成员，所以<strong>枚举类型至少需要一个成员，枚举不能多于 256 个成员</strong>。枚举默认的类型为 <code>uint8</code>，当枚举数足够多时，它会自动变成 <code>uint16</code>..等变大。可以通过 remix 部署后，函数的输入值内查看类型 <code>uint8</code> &#x2F; <code>uint16</code></p>
<ul>
<li>枚举类型，返回值是索引，默认值是 0;</li>
<li>枚举类型的默认值是第一个值。<ul>
<li>枚举类型 enum 至少应该有一名成员。</li>
</ul>
</li>
<li>设置的时候，可以设置为索引，也可以对应的枚举名称;</li>
<li>枚举类型 enum 可以与整数进行显式转换，但不能进行隐式转换。<ul>
<li>显示转换会在运行时检查数值范围，如果不匹配，将会引起异常。</li>
</ul>
</li>
</ul>
<p><strong>例子</strong>:考虑一个限制，将交易的状态限制为：<code>None</code>&#x2F;<code>Pending</code>&#x2F;<code>Shiped</code>&#x2F;<code>Completed</code>&#x2F;<code>Rejected</code>&#x2F;<code>Canceled</code> 这几种。这将确保交易状态仅在列出的状态内。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Enum &#123;</span><br><span class="line">    // 枚举类型的默认值是第一个值。</span><br><span class="line">    // 结构</span><br><span class="line">    enum Status &#123;</span><br><span class="line">        None, // 0</span><br><span class="line">        Pending, // 1</span><br><span class="line">        Shiped,// 2</span><br><span class="line">        Completed,</span><br><span class="line">        Rejected,</span><br><span class="line">        Canceled</span><br><span class="line">    &#125;</span><br><span class="line">    // 变量</span><br><span class="line">    Status public status;</span><br><span class="line"></span><br><span class="line">    // 设置索引值</span><br><span class="line">    function set(Status _status) external &#123;</span><br><span class="line">        status = _status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 由于枚举类型不属于 |ABI| 的一部分，因此对于所有来自 Solidity 外部的调用，</span><br><span class="line">    // &quot;getStatus&quot; 的签名会自动被改成 &quot;getStatus() returns (uint8)&quot;。</span><br><span class="line">    function getStatus() public view returns (Status) &#123;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getDefaultStatus() public view returns (uint256) &#123;</span><br><span class="line">        return uint256(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置</span><br><span class="line">    function ship() external &#123;</span><br><span class="line">        status = Status.Shiped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 恢复为0</span><br><span class="line">    function reset() external &#123;</span><br><span class="line">        delete status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多人感觉 enum 很少用，一是因为应用场景确实比较窄，二是因为可以被其他数据类型所代替；但按照编码规范，限制选择范围场景，除了 bool 以外的，推荐使用 enum 类型来定义。</p>
<p>枚举是显示所有整型相互转换，但不允许隐式转换。从整型显式转换枚举，会在运行时检查整数时候在枚举范围内，否则会导致异常（ Panic 异常 ）。</p>
<p>枚举还可以在合约或库定义之外的文件级别上声明。</p>
<h3 id="3-9-1-方法"><a href="#3-9-1-方法" class="headerlink" title="3.9.1 方法"></a>3.9.1 方法</h3><ul>
<li><code>type(NameOfEnum).min</code></li>
<li><code>type(NameOfEnum).max</code></li>
</ul>
<p>使用 <code>type(NameOfEnum).min</code> 和 <code>type(NameOfEnum).max</code> 你可以得到给定枚举的最小值和最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Enum &#123;</span><br><span class="line">    // 枚举类型的默认值是第一个值。</span><br><span class="line">    enum Status &#123;</span><br><span class="line">        None,//0</span><br><span class="line">        Pending,//1</span><br><span class="line">        Shiped,//2</span><br><span class="line">        Completed,//3</span><br><span class="line">        Rejected,//4</span><br><span class="line">        Canceled// 5</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getLargestValue() public pure returns (Status) &#123;</span><br><span class="line">        return type(Status).max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getSmallestValue() public pure returns (Status) &#123;</span><br><span class="line">        return type(Status).min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-10-用户定义的值类型"><a href="#3-10-用户定义的值类型" class="headerlink" title="3.10 用户定义的值类型"></a>3.10 用户定义的值类型</h2><p>Solidity 允许在一个基本的值类型上创建一个零成本的抽象。这类似于一个别名，但有更严格的类型要求。</p>
<p>用户定义值类型使用 <code>type UserType is DefaultType</code> 来定义。</p>
<p>其中 <code>UserType</code> 是新引入的类型的名称， <code>DefaultType</code> 必须是内置的<strong>值类型</strong>（”底层类型”）。自定义类型的值的数据表示则继承自底层类型，并且 <strong>ABI 中也使用底层类型。</strong></p>
<p>⚠️: 用户定义的类型 <code>UserType</code> 没有任何运算符或绑定成员函数。即使是操作符 <code>==</code> 也没有定义。也不允许与其他类型进行显式和隐式转换。</p>
<h3 id="3-10-1-方法"><a href="#3-10-1-方法" class="headerlink" title="3.10.1  方法"></a>3.10.1  方法</h3><ul>
<li><code>UserType.wrap()</code>: 用来从底层类型转换到自定义类型</li>
<li><code>UserType.unwrap()</code>: 从自定义类型转换到底层类型。</li>
</ul>
<p>案例：一个 18 位小数、256 bit 的浮点类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 使用用户定义的值类型表示 18 位小数、256 bit的浮点类型。</span><br><span class="line">type UFixed256x18 is uint256;</span><br><span class="line"></span><br><span class="line">/// 在 UFixed256x18 上进行浮点操作的精简库。</span><br><span class="line">library FixedMath &#123;</span><br><span class="line">    uint constant multiplier = 10**18;</span><br><span class="line"></span><br><span class="line">    /// 两个 UFixed256x18 数相加，</span><br><span class="line">    /// 溢出时恢复，依赖于 uint256 上的检查算术</span><br><span class="line">     function add(UFixed256x18 a, UFixed256x18 b) internal pure returns (UFixed256x18) &#123;</span><br><span class="line">        return UFixed256x18.wrap(UFixed256x18.unwrap(a) + UFixed256x18.unwrap(b));</span><br><span class="line">    &#125;</span><br><span class="line">    /// 将 UFixed256x18 和 uint256 相乘.</span><br><span class="line">    /// 溢出时恢复，依赖于 uint256 上的检查算术</span><br><span class="line">     function mul(UFixed256x18 a, uint256 b) internal pure returns (UFixed256x18) &#123;</span><br><span class="line">        return UFixed256x18.wrap(UFixed256x18.unwrap(a) * b);</span><br><span class="line">    &#125;</span><br><span class="line">    ///  UFixed256x18 向下取整.</span><br><span class="line">    /// @return 不超过 `a` 的最大整数。</span><br><span class="line">    function floor(UFixed256x18 a) internal pure returns (uint256) &#123;</span><br><span class="line">        return UFixed256x18.unwrap(a) / multiplier;</span><br><span class="line">    &#125;</span><br><span class="line">    /// 将 uint256 转换为相同值的 UFixed256x18。</span><br><span class="line">    /// 如果整数太大，则还原。</span><br><span class="line">    function toUFixed256x18(uint256 a) internal pure returns (UFixed256x18) &#123;</span><br><span class="line">        return UFixed256x18.wrap(a * multiplier);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    uint256 a = 1;</span><br><span class="line">    uint256 b = 2;</span><br><span class="line"></span><br><span class="line">    function testAdd() external view returns (UFixed256x18) &#123;</span><br><span class="line">        return FixedMath.add(FixedMath.toUFixed256x18(a), FixedMath.toUFixed256x18(b));</span><br><span class="line">    &#125;</span><br><span class="line">    function testMul() external view returns (UFixed256x18) &#123;</span><br><span class="line">        return FixedMath.mul(FixedMath.toUFixed256x18(a),b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>UFixed256x18.wrap</code> 和 <code>FixedMath.toUFixed256x18</code> 的签名相同，但执行的是两个完全不同的操作：</p>
<ul>
<li><code>UFixed256x18.wrap</code> 函数返回一个与输入的数据表示相同的自定义值类型（<code>UFixed256x18</code>）。</li>
<li><code>FixedMath.toUFixed256x18</code>则返回一个具有相同数值的 <code>UFixed256x18</code> 。</li>
</ul>
<h1 id="值类型-地址类型"><a href="#值类型-地址类型" class="headerlink" title="值类型:地址类型"></a>值类型:地址类型</h1><p>地址分为外部地址和合约地址，每个地址都有<strong>一块持久化内存区</strong>称为存储。</p>
<p>地址类型也是值类型，因为比较特殊，所以单独拿出来讲。地址类型是 Solidity 语言独有的数据类型，表示以太坊的地址类型。用 address 表示地址，长度是 20 个字节</p>
<h2 id="4-1-地址字面常量"><a href="#4-1-地址字面常量" class="headerlink" title="4.1 地址字面常量"></a>4.1 地址字面常量</h2><p>通常的地址类型是 <code>0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac</code> 。 而没有通过校验测试, 长度在 39 到 41 个数字之间的十六进制字面常量，会产生一个错误, 比如 <code>0XFFD0D80C48F6C3C5387B7CFA7AA03970BDB926AC</code> 就是一个错误 address 类型，会提示正确的地址</p>
<h2 id="4-2-address-uint160-bytes32-之间的转换"><a href="#4-2-address-uint160-bytes32-之间的转换" class="headerlink" title="4.2 address&#x2F;uint160&#x2F;bytes32 之间的转换"></a>4.2 address&#x2F;uint160&#x2F;bytes32 之间的转换</h2><ul>
<li><p>1 字节 8 位，一个 address 是 20 个字节，是 160 位，所以 <strong>address 可以用 uint160 表示</strong>。</p>
</li>
<li><p>1 字节可以表示为两个连续的十六进制数字，所以 <strong>address 可以用连续的 40 个十六进制数字表示</strong>。</p>
</li>
<li><p>address 不允许任何算数操作</p>
<p>如果将使用较大字节数组类型转换为 <code>address</code> ，例如 <code>bytes32</code> ，那么 <code>address</code> 将被截断。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    bytes32 public a =</span><br><span class="line">        0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC;</span><br><span class="line"></span><br><span class="line">    // 0x111122223333444455556666777788889999aAaa</span><br><span class="line">    address public b = address(uint160(bytes20(a)));</span><br><span class="line"></span><br><span class="line">    // 0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc</span><br><span class="line">    address public c = address(uint160(uint256(a)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️：为了减少转换歧义，我们在转换中显式截断处理。 以 32bytes 值 <code>0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC</code> 为例， 如果使用 <code>address(uint160(bytes20(b)))</code> 结果是 <code>0x111122223333444455556666777788889999aAaa</code>， 而使用 <code>address(uint160(uint256(b)))</code> 结果是 <code>0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc</code> 。</p>
<h2 id="4-3-两种形式的地址"><a href="#4-3-两种形式的地址" class="headerlink" title="4.3 两种形式的地址"></a>4.3 两种形式的地址</h2><ul>
<li><code>address</code>：保存一个 20 字节的值（以太坊地址的大小）。</li>
<li><code>address payable</code> ：可支付地址，与 <code>address</code> 相同，不过有成员函数 <code>transfer</code> 和 <code>send</code> 。</li>
</ul>
<p>如果你需要 <code>address</code> 类型的变量，并计划发送以太币给这个地址，那么声明类型为 <code>address payable</code> 可以明确表达出你的需求。 同样，尽量更早对他们进行区分或转换。</p>
<p>这种区别背后的思想是 <code>address payable</code> 可以向其发送以太币，而不能向一个普通的 <code>address</code> 发送以太币。比如，它可能是一个智能合约地址，并且不支持接收以太币。</p>
<h3 id="两种形式的地址转换"><a href="#两种形式的地址转换" class="headerlink" title="两种形式的地址转换"></a>两种形式的地址转换</h3><p>允许从 <code>address payable</code> 到 <code>address</code> 的隐式转换，而从 <code>address</code> 到 <code>address payable</code> 必须显示的 通过 <code>payable(&lt;address&gt;)</code> 进行转换。也只能通过 <code>payable(...)</code> 表达式把 <code>address</code> 类型和合约类型转换为 <code>address payable</code>。</p>
<p>在介绍地址 payable 方法时候会具体介绍，转换的时候注意下面两个点：</p>
<ol>
<li>只有能接收以太币的合约类型，才能够进行此转换，合约要么有 receive 或可支付的回退函数。</li>
<li><code>payable(0)</code> 是有效的，这是此规则的例外。</li>
</ol>
<h2 id="4-4-地址属性"><a href="#4-4-地址属性" class="headerlink" title="4.4 地址属性"></a>4.4 地址属性</h2><p>address 拥有如下属性；</p>
<ol>
<li><p>.balance : 以 Wei 为单位的余额。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.balance    returns(uint256)</span><br></pre></td></tr></table></figure>
</li>
<li><p>.code : 地址上的代码(可以为空)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.code        returns(bytes memory)</span><br></pre></td></tr></table></figure>
</li>
<li><p>.codehash : 地址的 codehash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.codehash    returns(bytes32)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-4-1-balance-属性"><a href="#4-4-1-balance-属性" class="headerlink" title="4.4.1 balance 属性"></a>4.4.1 balance 属性</h3><p>获取地址的余额，wei 单位。如下例子是获取指定地址的 ETH 余额，和当前调用者的余额。（基于当前使用的网络）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function getBalance1(address addr) public view returns (uint256) &#123;</span><br><span class="line">        return addr.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    function getBalance2() external view returns (uint256) &#123;</span><br><span class="line">        return address(msg.sender).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>address(this).balance</code> 查询当前合约的余额，获取合约本身的 ETH 余额如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function getBalance() external view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️: 在版本 0.5.0 之前，Solidity 允许通过合约实例来访问地址的成员，例如 <code>this.balance</code> ，不过现在禁止这样做，必须显式转换为地址后访问，如： <code>address(this).balance</code> 。</p>
<h3 id="4-4-2-code-属性"><a href="#4-4-2-code-属性" class="headerlink" title="4.4.2 code 属性"></a>4.4.2 code 属性</h3><p>可以查询任何智能合约的部署代码。使用 <code>.code</code> 来获取 EVM 的字节码，其返回 <code>bytes memory</code> ，值可能是空。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function getCode() public view returns (bytes memory) &#123;</span><br><span class="line">        return address(this).code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 外部地址 code 内容是空，</span><br><span class="line">    // 可以通过这个来判断地址是否为合约</span><br><span class="line">    function getAdsCode(address a_) public view returns (bytes memory) &#123;</span><br><span class="line">        return address(a_).code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:合约没有完全创建，也就是 constructor 没有完全执行完的时候，code 也是空。</p>
<h3 id="4-4-3-codehash-属性"><a href="#4-4-3-codehash-属性" class="headerlink" title="4.4.3 codehash 属性"></a>4.4.3 codehash 属性</h3><p>使用 <code>.codehash</code> 获得合约代码的 <code>Keccak-256 哈希值</code> (为 bytes32 )。</p>
<p>注意， <code>addr.codehash</code> 比使用 <code>keccak256(addr.code)</code> 更便宜。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function getCode() public view returns (bytes memory) &#123;</span><br><span class="line">        return address(this).code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getCodeByKeccak256() public view returns (bytes32) &#123;</span><br><span class="line">        return keccak256(address(this).code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getCodehash() public view returns (bytes32) &#123;</span><br><span class="line">        return address(this).codehash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-地址方法"><a href="#4-5-地址方法" class="headerlink" title="4.5 地址方法"></a>4.5 地址方法</h2><p>address 拥有如下方法；</p>
<ol>
<li><code>address()</code>: 可以将地址转换到地址类型。</li>
<li><code>payable()</code>: 将普通地址转为可支付地址。</li>
<li><code>.transfer(uint256 amount)</code>: 将余额转到当前地址（合约地址转账）</li>
<li><code>.send(uint256 amount)</code>: 将余额转到当前地址，并<strong>返回交易成功状态</strong>（合约地址转账）</li>
<li><code>.call(bytes memory)</code>: 用给定的有效载荷（payload）发出低级 <code>CALL</code> 调用，并<strong>返回交易成功状态和返回数据</strong>（调用合约的方法并转账）</li>
<li><code>.delegatecall(bytes memory)</code>: 用给定有效载荷（payload）发出低级 <code>DELEGATECALL</code> 调用，返回交易成功状态和返回数据**（调用合约的方法并转账）</li>
<li><code>staticcall(bytes memory)</code>: 用给定的有效载荷（payload）发出低级 <code>STATICCALL</code> 调用，并<strong>返回交易成功状态和返回数据</strong>（调用合约的方法并转账）</li>
</ol>
<h3 id="4-5-1-address"><a href="#4-5-1-address" class="headerlink" title="4.5.1 address()"></a>4.5.1 address()</h3><p><strong>1.获取当前合约地址:address(this)</strong></p>
<p><strong>2.uint 值转换成地址</strong></p>
<h3 id="4-5-2-payable"><a href="#4-5-2-payable" class="headerlink" title="4.5.2 payable()"></a>4.5.2 payable()</h3><p>注意：支付的时候，地址必须 <code>payable</code> 类型！从 <code>address</code> 到 <code>address payable</code> 的转换。可以通过 <code>payable(x)</code> 进行 ，其中 <code>x</code> 必须是 <code>address</code> 类型。</p>
<p>让普通地址为 payable 有两种方式</p>
<ul>
<li><p>方式一: 参数中 地址标注 address payable ,并且函数状态可变性标为payable</p>
<ul>
<li>这种更省 gas (<strong>推荐</strong>)</li>
</ul>
</li>
<li><p>方式二: 仅在内部进行 <code>payable(address)</code> 显示转换</p>
</li>
</ul>
<h3 id="4-5-3-transfer"><a href="#4-5-3-transfer" class="headerlink" title="4.5.3 transfer()"></a>4.5.3 transfer()</h3><p>将余额转到当前地址（合约地址转账）,语法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address payable&gt;.transfer(uint256 amount)</span><br></pre></td></tr></table></figure>

<ol>
<li>需要 payable address</li>
<li>使用固定（不可调节）的 2300 gas 的矿工费，错误会 reverts （回滚所有状态）<ol>
<li>2300 gas 足够转账，但是如果接收合约内的 <code>fallback</code> 和 <code>receive</code> 函数有恶意代码，复杂代码。容易导致 gas 耗尽的错误。</li>
</ol>
</li>
<li>失败时抛出异常<ol>
<li>如果当前合约的余额不够多，则 <code>transfer</code> 函数会执行失败，或者如果以太转移被接收帐户拒绝， <code>transfer</code> 函数同样会失败而进行回退。</li>
</ol>
</li>
<li>如果目标地址是一个合约，那么目标合约内部的 receive&#x2F;fallback 函数会随着调用 <code>transfer</code>函数一起执行，这是 EVM 的特性，没办法阻止。</li>
</ol>
<h3 id="4-5-4-send"><a href="#4-5-4-send" class="headerlink" title="4.5.4 send()"></a>4.5.4 send()</h3><p>将余额转到当前地址，并<strong>返回交易成功状态</strong>（合约地址转账）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;address payable&gt;.send(uint256 amount) returns (bool)</span><br><span class="line">send` 是 `transfer` 的低级版本。如果执行失败，当前的合约不会因为异常而终止。`transfer` 等价于`require(send())</span><br></pre></td></tr></table></figure>

<ol>
<li><p>需要 payable address</p>
</li>
<li><p>使用固定（不可调节）的 2300 gas 的矿工费。</p>
<ol>
<li>gas 同<code>transfer</code>一样的是 2300 gas ；足够转账，但是如果接收合约内的 <code>fallback</code> 和 <code>receive</code> 函数有恶意代码，复杂代码。容易导致 gas 耗尽的错误。</li>
</ol>
</li>
<li><p>失败时仅会返回false,不会终止执行（合约地址转账）;</p>
<ol>
<li><code>send()</code> 执行有一些风险：为了保证安全，必须检查 send 的返回值，如果交易失败，会回退以太币。</li>
</ol>
</li>
<li><p>补充：send 与 transfer 对应，但 <strong>send 更底层</strong>。如果执行失败，transfer 会因异常停止，而 send 会返回 false,transfer 相对 send 较安全</p>
</li>
</ol>
<h3 id="4-5-5-call-delegatecall-staticcall"><a href="#4-5-5-call-delegatecall-staticcall" class="headerlink" title="4.5.5 call&#x2F;delegatecall&#x2F;staticcall"></a>4.5.5 call&#x2F;delegatecall&#x2F;staticcall</h3><p>为了与不知道 ABI 的合约进行交互，Solidity 提供了函数 <code>call</code>&#x2F;<code>delegatecall</code>&#x2F;<code>staticcall</code> 直接控制编码。它们都带有一个 <code>bytes memory</code> 参数和返回执行<strong>成功状态</strong>（bool）和<strong>数据</strong>（bytes memory）。</p>
<p>函数 <code>abi.encode</code>，<code>abi.encodePacked</code>，<code>abi.encodeWithSelector</code> 和 <code>abi.encodeWithSignature</code> 可用于编码结构化数据。</p>
<p><strong>它们可以接受任意类型，任意数量的参数</strong>。这些参数会被打包到以 32 字节为单位的连续区域中存放。其中一个<strong>例外是当第一个参数被编码成正好 4 个字节的情况</strong>。 在这种情况下，这个参数后边不会填充后续参数编码，以允许使用函数签名。</p>
<p>下面具体的介绍三种 call。</p>
<h4 id="4-5-5-1-call"><a href="#4-5-5-1-call" class="headerlink" title="4.5.5.1 call()"></a>4.5.5.1 call()</h4><p>用给定的有效载荷（payload）发出低级 <code>CALL</code> 调用，并<strong>返回交易成功状态和返回数据</strong>（调用合约的方法并转账）, 格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.call(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>低级CALL调用：不需要 payable address, 普通地址即可</p>
<ol>
<li>注意: 调用 <code>call</code> 的时候，地址可以不具备 payable 属性</li>
</ol>
</li>
<li><p>返回两个参数，一个 <code>bool</code> 值代表成功或者失败，另外一个是可能存在的 <code>data</code></p>
</li>
<li><p>发送所有可用 gas，也可以自己调节 gas。</p>
<ol>
<li>如果 <code>fallback</code> 和 <code>receive</code> 内的代码相对复杂也可以，但是如果是恶意代码，需要考虑消耗的 gas 是否值得执行。</li>
<li><code>_ads.call&#123;value: msg.value,gas:2300&#125;(data)</code></li>
</ol>
</li>
<li><p>当合约调用合约时，不知道对方源码和 ABI 时候，可以使用 call 调用对方合约</p>
</li>
<li><p>推荐使用 call 转账 ETH，但是不推荐使用 call 来调用其他合约。</p>
<ol>
<li>原因是: call 调用的时候，将合约控制权交给对方，如果碰到恶意代码，或者不安全的代码就很容易凉凉。</li>
</ol>
</li>
<li><p>当调用不存在的合约方法时候，会触发对方合约内的fallback或receive</p>
<ol>
<li>我们的合约也可以在 <code>fallback</code> &#x2F; <code>receive</code> 这两个方法内抛出事件，查看是否有人对其做了什么操作。</li>
</ol>
</li>
<li><p>三种方法都提供 <code>gas</code> 选项，而 <code>value</code> 选项仅 <code>call</code> 支持 。三种 call 里只有 <code>call</code> 可以进行 ETH 转账，其他两种不可以进行转账。</p>
</li>
</ol>
<p><strong>例子 （重要）：调用其他合约方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test1 &#123;</span><br><span class="line">    string public name;</span><br><span class="line">    uint256 public age;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function setNameAndAge(string memory name_, uint256 age_)</span><br><span class="line">        external</span><br><span class="line">        payable</span><br><span class="line">        returns (string memory __name, uint256 __age)</span><br><span class="line">    &#123;</span><br><span class="line">        name = name_;</span><br><span class="line">        age = age_;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        return (name_, age_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CallTest &#123;</span><br><span class="line">    // 需要一个网页，动态的解析 _bys</span><br><span class="line">    bytes public bys;</span><br><span class="line"></span><br><span class="line">    function call_Test1_setNameAndAge(</span><br><span class="line">        address ads_,</span><br><span class="line">        string memory name_,</span><br><span class="line">        uint256 age_</span><br><span class="line">    ) external payable &#123;</span><br><span class="line">        bytes memory data = abi.encodeWithSignature(</span><br><span class="line">            &quot;setNameAndAge(string,uint256)&quot;,</span><br><span class="line">            name_,</span><br><span class="line">            age_</span><br><span class="line">        );</span><br><span class="line">        (bool success, bytes memory _bys) = ads_.call&#123;value: msg.value&#125;(data);</span><br><span class="line">        require(success, &quot;Call Failed&quot;);</span><br><span class="line">        bys = _bys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说下这个例子的原理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    普通调用:用户A 调用 CallTest 合约, 发送 100 wei ; </span><br><span class="line">    CallTest 调用 Test1, 发送 50 wei此时在 Test1 合约内部</span><br><span class="line">        msg.sender = CallTest</span><br><span class="line">        msg.value = 50</span><br><span class="line">        Test1 内部如果有状态变量修改，则会被修改</span><br><span class="line">        发送到 Test1 内的ETH主币也会被留在Test1内</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h4 id="4-5-5-2-delegatecall-委托调用"><a href="#4-5-5-2-delegatecall-委托调用" class="headerlink" title="4.5.5.2 delegatecall() 委托调用"></a>4.5.5.2 delegatecall() 委托调用</h4><p>发出低级函数 <code>DELEGATECALL</code>，失败时返回 false，发送所有可用 gas，也可以自己调节 gas。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.delegatecall(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure>

<p><code>delegatecall</code> 使用方法和 <code>call</code> 完全一样。区别在于，<code>delegatecall</code> 只调用给定地址的代码（函数），其他状态属性如（存储，余额 …）都来自当前合约。<code>delegatecall</code> 的目的是使用另一个合约中的库代码。</p>
<p>委托调用是：<strong>委托对方调用自己数据的</strong>。类似授权转账，比如我部署一个 Bank 合约， 授权 ContractA 使用 Bank 地址内的资金，ContractA 只拥有控制权，但是没有拥有权。</p>
<ul>
<li>委托调用后，所有变量修改都是发生在委托合约内部，并不会保存在被委托合约中。<ul>
<li>利用这个特性，可以通过更换被委托合约，来升级委托合约。</li>
</ul>
</li>
<li>委托调用合约内部，需要和被委托合约的内部参数完全一样，否则容易导致数据混乱<ul>
<li>可以通过顺序来避免这个问题，但是推荐完全一样</li>
</ul>
</li>
</ul>
<p><strong>例子 1（重要）</strong></p>
<p>代码如下:</p>
<ul>
<li><code>DelegateCall</code> 是委托合约</li>
<li><code>TestVersion1</code> 是第 1 次被委托合约</li>
<li><code>TestVersion2</code> 是第 2 次被委托合约</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 合约版本 V.1</span><br><span class="line">contract TestVersion1 &#123;</span><br><span class="line">    address public sender;</span><br><span class="line">    uint256 public value;</span><br><span class="line">    uint256 public num;</span><br><span class="line"></span><br><span class="line">    function set(uint256 num_) external payable &#123;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">        value = msg.value;</span><br><span class="line">        num = num_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 合约版本 V.2</span><br><span class="line">contract TestVersion2 &#123;</span><br><span class="line">    address public sender;</span><br><span class="line">    uint256 public value;</span><br><span class="line">    uint256 public num;</span><br><span class="line"></span><br><span class="line">    function set(uint256 num_) external payable &#123;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">        value = msg.value;</span><br><span class="line">        num = num_ * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 委托调用测试</span><br><span class="line">contract DelegateCall &#123;</span><br><span class="line">    address public sender;</span><br><span class="line">    uint256 public value;</span><br><span class="line">    uint256 public num;</span><br><span class="line"></span><br><span class="line">    function set(address _ads, uint256 num_) external payable &#123;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">        value = msg.value;</span><br><span class="line">        num = num_;</span><br><span class="line">        // 第1种 encode</span><br><span class="line">        // 不需知道合约名字，函数完全自定义</span><br><span class="line">        bytes memory data1 = abi.encodeWithSignature(&quot;set(uint256)&quot;, num_);</span><br><span class="line">        // 第2种 encode</span><br><span class="line">        // 需要合约名字，可以避免函数和参数写错</span><br><span class="line">        bytes memory data2 = abi.encodeWithSelector(TestVersion1.set.selector, num_);</span><br><span class="line"></span><br><span class="line">        (bool success, bytes memory _data) = _ads.delegatecall(data2);</span><br><span class="line"></span><br><span class="line">        require(success, &quot;DelegateCall set failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说下这个例子的原理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    委托调用</span><br><span class="line">    用户A 调用 DelegateCall 合约, 发送 100 wei ; DelegateCall 委托调用 Test1</span><br><span class="line">    此时在 Test1 合约内部</span><br><span class="line">        msg.sender = A</span><br><span class="line">        msg.value = 100</span><br><span class="line">        Test1 内部如果有状态变量修改，也不会被修改，会在DelegateCallB 内改变</span><br><span class="line">        发送到 Test1 内的ETH主币，会被留在 DelegateCallB 内，不会在Test1 内</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h4 id="4-5-5-3-staticcall-静态调用"><a href="#4-5-5-3-staticcall-静态调用" class="headerlink" title="4.5.5.3 staticcall() 静态调用"></a>4.5.5.3 staticcall() 静态调用</h4><p>用给定的有效载荷（payload）发出低级 <code>STATICCALL</code> 调用，并<strong>返回交易成功状态和返回数据</strong>（调用合约的方法并转账）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.staticcall(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure>

<p>它与 call 基本相同，发送所有可用 gas，也可以自己调节 gas，<strong>但如果被调用的函数以任何方式修改状态变量，都将回退</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 被调用的合约</span><br><span class="line">contract Hello1 &#123;</span><br><span class="line">    function echo() external pure returns (string memory) &#123;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hello2 &#123;</span><br><span class="line">    uint8 public a;</span><br><span class="line">    function echo() external returns (string memory) &#123;</span><br><span class="line">        a = 1;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用者合约</span><br><span class="line">contract SoldityTest &#123;</span><br><span class="line">    function callHello(address ads_) external view returns (string memory) &#123;</span><br><span class="line">        // 编码被调用者的方法签名</span><br><span class="line">        bytes4 methodId = bytes4(keccak256(&quot;echo()&quot;));</span><br><span class="line"></span><br><span class="line">        // 调用合约</span><br><span class="line">        (bool success, bytes memory data) = ads_.staticcall(</span><br><span class="line">            abi.encodeWithSelector(methodId)</span><br><span class="line">        );</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            return abi.decode(data, (string));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;error&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-三种-call-的总结"><a href="#4-6-三种-call-的总结" class="headerlink" title="4.6 三种 call 的总结"></a>4.6 三种 call 的总结</h3><ol>
<li><code>call</code> ， <code>delegatecall</code> 和 <code>staticcall</code> 都是非常低级的函数，应该只把它们当作最后一招来使用，它们破坏了 Solidity 的类型安全性。</li>
<li>三种方法都提供 <code>gas</code> 选项，而 <code>value</code> 选项仅 <code>call</code> 支持 。所以三种 call 里只有 <code>call</code> 可以进行 ETH 转账，其他两种不可以进行转账。</li>
<li>不管是读取状态还是写入状态，最好避免在合约代码中硬编码使用的 gas 值。这可能会引入<strong>错误</strong>，而且 gas 的消耗也是动态改变的。</li>
<li>如果在通过低级函数 <code>delegatecall</code> 发起调用时需要访问存储中的变量，那么这两个合约的存储布局需要一致，以便被调用的合约代码可以正确地通过变量名访问合约的存储变量。 这不是指在库函数调用（高级的调用方式）时所传递的存储变量指针需要满足那样情况。</li>
</ol>
<blockquote>
<p>⚠️ 注意: 在 0.5.0 版本以前, <code>.call</code>, <code>.delegatecall</code> and <code>.staticcall</code> 仅仅返回成功状态，没有返回值。</p>
</blockquote>
<blockquote>
<p>⚠️ 在 0.5.0 版本以前, 还有一个 <code>callcode</code> 函数，现在已经去除。</p>
</blockquote>
<h3 id="4-7-transfer-send-call-三种转账的总结"><a href="#4-7-transfer-send-call-三种转账的总结" class="headerlink" title="4.7 transfer &#x2F; send &#x2F; call 三种转账的总结"></a>4.7 transfer &#x2F; send &#x2F; call 三种转账的总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function byTransfer() public &#123;</span><br><span class="line">        payable(msg.sender).transfer(100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bySend() public &#123;</span><br><span class="line">        bool success = payable(msg.sender).send(100);</span><br><span class="line">        require(success, &quot;Send Fail&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果使用 transfer 或 send 函数必须添加fallback回退函数</span><br><span class="line">    fallback() external &#123;&#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>低级CALL调用<strong>不需要<code>payable address</code></strong>,transfer 和 send <strong>只能是 <code>payable address</code></strong></p>
<p>call的 gas 可以动态调整,transfer 和 send 只能是固定制 <code>2300</code></p>
<p>call除了可以转账外，可以还可以调用不知道 ABI 的方法，还可以调用的时候转账</p>
<ul>
<li>当调用不存在的合约方法时候，会触发对方合约内的 <code>fallback</code> 或者 <code>receive</code>。</li>
<li>如果使用 <code>_to.call&#123;value: 100&#125;(data)</code>，那么<code>data</code>中被调用的方法必须添加 <code>payable</code> 修饰符，否则转账失败！</li>
<li>因为可以调用方法，所以 call 有两个参数，除了一个 <code>bool</code> 值代表成功或者失败，另外一个是可能存在的 <code>data</code>，比如创建合约时候得到部署的地址，调用函数时候得到的函数放回值</li>
</ul>
<h3 id="4-8-注意事项"><a href="#4-8-注意事项" class="headerlink" title="4.8 注意事项"></a>4.8 注意事项</h3><p>使用 send 有很多危险：如果调用栈深度已经达到 1024（这总是可以由调用者所强制指定），转账会失败；并且如果接收者用光了 gas，转账同样会失败。为了保证以太币转账安全，总是检查 send 的返回值，利用 transfer 或者下面更好的方式： 用这种接收者取回钱的模式。</p>
<p><strong>call</strong>:在执行另一个合约函数时，应该尽可能避免使用 .call() ，因为它绕过了类型检查，函数存在检查和参数打包。</p>
<p>由于 EVM 会把对一个不存在的合约的调用作为是成功的。 Solidity 会在执行外部调用时使用 extcodesize 操作码进行额外检查。 这确保了即将被调用的合约要么实际存在（它包含代码）或者触发一个异常。低级调用不 包括这个检查，<strong>这使得它们在 GAS 方面更便宜，但也更不安全</strong>。</p>
<p>上面的这三个 call 方法都是底层的消息传递调用，最好仅在万不得已才进行使用，因为他们破坏了 Solidity 的类型安全。</p>
<h1 id="值类型-合约类型"><a href="#值类型-合约类型" class="headerlink" title="值类型:合约类型"></a>值类型:合约类型</h1><p>⚠️ 注意：合约不支持任何运算符。</p>
<h2 id="5-1-合约的属性"><a href="#5-1-合约的属性" class="headerlink" title="5.1 合约的属性"></a>5.1 合约的属性</h2><p>合约类型的成员是合约的外部函数及 public 的 状态变量。</p>
<p>对于合约 C 可以使用 type(C) 获取合约的类型信息，获得合约名</p>
<ul>
<li><pre><code class="solidity">type(C).name
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```solidity</span><br><span class="line">  type(C).creationCode</span><br></pre></td></tr></table></figure>

- 获得包含创建合约字节码的内存字节数组。
- 该值和合约内使用 `address(this).code;` 结果一样。
- 它可以在内联汇编中构建自定义创建例程，尤其是使用 `create2` 操作码。
- 不能在合约本身或派生的合约访问此属性。 因为会引起循环引用。
</code></pre>
</li>
<li><pre><code class="solidity">type(C).runtimeCode
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 获得合约的运行时字节码的内存字节数组。这是通常由 `C` 的构造函数部署的代码。</span><br><span class="line">  - 如果 `C` 有一个使用内联汇编的构造函数，那么可能与实际部署的字节码不同。</span><br><span class="line">  - 还要注意库在部署时修改其运行时字节码以防范定期调用（guard against regular calls）。 与 `.creationCode` 有相同的限制，不能在合约本身或派生的合约访问此属性。 因为会引起循环引用。</span><br><span class="line"></span><br><span class="line"># 引用类型的额外注解:数据位置</span><br><span class="line"></span><br><span class="line">在讲引用类型之前，先介绍数据位置。这是因为在 Solidity 中，引用类型是由简单数据类型组合而成，相比于简单的值类型，这些类型通常通过名称引用。这些类型涉及到的数据量较大，复制它们可能要消耗大量 Gas，所以我们在使用引用数据类型时，必须考虑存储位置。我们需要仔细考虑数据是保存在内存中，还是在 EVM 存储区中。这就是线介绍数据位置的原因。</span><br><span class="line"></span><br><span class="line">**注意：所有的引用类型，都有数据位置这个额外的注解来指定存储在哪里，所以一定要掌握好。**</span><br><span class="line"></span><br><span class="line">## 6.1 数据位置的基础介绍</span><br><span class="line"></span><br><span class="line">在合约中声明和使用的变量都有一个数据位置，合约变量的数据位置将会影响 Gas 消耗量。</span><br><span class="line"></span><br><span class="line">Solidity 提供的有三种如下数据位置。</span><br><span class="line"></span><br><span class="line">- 存储 storage : 状态变量保存的位置，只要合约存在就一直存储．</span><br><span class="line">- 内存 memory : 即数据在内存中，因此数据仅在其生命周期内（函数调用期间）有效。不能用于外部调用。</span><br><span class="line">- 调用数据 calldata : 用来保存函数参数的特殊数据位置，是一个**只读位置**。</span><br><span class="line">  - 调用数据 calldata 是不可修改的、非持久的函数参数存储区域，效果大多类似 内存 memory 。</span><br><span class="line">  - 主要用于外部函数的参数，但也可用于其他变量，无论外部内部函数都可以使用。</span><br><span class="line"></span><br><span class="line">核心：更改数据位置或类型转换将始终产生自动进行一份拷贝，而在同一数据位置内（对于 存储 storage 来说）的复制仅在某些情况下进行拷贝。</span><br><span class="line"></span><br><span class="line">### 6.1.1 storage</span><br><span class="line"></span><br><span class="line">```solidity</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract DataLocation &#123;</span><br><span class="line">    // storage</span><br><span class="line">    uint256 stateVariable = 1;</span><br><span class="line">    uint256[] stateArray = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">    // uint storage stateVariable; // Expected identifier but got &#x27;storage&#x27;</span><br><span class="line">    // uint[] memory stateArray; // Expected identifier but got &#x27;memory&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>该存储位置存储永久数据，这意味着该数据可以被合约中的所有函数访问。可以把它视为计算机的硬盘数据，所有数据都永久存储。保存在存储区(storage)中的变量，以智能合约的状态存储，并且在函数调用之间保持持久性。与其他数据位置相比，存储区数据位置的成本较高。</p>
<p>storage 是永久存储在以太坊区块链中，更具体地说存储在存储 Merkle Patricia 树中，<strong>形成帐户状态信息的一部分</strong>。一旦使用这个类型，数据将永远存在。</p>
<p><strong>重点:状态变量总是存储在存储区(storage)中,并且不能显式地标记状态变量的位置。</strong>。状态变量是强制为 storage。</p>
<h3 id="6-1-2-memory"><a href="#6-1-2-memory" class="headerlink" title="6.1.2  memory"></a>6.1.2  memory</h3><p>内存位置是临时数据，比存储位置便宜。它只能在函数中访问。通常，内存数据用于保存临时变量，以便在函数执行期间进行计算。一旦函数执行完毕，它的内容就会被丢弃。你可以把它想象成每个单独函数的内存(RAM)。</p>
<p>memory：<strong>存储在内存中，即分配、即使用，越过作用域则不可访问，等待被回收</strong>。</p>
<h5 id="重点-1-函数参数-包括返回参数-都存储在内存中。"><a href="#重点-1-函数参数-包括返回参数-都存储在内存中。" class="headerlink" title="重点 1:函数参数(包括返回参数)都存储在内存中。"></a><strong>重点 1:函数参数(包括返回参数)都存储在内存中。</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract DataLocation &#123;</span><br><span class="line">    function add(uint256 num1, uint256 num2)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256 result)</span><br><span class="line">    &#123;</span><br><span class="line">        return num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中: 函数参数 <code>uint num1</code> 与 <code>uint num2</code>，返回值 <code>uint result</code> 都存储在内存中。</p>
<h5 id="重点-2-引用类型的局部变量，需要显式指定数据位置-storage-memory"><a href="#重点-2-引用类型的局部变量，需要显式指定数据位置-storage-memory" class="headerlink" title="重点 2:引用类型的局部变量，需要显式指定数据位置(storage&#x2F;memory)"></a><strong>重点 2:引用类型的局部变量，需要显式指定数据位置(storage&#x2F;memory)</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Locations &#123;</span><br><span class="line">    struct Book &#123;</span><br><span class="line">        string title;</span><br><span class="line">        string author;</span><br><span class="line">        uint256 book_id;</span><br><span class="line">    &#125;</span><br><span class="line">    Book public java; // 一本 java 书</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function test() public &#123;</span><br><span class="line">        /* 此处都是局部变量  */</span><br><span class="line">        // 值类型:所以它们被存储在内存中</span><br><span class="line">        bool flag = true;</span><br><span class="line">        uint256 number = 1;</span><br><span class="line">        address account = 0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac;</span><br><span class="line">        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff)));</span><br><span class="line"></span><br><span class="line">        // Data location can only be specified for array, struct or mapping types,</span><br><span class="line">        // but &quot;memory&quot; was given.</span><br><span class="line">        // bool memory flag2; // 错误:值类型的数据不能标示 memory</span><br><span class="line"></span><br><span class="line">        // 引用类型:需要显示指定数据位置，此处指定为内存</span><br><span class="line">        uint256[] memory localArray; // array</span><br><span class="line">        // uint8[] memory nums = [1, 2, 3]; // 内存中不能创建动态数组</span><br><span class="line">        uint8[3] memory numsFixed = [1, 2, 3];</span><br><span class="line">        uint256[] memory a = new uint256[](5); // 推荐</span><br><span class="line">        a[1] = 1;</span><br><span class="line">        a[2] = 2;</span><br><span class="line">        a[3] = 3;</span><br><span class="line">        a[4] = 4;</span><br><span class="line"></span><br><span class="line">        string memory myStr = &quot;hello&quot;; // string</span><br><span class="line"></span><br><span class="line">        // 映射不能在函数中动态创建，您必须从状态变量中分配它们。</span><br><span class="line">        // mapping(address =&gt; bool) memory myMapping;</span><br><span class="line">        mapping(address =&gt; uint256) storage ref = balances; // mapping</span><br><span class="line">        java = Book(&#123;title: &quot;Solidity&quot;, author: &quot;Anbang&quot;, book_id: 1&#125;); // struct</span><br><span class="line">        bytes memory bc = bytes(&quot;!&quot;); //</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>mapping 和 struct 类型，不能在函数中动态创建，必须从状态变量中分配它们。</li>
<li>内存中不能创建动态数组</li>
</ul>
<h5 id="重点-3-函数的输入和输出参数如果是数组-使用-memory"><a href="#重点-3-函数的输入和输出参数如果是数组-使用-memory" class="headerlink" title="重点 3:函数的输入和输出参数如果是数组,使用 memory"></a><strong>重点 3:函数的输入和输出参数如果是数组,使用 memory</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract DataLocations &#123;</span><br><span class="line">    // name_ 是 string ，所以使用 memory</span><br><span class="line">    // mm_ 是 uint256[] ，所以使用 memory</span><br><span class="line">    // 输出相同，也是使用 memory</span><br><span class="line">    function examples2(string memory name_, uint256[] memory mm_)</span><br><span class="line">        external</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256[] memory memArr, string memory myName)</span><br><span class="line">    &#123;</span><br><span class="line">        memArr = new uint256[](mm_.length);</span><br><span class="line">        myName = name_;</span><br><span class="line">        for (uint256 index = 0; index &lt; mm_.length; index++) &#123;</span><br><span class="line">            memArr[index] = mm_[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="重点-4-引用类型的局部变量-指定-storage-和-memory-的区别"><a href="#重点-4-引用类型的局部变量-指定-storage-和-memory-的区别" class="headerlink" title="重点 4:引用类型的局部变量:指定 storage 和 memory 的区别"></a><strong>重点 4:引用类型的局部变量:指定 storage 和 memory 的区别</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract DataLocations &#123;</span><br><span class="line">    struct MyStruct &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint256 age;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(address =&gt; MyStruct) public myStructs;</span><br><span class="line"></span><br><span class="line">    function test1() external returns (MyStruct memory) &#123;</span><br><span class="line">        myStructs[msg.sender] = MyStruct(&#123;name: &quot;Anbang1&quot;, age: 18&#125;);</span><br><span class="line"></span><br><span class="line">        // storage 会修改状态变量</span><br><span class="line">        MyStruct storage myStruct1 = myStructs[msg.sender];</span><br><span class="line">        myStruct1.age++;</span><br><span class="line">        return myStruct1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test2() external returns (MyStruct memory) &#123;</span><br><span class="line">        myStructs[msg.sender] = MyStruct(&#123;name: &quot;Anbang2&quot;, age: 18&#125;);</span><br><span class="line"></span><br><span class="line">        // memory 函数运行完后即消失，修改的值也不会储存在状态变量中</span><br><span class="line">        MyStruct memory myStruct2 = myStructs[msg.sender];</span><br><span class="line">        myStruct2.age++;</span><br><span class="line">        return myStruct2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>storage</code>修改引用数据: 会修改状态变量</li>
<li><code>memory</code>修改引用数据: 函数运行完后即消失，修改的值也不会储存在状态变量中</li>
</ul>
<h3 id="6-1-3-calldata"><a href="#6-1-3-calldata" class="headerlink" title="6.1.3  calldata"></a>6.1.3  calldata</h3><p>calldata 是不可修改的非持久性数据位置，所有传递给函数的值，都存储在这里。此外，<code>calldata</code> 是外部函数(external function)的参数的默认位置。外部函数(external function)的参数存储在 calldata 中。函数的返回值中也可以使用 calldata 数据位置的数组和结构，但是无法给其分配空间。</p>
<ul>
<li><strong>要点: calldata 只能用在函数的输入和输出参数中</strong></li>
<li><strong>要点: calldata 用在输入参数中，比 memorg 更省 gas</strong></li>
<li><strong>要点: calldata 的参数不允许修改，但是 memorg 参数允许修改</strong></li>
</ul>
<p>存储函数参数，它是只读的，不会永久存储的一个数据位置。外部函数(external function)的参数被强制指定为 calldata，效果与 memory 类似。</p>
<blockquote>
<p>注解: 如果可以的话，请尽量使用 calldata 作为数据位置，因为它将避免复制，并确保不能修改数据。</p>
</blockquote>
<h3 id="6-1-4-stack"><a href="#6-1-4-stack" class="headerlink" title="6.1.4 stack"></a>6.1.4 stack</h3><p>堆栈是由 EVM (Ethereum 虚拟机)维护的非持久性数据。EVM 使用堆栈数据位置在执行期间加载变量。堆栈位置最多有 1024 个级别的限制。</p>
<h3 id="6-1-5-小结"><a href="#6-1-5-小结" class="headerlink" title="6.1.5 小结"></a>6.1.5 小结</h3><p>按照关键字:</p>
<ul>
<li>storage: 存储区: 状态变量总是储存在<strong>存储区</strong>上</li>
<li>memory: 内存区: 局部变量使用，只在内存中生效。<ul>
<li>值类型的局部变量，存储在<strong>内存</strong>中。</li>
<li><strong>引用类型局部变量，需要显式地指定数据位置</strong>。</li>
<li>函数的输入参数如果是数组或者 string，必须是 <code>memory</code> 或 <code>calldata</code></li>
<li>内存中的数组必须是定长数组（不能使用 push 赋值），动态数组只能储存在状态变量中。</li>
</ul>
</li>
<li>calldata<ul>
<li>和 memory 类似，但是 calldata 只能用在函数的输入参数中。</li>
<li>相比使用 memory ,合约输入参数如果使用 calldata, 可以节约 gas</li>
</ul>
</li>
</ul>
<p>按照函数参数:</p>
<ul>
<li>内部函数参数: (包括返回参数)都存储在<strong>memory（内存）</strong>中。</li>
<li>外部函数参数: (不包括返回参数)存储在 <code>calldata</code> 中。</li>
</ul>
<h2 id="6-2-不同数据位置之间的赋值规则"><a href="#6-2-不同数据位置之间的赋值规则" class="headerlink" title="6.2 不同数据位置之间的赋值规则"></a>6.2 不同数据位置之间的赋值规则</h2><p>本小节总结如下:</p>
<ol>
<li><p>将存储变量赋值给存储变量</p>
<ul>
<li><code>值 类 型</code>: 创建一个新副本。</li>
<li><code>引用类型</code>: 创建一个新副本。</li>
</ul>
</li>
<li><p>将内存变量赋值给存储变量</p>
<ul>
<li><code>值 类 型</code>: 创建一个新副本。</li>
<li><code>引用类型</code>: 创建一个新副本。</li>
</ul>
</li>
<li><p>将存储变量赋值给内存变量</p>
<ul>
<li><code>值 类 型</code>: 创建一个新副本。</li>
<li><code>引用类型</code>: 创建一个新副本。</li>
</ul>
</li>
<li><p>将内存变量赋值给内存变量 (同类型)</p>
<ul>
<li><p><code>值 类 型</code>: 创建一个新副本。</p>
</li>
<li><p><code>引用类型</code>: 不会创建副本。(<strong>重要</strong>)</p>
</li>
</ul>
</li>
</ol>
<h2 id="6-3-calldata-和-memeory-区别"><a href="#6-3-calldata-和-memeory-区别" class="headerlink" title="6.3 calldata 和 memeory 区别"></a>6.3 calldata 和 memeory 区别</h2><p><strong>函数调用函数时的区别</strong>: <code>calldata可以隐式转换为memory</code></p>
<ul>
<li>calldata 参数可以隐式转换为 memory</li>
<li>memory 参数不可以隐式转换为 calldata</li>
</ul>
<h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><ul>
<li><p>array</p>
<ul>
<li>基本类型组成的数组集合。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint256[5] public T1 = [1, 2, 3, 4, 5];</span><br><span class="line">address[5] public A = [0xff...6ac];</span><br><span class="line">byte[5] public A = [0xff...6ac];</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串与 bytes 是特殊的数组，所以也是引用类型</li>
</ul>
</li>
<li><p>string: 是一个动态尺寸的 utf-8 编码字符串</p>
<ul>
<li>他其实是一个特殊的可变字节数组，同时其也是一个引用类型</li>
</ul>
</li>
<li><p>bytes: 动态十六进制字节数组</p>
<ul>
<li>bytes 类似于 <code>byte[]</code>，但它在 calldata 中被紧密地打包。因此，相比于 <code>byte[]</code>，bytes 应该优先使用，因为更便宜。</li>
<li>string 等价于 bytes，但不允许长度或索引访问。</li>
</ul>
</li>
<li><p>mapping</p>
</li>
<li><p>struct：为了允许 evm 的优化，请确保 storage 中的变量和 <code>struct</code> 成员的书写顺序允许它们被紧密地打包。例如，应该按照 <code>uint128，uint128，uint256</code> 的顺序来声明状态变量，而不是使用 <code>uint128，uint256，uint128</code>，因为前者只占用两个存储插槽，而后者将占用三个。</p>
</li>
</ul>
<h2 id="7-1-array-数组"><a href="#7-1-array-数组" class="headerlink" title="7.1 array 数组"></a>7.1 array 数组</h2><p>数组是存储<strong>同类元素的有序集合</strong>。数组声明时可以是固定大小的，也可以是动态调整长度。</p>
<p>下面是 array 的总结:</p>
<ul>
<li><p>声明和初始化数组</p>
<ul>
<li>数组元素可以是任何类型，包括映射或结构体。对类型的限制是映射只能存储在存储 storage 中，并且公开访问函数的参数需要是 ABI 类型。</li>
</ul>
</li>
<li><p>访问和修改数组元素</p>
<ul>
<li><pre><code class="solidity">arr[_index]
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 通过索引进行获取特定元素</span><br><span class="line"></span><br><span class="line">  - 可以通过索引修改值</span><br><span class="line"></span><br><span class="line">  - 状态变量标记 `public` 的数组，Solidity 创建一个 `getter函数` 。 下标的索引数字就是 `getter函数` 的参数。</span><br><span class="line"></span><br><span class="line">  - 访问超出数组长度的元素会导致异常（assert 类型异常 ）。 可以使用 .push() 方法在末尾追加一个新元素，其中 .push() 追加一个零初始化的元素并返回对它的引用。</span><br><span class="line"></span><br><span class="line">- 函数中返回数组</span><br><span class="line"></span><br><span class="line">  - 如果想把数组全部返回，需要通过函数进行操作。在函数中返回数组</span><br><span class="line"></span><br><span class="line">- 动态数组和定长数组</span><br><span class="line"></span><br><span class="line">  - 动态数组只能存在于状态变量中</span><br><span class="line">  - 内存中只能创建定长数组</span><br><span class="line"></span><br><span class="line">- 创建内存数组</span><br><span class="line"></span><br><span class="line">  - 对于 storage 数组，元素可以是任意类型(其他数组、映射或结构)。</span><br><span class="line">  - 对于 memory 数组，元素类型不能是映射类型，如果它是一个 public 函数的参数，那么元素类型必须是 ABI 类型。</span><br><span class="line"></span><br><span class="line">- 数组的属性</span><br><span class="line"></span><br><span class="line">  - `length`: 获取数组的长度</span><br><span class="line"></span><br><span class="line">- 数组的方法</span><br><span class="line"></span><br><span class="line">  - push : 只有动态数组可以使用，只能用在动态数组上</span><br><span class="line">  - pop: 删除最后一个长度，只能用在动态数组上</span><br><span class="line">  - delete: 清空对应的索引；清空不是删除，并不会改变长度，索引位置的值会改为默认值。</span><br><span class="line">  - 数组切片: `x[start:end]`</span><br><span class="line"></span><br><span class="line">### 7.1.1 数组的创建</span><br><span class="line"></span><br><span class="line">数组长度上分为 **固定长度数组** 和 **可变长度数组**，类型上分为**一维数组**和**多维数组**；</span><br><span class="line"></span><br><span class="line">一个元素类型为 `T`，固定长度为 `k` 的数组可以声明为 `T[k]`，而动态数组声明为 `T[]`。</span><br><span class="line"></span><br><span class="line">```solidity</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    // 固定长度数组</span><br><span class="line">    address[5] public A =   [0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac];</span><br><span class="line">    uint256[10] public arr1 = [0, 1, 2]; // 赋值的数组长度不超过10都可以</span><br><span class="line">    uint256[10] public arr2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br><span class="line">    </span><br><span class="line">    //先声明再赋值</span><br><span class="line">    uint256[10] public arr1;</span><br><span class="line">    function test() external &#123;</span><br><span class="line">        arr1[0] = 1;</span><br><span class="line">        arr1[1] = 10;</span><br><span class="line">        arr1[2] = 100;</span><br><span class="line">        arr1[9] = 900;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 可变长度数组</span><br><span class="line">    /*</span><br><span class="line">         用方式 2 创建数组时，若数组为成员变量, 则默认为 storage 类型；</span><br><span class="line">         若为局部变量默认为 `memory` 类型，`memory` 类型的数组，必须声明长度，并且长度创建后不可变。</span><br><span class="line">         `push` 方法不能用在 `memeory` 的数组上,只能逐个索引的赋值。</span><br><span class="line">     */</span><br><span class="line">    uint256[] public T1 = [1, 2, 3, 4, 5]; // 方式 1</span><br><span class="line">    uint256[] public T2 = new uint256[](5); // 方式 2</span><br><span class="line">    </span><br><span class="line">    //二维数组:创建（注意这里跟其它语言比，数组长度的声明位置是反的）</span><br><span class="line">    uint256[2][3] public T = [[1, 2], [3, 4], [5, 6]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>如果能使用定长数组，就使用定长数组，因为它很便宜。</strong></p>
<h3 id="7-1-2-数组常量"><a href="#7-1-2-数组常量" class="headerlink" title="7.1.2 数组常量"></a>7.1.2 数组常量</h3><p>正常看到下方代码应该没什么问题，但是注意:函数 s 中数组类型是<code>uint256</code>，而函数 t 中输入的数组类型是<code>uint8</code>, 这里需要将 uint8 转换一下<code>s([uint256(1), uint256(2)]);</code>;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract T &#123;</span><br><span class="line">    function s(uint256[2] memory _arr) public &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function t() public &#123;</span><br><span class="line">        // s([1, 2]); // 默认这么写不行的 ❌</span><br><span class="line">        s([uint256(1), uint256(2)]); // ✅</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能转成小的类型，就不会转成大的，这是数组常量的<strong>懒惰性</strong>。如下是一个比较经典的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract T &#123;</span><br><span class="line">    int8[2] public a = [1, -1];</span><br><span class="line">    // int8[2] public a = [int8(1), -1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组常量 <code>[1, -1]</code> 是无效的，因为第一个表达式类型是 <code>uint8</code> 而第二个类似是 <code>int8</code> 他们不可以隐式的相互转换。 为了确保可以运行，你是可以使用例如： <code>[int8(1), -1]</code> 。</p>
<p>由于不同类型的固定大小的内存数组不能相互转换(尽管基础类型可以)，如果你想使用二维数组常量，你必须显式地指定一个基础类型:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function f() public pure returns (uint24[2][4] memory) &#123;</span><br><span class="line">        // 下面代码无法工作，因为没有匹配内部类型</span><br><span class="line">        // uint[2][4] memory x = [[0x1, 1], [0xffffff, 2], [0xff, 3], [0xffff, 4]];</span><br><span class="line"></span><br><span class="line">        uint24[2][4] memory x = [</span><br><span class="line">            [uint24(0x1), 1],</span><br><span class="line">            [0xffffff, 2],</span><br><span class="line">            [uint24(0xff), 3],</span><br><span class="line">            [uint24(0xffff), 4]</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-1-2-数组的属性"><a href="#7-1-2-数组的属性" class="headerlink" title="7.1.2 数组的属性"></a>7.1.2 数组的属性</h3><h5 id="length数组有-length-属性表示当前数组的长度。-一经创建，内存-memory-数组的大小就是固定的（但却是动态的，也就是说，它可以根据运行时的参数创建）。"><a href="#length数组有-length-属性表示当前数组的长度。-一经创建，内存-memory-数组的大小就是固定的（但却是动态的，也就是说，它可以根据运行时的参数创建）。" class="headerlink" title="length数组有 length 属性表示当前数组的长度。 一经创建，内存 memory 数组的大小就是固定的（但却是动态的，也就是说，它可以根据运行时的参数创建）。"></a>length数组有 <code>length</code> 属性表示当前数组的长度。 一经创建，内存 memory 数组的大小就是固定的（但却是动态的，也就是说，它可以根据运行时的参数创建）。</h5><p><strong>通过 <code>arr.length</code> 获取数组的长度</strong></p>
<p><strong>不能通过设置 <code>arr.length</code> 来调整动态数组的长度。</strong></p>
<h3 id="7-1-3-数组的方法"><a href="#7-1-3-数组的方法" class="headerlink" title="7.1.3 数组的方法"></a>7.1.3 数组的方法</h3><ul>
<li><p>push : 只有动态数组可以使用，动态的 storage 数组以及bytes类型可以用，string类型不可以</p>
<ul>
<li><code>push()</code>: 它用来添加新的零初始化元素到数组末尾，并返回元素引用.因此可以这样：<code>x.push().t = 2</code> 或 <code>x.push() = b</code>.</li>
<li><code>push(x)</code>: 用来在数组末尾添加一个给定的元素，这个函数没有返回值．</li>
</ul>
</li>
<li><p><code>pop:</code> 删除最后一个长度</p>
<ul>
<li>它用来从数组末尾删除元素。 同样的会在移除的元素上隐含调用 delete 。</li>
</ul>
</li>
<li><p><code>delete</code>: 删除对应的索引；删除并不会改变长度，索引位置的值会改为默认值。</p>
</li>
<li><p><code>x[start:end]</code>: 数组切片，仅可使用于 <code>calldata</code> 数组.</p>
</li>
</ul>
<h2 id="7-2-bytes"><a href="#7-2-bytes" class="headerlink" title="7.2.bytes"></a>7.2.bytes</h2><p><code>string</code> 和 <code>bytes</code> 类型的变量是特殊的数组。 <code>bytes</code> 可以通过索引或者<code>.length</code>来访问数据。string 与 bytes 相同，但不允许用<code>.length</code>或索引来访问数据。</p>
<ul>
<li>对任意长度的原始字节数据使用 <code>bytes</code>，对任意长度字符串（UTF-8）数据使用 <code>string</code> 。</li>
<li>如果使用一个长度限制的字节数组，应该使用一个 <code>bytes1</code> 到 <code>bytes32</code> 的具体类型，因为它们便宜得多。</li>
<li><code>bytesN[]</code> 和 <code>bytes</code> 可以转换: bytes1 是值类型，比如 <code>0x61</code>; <code>bytes</code>是可变字节数组,如果 bytes1 想要借用 bytes 的方法，就需要转换成 bytes;</li>
</ul>
<h3 id="7-2-1-创建"><a href="#7-2-1-创建" class="headerlink" title="7.2.1 创建"></a>7.2.1 创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    bytes public welcome = bytes(&quot;1.Welcome&quot;);</span><br><span class="line">    bytes public temp1 = new bytes(2); // 可变字节数组创建方式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-2-bytes-和-bytes32-区别"><a href="#7-2-2-bytes-和-bytes32-区别" class="headerlink" title="7.2.2 bytes 和 bytes32[] 区别"></a>7.2.2 bytes 和 bytes32[] 区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// bytes / bytes32 / bytes32[] 区别</span><br><span class="line">// bytes:可变字节数组 ： 引用类型</span><br><span class="line">// bytes32: 固定长度的字节数组 ： 值类型</span><br><span class="line">// bytes32[]: 由“固定长度的字节数组” 组成的 数组类型</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    bytes public welcome1 = bytes(&quot;1.Welcome&quot;);</span><br><span class="line">    bytes32 public welcome2 = &quot;a&quot;;</span><br><span class="line">    bytes32[] public welcome3 = [bytes32(&quot;a&quot;)];</span><br><span class="line"></span><br><span class="line">    bytes32[] public abcArray = [bytes1(&quot;a&quot;), bytes1(&quot;b&quot;), bytes1(&quot;c&quot;)];</span><br><span class="line"></span><br><span class="line">    // 0x616263</span><br><span class="line">    bytes public abcBytes = bytes(&quot;abc&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>abcBytes</code> 的值是: <code>0x616263</code>;</p>
<p><code>abcArray</code> 的值是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    0x6100000000000000000000000000000000000000000000000000000000000000,</span><br><span class="line">    0x6200000000000000000000000000000000000000000000000000000000000000,</span><br><span class="line">    0x6300000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><code>bytes</code> 有点类似于 <code>bytes1[]</code>的紧打包，我们可以把上面例子中 bytes32 改为 bytes1 类型进行对比。</p>
<p>我们更多时候应该使用 <code>bytes</code> 而不是 <code>bytes32[]</code>这种数组类型 ，因为 Gas 费用更低;</p>
<ul>
<li><code>bytes32[]</code> 会在元素之间添加 31 个填充字节。</li>
<li><code>bytes</code> 由于紧密包装，这没有填充字节。</li>
</ul>
<h3 id="7-2-3-属性"><a href="#7-2-3-属性" class="headerlink" title="7.2.3  属性"></a>7.2.3  属性</h3><ul>
<li><p>获取 bytes 长度</p>
<ul>
<li>bytesVar.length:以字节长度表示字符串的长度</li>
</ul>
</li>
<li><p>获取指定索引的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes1 temp1 = bytes(welcome)[_index]; // 返回固定长度的 bytes1</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-2-4-方法"><a href="#7-2-4-方法" class="headerlink" title="7.2.4 方法"></a>7.2.4 方法</h3><h4 id="bytes-concat-拼接"><a href="#bytes-concat-拼接" class="headerlink" title="bytes.concat 拼接"></a>bytes.concat 拼接</h4><ul>
<li><code>bytes.concat(...) returns (bytes memory)</code></li>
<li><code>bytes.concat( )</code>返回空数组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    bytes public concatBytes = bytes.concat();</span><br><span class="line">    bytes public welcome = bytes(&quot;a&quot;);</span><br><span class="line">    bytes public concatBytes = bytes.concat(welcome, bytes(&quot;b&quot;), bytes1(&quot;c&quot;),&quot;a&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="push-方法"><a href="#push-方法" class="headerlink" title="push 方法"></a>push 方法</h4><p>注意： push 是单个字节，是 <code>bytes1</code>的固定长度,而不是 <code>bytes</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    bytes public welcome1 = bytes(&quot;Welcome&quot;);</span><br><span class="line">    bytes public welcome2 = new bytes(10);</span><br><span class="line"></span><br><span class="line">    function testPush() public &#123;</span><br><span class="line">        welcome1.push(bytes(&quot;A&quot;)[0]);</span><br><span class="line">        welcome2.push(bytes1(&quot;B&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pop-方法"><a href="#pop-方法" class="headerlink" title="pop 方法"></a>pop 方法</h4><p>删除数组的最后一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    bytes public welcome1 = bytes(&quot;Welcome&quot;);</span><br><span class="line">    bytes public welcome2 = new bytes(10);</span><br><span class="line"></span><br><span class="line">    function testPop() public &#123;</span><br><span class="line">        welcome1.pop();</span><br><span class="line">        welcome2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="delete-清空字节数组"><a href="#delete-清空字节数组" class="headerlink" title="delete 清空字节数组"></a>delete 清空字节数组</h4><p>使用 <code>delete</code> 全局关键字;</p>
<ul>
<li><code>delete bytesName</code></li>
<li><code>delete bytesName[index]</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    bytes public welcome1 = bytes(&quot;Welcome&quot;);</span><br><span class="line"></span><br><span class="line">    function deleteAll() public &#123;</span><br><span class="line">        delete welcome1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deleteIndex(uint256 index_) public &#123;</span><br><span class="line">        delete welcome1[index_];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="x-start-end-数组切片"><a href="#x-start-end-数组切片" class="headerlink" title="x[start:end]:数组切片"></a><code>x[start:end]</code>:数组切片</h4><p>注意：数组切片只能用在 calldata 类型上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Proxy &#123;</span><br><span class="line">    bytes public welcome1 = bytes(&quot;Welcome&quot;);</span><br><span class="line">    bytes4 public temp1 = bytes4(welcome1); // 0x57656c63</span><br><span class="line"></span><br><span class="line">    // 把 welcome1 的值传入参数</span><br><span class="line">    function forward(bytes calldata payload)</span><br><span class="line">        external pure</span><br><span class="line">        returns(bytes memory temp2,bytes4 temp3)</span><br><span class="line">    &#123;</span><br><span class="line">        // 切片方法只能用在 calldata 上。</span><br><span class="line">        temp2 = payload[:4];</span><br><span class="line">        temp3 = bytes4(payload[:4]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-5-字符串-到-bytes-的转换"><a href="#7-2-5-字符串-到-bytes-的转换" class="headerlink" title="7.2.5 字符串 到 bytes 的转换"></a>7.2.5 字符串 到 bytes 的转换</h3><p>转换方法: 可以使用 <code>bytes()</code> 构造函数将字符串转换为 <code>bytes</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function trans(string memory _str) external pure returns (bytes memory) &#123;</span><br><span class="line">        return bytes(_str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-6-bytes-到-字符串-的转换"><a href="#7-2-6-bytes-到-字符串-的转换" class="headerlink" title="7.2.6 bytes 到 字符串 的转换"></a>7.2.6 bytes 到 字符串 的转换</h3><p>转换方法: 可以使用 <code>string()</code> 构造函数将 <code>bytes</code> 转换为字符串。</p>
<p>注意: 字节数组分为动态大小和固定大小的。如果是固定大小字节数组，需要先转为动态大小字节数组。</p>
<ul>
<li><code>动态大小字节数组</code> —&gt; <code>string</code></li>
<li><code>固定大小字节数组</code> —&gt; <code>动态大小字节数组</code> —&gt; <code>string</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    string public data1;</span><br><span class="line">    string public data2;</span><br><span class="line"></span><br><span class="line">    // `动态大小字节数组` —&gt; `string`</span><br><span class="line">    function trans1() external &#123;</span><br><span class="line">        bytes memory bstr = new bytes(2);</span><br><span class="line">        bstr[0] = &quot;a&quot;;</span><br><span class="line">        bstr[1] = &quot;b&quot;;</span><br><span class="line">        data1 = string(bstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // `固定大小字节数组` —&gt; `动态大小字节数组` —&gt; `string`</span><br><span class="line">    function trans2() external &#123;</span><br><span class="line">        // 固定大小字节数组</span><br><span class="line">        bytes2 ab = 0x6162;</span><br><span class="line"></span><br><span class="line">        // `固定大小字节数组` —&gt; `动态大小字节数组`</span><br><span class="line">        bytes memory temp = new bytes(ab.length); // 可变字节数组创建方式</span><br><span class="line">        for (uint256 i = 0; i &lt; ab.length; i++) &#123;</span><br><span class="line">            temp[i] = ab[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // `动态大小字节数组` —&gt; `string`</span><br><span class="line">        data2 = string(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-string"><a href="#7-3-string" class="headerlink" title="7.3 string"></a>7.3 string</h2><p>Solidity 中，字符串值使用双引号(<code>&quot;&quot;</code>)或单引号(<code>&#39;&#39;</code>)包括，字符串类型用 string 表示。<code>string</code> 和 <code>bytes</code> 类型的变量是特殊的数组，是引用类型。</p>
<h3 id="7-3-1-格式"><a href="#7-3-1-格式" class="headerlink" title="7.3.1 格式"></a>7.3.1 格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract For &#123;</span><br><span class="line">    string public a = &quot;a&quot; &quot;b&quot; &quot;c&quot;;</span><br><span class="line">    string public b = &quot;abc&quot;;</span><br><span class="line">    string public c = &#x27;x&#x27; &#x27;y&#x27; &#x27;z&#x27;;</span><br><span class="line">    string public d = &#x27;xyz&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-2-属性"><a href="#7-3-2-属性" class="headerlink" title="7.3.2 属性"></a>7.3.2 属性</h3><p>string 并没有获取其字符串长度的 length 属性; 也没提供获取某个索引字节码的索引属性。</p>
<p>我们可以通过把 string 转换成 <code>bytes</code>，借助<code>bytes</code> 的属性。</p>
<p>例子: 下面是使用 <code>getLength()</code> 获取长度，使用<code>modi()</code>修改字符串，使用 <code>getIndexValue()</code> 获取字符串的指定索引的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    string public welcome = &quot;1.Welcome&quot;;</span><br><span class="line"></span><br><span class="line">    function getLength() public view returns (uint256 welcomeLength) &#123;</span><br><span class="line">        welcomeLength = bytes(welcome).length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getIndexValue(uint256 _index) public view returns (string memory) &#123;</span><br><span class="line">        bytes1 temp1 = bytes(welcome)[_index]; // 返回固定长度的 bytes1</span><br><span class="line">        bytes memory temp2 = new bytes(1); // 可变字节数组创建方式</span><br><span class="line">        temp2[0] = temp1;</span><br><span class="line">        return string(temp2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function modi() public &#123;</span><br><span class="line">        bytes(welcome)[0] = bytes1(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-3-方法"><a href="#7-3-3-方法" class="headerlink" title="7.3.3 方法"></a>7.3.3 方法</h3><p>Solidity string 本身并没有操作函数，需要借助全局的函数</p>
<ul>
<li>字符串拼接<ul>
<li><code>string.concat()</code></li>
<li>如果不使用参数调用 string.concat 将返回空数组。</li>
</ul>
</li>
<li>将 bytes 转换到字符串<ul>
<li><code>string()</code></li>
</ul>
</li>
<li>将 字符串 转换到 bytes<ul>
<li><code>bytes()</code></li>
</ul>
</li>
<li>比较两个字符串<ul>
<li><code>keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))</code></li>
<li><code>keccak256(bytes(s1)) == keccak256(bytes(s2))</code>:更省 gas</li>
</ul>
</li>
</ul>
<p><strong>string.concat</strong>:可以使用 <code>string.concat</code> 连接任意数量的 string 字符串。 该函数返回一个 <code>string memory</code> ，包含所有参数的内容，无填充方式拼接在一起。 如果你想使用不能隐式转换为 string 的其他类型作为参数，你需要先把它们转换为 string。</p>
<p>输入字符串，输出拼接后的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    string public welcome = &quot;Welcome&quot;;</span><br><span class="line"></span><br><span class="line">    // 写一个 welcome username 的小方法</span><br><span class="line">    // Welcome Anbang!</span><br><span class="line">    function test(string memory name_)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns(string memory concatString)&#123;</span><br><span class="line">            bytes memory bs = bytes(&quot;!&quot;);</span><br><span class="line">            // welcome + name_ + bs</span><br><span class="line">            // 内部是使用字符串，如果是bytes，需要转换为 string 类型</span><br><span class="line">            concatString = string.concat(</span><br><span class="line">                welcome,</span><br><span class="line">                name_,</span><br><span class="line">                string(bs)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你不使用参数调用 <code>string.concat</code> 或 <code>bytes.concat</code> 将返回空数组。</p>
<h2 id="7-4-mapping-映射"><a href="#7-4-mapping-映射" class="headerlink" title="7.4 mapping 映射"></a>7.4 mapping 映射</h2><p>mapping 可以看作一个哈希表，会执行虚拟化初始化，使所有可能的值都是该类型的默认值。其实 mapping 并不是一个哈希表，没有 key 集合，也没有 value 集合，所以 mapping 没办法遍历&#x2F;迭代。</p>
<p>数组中找某一个值需要循环遍历，这是很消耗 Gas 的，而使用 mapping 就可以很好的解决这个问题。映射可以很方便的获取某个值。映射并没有做迭代的方法。</p>
<h3 id="7-4-1本节重点"><a href="#7-4-1本节重点" class="headerlink" title="7.4.1本节重点"></a>7.4.1本节重点</h3><p>声明映射类型的语法：<code>mapping(_KeyType =&gt; _ValueType)</code></p>
<p><code>_KeyType</code>：可以是任何内置类型，或者 bytes 和 字符串,键是唯一的，其赋值方式为：<code>map[a]=test</code>; 意思是键为 a,值为 test；</p>
<p><code>_ValueType</code>： 可以是任何类型，用户自定义类型也可以。</p>
<p>mapping 支持嵌套,映射的数据位置(data location)只能是 <code>storage</code>，通常用于状态变量,mapping不能用于public</p>
<p>函数的参数或返回结果</p>
<ul>
<li>映射只能是 storage 的数据位置，因此只允许作为状态变量 或 作为函数内的 storage 引用 或 作为库函数的参数。它们不能用<strong>合约公有函数的参数或返回值</strong>。</li>
<li>这些限制同样适用于包含映射的数组和结构体。</li>
</ul>
<p><strong>问答题：为什么映射不能像哈希表一样遍历？</strong></p>
<p>映射与哈希表不同的地方：<strong>在映射中,并不存储 key，而是存储它的 <code>keccak256</code> 哈希值，从而便于查询实际的值</strong>。正因为如此，映射是没有长度的，也没有 <code>key 的集合</code>或 <code>value 的集合</code>的概念。映射只能是存储的数据位置，因此只允许作为状态变量或作为函数内的存储引用 或 作为库函数的参数。</p>
<h3 id="7-4-2-创建格式"><a href="#7-4-2-创建格式" class="headerlink" title="7.4.2 创建格式"></a>7.4.2 创建格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Mapping &#123;</span><br><span class="line">    // 普通</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line">    // 嵌套</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; bool)) public friends;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-3-如何获取-设置-删除"><a href="#7-4-3-如何获取-设置-删除" class="headerlink" title="7.4.3 如何获取-设置-删除"></a>7.4.3 如何获取-设置-删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Mapping &#123;</span><br><span class="line">    // 普通</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    // 嵌套</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; bool)) public friends;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        balances[msg.sender] = 100;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function blanceGet() external view returns (uint256) &#123;</span><br><span class="line">        // 获取</span><br><span class="line">        return balances[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function blanceSet(uint256 amount) external &#123;</span><br><span class="line">        // 设置</span><br><span class="line">        balances[msg.sender] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function blanceDelete() external &#123;</span><br><span class="line">        // 删除</span><br><span class="line">        delete balances[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function friendGet() external view returns (bool) &#123;</span><br><span class="line">        // 获取</span><br><span class="line">        return friends[msg.sender][address(0)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function friendSet() external &#123;</span><br><span class="line">        // 设置</span><br><span class="line">        friends[msg.sender][address(0)] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function friendDelete() external &#123;</span><br><span class="line">        // 删除</span><br><span class="line">        delete friends[msg.sender][address(0)];</span><br><span class="line">        // delete friends[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-4-作为局部变量的使用"><a href="#7-4-4-作为局部变量的使用" class="headerlink" title="7.4.4 作为局部变量的使用"></a>7.4.4 作为局部变量的使用</h3><p><code>mapping</code> 类型可以用做局部变量，但只能引用状态变量，而且存储位置为 storage。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 作为局部变量的使用</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // 普通 mapping</span><br><span class="line">    mapping(address =&gt; uint256) public balances; // 普通mapping</span><br><span class="line"></span><br><span class="line">    // storage: 改变内部 ref，会影响 balances 的值</span><br><span class="line">    // 不能声明为 memory</span><br><span class="line">    function updataBalance() public returns(uint256)&#123;</span><br><span class="line">        // mapping(address=&gt;uint256) memory ref = balances; // ❌</span><br><span class="line">        mapping(address=&gt;uint256) storage ref = balances;</span><br><span class="line">        ref[msg.sender] += 3;</span><br><span class="line">        return ref[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-5-在-ERC20-token-中的用法"><a href="#7-4-5-在-ERC20-token-中的用法" class="headerlink" title="7.4.5 在 ERC20 token 中的用法"></a>7.4.5 在 ERC20 token 中的用法</h3><p>下面的例子是ERC20 token的简单版本 <code>._allowances</code> 是一个嵌套 mapping 的例子 <code>._allowances</code> 用来记录其他的账号，可以允许从其账号使用多少数量的币．</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// mapping 在 ERC20 token 中的用法</span><br><span class="line">contract MappingExample &#123;</span><br><span class="line">    // 余额</span><br><span class="line">    mapping(address =&gt; uint256) private _balances;</span><br><span class="line">    // 授权:</span><br><span class="line">    // 授权人 - 代理人 - 授权金额</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line">    event Approval(</span><br><span class="line">        address indexed owner,</span><br><span class="line">        address indexed spender,</span><br><span class="line">        uint256 value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 获取：授权金额</span><br><span class="line">    function allowance(address owner, address spender)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        return _allowances[owner][spender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查：授权金额大于等于需要操作的金额</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address sender,</span><br><span class="line">        address recipient,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) public returns (bool) &#123;</span><br><span class="line">        require(</span><br><span class="line">            _allowances[sender][msg.sender] &gt;= amount,</span><br><span class="line">            &quot;ERC20: Allowance not high enough.&quot;</span><br><span class="line">        );</span><br><span class="line">        _allowances[sender][msg.sender] -= amount; // 设置额度</span><br><span class="line">        _transfer(sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置：</span><br><span class="line">    function approve(address spender, uint256 amount) public returns (bool) &#123;</span><br><span class="line">        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">        _allowances[msg.sender][spender] = amount;</span><br><span class="line">        emit Approval(msg.sender, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _transfer(</span><br><span class="line">        address sender,</span><br><span class="line">        address recipient,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) internal &#123;</span><br><span class="line">        require(sender != address(0), &quot;ERC20: transfer from the zero address&quot;);</span><br><span class="line">        require(recipient != address(0), &quot;ERC20: transfer to the zero address&quot;);</span><br><span class="line">        require(_balances[sender] &gt;= amount, &quot;ERC20: Not enough funds.&quot;);</span><br><span class="line"></span><br><span class="line">        _balances[sender] -= amount;</span><br><span class="line">        _balances[recipient] += amount;</span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-6-可迭代映射"><a href="#7-4-6-可迭代映射" class="headerlink" title="7.4.6 可迭代映射"></a>7.4.6 可迭代映射</h3><p>遍历所有 Mapping 内的数据，（Mapping 配合 array ）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line">    // 用于检查:地址是否已经存在于 balancesKey</span><br><span class="line">    mapping(address =&gt; bool) public balancesInserted;</span><br><span class="line">    address[] public balancesKey; // 所有地址</span><br><span class="line"></span><br><span class="line">    // 设置</span><br><span class="line">    function set(address ads_,uint256 amount_) external&#123;</span><br><span class="line">        balances[ads_] = amount_;</span><br><span class="line">        // 1.检查</span><br><span class="line">        if(!balancesInserted[ads_])&#123;</span><br><span class="line">            // 2.修改检查条件</span><br><span class="line">            balancesInserted[ads_] = true;</span><br><span class="line">            // 3.正在的操作</span><br><span class="line">            balancesKey.push(ads_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取</span><br><span class="line">    function get(uint256 index_) external view returns(uint256)&#123;</span><br><span class="line">        require(index_&lt;balancesKey.length,&quot;index_ error&quot;);</span><br><span class="line">        return balances[balancesKey[index_]];</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取所有</span><br><span class="line">    function totalAddress() external view returns(uint256)&#123;</span><br><span class="line">        return balancesKey.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取第一个值</span><br><span class="line">    function first() external view returns(uint256)&#123;</span><br><span class="line">        return balances[balancesKey[0]];</span><br><span class="line">    &#125;</span><br><span class="line">    // 最后一个值</span><br><span class="line">    function latest() external view returns(uint256)&#123;</span><br><span class="line">        return balances[balancesKey[balancesKey.length-1]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>更完善的实现: <a target="_blank" rel="noopener" href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol">https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol</a></li>
<li>更新的实现: <a target="_blank" rel="noopener" href="https://learnblockchain.cn/docs/solidity/types.html#iterable-mappings">https://learnblockchain.cn/docs/solidity/types.html#iterable-mappings</a></li>
</ul>
<h2 id="7-5-struct-结构体"><a href="#7-5-struct-结构体" class="headerlink" title="7.5 struct 结构体"></a>7.5 struct 结构体</h2><h3 id="7-5-1-创建语法"><a href="#7-5-1-创建语法" class="headerlink" title="7.5.1 创建语法"></a>7.5.1 创建语法</h3><p>要定义结构体，使用 <code>struct</code> 关键字。<code>struct</code> 关键字定义了一个新的数据类型，包含多个成员。结构体是可以将多个变量进行编组的自定义类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    struct Book &#123;</span><br><span class="line">        string title;</span><br><span class="line">        string author;</span><br><span class="line">        uint256 book_id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-2-三种创建方法"><a href="#7-5-2-三种创建方法" class="headerlink" title="7.5.2 三种创建方法"></a>7.5.2 三种创建方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 第 1 种生成</span><br><span class="line">Book memory solidity1 = Book(unicode&quot;Solidity 高级程序设计&quot;, &quot;Anbang&quot;, ++bookId);</span><br><span class="line"></span><br><span class="line">// 第 2 种生成</span><br><span class="line">Book memory solidity2 = Book(&#123;</span><br><span class="line">    title: unicode&quot;Solidity 高级程序设计&quot;,</span><br><span class="line">    author: &quot;Anbang&quot;,</span><br><span class="line">    book_id: ++bookId,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 第 3 种生成</span><br><span class="line">Book memory temp;</span><br><span class="line">temp.title = unicode&quot;Solidity 高级程序设计&quot;;</span><br><span class="line">temp.author = &quot;Anbang&quot;;</span><br><span class="line">temp.book_id = ++bookId;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-3-读取"><a href="#7-5-3-读取" class="headerlink" title="7.5.3 读取"></a>7.5.3 读取</h3><p>函数内仅读取结构体，使用 memory 和 storage 区别:</p>
<ol>
<li>函数内读取并返回,如果使用 memory 变量接收:<ol>
<li>从状态变量拷贝到内存中，然后内存中的变量拷贝到返回值。两次拷贝，消耗 gas 多</li>
<li><code>Book memory _book = book;</code></li>
</ol>
</li>
<li>函数内读取并返回，如果使用 storage 变量接收:<ol>
<li>直接从状态变量读取，状态变量拷贝到返回值。1 次拷贝，消耗 gas 小</li>
</ol>
</li>
<li>总结: 读取时候推荐使用 <code>storage</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 读取</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    struct Book &#123;</span><br><span class="line">        string title;</span><br><span class="line">        string author;</span><br><span class="line">        uint256 book_id;</span><br><span class="line">    &#125;</span><br><span class="line">    Book public book = Book(&quot;Solidity&quot;, &quot;Anbang&quot;, 1);</span><br><span class="line"></span><br><span class="line">    // memory  30029 gas</span><br><span class="line">    // 函数内读取并返回：使用 memory 变量接收</span><br><span class="line">    //  两次拷贝，所以消耗的 gas 多</span><br><span class="line">    function get1() external view</span><br><span class="line">        returns(</span><br><span class="line">            string memory,</span><br><span class="line">            string memory,</span><br><span class="line">            uint256</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">         // 从状态变量拷贝到内存中</span><br><span class="line">        Book memory _book = book;</span><br><span class="line">        // 内存中的变量拷贝到返回值；2次拷贝</span><br><span class="line">        return (_book.title,_book.author,_book.book_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // storage 29983 gas</span><br><span class="line">    // 函数内读取并返回：使用 storage 变量接收</span><br><span class="line">    function get2() external view</span><br><span class="line">        returns(</span><br><span class="line">            string memory,</span><br><span class="line">            string memory,</span><br><span class="line">            uint256</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        // 从状态变量读取，没有拷贝的行为</span><br><span class="line">        Book storage _book = book;</span><br><span class="line"></span><br><span class="line">        // 状态变量拷贝到返回值。1次拷贝</span><br><span class="line">        return (_book.title,_book.author,_book.book_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-4-修改"><a href="#7-5-4-修改" class="headerlink" title="7.5.4 修改"></a>7.5.4 修改</h3><p>函数内读取时，标记 <code>memory</code> &#x2F; <code>storage</code>,会产生完全不同的结果；</p>
<p>特别注意：**如果结构体内包含 <code>mapping</code> 类型，则必须使用 <code>storage</code>，不可以使用 memeory.**，否则报错</p>
<p>函数内获取并修改结构体：</p>
<ul>
<li>因为要修改状态变量，所以使用 storage</li>
<li>函数内直接修改变量; 在修改一个属性时比较省 Gas 费用</li>
<li>函数内先获取存储到 storage 再修改:修改多个属性的时候比较省 Gas 费用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Structs &#123;</span><br><span class="line">    struct Book &#123;</span><br><span class="line">        string title;</span><br><span class="line">        string author;</span><br><span class="line">        uint256 book_id;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 private bookId;</span><br><span class="line">    Book public book1; // Book类型</span><br><span class="line">    Book public book2; // Book类型</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; Book) public students; // mapping 类型</span><br><span class="line"></span><br><span class="line">    // 设置 book1</span><br><span class="line">    function setBook1() external &#123;</span><br><span class="line">        Book memory temp;</span><br><span class="line">        temp.title = unicode&quot;Solidity 高级程序设计&quot;;</span><br><span class="line">        temp.author = &quot;Yaoqi&quot;;</span><br><span class="line">        temp.book_id = ++bookId;</span><br><span class="line">        book1 = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置 book2</span><br><span class="line">    // ✅ 最优方案，推荐:直接修改</span><br><span class="line">    function setBook2() external &#123;</span><br><span class="line">        book2.title = unicode&quot;Solidity 高级程序设计&quot;;</span><br><span class="line">        book2.author = &quot;Yaoqi&quot;;</span><br><span class="line">        book2.book_id = ++bookId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ✅ 最优方案，推荐:直接修改</span><br><span class="line">    function set1Student() external &#123;</span><br><span class="line">        Book storage temp = students[msg.sender];</span><br><span class="line">        temp.title = unicode&quot;Solidity 高级程序设计&quot;;</span><br><span class="line">        temp.author = &quot;Anbang&quot;;</span><br><span class="line">        temp.book_id = ++bookId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function set2Student() external &#123;</span><br><span class="line">        Book memory temp;</span><br><span class="line">        temp.title = unicode&quot;Solidity 高级程序设计&quot;;</span><br><span class="line">        temp.author = &quot;Anbang&quot;;</span><br><span class="line">        temp.book_id = ++bookId;</span><br><span class="line">        students[msg.sender] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-5-删除"><a href="#7-5-5-删除" class="headerlink" title="7.5.5 删除"></a>7.5.5 删除</h3><p>删除结构体的变量，仅仅是重置数据，并不是完全的删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    struct Book &#123;</span><br><span class="line">        string title;</span><br><span class="line">        string author;</span><br><span class="line">        uint256 book_id;</span><br><span class="line">    &#125;</span><br><span class="line">    Book public book = Book(&quot;Solidity&quot;, &quot;Anbang&quot;, 1);</span><br><span class="line"></span><br><span class="line">    function del() external</span><br><span class="line">    &#123;</span><br><span class="line">        delete book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>Solidity 允许类型之间进行隐式转换和显式转换。</p>
<p><strong>前文回顾</strong>: <code>bytes1</code> 对应 <code>uint8</code>，对应两位连续的十六进制数字 <code>0xXX</code>。</p>
<h2 id="8-1-隐式转换"><a href="#8-1-隐式转换" class="headerlink" title="8.1 隐式转换"></a>8.1 隐式转换</h2><h3 id="8-1-1-发生场景"><a href="#8-1-1-发生场景" class="headerlink" title="8.1.1 发生场景"></a>8.1.1 发生场景</h3><p>在<strong>赋值</strong>, <strong>函数参数传递</strong>以及应用运算符时，会发生隐式转换。</p>
<h3 id="8-1-2-转换的标准"><a href="#8-1-2-转换的标准" class="headerlink" title="8.1.2  转换的标准"></a>8.1.2  转换的标准</h3><ol>
<li>值类型</li>
<li>源类型必须是目标类型的子集。</li>
</ol>
<p>例如，<code>uint8</code> 可以转换为 <code>uint16</code>&#x2F;<code>uint24</code>..&#x2F;<code>uint256</code>，因为<code>uint8</code>是<code>uint16</code>这些类型的子集。</p>
<p>但是 <code>int8</code> 不可以转换为 <code>uint256</code>，因为 <code>int8</code> 可以包含 <code>uint256</code> 中不允许的负值，比如 <code>-1</code>。</p>
<h3 id="8-1-3-相交集合的类型，不能隐式转换。"><a href="#8-1-3-相交集合的类型，不能隐式转换。" class="headerlink" title="8.1.3  相交集合的类型，不能隐式转换。"></a>8.1.3  相交集合的类型，不能隐式转换。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    int8 public a1 = 3;</span><br><span class="line"></span><br><span class="line">    // Type int8 is not implicitly convertible to expected type uint16.</span><br><span class="line">    // uint16 public a2 = a1;</span><br><span class="line"></span><br><span class="line">    uint8 public b1 = 3;</span><br><span class="line">    uint16 public b2 = b1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-1-4-把整数字面量赋值给整型时，不能超出范围而发生截断，否则会报错。"><a href="#8-1-4-把整数字面量赋值给整型时，不能超出范围而发生截断，否则会报错。" class="headerlink" title="8.1.4 把整数字面量赋值给整型时，不能超出范围而发生截断，否则会报错。"></a>8.1.4 把整数字面量赋值给整型时，不能超出范围而发生截断，否则会报错。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo1 &#123;</span><br><span class="line">    uint8 public a = 12; // no error</span><br><span class="line">    uint32 public b = 1234; // no error</span><br><span class="line">    uint16 public c = 0x01;</span><br><span class="line"></span><br><span class="line">    // Type int_const 123456 is not implicitly convertible</span><br><span class="line">    // to expected type uint8. Literal is too large to fit in uint8.</span><br><span class="line">    // uint8 d = 123456;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-1-4-函数参数传递"><a href="#8-1-4-函数参数传递" class="headerlink" title="8.1.4 函数参数传递"></a>8.1.4 函数参数传递</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 函数的传参</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint256 public a;</span><br><span class="line"></span><br><span class="line">    function test1(uint256 u_) public &#123;</span><br><span class="line">        a = u_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test2() external &#123;</span><br><span class="line">        uint8 temp = 3;</span><br><span class="line">        test1(temp); //</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 函数的传参</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint256 public a;</span><br><span class="line"></span><br><span class="line">    function test1(uint256[3] memory u_) public &#123;</span><br><span class="line">        a = u_[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 禁止的：</span><br><span class="line">    function test2() external &#123;</span><br><span class="line">        // function call. Invalid implicit conversion from uint8[3]</span><br><span class="line">        // memory to uint256[3] memory requested.</span><br><span class="line">        // test1([1,2,3]);</span><br><span class="line">        test1([uint256(1),uint256(2),uint256(3)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-1-5-运算符应用"><a href="#8-1-5-运算符应用" class="headerlink" title="8.1.5 运算符应用"></a>8.1.5 运算符应用</h3><p>则编译器将尝试将<strong>其中一个操作数</strong>隐式转换为<strong>另一个操作数的类型</strong>（赋值也是如此）。 这意味着操作始终以操作数之一的类型执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 运算符</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint8 public  x = 1;</span><br><span class="line">    uint16 public  y = 2;</span><br><span class="line"></span><br><span class="line">    // uint8 + uint16 =&gt; uint16 + uint16 = uint16</span><br><span class="line">    // uint16 =&gt; uint32</span><br><span class="line">    uint32 public  z = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，加法的操作数 x 和 y 没有相同的类型，uint8 可以被隐式转换为 uint16，相反却不可以。 因此在执行加法之前，将 uint8 转换为 uint16 的类型，结果类型是 uint16。因为它被赋值给 uint32 类型的变量，又进行了另一个类似逻辑的隐式转换.</p>
<h2 id="8-2-显式转换"><a href="#8-2-显式转换" class="headerlink" title="8.2 显式转换"></a>8.2 显式转换</h2><p>可以使用类型关键字，显式地将数据类型转换为另一种类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // uint8 =&gt; uint16</span><br><span class="line">    uint8 public a1 = 3;</span><br><span class="line">    uint16 public a2 = uint16(a1);</span><br><span class="line"></span><br><span class="line">    int8 public b1 = 3;</span><br><span class="line">    //Explicit type conversion not allowed from &quot;int8&quot; to &quot;uint256&quot;.</span><br><span class="line">    // uint256 b2 = uint256(b1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-1-int-uint-整型转换"><a href="#8-2-1-int-uint-整型转换" class="headerlink" title="8.2.1 int&#x2F;uint 整型转换"></a>8.2.1 int&#x2F;uint 整型转换</h3><p>整型加大数据位置是从左侧增加，减小数据位置也是从左侧移除；（<strong>整型是右对齐</strong>）</p>
<ul>
<li>整型转换成更大的类型，从左侧添加填充位。</li>
<li>整型转换成更小的类型，会丢失左侧数据。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // 整型转换成更大的类型，从左侧添加填充位。</span><br><span class="line">    // uint16 =&gt; uint32</span><br><span class="line">    uint16 public a1 = 22136;       // 等于 0x5678</span><br><span class="line">    uint32 public a2 = uint32(a1); // a2 = 22136</span><br><span class="line"></span><br><span class="line">    // uint16 =&gt; uint8</span><br><span class="line">    uint8 public a3 = uint8(a1); // a4 = 0x78</span><br><span class="line">    uint8 public a4 = 0x78;</span><br><span class="line"></span><br><span class="line">    // 整型转换成更小的类型，会丢失左侧数据。</span><br><span class="line">    // uint32 =&gt; uint16</span><br><span class="line">    uint32 public b1 = 0x12345678; // 0x12345678</span><br><span class="line">    uint16 public b2 = uint16(b1); // 0x5678 | b2 = 22136</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>整数显式转换为更大的类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint16 a = 0x1234;</span><br><span class="line">uint32 b = uint32(a); // b 为 0x00001234 now</span><br></pre></td></tr></table></figure>

<p><strong>整数显式转换成更小的类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint32 a = 0x12345678;</span><br><span class="line">uint16 b = uint16(a); // 此时 b 的值是 0x5678</span><br></pre></td></tr></table></figure>

<h3 id="8-2-1-bytes-字节类型转换"><a href="#8-2-1-bytes-字节类型转换" class="headerlink" title="8.2.1 bytes 字节类型转换"></a>8.2.1 bytes 字节类型转换</h3><p>字节加大数据位置是从右侧增加，减小数据位置也是从右侧移除；（<strong>字节是左对齐</strong>）</p>
<ul>
<li>字节转换为更大的类型时，从右侧添加填充位。</li>
<li>字节转换到更小的类型时，丢失右侧数据。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // 字节转换为更大的类型时，从右侧添加填充位。</span><br><span class="line">    // bytes2 =&gt;bytes4</span><br><span class="line">    bytes2 public a1 = 0x5678;</span><br><span class="line">    bytes4 public a2 = bytes4(a1); // a2 = 0x56780000</span><br><span class="line"></span><br><span class="line">    // 字节转换到更小的类型时，丢失右侧数据。</span><br><span class="line">    // bytes4 =&gt; bytes2</span><br><span class="line">    bytes4 public b1 = 0x12345678;</span><br><span class="line">    bytes2 public b2 = bytes2(b1); // b2 = 0x1234</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>bytes 显式转换成更小的类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bytes2 a = 0x1234;</span><br><span class="line">bytes1 b = bytes1(a); // b 为 0x12</span><br></pre></td></tr></table></figure>

<p><strong>bytes 显式转换成更大的类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bytes2 a = 0x1234;</span><br><span class="line">bytes4 b = bytes4(a); // b 为 0x12340000</span><br></pre></td></tr></table></figure>

<h3 id="8-2-3-bytes-与-uint-转换"><a href="#8-2-3-bytes-与-uint-转换" class="headerlink" title="8.2.3 bytes 与 uint 转换"></a>8.2.3 bytes 与 uint 转换</h3><p>只有当字节类型和整数类型大小相同时，才可以进行转换。</p>
<p>因为整数和定长字节数组在截断（或填充）时行为是不同的，如果要在不同的大小的整数和定长字节数组之间进行转换，<strong>必须使用一个中间类型来明确进行所需截断和填充的规则</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bytes2 a = 0x1234;</span><br><span class="line">uint32 b = uint16(a);           // b 为 0x00001234</span><br><span class="line">uint32 c = uint32(bytes4(a));   // c 为 0x12340000</span><br><span class="line"></span><br><span class="line">uint8  d = uint8(uint16(a));    // d 为 0x34</span><br><span class="line">uint8  e = uint8(bytes1(a));    // e 为 0x12</span><br></pre></td></tr></table></figure>

<p><strong>1.bytes 转换成 uint</strong>: <strong>先转类型，再转大小</strong></p>
<ul>
<li>推荐先把 bytes 显示转换成数字类型后，再转换成更大或更小的数字</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// - `uint8`  等于两位连续的十六进制数字 `0xXX`</span><br><span class="line">// - `bytes1` 等于两位连续的十六进制数字 `0xXX`</span><br><span class="line">// - `bytes1` 等于 `uint8`</span><br><span class="line">contract Demo1 &#123;</span><br><span class="line">    // bytes =&gt; uint</span><br><span class="line">    bytes2 public a1 = 0x5678; // : 十进制数字 = 22136</span><br><span class="line">    bytes4 public a2 = bytes4(a1); // a2 = 0x56780000 : 十进制数字 = 1450704896</span><br><span class="line">    bytes1 public a3 = bytes1(a1); // a3 = 0x56 : 十进制数字 = 86</span><br><span class="line"></span><br><span class="line">    // -- 增大</span><br><span class="line">    // bytes 显示转换成数字后，显示转换更大的数字 (这里也可以隐式完成)</span><br><span class="line">    uint32 public a4 = uint32(uint16(a1)); // ✅ a4 = 0x00005678 : 十进制 = 22136</span><br><span class="line">    // bytes 显示转换成更大数字对应的的bytes，然后bytes显示转换成匹配的数字</span><br><span class="line">    uint32 public a5 = uint32(bytes4(a1)); // ❌ a5 = 0x56780000 : 十进制 = 1450704896</span><br><span class="line"></span><br><span class="line">    // -- 减小</span><br><span class="line">    // bytes 显示转换成数字后，显示转换成更小的数字</span><br><span class="line">    uint8 public a6 = uint8(uint16(a1)); // ✅ a6 = 0x78 : 十进制 = 120</span><br><span class="line">    // bytes 显示转换成更小数字对应的的bytes，然后bytes显示转换成匹配的数字</span><br><span class="line">    uint8 public a7 = uint8(bytes1(a1)); // ❌ a7 = 0x56 : 十进制 = 86</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.uint 转换成 bytes</strong>: <strong>先转大小，再转类型</strong></p>
<ul>
<li>推荐先把 uint 显示转换成更大 bytes 对应的 uint，然后 uint 再显示转换成匹配的 bytes</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo2 &#123;</span><br><span class="line">    // uint =&gt; bytes</span><br><span class="line">    uint16 public b1 = 0x5678; // 0x5678 : 十进制 = 22136</span><br><span class="line">    uint32 public b2 = uint32(b1); // b2 = 0x00005678 : 十进制 = 22136</span><br><span class="line">    uint8 public b3 = uint8(b1); // b3 = 0x78 : 十进制 = 120</span><br><span class="line">    // -- 增大</span><br><span class="line">    // uint 显示转换成bytes类型后，再显示转换成更大或更小的bytes</span><br><span class="line">    bytes4 public b4 = bytes4(bytes2(b1)); // ❌ b4 = 0x56780000</span><br><span class="line">    // uint 显示转换成更大bytes对应的uint，然后uint再显示转换成匹配的bytes</span><br><span class="line">    bytes4 public b5 = bytes4(uint32(b1)); //  ✅ b5 = 0x00005678</span><br><span class="line"></span><br><span class="line">    // -- 减小</span><br><span class="line">    // uint 显示转换成bytes类型后，再显示转换成更大或更小的bytes</span><br><span class="line">    bytes1 public b6 = bytes1(bytes2(b1)); // ❌ b4 = 0x56</span><br><span class="line">    // uint 显示转换成更大bytes对应的uint，然后uint再显示转换成匹配的bytes</span><br><span class="line">    bytes1 public b7 = bytes1(uint8(b1)); // ✅ b4 = 0x78</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-4-bytes-和-bytesN-之间转换"><a href="#8-2-4-bytes-和-bytesN-之间转换" class="headerlink" title="8.2.4 bytes 和 bytesN 之间转换"></a>8.2.4 bytes 和 bytesN 之间转换</h3><p><code>bytes</code> 数组和 <code>bytes calldata</code> 切片可以显示转换为固定长度的 bytes 类型(<code>bytes1...bytes32</code>).</p>
<ul>
<li>如果数组比固定长度的 bytes 类型长，则在末尾处会发生截断。</li>
<li>如果数组比目标类型短，它将在末尾用零填充。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    // 0x6162636465666768</span><br><span class="line">    bytes public bts = &quot;abcdefgh&quot;;</span><br><span class="line">    bytes3 public b1 = bytes3(bts);</span><br><span class="line">    bytes8 public b2 = bytes8(bts);</span><br><span class="line">    bytes16 public b3 = bytes16(bts);</span><br><span class="line">    bytes32 public b4 = bytes32(bts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充</strong>：使用切片也可以把数据从 bytes 转为 bytesN。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    // 0x6162636465666768</span><br><span class="line">    bytes public bts = &quot;abcdefgh&quot;;</span><br><span class="line"></span><br><span class="line">    function f(bytes calldata bts_)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes3,bytes16)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        bytes3 b1 = bytes3(bts_);</span><br><span class="line">        bytes16 b2 = bytes16(bts_[:8]);</span><br><span class="line">        return (b1, b2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-5-bytes-与-address-转换"><a href="#8-2-5-bytes-与-address-转换" class="headerlink" title="8.2.5 bytes 与 address 转换"></a>8.2.5 bytes 与 address 转换</h3><p>address 的格式是 <code>0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac</code>，是一个 <strong>bytes20</strong> 的数据。</p>
<p>地址是取 <code>bytes32</code> 数据中的后 20 位。如果想删除前面的 12 位数据，可以使用 solidity assembly (内联汇编) 来截取，也可以借助 <code>uint</code> 转换成更小的类型，会丢失左侧数据的特性来完成。</p>
<p>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // 获取即将部署的地址</span><br><span class="line">    function getAddress(bytes memory bytecode, uint256 _salt)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (address)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes32 hash = keccak256(</span><br><span class="line">            abi.encodePacked(</span><br><span class="line">                bytes1(0xff), // 固定字符串</span><br><span class="line">                address(this), // 当前工厂合约地址</span><br><span class="line">                _salt, // salt</span><br><span class="line">                keccak256(bytecode) //部署合约的 bytecode</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        // bytes 转换成 uint: 先转类型，再转大小</span><br><span class="line">        //      bytes32 =&gt; uint256 =&gt; uint160</span><br><span class="line">        // uint160 转 address</span><br><span class="line">        //      uint160 =&gt; address</span><br><span class="line">        return address(uint160(uint256(hash)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前文介绍过编码的方式: <code>keccak256(abi.encodePacked())</code>，返回的是 <code>bytes32</code> 类型。</p>
<p>这个小例子是<strong>合约部署合约</strong>那章节中 create2 代码的一部分，相关的更多演示请查看 create2 创建。</p>
<h2 id="8-3-数字转换成字符串"><a href="#8-3-数字转换成字符串" class="headerlink" title="8.3 数字转换成字符串"></a>8.3 数字转换成字符串</h2><h3 id="8-3-1-直接借助-bytes-和-string（未完成）"><a href="#8-3-1-直接借助-bytes-和-string（未完成）" class="headerlink" title="8.3.1 直接借助 bytes 和 string（未完成）"></a>8.3.1 直接借助 bytes 和 string（未完成）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // `固定大小字节数组` —&gt; `动态大小字节数组` —&gt; `string`</span><br><span class="line">    function test(uint8 num_) public pure returns (bytes1 ab,string memory data) &#123;</span><br><span class="line">        // 固定大小字节数组</span><br><span class="line">        ab = bytes1(num_);</span><br><span class="line"></span><br><span class="line">        // `固定大小字节数组` —&gt; `动态大小字节数组`</span><br><span class="line">        bytes memory temp = new bytes(ab.length); // 可变字节数组创建方式</span><br><span class="line">        for (uint8 i = 0; i &lt; ab.length; i++) &#123;</span><br><span class="line">            temp[i] = ab[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // `动态大小字节数组` —&gt; `string`</span><br><span class="line">        data = string(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-2-借助单个数字转换（推荐）"><a href="#8-3-2-借助单个数字转换（推荐）" class="headerlink" title="8.3.2 借助单个数字转换（推荐）"></a>8.3.2 借助单个数字转换（推荐）</h3><p>这种方法是借助将 0-9 的数字进行转换，然后超过十位的数字，通过 <code>%</code> 来得到，并且拼接在一起。<br>推荐方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function uintToString(uint256 _uint)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (string memory str)</span><br><span class="line">    &#123;</span><br><span class="line">        if (_uint == 0) return &quot;0&quot;;</span><br><span class="line">        while (_uint != 0) &#123;</span><br><span class="line">            //取模</span><br><span class="line">            uint256 remainder = _uint % 10;</span><br><span class="line">            //每取一位就移动一位，个位、十位、百位、千位……</span><br><span class="line">            _uint = _uint / 10;</span><br><span class="line">            //将字符拼接，注意字符位置</span><br><span class="line">            str =  string.concat(toStr(remainder), str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function toStr(uint256 num_) internal pure returns (string memory) &#123;</span><br><span class="line">        require(num_ &lt; 10,&quot;error&quot;);</span><br><span class="line">        bytes memory alphabet = &quot;0123456789&quot;;</span><br><span class="line">        bytes memory str = new bytes(1);</span><br><span class="line">        str[0] = alphabet[num_];</span><br><span class="line">        return string(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/06/09/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/01-%E5%88%9D%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/09/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/01-%E5%88%9D%E8%AF%86/" class="post-title-link" itemprop="url">01-初识</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-09 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-09T00:00:00+08:00">2022-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p>Solidity 是在兼容 EVM 的区块链上开发智能合约的语言，我们不需要关心所在区块链底层逻辑，只要是兼容 EVM 的公链，我们都可以使用 Solidity 进行智能合约的编码。简单了解以下的区块链概念：</p>
<h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1><p>你可能听过区块链的双花攻击，女巫攻击等作恶方式。如果你没有听过也没有关系，因为它们对于智能合约开发来说并不重要，我们编写的 Solidity 代码能运行在以太坊网络，也可以运行在 BSC， Matic，Eos EVM 网络等，就像前文说的那样，无论他们采用什么底层逻辑，只要它们支持 EVM 就足够了，底层逻辑不用关心。</p>
<p>我们需要关心的是，<strong>区块可能被回滚，交易可能被作废</strong>，所以会出现你发起的交易被回滚甚至从区块链中抹除掉的可能。区块链不能保证当前的交易一定包含在下一个区块中。如果你开发的合约有顺序关系，要注意这个特性。合约内的逻辑，不能将某一个块作为依赖。</p>
<h1 id="合约代码中的三种注释"><a href="#合约代码中的三种注释" class="headerlink" title="合约代码中的三种注释"></a>合约代码中的三种注释</h1><p>我们看到第一行的代码是 <code>// SPDX-License-Identifier: MIT</code> 这里面的 <code>//</code> 符号，是注释符。用来标记和记录代码开发相关的事情，注释的内容是不会被程序运行，Solidity 支持单行注释和块注释，注释是为了更好的解释代码。<strong>请不要相信好的代码不需要注释这种鬼言论</strong>。代码中加入注释可以更好的团队协作，让自己更好的进行代码开发，以及让阅读者更快捷的理解代码逻辑。在实际工作中经常会出现自己写的代码一年半载之后再看，复杂些的逻辑可能需要浪费很多时间在代</p>
<h2 id="2-1-单行注释"><a href="#2-1-单行注释" class="headerlink" title="2.1 单行注释"></a>2.1 单行注释</h2><p>格式: <code>// 注释内容</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">// 这是单行注释</span><br></pre></td></tr></table></figure>

<p>如上，<code>//</code> 后面的内容都会被编译器忽略，为了可读性，一般会在<code>//</code>后面加一个空格。</p>
<h2 id="2-2-块注释"><a href="#2-2-块注释" class="headerlink" title="2.2 块注释"></a>2.2 块注释</h2><p>格式如下，在 <code>/*</code> 与 <code>*/</code> 之间的内容，都被编译器忽略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">这是块注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>为了可读性，一般块注释的行首都加 <code>*</code> 和空格，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 这是块注释</span><br><span class="line">* 这是块注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h2 id="2-3-NatSpec-描述注释"><a href="#2-3-NatSpec-描述注释" class="headerlink" title="2.3 NatSpec 描述注释"></a>2.3 NatSpec 描述注释</h2><p>单行使用 <code>///</code> 开始，多行使用 <code>/**</code> 开头以 <code>*/</code> 结尾。NatSpec 描述注释的作用非常重要，它是为函数、返回变量等提供丰富的文档。在编写合约的时候，强烈推荐使用 <code>NatSpec</code> 为所有的开放接口（只要是在 <code>ABI</code> 里呈现的内容）进行完整的注释。</p>
<h4 id="简单演示"><a href="#简单演示" class="headerlink" title="简单演示"></a>简单演示</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">/// @title  一个简单的数据存储演示</span><br><span class="line">/// @author Anbang</span><br><span class="line">/// @notice 您智能将此合约用于最基本的演示</span><br><span class="line">/// @dev    提供了存储方法/获取方法</span><br><span class="line">/// @custom  自定义的描述/这个是实验的测试合约</span><br><span class="line">contract  TinyStorage &#123;</span><br><span class="line">    // data</span><br><span class="line">    uint256 storedData;</span><br><span class="line"></span><br><span class="line">    /// @notice 储存 x</span><br><span class="line">    /// @param _x: storedData 将要修改的值</span><br><span class="line">    /// @dev   将数字存储在状态变量 storedData 中</span><br><span class="line">    function set(uint256 _x) public&#123;</span><br><span class="line">        storedData = _x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// @notice 返回存储的值</span><br><span class="line">    /// @return 储存值</span><br><span class="line">    /// @dev   检索状态变量 storedData 的值</span><br><span class="line">    function get() public view returns(uint256)&#123;</span><br><span class="line">        return storedData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice 第二种写法</span><br><span class="line">     * @param _x: XXXXX</span><br><span class="line">     * @dev   XXXXX</span><br><span class="line">     * @return XXXXX</span><br><span class="line">     * @inheritdoc :</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面所有标签都是可选的。下表解释了每个 NatSpec 标记的用途以及可以使用在哪些位置。我们可以选择合适的标记进行记录</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
<th>语境</th>
</tr>
</thead>
<tbody><tr>
<td><code>@title</code></td>
<td>描述 contract&#x2F;interface 的标题</td>
<td>contract, interface, library</td>
</tr>
<tr>
<td><code>@author</code></td>
<td>作者姓名</td>
<td>contract, interface, library</td>
</tr>
<tr>
<td><code>@notice</code></td>
<td>向最终用户解释这是做什么的</td>
<td>contract, interface, library, function, 公共状态变量 event</td>
</tr>
<tr>
<td><code>@dev</code></td>
<td>向开发人员解释任何额外的细节</td>
<td>contract, interface, library, function, 状态变量, event</td>
</tr>
<tr>
<td><code>@param</code></td>
<td>记录参数（后面必须跟参数名称）</td>
<td>function, event, 自定义错误</td>
</tr>
<tr>
<td><code>@return</code></td>
<td>函数的返回变量</td>
<td>function, 公共状态变量</td>
</tr>
<tr>
<td><code>@inheritdoc</code></td>
<td>从基本函数中复制所有缺失的标签（必须后跟合约名称）</td>
<td>function, 公共状态变量</td>
</tr>
<tr>
<td><code>@custom:...</code></td>
<td>自定义标签，语义由应用程序定义</td>
<td>所有位置均可以</td>
</tr>
</tbody></table>
<h4 id="文档输出"><a href="#文档输出" class="headerlink" title="文档输出"></a>文档输出</h4><p>使用 <code>NatSpec</code> 描述注释的另一个好处是，当被编译器解析时，上面示例中的代码将生成两个不同的 JSON 文件。</p>
<ul>
<li>User Documentation：供最终用户在执行功能时作为通知使用的</li>
<li>Developer Documentation：供开发人员使用的。</li>
</ul>
<p>如果将上述合约另存为，<code>a.sol</code> 则您可以使用以下命令生成文档：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solc --userdoc --devdoc a.sol</span><br></pre></td></tr></table></figure>

<h4 id="继承说明"><a href="#继承说明" class="headerlink" title="继承说明"></a>继承说明</h4><p>TODO: 在后面合约继承的时候再演示使用。</p>
<p>如果函数是继承别的合约，没有 NatSpec 的函数将自动继承其基本函数的文档。但是下面三种情况是例外的：</p>
<ul>
<li>当参数名称不同时。<ul>
<li>这时候是函数的重载，函数签名已经发生了改变。</li>
</ul>
</li>
<li>当有多个基本功能时。<ul>
<li>这时候因为发生了冲突，supper 中有多个父级</li>
</ul>
</li>
<li>当有一个明确的 <code>@inheritdoc</code> 标签指定应该使用哪个合约来继承时。</li>
</ul>
<p>更多 NatSpec 请参考: <a target="_blank" rel="noopener" href="https://github.com/aragon/radspec">https://github.com/aragon/radspec</a></p>
<h1 id="合约结构介绍"><a href="#合约结构介绍" class="headerlink" title="合约结构介绍"></a>合约结构介绍</h1><h2 id="3-1-SPDX-版权声明https-spdx-org-licenses"><a href="#3-1-SPDX-版权声明https-spdx-org-licenses" class="headerlink" title="3.1 SPDX 版权声明https://spdx.org/licenses/"></a>3.1 SPDX 版权声明<a target="_blank" rel="noopener" href="https://spdx.org/licenses/">https://spdx.org/licenses/</a></h2><p> <code>// SPDX-License-Identifier: MIT</code> 就是合约的版权声明。其中 <strong>SPDX-License-Identifier</strong>(SPDX 许可标示) 是标注当前的智能合约采用什么样的对外开放标准，该标准规定了别人是否拥有商业开发，学习使用等权利。代码中使用的 <code>MIT</code> 规定了其他人随便用该代码，但出问题不负责。SPDX 许可标示的注释在文件的任何位置都可以被编译器识别到的，按照规范建议把它放在文件的顶部第一行。</p>
<p>如果一个项目开源了智能合约的源代码，可以更好地建立社区信任。但是由于提供源代码就不可避免的涉及到版权或者法律问题。所以 solidity 鼓励开源，但是开源并不等于放弃版权。如果你不想指定任何许可证，或者代码就是不想开源，Solidity 推荐使用 <code>UNLICENSED</code> ;<code>UNLICENSED</code> 不存在于 SPDX 许可证列表中,与 UNLICENSE （授予所有人所有权利）不同，它比 <code>UNLICENSE</code> 多一个 <code>D</code> 字母。</p>
<p>需要注意: 源代码这里，编译器不会验证 SPDX 许可标示是否符合规范，比如我可以写为 <code>// SPDX-License-Identifier: ANBANG</code> ，并不会影响代码的运行。但是这里的标示会被打包在 <code>bytecode metadata</code> 里。</p>
<h2 id="3-2-pragma-solidity-版本限制"><a href="#3-2-pragma-solidity-版本限制" class="headerlink" title="3.2 pragma solidity 版本限制"></a>3.2 pragma solidity 版本限制</h2><p> <code>pragma solidity ^0.8.17;</code> 指令，它是告诉编译器，我当前的合约代码采用的是 Solidity 0.8.17 这个版本为基础编写的，解析部署时需要在匹配的版本下进行，在区块链浏览器上进行合约验证时，也需要选择匹配的版本。</p>
<p>而 <code>^0.8.17</code> 中的 <code>^</code> 表示小版本兼容，大版本不兼容，相当于 <code>pragma solidity &gt;= 0.8.17 &lt; 0.9.0;</code>。他既不允许低于<code>0.8.17</code>的编译器编译，也不允许大于等于 <code>0.9.0</code> 版本的编译器进行编译。之所以这么写，不写死 <code>pragma solidity 0.8.17;</code> 是为了可以享受到编译器的补丁版，比如以后出来了 <code>0.8.40</code> 版本，那么当前合约是可以运行在未来的 <code>0.8.40</code> 这个新版本的编译器。但是如果是大版本升级到了 <code>0.9.0</code>，那么编译器不会用新版的<code>0.9.x</code>解析，会使用 0.8 的最后一个稳定版本来进行解析编译。这里如果不加 <code>^</code>,直接写<code>pragma solidity 0.8.17;</code>,就是告诉编译器，当前合约只选择在 <code>0.8.17</code> 版本来编译和部署；这样做的缺点就是享受不到以后出的补丁版的编译器。</p>
<p>如果你打算跨大版本的合约，可以使用<code>&gt;</code> &#x2F;<code>&gt;=</code>&#x2F;<code>&lt;</code>&#x2F;<code>&lt;=</code>来操作，比如 <code>pragma solidity &gt;=0.7.0 &lt;0.9.0;</code>。</p>
<blockquote>
<p>注意：<code>pragma</code> 指令只对当前的源文件起作用，如果把文件 <code>B</code> 导入到文件 <code>A</code>，文件 B 的 pragma 将不会自动应用于文件 A。</p>
</blockquote>
<h1 id="import-导入声明"><a href="#import-导入声明" class="headerlink" title="import 导入声明"></a>import 导入声明</h1><p>功能：从其他文件内倒入需要的变量或者函数。</p>
<p>既可以导入<strong>本地文件</strong>，也可以导入 <strong>url</strong>(网络上的 ipfs，http 或者 git 文件)</p>
<ol>
<li><p>导入所有的全局标志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;filename&quot;;</span><br></pre></td></tr></table></figure>

<p>到当前全局范围</p>
<ol>
<li>导入本地文件:<code>import &quot;./ERC20.sol&quot;;</code>，其中<code>./</code>表示当前目录，查找路径参考</li>
<li>导入网络文件:<code>import &quot;https://github.com/aaa/.../tools.sol&quot;;</code></li>
<li>导入本地 NPM 库:<ol>
<li><code>$ npm install @openzeppelin/contracts</code></li>
<li><code>import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;;</code></li>
</ol>
</li>
</ol>
</li>
<li><p>导入所有的全局标志，并创建新的全局符号</p>
<ol>
<li>方式一: <code>import * as symbolName from &quot;filename&quot;;</code></li>
<li>方式二: <code>import &quot;filename&quot; as symbolName;</code></li>
</ol>
</li>
<li><p>按需导入，按需修改名称</p>
<ol>
<li><code>import &#123;symbol1 as aliasName, symbol2&#125; from &quot;filename&quot;;</code></li>
</ol>
</li>
</ol>
<p>不推荐导入变量标示名到当前全局范围的方式，因为不可控，容易污染当前的命名空间。如果全局导入，推荐使用 <code>import &quot;filename&quot; as symbolName;</code></p>
<p>注：一份源文件可以包含多个版本声明、多<strong>个导入声明</strong>和多个合约声明。</p>
<h1 id="fallback"><a href="#fallback" class="headerlink" title="fallback"></a>fallback</h1><p>fallback 函数是调用合约没有的方法时候执行，同时也可以设置为允许接收网络主币。</p>
<ul>
<li><p>语法</p>
<ul>
<li>不带参数: <code>fallback () external [payable]</code></li>
<li>带参数: <code>fallback (bytes calldata input) external [payable] returns (bytes memory output)</code></li>
<li>没有<code>function</code>关键字。必须是<code>external</code>可见性，</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// function fallback() external payable &#123;&#125;</span><br><span class="line">// 正确写法不带 function，直接写 fallback，fallback 如果使用 function 修饰，则有警告</span><br><span class="line">// This function is named &quot;fallback&quot; but is not the fallback function of the contract.</span><br><span class="line">// If you intend this to be a fallback function, use  &quot;fallback(...) &#123; ... &#125;&quot; without</span><br><span class="line">// the &quot;function&quot; keyword to define it.</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>回退函数在两种情况被调用</strong>：</p>
<ul>
<li>向合约转账；<ul>
<li>如果使用 call 转账，会执行 fallback。</li>
<li>如果使用合约内已有的 <code>deposit</code> 转账，不会执行 fallback</li>
</ul>
</li>
<li>执行合约不存在的方法<ul>
<li>就会执行 fallback 函数。（执行合约不存在的方法时执行）</li>
</ul>
</li>
</ul>
<h1 id="receive-以太函数"><a href="#receive-以太函数" class="headerlink" title="receive 以太函数"></a>receive 以太函数</h1><p>receive 只负责接收主币,一个合约最多有一个 <code>receive</code> 函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">receive() external payable &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>没有 <code>function</code> 关键字</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// function receive() external payable &#123;&#125;</span><br><span class="line">// receive 如果使用 function 修饰，则有如下警告</span><br><span class="line">// This function is named &quot;receive&quot; but is not the receive function of</span><br><span class="line">// the contract. If you intend this to be a receive function,</span><br><span class="line">// use &quot;receive(...) &#123; ... &#125;&quot; without the &quot;function&quot; keyword to define it.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>receive 函数类型必须是 <code>payable</code> 的，并且里面的语句只有在通过外部地址往合约里转账的时候执行。</p>
</li>
<li><p>它可以是 <code>virtual</code> 的，可以被重载也可以有 修改器(modifier) 。</p>
</li>
<li><p>如果没有定义 <code>接收函数 receive</code>，就会执行 <code>fallback</code> 函数。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    event Log(string funName, address from, uint256 value, bytes data);</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        // receive 被调用的时候不存在 msg.data，所以不使用这个，直接用空字符串</span><br><span class="line">        emit Log(&quot;receive&quot;, msg.sender, msg.value, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() external view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子通过 calldata 执行转账，无参数时候会触发 receive 函数。但是如果有参数，比如<code>0x00</code>,则会报错 <em>‘Fallback’ function is not defined</em></p>
<p>在对合约没有任何附加数据调用（通常是对合约转账）是会执行 <code>receive</code>函数．例如　通过 <code>.send()</code> or <code>.transfer()</code>。</p>
<p>声明为 payable 之后，其所消耗的 gas 最大量就会被限定在 2300。除了基础的日志输出之外，进行其他操作的余地很小。下面的操作消耗会操作 2300 gas :</p>
<p>扩展阅读 ⚠️: 一个没有 receive 函数的合约，可以作为 <em>coinbase 交易</em> （又名<em>矿工区块回报</em> ）的接收者或者作为 <code>selfdestruct</code> 的目标来接收以太币。一个合约不能对这种以太币转移做出反应，因此也不能拒绝它们。这是 EVM 在设计时就决定好的，而且 Solidity 无法绕过这个问题。这也意味着 <code>address(this).balance</code> 可以高于合约中实现的一些手工记帐的总和（例如在 receive 函数中更新的累加器记帐）。</p>
<h1 id="receive-和-fallback-共存的调用"><a href="#receive-和-fallback-共存的调用" class="headerlink" title="receive 和 fallback 共存的调用"></a>receive 和 fallback 共存的调用</h1><p>注意：这里 fallback 需要是 <code>payable</code> 类型的。如下图:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    调用时发送了ETH</span><br><span class="line">            |</span><br><span class="line">判断 msg.data 是否为空</span><br><span class="line">          /     \</span><br><span class="line">        是       否</span><br><span class="line">是否存在 receive   fallbak()</span><br><span class="line">      /   \</span><br><span class="line">    存在   不存在</span><br><span class="line">    /        \</span><br><span class="line">receive()   fallbak()</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>: 只有 <code>msg.data</code> 为空，并且存在 <code>receive</code> 的时候，才会运行 <code>receive</code>。</p>
<p>如果不存在 <code>receive</code> 以太函数，<code>payable</code> 的 <code>fallback</code> 函数也可以在纯以太转账的时候执行。但是推荐总是定义一个 receive 函数，而不是定义一个 payable 的 fallback 函数。</p>
<h1 id="selfdestruct-合约自毁"><a href="#selfdestruct-合约自毁" class="headerlink" title="selfdestruct:合约自毁"></a>selfdestruct:合约自毁</h1><p>合约代码从区块链上移除的唯一方式是合约在合约地址上的执行自毁操作 <code>selfdestruct</code> 。<code>selfdestruct</code> 作用是 <strong>销毁合约</strong>，并<strong>把余额发送到指定地址类型 Address</strong>。</p>
<p>做了两件事：</p>
<ul>
<li>销毁合约:它使合约变为无效，删除该地址地字节码。</li>
<li>它把合约的所有资金强制发送到目标地址。<ul>
<li>如果接受的地址是合约，即使里面没有 <code>fallback</code> 和 <code>receive</code> 也会发送过去</li>
</ul>
</li>
<li>除非必要，不建议销毁合约。<ul>
<li>如果有人发送以太币到移除的合约，这些以太币可能将永远丢失</li>
<li>如果要禁用合约，可以通过修改某个内部状态让所有函数无法执行，这样也可以达到目的。</li>
</ul>
</li>
<li>即便一个合约的代码中没有显式地调用 <code>selfdestruct</code>，它仍然有可能通过 <code>delegatecall</code> 或 <code>callcode</code> 执行自毁操作。</li>
</ul>
<p>⚠️：即使一个合约被 <code>selfdestruct</code> 删除，它仍然是区块链历史的一部分，区块链的链条中不可能无缘无故消失一个块，这样他们就没办法做校验了。 因此，使用 <code>selfdestruct</code> 与从硬盘上删除数据是不同的。</p>
<p>请注意 <code>selfdestruct</code> 具有从 EVM 继承的一些特性：</p>
<ul>
<li>接收合约的 <code>receive</code> 函数 不会执行。</li>
<li>合约仅在交易结束时才真正被销毁，并且 <code>revert</code> 可能会“撤消”销毁。此外，当前合约内的所有函数都可以被直接调用，包括当前函数。</li>
</ul>
<h2 id="8-1自我毁灭"><a href="#8-1自我毁灭" class="headerlink" title="8.1自我毁灭"></a>8.1自我毁灭</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Kill &#123;</span><br><span class="line">    uint256 public aaa = 123;</span><br><span class="line"></span><br><span class="line">    function kill() external&#123;</span><br><span class="line">        selfdestruct(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-2通过合约调用毁灭"><a href="#8-2通过合约调用毁灭" class="headerlink" title="8.2通过合约调用毁灭"></a>8.2通过合约调用毁灭</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Kill &#123;</span><br><span class="line">    uint256 public aaa = 123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function kill() external &#123;</span><br><span class="line">        selfdestruct(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Helper &#123;</span><br><span class="line">    // 没有 `fallback` 和 `receive`，正常没办法接受ETH主币</span><br><span class="line">    function getBalance() external view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // kill 后，此时 Helper 余额就会强制收到ETH主币</span><br><span class="line">    function kill(Kill _kill) external &#123;</span><br><span class="line">        _kill.kill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h1><ul>
<li><p><strong>栈</strong>：合约的所有计算都在一个被称为栈（stack）的区域执行，栈最大有 1024 个元素，每一个元素长度是 256 bit；所以调用深度被限制为 1024 ，对复杂的操作，推荐使用循环而不是递归。</p>
</li>
<li><p><code>string message = &quot;Hello World!&quot;;</code> 这种没有明确标注可视范围的情况下，<code>message</code> 的可视范围是什么? 是 <code>internal</code> 还是 <code>private</code>?</p>
<ul>
<li>private</li>
</ul>
</li>
<li><p>合约进行<code>selfdestruct</code>后，还可以调用状态变量和函数么？</p>
<ul>
<li>可以调用，但是返回默认值。如果想调用，也可以在存档节点里指定未删除的高度进行调用。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/06/06/%E5%8C%BA%E5%9D%97%E9%93%BE/Gas%E4%BC%98%E5%8C%96/%E6%8E%A7%E5%88%B6Gas%E6%88%90%E6%9C%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/06/%E5%8C%BA%E5%9D%97%E9%93%BE/Gas%E4%BC%98%E5%8C%96/%E6%8E%A7%E5%88%B6Gas%E6%88%90%E6%9C%AC/" class="post-title-link" itemprop="url">控制Gas成本</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-06 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-06T00:00:00+08:00">2022-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Gas%E4%BC%98%E5%8C%96/" itemprop="url" rel="index">
                    <span itemprop="name">Gas优化</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>487</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="优化合约"><a href="#优化合约" class="headerlink" title="优化合约"></a>优化合约</h1><p>Solidity 编译器内置了一些优化器来改进合约的执行效率和生成更高效的字节码：</p>
<p>使用<code>--optimize</code>选项来启用优化器,使用<code>--optimize-runs</code>选项来指定优化器运行的次数</p>
<p><strong>solc –optimize (–optimize-runs 200) MyContract.sol</strong> </p>
<p>truffle、hardhat、Remix中都有配置这个选项</p>
<h1 id="与永久性存储交互"><a href="#与永久性存储交互" class="headerlink" title="与永久性存储交互"></a>与永久性存储交互</h1><blockquote>
<p>以太坊上有三种数据存储位置： 内存（memory）、（永久性）存储（storage）以及调用数据calldata</p>
</blockquote>
<p>查看<a target="_blank" rel="noopener" href="https://ethereum.github.io/yellowpaper/paper.pdf"><em>以太坊黄皮书</em></a> 附录G 全面了解EVM操作码成本。</p>
<p>永久性存储操作码(<code>SSTORE</code>)非常昂贵。首次写插槽时，每个32个字节的当前成本是为20,000 Gas(在10 Gwei gas价格下为5美分，每ETH为250美元)，而后续每次修改则为5,000 Gas。尽管从理论上讲复杂度成本是<code>恒定的</code>，但它却是算术或内存运算成本的一千倍以上，而算术或内存运算的成本通常不到10 Gas。目前整个区块(截至2020年10月)的Gas限制为〜12,000,000 Gas实，开发人员应设计其智能合约以最大程度地减少所需的存储插槽数量。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/06/06/%E5%8C%BA%E5%9D%97%E9%93%BE/Gas%E4%BC%98%E5%8C%96/%E8%8A%82%E7%9C%81Gas%E7%9A%84%E5%90%88%E7%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/06/%E5%8C%BA%E5%9D%97%E9%93%BE/Gas%E4%BC%98%E5%8C%96/%E8%8A%82%E7%9C%81Gas%E7%9A%84%E5%90%88%E7%BA%A6/" class="post-title-link" itemprop="url">节省Gas的合约</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-06 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-06T00:00:00+08:00">2022-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-09 10:01:35" itemprop="dateModified" datetime="2023-11-09T10:01:35+08:00">2023-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Gas%E4%BC%98%E5%8C%96/" itemprop="url" rel="index">
                    <span itemprop="name">Gas优化</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="使用短路模式排序Solidity操作"><a href="#使用短路模式排序Solidity操作" class="headerlink" title="使用短路模式排序Solidity操作"></a>使用短路模式排序Solidity操作</h1><p>短路（short-circuiting）是一种使用或&#x2F;与逻辑来排序不同成本操作的solidity合约 开发模式，它<strong>将低gas成本的操作放在前面</strong>，高gas成本的操作放在后面，这样如果前面的低成本操作可行，就可以跳过（短路）后面的高成本以太坊虚拟机操作了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f(x) 是低gas成本的操作</span></span><br><span class="line"><span class="comment">// g(y) 是高gas成本的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按如下排序不同gas成本的操作</span></span><br><span class="line"><span class="built_in">f</span>(x) || <span class="built_in">g</span>(y)</span><br><span class="line"><span class="built_in">f</span>(x) &amp;&amp; <span class="built_in">g</span>(y)</span><br></pre></td></tr></table></figure>

<h1 id="删减不必要的Solidity库"><a href="#删减不必要的Solidity库" class="headerlink" title="删减不必要的Solidity库"></a>删减不必要的Solidity库</h1><p>在开发Solidity智能合约时，我们引入的库<strong>通常只需要用到其中的部分功能</strong>，这意味着其中可能会包含大量对于你的智能合约而言其实是冗余的solidity代码。如果可以在你自己的合约里安全有效地实现所依赖的库功能，那么就能够达到优化solidity合约的gas利用的目的。</p>
<p>例如，在下面的solidity代码中，我们的以太坊合约只是用到了SafeMath库的<code>add</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;./SafeMath.sol&#x27; as SafeMath;</span><br><span class="line"></span><br><span class="line">contract SafeAddition &#123;</span><br><span class="line"> function safeAdd(uint a, uint b) public pure returns(uint) &#123;</span><br><span class="line"> return SafeMath.add(a, b);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过参考SafeMath的这部分代码的实现，可以把对这个solidity库的依赖剔除掉：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract SafeAddition &#123;</span><br><span class="line"> function safeAdd(uint a, uint b) public pure returns(uint) &#123;</span><br><span class="line"> uint c = a + b;</span><br><span class="line"> require(c &gt;= a, &quot;Addition overflow&quot;);</span><br><span class="line"> return c;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="精确声明Solidity合约函数的可见性"><a href="#精确声明Solidity合约函数的可见性" class="headerlink" title="精确声明Solidity合约函数的可见性"></a>精确声明Solidity合约函数的可见性</h1><p>在Solidity合约开发中，显式声明函数的可见性不仅可以提高智能合约的安全性， 同时也有利于优化合约执行的gas成本。例如，通过显式地标记函数为外部函数（External），可以强制将函数参数的存储位置设置为<code>calldata</code>，这会节约每次函数执行时所需的以太坊gas成本。</p>
<blockquote>
<p>External 可见性比 public 消耗gas 少</p>
</blockquote>
<h1 id="使用适合的数据类型"><a href="#使用适合的数据类型" class="headerlink" title="使用适合的数据类型"></a>使用适合的数据类型</h1><p>在Solidity中，有些数据类型要比另外一些数据类型的gas成本高。有必要 了解可用数据类型的gas利用情况，以便根据你的需求选择效率最高的那种。 下面是关于solidity数据类型gas消耗情况的一些规则：</p>
<ul>
<li>在任何可以使用<code>uint</code>类型的情况下，不要使用<code>string</code>类型</li>
<li>存储uint256要比存储uint8的gas成本低，为什么？点击这里查看<a target="_blank" rel="noopener" href="https://ethereum.stackexchange.com/questions/3067/why-does-uint8-cost-more-gas-than-uint256">原文</a></li>
<li>当可以使用<code>bytes</code>类型时，不要在solidity合约种使用<code>byte[]</code>类型</li>
<li>如果<code>bytes</code>的长度有可以预计的上限，那么尽可能改用bytes1~bytes32这些具有固定长度的solidity类型</li>
<li>bytes32所需的gas成本要低于string类型</li>
</ul>
<h1 id="避免Solidity智能合约中的死代码"><a href="#避免Solidity智能合约中的死代码" class="headerlink" title="避免Solidity智能合约中的死代码"></a>避免Solidity智能合约中的死代码</h1><p>死代码（Dead code）是指那些永远也不会执行的Solidity代码，例如那些执行条件永远也不可能满足的代码，就像下面的两个自相矛盾的条件判断里的Solidity代码块，消耗了以太坊gas资源但没有任何作用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function deadCode(uint x) public pure &#123;</span><br><span class="line"> if(x &lt; 1) &#123;</span><br><span class="line">    if(x &gt; 2) &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="避免使用不必要的条件判断"><a href="#避免使用不必要的条件判断" class="headerlink" title="避免使用不必要的条件判断"></a>避免使用不必要的条件判断</h1><p>有些条件断言的结果不需要Solidity代码的执行就可以知道结果，那么这样的条件判断就可以精简掉。例如下面的Solidity合约代码中的两级判断条件，内层的判断是在浪费宝贵的以太坊gas资源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function opaquePredicate(uint x) public pure &#123;</span><br><span class="line"> if(x &lt; 1) &#123;</span><br><span class="line">    if(x &lt; 0 ) &#123;  // uint 不可能小于0</span><br><span class="line">    return x;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="避免在循环中执行gas成本高的操作"><a href="#避免在循环中执行gas成本高的操作" class="headerlink" title="避免在循环中执行gas成本高的操作"></a>避免在循环中执行gas成本高的操作</h1><p>由于<code>SLOAD</code>和<code>SSTORE</code>操作码的成本高昂，因此管理storage变量的gas成本 要远远高于内存变量，所以要避免在循环中操作storage变量。例如下面的 solidity 代码中，<code>num</code>变量是一个storage变量，那么未知循环次数的若干次操作，很可能会造成solidity开发者意料之外的以太坊gas消耗黑洞：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint num = 0;</span><br><span class="line"></span><br><span class="line">function expensiveLoop(uint x) public &#123;</span><br><span class="line">  for(uint i = 0; i &lt; x; i++) &#123;</span><br><span class="line">    num += 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决上述以太坊合约代码问题的方法，是创建一个solidity临时变量 来代替上述全局变量参与循环，然后在循环结束后重新将临时变量的值赋给全局状态变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint num = 0;</span><br><span class="line"></span><br><span class="line">function lessExpensiveLoop(uint x) public &#123;</span><br><span class="line">  uint temp = num;</span><br><span class="line">  for(uint i = 0; i &lt; x; i++) &#123;</span><br><span class="line">    temp += 1;</span><br><span class="line">  &#125;</span><br><span class="line">  num = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="避免使用常量结果的循环"><a href="#避免使用常量结果的循环" class="headerlink" title="避免使用常量结果的循环"></a>避免使用常量结果的循环</h1><p>如果一个循环计算的结果是无需编译执行Solidity代码就可以预测的，那么 就不要使用循环，这可以可观地节省gas。例如下面的以太坊合约代码就可以 直接设置num变量的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function constantOutcome() public pure returns(uint) &#123;</span><br><span class="line">  uint num = 0;</span><br><span class="line">  for(uint i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">    num += 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="合并循环"><a href="#合并循环" class="headerlink" title="合并循环"></a>合并循环</h1><p>有时候在Solidity智能合约中，你会发现两个循环的判断条件一致，那么在这种情况下就没有理由不合并它们。例如下面的以太坊合约代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function loopFusion(uint x, uint y) public pure returns(uint) &#123;</span><br><span class="line">  for(uint i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">    x += 1;</span><br><span class="line">  &#125;</span><br><span class="line">  for(uint i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">    y += 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="避免循环中的重复计算"><a href="#避免循环中的重复计算" class="headerlink" title="避免循环中的重复计算"></a>避免循环中的重复计算</h1><p>如果循环中的某个Solidity表达式在每次迭代都产生同样的结果，那么就可以将其 移出循环先行计算，从而节省掉循环中额外的gas成本。如果表达式中使用的变量是storage变量， 这就更重要了。例如下面的智能合约代码中表达式<code>a*b</code>的值，并不需要每次迭代重新计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint a = 4;</span><br><span class="line">uint b = 5;</span><br><span class="line">function repeatedComputations(uint x) public returns(uint) &#123;</span><br><span class="line">  uint sum = 0;</span><br><span class="line">  for(uint i = 0; i &lt;= x; i++) &#123;</span><br><span class="line">    sum = sum + a * b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="去除循环中的比较运算"><a href="#去除循环中的比较运算" class="headerlink" title="去除循环中的比较运算"></a>去除循环中的比较运算</h1><p>如果在循环的每个迭代中执行比较运算，但每次的比较结果都相同，则应将其从循环中删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function unilateralOutcome(uint x) public returns(uint) &#123;</span><br><span class="line">  uint sum = 0;</span><br><span class="line">  for(uint i = 0; i &lt;= 100; i++) &#123;</span><br><span class="line">    if(x &gt; 1) &#123;</span><br><span class="line">      sum += 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="不要存储不必要的数据"><a href="#不要存储不必要的数据" class="headerlink" title="不要存储不必要的数据"></a>不要存储不必要的数据</h1><p>这听起来似乎很明显，但是非常值得一提。编写智能合约时，你应该只存储交易验证所需的内容。与合约逻辑无关的交易记录或详细说明之类的数据可能不需要保存在合约存储中。</p>
<h1 id="将多个小变量打包到单个字中"><a href="#将多个小变量打包到单个字中" class="headerlink" title="将多个小变量打包到单个字中"></a>将多个小变量打包到单个字中</h1><blockquote>
<p>译者注：标题中的”字”, 也称为字长，表示每个指令操作的数据长度。</p>
</blockquote>
<p>EVM在32字节字长存储模型下运行。可以将小于32个字节的多个变量打包到一个存储槽中，以最大程度地减少<code>SSTORE</code>操作码的数量。尽管Solidity <a target="_blank" rel="noopener" href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html">自动尝试将小的基本类型打包到同一插槽中</a>，但是糟糕的结构体成员排序可能会阻止编译器执行此操作。考虑下面的<code>Good</code>和<code>Bad</code>结构体。</p>
<p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Gas%E4%BC%98%E5%8C%96/img/MGf38d9w.png" alt="Image for post"></p>
<p>第一个<code>doBad()</code>函数调用执行消耗约60,000 Gas，而<code>doGood()</code>仅消耗约40,000 Gas。注意是一个字长存储的差异(20,000 Gas)，因为<code>Good</code>结构将两个uint128打包为一个字。</p>
<h1 id="在合约的字节码中存储值"><a href="#在合约的字节码中存储值" class="headerlink" title="在合约的字节码中存储值"></a>在合约的字节码中存储值</h1><p>一种相对便宜的存储和读取信息的方法是，将信息部署在区块链上时，直接将其包含在智能合约的字节码中。不利之处是此值以后不能更改。但是，用于加载和存储数据的 gas 消耗将大大减少。有两种可能的实现方法：</p>
<ol>
<li>将变量声明为 <em>constant</em> 常量 (声明为 <a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/1059">immutable</a> 同样也可以降低 gas)</li>
<li>在你要使用的任何地方对其进行硬编码。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint256 public v1;</span><br><span class="line">uint256 public constant v2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params"></span>) returns (uint256 result) &#123;</span><br><span class="line">    <span class="keyword">return</span> v1 * v2 * <span class="number">10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量<em>v1</em> 是合约状态的一部分，而<em>v2</em>和<em>1000</em>是合约字节码的一部分。</p>
<h1 id="带有-数字的变量，读取时候花费-gas-更少"><a href="#带有-数字的变量，读取时候花费-gas-更少" class="headerlink" title="带有_数字的变量，读取时候花费 gas 更少"></a>带有<code>_</code>数字的变量，读取时候花费 gas 更少</h1>
      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/18/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="幺柒YQ"
      src="/images/avater.png">
  <p class="site-author-name" itemprop="name">幺柒YQ</p>
  <div class="site-description" itemprop="description">努力坚持就会有希望</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">232</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kpyaoqi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kpyaoqi" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:18312386077@163.com" title="E-Mail → mailto:18312386077@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat.jpg" title="WeChat → images&#x2F;wechat.jpg"><i class="fa fa-fw fa-wechat"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/qq.jpg" title="QQ → images&#x2F;qq.jpg"><i class="fa fa-fw fa-qq"></i>QQ</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://stackoverflow.com/" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;" rel="noopener" target="_blank">Stackoverflow</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2021-11 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">幺柒YQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">899k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:37</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共379.4k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  


</body>
</html>
