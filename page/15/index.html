<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://kongpengyq.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="努力坚持就会有希望">
<meta property="og:type" content="website">
<meta property="og:title" content="YQ &amp; 博客">
<meta property="og:url" content="https://kongpengyq.com/page/15/index.html">
<meta property="og:site_name" content="YQ &amp; 博客">
<meta property="og:description" content="努力坚持就会有希望">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="幺柒YQ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://kongpengyq.com/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>YQ & 博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="YQ & 博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YQ & 博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/08/24/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/7-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7Utils/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/24/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/7-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7Utils/" class="post-title-link" itemprop="url">7-实用工具Utils</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-24 00:00:00" itemprop="dateCreated datePublished" datetime="2022-08-24T00:00:00+08:00">2022-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ether-5-4-js/" itemprop="url" rel="index">
                    <span itemprop="name">ether@5.4.js</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="应用程序二进制接口"><a href="#应用程序二进制接口" class="headerlink" title="应用程序二进制接口"></a>应用程序二进制接口</h1><h2 id="1-1-AbiCoder"><a href="#1-1-AbiCoder" class="headerlink" title="1.1 AbiCoder"></a>1.1 AbiCoder</h2><p><strong>AbiCoder</strong>是编码器的集合，可用于在EVM和更高级别库之间通过二进制数据格式进行编码和解码的操作。</p>
<p>大多数开发人员不需要直接使用这个类，因为Interface类极大地简化了这些操作。</p>
<h2 id="1-2-ABI格式"><a href="#1-2-ABI格式" class="headerlink" title="1.2 ABI格式"></a>1.2 ABI格式</h2><h3 id="1-2-1-HUman-REadable-ABI"><a href="#1-2-1-HUman-REadable-ABI" class="headerlink" title="1.2.1 HUman-REadable ABI"></a>1.2.1 HUman-REadable ABI</h3><p><strong>Human-Readable ABI</strong> 是早期被 ethers 所描述提出的， 它允许使用一个Solidity式签名(Solidity signature)来描述每个方法(method)、事件(event)和错误(error)。</p>
<h3 id="1-2-2-Solidity-JSON-ABI"><a href="#1-2-2-Solidity-JSON-ABI" class="headerlink" title="1.2.2 **Solidity JSON **ABI"></a>1.2.2 **Solidity JSON **ABI</h3><p><strong>Solidity JSON ABI</strong>是许多工具导出的标准格式，包括Solidity编译器.</p>
<h3 id="1-2-3-Solidity-Object-ABI"><a href="#1-2-3-Solidity-Object-ABI" class="headerlink" title="1.2.3 Solidity Object ABI"></a>1.2.3 <strong>Solidity Object</strong> ABI</h3><p>使用JSON.parse解析Solidity JSON ABI的结果完全与Interface类兼容， 且该对象的每个方法、事件和错误都与Fragment类兼容。</p>
<p>一些开发人员可能更喜欢这种方式，因为它允许将ABI属性作为普通的JavaScript对象访问，并且Solidity ABI与JSON ABI非常匹配。</p>
<h2 id="1-3-Fragments"><a href="#1-3-Fragments" class="headerlink" title="1.3 Fragments"></a>1.3 Fragments</h2><p>对一个ABI进行描述解释</p>
<h3 id="1-3-0-Formats"><a href="#1-3-0-Formats" class="headerlink" title="1.3.0 Formats"></a>1.3.0 Formats</h3><p>每个Fragment和ParamType可以使用其<code>format</code>方法输出。</p>
<p><strong><em>ethers</em>.<em>utils</em>.<em>FormatTypes</em>.full ⇒ <em>string</em>：</strong>这是一个完整的人类可读(human-readable)的字符串，包括所有的参数名，任何可选的修饰符	(例如，<code>indexed</code>，<code>public</code>等)和空格，以提高代码可读性。</p>
<p><strong><em>ethers</em>.<em>utils</em>.<em>FormatTypes</em>.minimal ⇒ <em>string</em>：</strong>这类似于<code>full</code>，除了没有不必要的空白或参数名。这对于存储最小的字符串非常有用，	该字符串仍然可以使用Fragment . from， 从完全重构原始的Fragment。</p>
<p><strong><em>ethers</em>.<em>utils</em>.<em>FormatTypes</em>.json ⇒ <em>string</em>：</strong>这将返回一个JavaScript对象，安全地调用<code>JSON.stringify</code>创建一个JSON字符串。</p>
<p><strong><em>ethers</em>.<em>utils</em>.<em>FormatTypes</em>.sighash ⇒ <em>string</em>：</strong>一个最小的输出格式，Solidity在计算签名哈希或事件主题topic的哈希时使用它。</p>
<h3 id="1-3-1-Fragment"><a href="#1-3-1-Fragment" class="headerlink" title="1.3.1 Fragment"></a>1.3.1 <strong>Fragment</strong></h3><p>一个ABI是<strong>Fragments</strong>的集合，每个fragment指定:一个错误、一个事件、一个函数、一个构造函数</p>
<p><strong>属性：</strong></p>
<p><strong><em>fragment</em>.name ⇒ <em>string</em>：</strong>事件或函数的name。如果是ConstructorFragment时为null。</p>
<p><em><strong>fragment*.type ⇒ *string：</strong></em>这是一个表示Fragment类型的字符串。如:<code>constructor</code>、<code>event</code>、<code>function</code></p>
<p>**<em>fragment</em>.inputs ⇒ *Array&lt; ParamType &gt;*：**构造函数、事件等输入参数的ParamType的数组。</p>
<p><strong>方法：</strong></p>
<p><strong><em>fragment</em>.format( [ <em>format</em> &#x3D; <em>sighash</em> ] ) ⇒ <em>string</em>：</strong>使用可用的输出格式创建Fragment的字符串描述。</p>
<p><strong><em>ethers</em>.<em>utils</em>.______Fragment.from( <em>objectOrString</em> ) ⇒ ____<em>Fragment</em>：</strong>从任何兼容的object或String创建一个新的**__Fragment**子类。</p>
<p><strong><em>ethers</em>.<em>utils</em>.<em>Fragment</em>.is__Fragment( <em>object</em> ) ⇒ <em>boolean</em>：</strong>如果<em>object</em> 是一个**__Fragment**返回true。</p>
<h3 id="1-3-2-ConstructorFragment"><a href="#1-3-2-ConstructorFragment" class="headerlink" title="1.3.2 ConstructorFragment"></a>1.3.2 ConstructorFragment</h3><p>**<em>fragment</em>.gas ⇒ *大数(BigNumber)*：**表示部署期间应该使用的gas limit，它可以是null。</p>
<p><strong><em>fragment</em>.payable ⇒ <em>boolean</em>：</strong>表示构造函数在部署期间是否可以接收ether(例如：msg.value !&#x3D; 0)。</p>
<p><strong><em>fragment</em>.stateMutability ⇒ <em>string</em>：</strong>构造函数的state mutability。它可以是:<code>nonpayable</code>、<code>payable</code></p>
<h3 id="1-3-3-ErrorFragment"><a href="#1-3-3-ErrorFragment" class="headerlink" title="1.3.3 ErrorFragment"></a>1.3.3 ErrorFragment</h3><h3 id="1-3-4-EventFragment"><a href="#1-3-4-EventFragment" class="headerlink" title="1.3.4 EventFragment"></a>1.3.4 EventFragment</h3><p><strong><em>fragment</em>.anonymous ⇒ <em>boolean</em>：</strong>表示事件(event)是否匿名。匿名事件在创建日志时不会将其topic哈希值注入到topic0中</p>
<h3 id="1-3-5-FunctionFragment"><a href="#1-3-5-FunctionFragment" class="headerlink" title="1.3.5 FunctionFragment"></a>1.3.5 FunctionFragment</h3><p><strong><em>fragment</em>.constant ⇒ <em>boolean</em>：</strong>表示函数是否为常量(即不改变状态)。如果设为true表示状态可变性是<code>pure</code> 或 <code>view</code>。</p>
<p><strong><em>fragment</em>.stateMutability ⇒ <em>string</em>：</strong>构造器的状态可变性。它可以是:<code>nonpayable</code>、<code>payable</code>、<code>pure</code>、<code>view</code></p>
<p>**<em>fragment</em>.outputs ⇒ *Array&lt; ParamType &gt;*：**函数输出参数的列表。</p>
<h3 id="1-3-6-ParamType"><a href="#1-3-6-ParamType" class="headerlink" title="1.3.6 ParamType"></a>1.3.6 ParamType</h3><p>表示Solidity中的参数:</p>
<p><strong>属性：</strong></p>
<p><strong><em>paramType</em>.name ⇒ <em>string</em>：</strong>本地参数名。对于未命名的参数，这个值为null。例如，参数字符串<code>string foobar</code>会输出<code>foobar</code>。</p>
<p><em><strong>paramType*.type ⇒ *string：</strong></em>参数的完整类型，包括元组和数组符号。对于未命名的参数，这个值可能为null。</p>
<p><em><strong>paramType*.baseType ⇒ *string：</strong></em>参数的基类型(base type)。对于原始类型(例如<code>address</code>, <code>uint256</code>等)，这等同于type。 对于数组，	它将是string <code>array</code>，对于元组，它将是string <code>tuple</code>。</p>
<p><em><strong>paramType*.indexed ⇒ *boolean：</strong></em>参数是否被标记为索引。这只适用于参数是EventFragment的部分。</p>
<p><em><strong>paramType*.arrayChildren ⇒ *ParamType：</strong></em>数组的children类型。对于任何非数组的参数，这将是null。</p>
<p><em><strong>paramType*.arrayLength ⇒ *number：</strong></em>数组的长度，或动态数组的长度<code>-1</code>。对于不是数组的参数，这个值为null。</p>
<p>**<em>paramType</em>.components ⇒ *Array&lt; ParamType &gt;*：**元组的组成部分。这对于非元组参数是null。</p>
<p><strong>方法：</strong></p>
<p><strong><em>paramType</em>.format( [ <em>outputType</em> &#x3D; <em>sighash</em> ] )：</strong>使用可用的output formats创建Fragment的字符串描述。</p>
<p><strong><em>ethers</em>.<em>utils</em>.<em>ParamType</em>.from( <em>objectOrString</em> ) ⇒ <em>ParamType</em>：</strong>从任何兼容的<em>object或String</em>创建一个新的<strong>ParamType</strong>。</p>
<p><strong><em>ethers</em>.<em>utils</em>.<em>ParamType</em>.isParamType( <em>object</em> ) ⇒ <em>boolean</em>：</strong>如果<em>object</em> 是一个<strong>ParamType</strong>返回true。</p>
<h2 id="1-4-Interface"><a href="#1-4-Interface" class="headerlink" title="1.4 Interface"></a>1.4 Interface</h2><p>**接口(Interface)**类是以太坊网络上的与合约交互所需的编码和解码的一种抽象,EVM本身并不理解ABI是什么。</p>
<p>它只是一组商定的格式，用于编码合约所需的各种类型的数据，以便它们可以相互交互。</p>
<p><strong>（创建实例)new <em>ethers</em>.<em>utils</em>.Interface( <em>abi</em> ):<strong>从表示<em>abi</em>的JSON字符串或对象创建一个新的</strong>接口</strong>。</p>
<h3 id="1-4-1-属性"><a href="#1-4-1-属性" class="headerlink" title="1.4.1 属性"></a>1.4.1 属性</h3><p>**<em>interface</em>.fragments ⇒ *Array&lt; Fragment &gt;*：**接口中所有的Fragments。</p>
<p><em><strong>interface*.errors ⇒ *Array&lt; ErrorFragment &gt;：</strong></em>接口中所有的Error Fragments。</p>
<p><em><strong>interface*.events ⇒ *Array&lt; EventFragment &gt;：</strong></em>接口中所有的Event Fragments。</p>
<p><em><strong>interface*.functions ⇒ *Array&lt; FunctionFragment &gt;：</strong></em>接口中所有的Function Fragments。</p>
<p><em><strong>interface*.deploy ⇒ *ConstructorFragment“：</strong></em>接口中所有的Constructor Fragments。</p>
<h3 id="1-4-2-格式化"><a href="#1-4-2-格式化" class="headerlink" title="1.4.2 格式化"></a>1.4.2 格式化</h3><p>**<em>interface</em>.format( [ <em>format</em> ] ) ⇒ *string | Array&lt; string &gt;*：**返回格式化的接口。如果格式类型是<code>json</code>，则返回一个字符串，否则返回	一个由human-readable（人类可读）字符串组成的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">FormatTypes</span> = ethers.<span class="property">utils</span>.<span class="property">FormatTypes</span>;</span><br><span class="line"></span><br><span class="line">iface.<span class="title function_">format</span>(<span class="title class_">FormatTypes</span>.<span class="property">json</span>)</span><br><span class="line"><span class="comment">// &#x27;[&#123;&quot;type&quot;:&quot;constructor&quot;,&quot;payable&quot;:false,&quot;inputs&quot;:[&#123;&quot;type&quot;:&quot;string&quot;,&quot;name&quot;:&quot;symbol&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;name&quot;:&quot;name&quot;&#125;]&#125;,&#123;&quot;type&quot;:&quot;function&quot;,&quot;name&quot;:&quot;transferFrom&quot;,&quot;constant&quot;:false,&quot;payable&quot;:false,&quot;inputs&quot;:[&#123;&quot;type&quot;:&quot;address&quot;,&quot;name&quot;:&quot;from&quot;&#125;,&#123;&quot;type&quot;:&quot;address&quot;,&quot;name&quot;:&quot;to&quot;&#125;,&#123;&quot;type&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;amount&quot;&#125;],&quot;outputs&quot;:[]&#125;,&#123;&quot;type&quot;:&quot;function&quot;,&quot;name&quot;:&quot;mint&quot;,&quot;constant&quot;:false,&quot;stateMutability&quot;:&quot;payable&quot;,&quot;payable&quot;:true,&quot;inputs&quot;:[&#123;&quot;type&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;amount&quot;&#125;],&quot;outputs&quot;:[]&#125;,&#123;&quot;type&quot;:&quot;function&quot;,&quot;name&quot;:&quot;balanceOf&quot;,&quot;constant&quot;:true,&quot;stateMutability&quot;:&quot;view&quot;,&quot;payable&quot;:false,&quot;inputs&quot;:[&#123;&quot;type&quot;:&quot;address&quot;,&quot;name&quot;:&quot;owner&quot;&#125;],&quot;outputs&quot;:[&#123;&quot;type&quot;:&quot;uint256&quot;&#125;]&#125;,&#123;&quot;type&quot;:&quot;event&quot;,&quot;anonymous&quot;:false,&quot;name&quot;:&quot;Transfer&quot;,&quot;inputs&quot;:[&#123;&quot;type&quot;:&quot;address&quot;,&quot;name&quot;:&quot;from&quot;,&quot;indexed&quot;:true&#125;,&#123;&quot;type&quot;:&quot;address&quot;,&quot;name&quot;:&quot;to&quot;,&quot;indexed&quot;:true&#125;,&#123;&quot;type&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;amount&quot;&#125;]&#125;,&#123;&quot;type&quot;:&quot;error&quot;,&quot;name&quot;:&quot;AccountLocked&quot;,&quot;inputs&quot;:[&#123;&quot;type&quot;:&quot;address&quot;,&quot;name&quot;:&quot;owner&quot;&#125;,&#123;&quot;type&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;balance&quot;&#125;]&#125;,&#123;&quot;type&quot;:&quot;function&quot;,&quot;name&quot;:&quot;addUser&quot;,&quot;constant&quot;:false,&quot;payable&quot;:false,&quot;inputs&quot;:[&#123;&quot;type&quot;:&quot;tuple&quot;,&quot;name&quot;:&quot;user&quot;,&quot;components&quot;:[&#123;&quot;type&quot;:&quot;string&quot;,&quot;name&quot;:&quot;name&quot;&#125;,&#123;&quot;type&quot;:&quot;address&quot;,&quot;name&quot;:&quot;addr&quot;&#125;]&#125;],&quot;outputs&quot;:[&#123;&quot;type&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;id&quot;&#125;]&#125;,&#123;&quot;type&quot;:&quot;function&quot;,&quot;name&quot;:&quot;addUsers&quot;,&quot;constant&quot;:false,&quot;payable&quot;:false,&quot;inputs&quot;:[&#123;&quot;type&quot;:&quot;tuple[]&quot;,&quot;name&quot;:&quot;user&quot;,&quot;components&quot;:[&#123;&quot;type&quot;:&quot;string&quot;,&quot;name&quot;:&quot;name&quot;&#125;,&#123;&quot;type&quot;:&quot;address&quot;,&quot;name&quot;:&quot;addr&quot;&#125;]&#125;],&quot;outputs&quot;:[&#123;&quot;type&quot;:&quot;uint256[]&quot;,&quot;name&quot;:&quot;id&quot;&#125;]&#125;,&#123;&quot;type&quot;:&quot;function&quot;,&quot;name&quot;:&quot;getUser&quot;,&quot;constant&quot;:true,&quot;stateMutability&quot;:&quot;view&quot;,&quot;payable&quot;:false,&quot;inputs&quot;:[&#123;&quot;type&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;id&quot;&#125;],&quot;outputs&quot;:[&#123;&quot;type&quot;:&quot;tuple&quot;,&quot;name&quot;:&quot;user&quot;,&quot;components&quot;:[&#123;&quot;type&quot;:&quot;string&quot;,&quot;name&quot;:&quot;name&quot;&#125;,&#123;&quot;type&quot;:&quot;address&quot;,&quot;name&quot;:&quot;addr&quot;&#125;]&#125;]&#125;]&#x27;</span></span><br><span class="line"></span><br><span class="line">iface.<span class="title function_">format</span>(<span class="title class_">FormatTypes</span>.<span class="property">full</span>)</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   &#x27;constructor(string symbol, string name)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function transferFrom(address from, address to, uint256 amount)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function mint(uint256 amount) payable&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function balanceOf(address owner) view returns (uint256)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;event Transfer(address indexed from, address indexed to, uint256 amount)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;error AccountLocked(address owner, uint256 balance)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function addUser(tuple(string name, address addr) user) returns (uint256 id)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function addUsers(tuple(string name, address addr)[] user) returns (uint256[] id)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function getUser(uint256 id) view returns (tuple(string name, address addr) user)&#x27;</span></span><br><span class="line"><span class="comment">// ]</span></span><br><span class="line"></span><br><span class="line">iface.<span class="title function_">format</span>(<span class="title class_">FormatTypes</span>.<span class="property">minimal</span>)</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   &#x27;constructor(string,string)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function transferFrom(address,address,uint256)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function mint(uint256) payable&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function balanceOf(address) view returns (uint256)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;event Transfer(address indexed,address indexed,uint256)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;error AccountLocked(address,uint256)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function addUser(tuple(string,address)) returns (uint256)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function addUsers(tuple(string,address)[]) returns (uint256[])&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function getUser(uint256) view returns (tuple(string,address))&#x27;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-3-Fragment-Access"><a href="#1-4-3-Fragment-Access" class="headerlink" title="1.4.3 Fragment Access"></a>1.4.3 <strong>Fragment Access</strong></h3><p><strong><em>interface</em>.getFunction( <em>fragment</em> ) ⇒ FunctionFragment：</strong>返回<em>fragment</em>的FunctionFragment</p>
<p><strong><em>interface</em>.getError( <em>fragment</em> ) ⇒ ErrorFragment：</strong>返回<em>fragment</em>的ErrorFragment</p>
<p><strong><em>interface</em>.getEvent( <em>fragment</em> ) ⇒ EventFragment：</strong>返回<em>fragment</em>的EventFragment</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过方法(method)的签名，这是经过标准化后的，因此空格和多余的属性会被舍去</span></span><br><span class="line"></span><br><span class="line">iface.<span class="title function_">getFunction</span>(<span class="string">&quot;transferFrom(address, address, uint256)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过name的方式;这只在方法名称是唯一确定的情况下才有效</span></span><br><span class="line">iface.<span class="title function_">getFunction</span>(<span class="string">&quot;transferFrom&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过函数选择器</span></span><br><span class="line">iface.<span class="title function_">getFunction</span>(<span class="string">&quot;0x23b872dd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果方法不存在将抛出异常</span></span><br><span class="line">iface.<span class="title function_">getFunction</span>(<span class="string">&quot;doesNotExist()&quot;</span>);</span><br><span class="line"><span class="comment">// [Error: no matching function] &#123;</span></span><br><span class="line"><span class="comment">//   argument: &#x27;signature&#x27;,</span></span><br><span class="line"><span class="comment">//   code: &#x27;INVALID_ARGUMENT&#x27;,</span></span><br><span class="line"><span class="comment">//   reason: &#x27;no matching function&#x27;,</span></span><br><span class="line"><span class="comment">//   value: &#x27;doesNotExist()&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-4-签名和主题的哈希"><a href="#1-4-4-签名和主题的哈希" class="headerlink" title="1.4.4 签名和主题的哈希"></a>1.4.4 签名和主题的哈希</h3><p><em>*<em>interface</em>.getSighash( <em>fragment</em> ) ⇒ *string&lt; DataHexString&lt; 4 &gt; &gt;<em>：**返回</em>fragment</em>的签名哈希(sighash)或函数选择器(Function Selector)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iface.<span class="title function_">getSighash</span>(<span class="string">&quot;balanceOf&quot;</span>);</span><br><span class="line">iface.<span class="title function_">getSighash</span>(<span class="string">&quot;balanceOf(address)&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fragment = iface.<span class="title function_">getFunction</span>(<span class="string">&quot;balanceOf&quot;</span>)</span><br><span class="line">iface.<span class="title function_">getSighash</span>(fragment);</span><br><span class="line"><span class="comment">// &#x27;0x70a08231&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>interface</em>.getEventTopic( <em>fragment</em> ) ⇒ string&lt; DataHexString&lt; 32 &gt; &gt;：</strong>返回<em>fragment</em>的主题哈希(topic hash)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iface.<span class="title function_">getEventTopic</span>(<span class="string">&quot;Transfer&quot;</span>);</span><br><span class="line">iface.<span class="title function_">getEventTopic</span>(<span class="string">&quot;Transfer(address, address, uint)&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fragment = iface.<span class="title function_">getEvent</span>(<span class="string">&quot;Transfer&quot;</span>)</span><br><span class="line">iface.<span class="title function_">getEventTopic</span>(fragment);</span><br><span class="line"><span class="comment">// &#x27;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-5-编码数据"><a href="#1-4-5-编码数据" class="headerlink" title="1.4.5 编码数据"></a>1.4.5 编码数据</h3><h3 id="1-4-6-解码数据"><a href="#1-4-6-解码数据" class="headerlink" title="1.4.6 解码数据"></a>1.4.6 解码数据</h3><h3 id="1-4-7-解析"><a href="#1-4-7-解析" class="headerlink" title="1.4.7 解析"></a>1.4.7 解析</h3><h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h1><p><em>*<em>ethers</em>.<em>utils</em>.getAddress( <em>address</em> ) ⇒ *string&lt; 地址(Address) &gt;<em>：**返回一个校验和</em>地址</em>。</p>
<p>**<em>ethers</em>.<em>utils</em>.getIcapAddress( <em>address</em> ) ⇒ *string&lt; IcapAddress &gt;*：**返回一个ICAP address地址，与getAddress具有相同的限制条件。</p>
<p><strong><em>ethers</em>.<em>utils</em>.isAddress( <em>address</em> ) ⇒ boolean：</strong>如果地址有效(任何支持的格式)则返回true。</p>
<p><em>*<em>ethers</em>.<em>utils</em>.computeAddress( <em>publicOrPrivateKey</em> ) ⇒ *string&lt; 地址(Address) &gt;<em>：**返回</em>publicOrPrivateKey</em>的地址。公钥可以压缩或不压缩，私钥将自动转换为派生的公钥。</p>
<p>**<em>ethers</em>.<em>utils</em>.recoverAddress( <em>digest</em> , <em>signature</em> ) ⇒ *string&lt; 地址(Address) &gt;*：**使用ECDSA Public Key Recovery来确定摘要(digest)生成签名的公钥地址，</p>
<p>**<em>ethers</em>.<em>utils</em>.getContractAddress( <em>transaction</em> ) ⇒ *string&lt; 地址(Address) &gt;*：**一个交易用于部署合约则返回部署合约后的合约地址。</p>
<p>**<em>ethers</em>.<em>utils</em>.getCreate2Address( <em>from</em> , <em>salt</em> , <em>initCodeHash</em> ) ⇒ *string&lt; 地址(Address) &gt;*：**返回给定CREATE2调用后的合约地址。</p>
<h1 id="大数-BigNumber"><a href="#大数-BigNumber" class="headerlink" title="大数(BigNumber)"></a>大数(BigNumber)</h1><p><strong>BigNumber</strong>是一个可以安全地对任意大小的数字进行数学运算的对象。</p>
<p>大多数需要返回值的操作将返回一个<strong>BigNumber</strong>，接受值的参数通常会接收它们。</p>
<h2 id="3-1-创建实例"><a href="#3-1-创建实例" class="headerlink" title="3.1 创建实例"></a>3.1 创建实例</h2><p>BigNumber的构造函数不能被直接调用。相反，使用静态<code>BigNumber.from</code>。</p>
<p><em>*<em>ethers</em>.<em>BigNumber</em>.from( <em>aBigNumberish</em> ) ⇒ *大数(BigNumber)<em>：**为</em>aBigNumberish</em>返回一个<strong>BigNumber</strong>的实例</p>
<h2 id="3-2-方法"><a href="#3-2-方法" class="headerlink" title="3.2 方法"></a>3.2 方法</h2><h3 id="3-2-1-数学运算"><a href="#3-2-1-数学运算" class="headerlink" title="3.2.1 数学运算"></a>3.2.1 数学运算</h3><p><em>*<em>BigNumber</em>.add( <em>otherValue</em> ) ⇒ *大数(BigNumber)<em>：**返回值为</em>BigNumber</em> <strong>+</strong> <em>otherValue</em>的BigNumber。</p>
<p>**<em>BigNumber</em>.sub( <em>otherValue</em> ) ⇒ *大数(BigNumber)*：**返回值为 <em>BigNumber</em> <strong>-</strong> <em>otherValue</em>的BigNumber。</p>
<p>**<em>BigNumber</em>.mul( <em>otherValue</em> ) ⇒ *大数(BigNumber)*：**返回值为 <em>BigNumber</em> <strong>×</strong> <em>otherValue</em>的BigNumber。</p>
<p><em><strong>BigNumber*.div( <em>divisor</em> ) ⇒ *大数(BigNumber)：</strong></em>返回值为 <em>BigNumber</em> <strong>÷</strong> <em>divisor</em>的BigNumber。</p>
<p><em><strong>BigNumber*.mod( <em>divisor</em> ) ⇒ *大数(BigNumber)：</strong></em>返回值为 <em>BigNumber</em> ÷ <em>divisor</em>余数的BigNumber。</p>
<p><em><strong>BigNumber*.pow( <em>exponent</em> ) ⇒ *大数(BigNumber)：</strong></em>返回值为 <em>BigNumber</em> 指数的幂为<em>exponent</em>的BigNumber。</p>
<p>**<em>BigNumber</em>.abs( ) ⇒ *大数(BigNumber):***返回值为绝对值的BigNumber。</p>
<p>**<em>BigNumber</em>.mask( <em>bitcount</em> ) ⇒ *大数(BigNumber):**<em>返回一个BigNumber，其BigNumber的值超出</em>bitcount*最低有效位的位则设为0。</p>
<h4 id="Two’s-Complement"><a href="#Two’s-Complement" class="headerlink" title="Two’s Complement"></a>Two’s Complement</h4><p>Two’s Complement是用于编码和解码固定宽度的有符号值，同时有效地保留数学运算。大多数用户不需要与它们交互。</p>
<p>**<em>BigNumber</em>.fromTwos( <em>bitwidth</em> ) ⇒ <em>大数(BigNumber)</em>:**返回一个BigNumber, 值由带位宽（bitwidth）的二进制补码转换而来。</p>
<p>**<em>BigNumber</em>.toTwos( <em>bitwidth</em> ) ⇒ *大数(BigNumber)*：**返回一个BigNumber, BigNumber的值转换为带位宽的二进制补码。</p>
<h3 id="3-2-2-比较和相等"><a href="#3-2-2-比较和相等" class="headerlink" title="3.2.2 比较和相等"></a>3.2.2 比较和相等</h3><p><strong><em>BigNumber</em>.eq( <em>otherValue</em> ) ⇒ <em>boolean</em>：</strong>当且仅当<em>BigNumber</em>的值等于<em>otherValue</em>时返回true。</p>
<p><em><strong>BigNumber*.lt( <em>otherValue</em> ) ⇒ *boolean：</strong></em>当且仅当<em>BigNumber</em>的值**&lt;**otherValue时返回true。</p>
<p><em><strong>BigNumber*.lte( <em>otherValue</em> ) ⇒ *boolean：</strong></em>当且仅当<em>BigNumber</em>的值<strong>≤</strong>otherValue时返回true。</p>
<p><strong><em>BigNumber</em>.gt( <em>otherValue</em> ) ⇒ <em>boolean</em>：</strong>当且仅当<em>BigNumber</em>的值**&gt;**<em>otherValue</em>时返回true。</p>
<p><em><strong>BigNumber*.gte( <em>otherValue</em> ) ⇒ *boolean：</strong></em>当且仅当<em>BigNumber</em>的值<strong>≥</strong><em>otherValue</em>时返回true。</p>
<p><em><strong>BigNumber*.isZero( ) ⇒ *boolean：</strong></em>当且仅当<em>BigNumber</em>的值为0时返回true。</p>
<h3 id="3-2-3-转换"><a href="#3-2-3-转换" class="headerlink" title="3.2.3 转换"></a>3.2.3 转换</h3><p><strong><em>BigNumber</em>.toBigInt( ) ⇒ <em>bigint</em>：</strong>在支持BigInt的平台上以JavScript BigInt值返回BigNumber的值。</p>
<p><strong><em>BigNumber</em>.toNumber( ) ⇒ <em>number</em>：</strong>将BigNumber的值转换JavaScript值。</p>
<blockquote>
<p>如果该值大于<em>Number.MAX_SAFE_INTEGER</em>或小于等于<em>Number.MIN_SAFE_INTEGER</em>， 则会<strong>抛出一个错误</strong>。</p>
</blockquote>
<p><strong><em>BigNumber</em>.toString( ) ⇒ <em>string</em>：</strong>以十进制字符串的形式返回BigNumber的值。</p>
<p>**<em>BigNumber</em>.toHexString( ) ⇒ *string&lt; DataHexString &gt;*：**返回BigNumber的值为十六进制的值，<code>0x</code>是前缀DataHexString.。</p>
<h3 id="3-2-4-检查"><a href="#3-2-4-检查" class="headerlink" title="3.2.4 检查"></a>3.2.4 检查</h3><p><strong><em>ethers</em>.<em>BigNumber</em>.isBigNumber( <em>object</em> ) ⇒ <em>boolean</em>：</strong>当且仅当对象是BigNumber是<em>对象</em>时返回true。</p>
<h1 id="字节处理"><a href="#字节处理" class="headerlink" title="字节处理"></a>字节处理</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p><strong>Bytes：Bytes</strong>是一个Array或TypedArray对象， 每个值都在有效字节范围内(例如0到255之间)，或者是一个具有<code>length</code>属性的对象，每	个索引的属性都在有效字节范围内。</p>
<p><strong>BytesLike：BytesLike</strong>可以是Bytes或DataHexString。</p>
<p><strong>DataHexString：DataHexstring</strong>与HexString是相同的，除了它有偶数个nibbles，因此二进制数据作为字符串是有效的。</p>
<p><strong>HexString：Hexstring</strong>是一个字符串，有一个0x前缀，后面跟着nibbles number类型(例如，不区分大小写的十六进制字符<code>0-9</code>和<code>a-f</code>)</p>
<p><strong>Signature：</strong></p>
<ul>
<li><strong>r</strong> and <strong>s</strong> — The x co-ordinate of <strong>r</strong> and the <strong>s</strong> value of the signature</li>
<li><strong>v</strong> — The parity of the y co-ordinate of <strong>r</strong></li>
<li><strong>_vs</strong> — The compact representation of the <strong>s</strong> and <strong>v</strong></li>
<li><strong>recoveryParam</strong> — The normalized (i.e. 0 or 1) value of <strong>v</strong></li>
</ul>
<p>**Raw Signature：原始签名(Raw Signature)**是一种常见的签名格式，r, s和v被连接成一个65字节(130 nibble)的DataHexString。</p>
<p><strong>SignatureLike：SignatureLike</strong>类似于一个Signature，除了多余的属性可以被省略或者它也可以是一个 Raw Signature。</p>
<p>​	例如，如果指定了**_vs<strong>，则</strong>s<strong>和</strong>v<strong>可以省略。同样，如果提供了</strong>recoveryParam<strong>， 则可以省略</strong>v**(在这种情况下，可以计算出缺失的值)。</p>
<h2 id="4-1-检查"><a href="#4-1-检查" class="headerlink" title="4.1 检查"></a>4.1 检查</h2><p><strong><em>ethers</em>.<em>utils</em>.isBytes( <em>object</em> ) ⇒ <em>boolean</em>：</strong>当且仅当<em>object</em>为有效Bytes时返回true。</p>
<p><strong><em>ethers</em>.<em>utils</em>.isBytesLike( <em>object</em> ) ⇒ <em>boolean</em>：</strong>当且仅当<em>object</em>是Bytes或DataHexString时返回true。</p>
<p><strong><em>ethers</em>.<em>utils</em>.isHexString( <em>object</em> , [ <em>length</em> ] ) ⇒ <em>boolean</em>：</strong>当且仅当<em>object</em>是一个有效的十六进制字符串时返回true。 如果指定了<em>length</em>并且<em>object</em> 不是一个有效的长度字节的DataHexString，则抛出一个InvalidArgument错误。</p>
<h2 id="4-2-数组和十六进制字符串之间的转换"><a href="#4-2-数组和十六进制字符串之间的转换" class="headerlink" title="4.2 数组和十六进制字符串之间的转换"></a>4.2 数组和十六进制字符串之间的转换</h2><p><strong><em>ethers</em>.<em>utils</em>.arrayify( <em>DataHexStringOrArrayish</em> [ , <em>options</em> ] ) ⇒ <em>Uint8Array</em>：</strong>将<em>DataHexStringOrArrayish</em>转换为Uint8Array。</p>
<p><em>*<em>ethers</em>.<em>utils</em>.hexlify( <em>hexstringOrArrayish</em> ) ⇒ *string&lt; DataHexString &gt;<em>：**将</em>hexstringOrArrayish</em>转换为DataHexString。</p>
<p><em>*<em>ethers</em>.<em>utils</em>.hexValue( <em>aBigNumberish</em> ) ⇒ *string&lt; HexString &gt;<em>：**将</em>aBigNumberish</em>转换为HexString，没有前导零。</p>
<h2 id="4-3-数组处理"><a href="#4-3-数组处理" class="headerlink" title="4.3 数组处理"></a>4.3 数组处理</h2><p><strong><em>ethers</em>.<em>utils</em>.concat( <em>arrayOfBytesLike</em> ) ⇒ <em>Uint8Array</em>：</strong>将<em>arrayOfBytesLike</em>中的所有<a target="_blank" rel="noopener" href="https://learnblockchain.cn/ethers_v5/api/utils/bytes/#BytesLike">BytesLike</a>连接到一个单独的Uint8Array中。</p>
<p><strong><em>ethers</em>.<em>utils</em>.stripZeros( <em>aBytesLike</em> ) ⇒ <em>Uint8Array</em>：</strong>返回一个无前导零<em>aBtyesLike</em>字节的Uint8Array</p>
<p><strong><em>ethers</em>.<em>utils</em>.zeroPad( <em>aBytesLike</em> , <em>length</em> ) ⇒ <em>Uint8Array</em>：</strong></p>
<p>返回一个以aBytesLike为单位的Uint8Array，前面有0字节的length bytes long。</p>
<p>如果<em>aBytesLike</em>的长度已经超过长度字节，则会抛出InvalidArgument错误。</p>
<h2 id="4-4-十六进制字符串处理"><a href="#4-4-十六进制字符串处理" class="headerlink" title="4.4 十六进制字符串处理"></a>4.4 十六进制字符串处理</h2><p><em>*<em>ethers</em>.<em>utils</em>.hexConcat( <em>arrayOfBytesLike</em> ) ⇒ *string&lt; DataHexString &gt;<em>：**将</em>arrayOfBytesLike</em>中的所有BytesLike连接成一个单一的DataHexString。</p>
<p><em>*<em>ethers</em>.<em>utils</em>.hexDataLength( <em>aBytesLike</em> ) ⇒ *string&lt; DataHexString &gt;<em>：**返回</em>aBytesLike</em>的长度(以字节为单位)。</p>
<p><em>*<em>ethers</em>.<em>utils</em>.hexDataSlice( <em>aBytesLike</em> , <em>offset</em> [ , <em>endOffset</em> ] ) ⇒ <em>string&lt; DataHexString &gt;<em>*<em>：返回一个</em>aBytesLike*切片的DataHexString表示，从</em>offset</em>(以字节为单位)到*endOffset</em>(以字节为单位)。 如果省略了<em>endOffset</em>，则使用<em>aBytesLike</em>的长度。</p>
<p><em>*<em>ethers</em>.<em>utils</em>.hexStripZeros( <em>aBytesLike</em> ) ⇒ *string&lt; HexString &gt;<em>：**返回</em>aBytesLike</em>的HexString表示形式，去掉所有前导零。</p>
<p><em>*<em>ethers</em>.<em>utils</em>.hexZeroPad( <em>aBytesLike</em> , <em>length</em> ) ⇒ *string&lt; DataHexString &gt;<em>：**返回被填充到</em>length</em>字节的<em>aBytesLike</em>的DataHexString表示。如果<em>aBytesLike</em>的长度已经超过<em>length</em>字节，则会抛出InvalidArgument错误。</p>
<h2 id="4-5-签名转换"><a href="#4-5-签名转换" class="headerlink" title="4.5 签名转换"></a>4.5 签名转换</h2><p><em>*<em>ethers</em>.<em>utils</em>.joinSignature( <em>aSignatureLike</em> ) ⇒ *string&lt; RawSignature &gt;<em>：**返回</em>aSignaturelike</em>的原始格式，它是65字节(130个nibbles)长，连接签名的<strong>r</strong>, <strong>s</strong>和(标准化后))<strong>v</strong>。</p>
<p><strong><em>ethers</em>.<em>utils</em>.splitSignature( <em>aSignatureLikeOrBytesLike</em> ) ⇒ <em>Signature</em>：</strong>返回<em>aSignaturelike</em>的完整扩展格式或原始格式DataHexString，将自动计算所有缺失的属性。</p>
<h2 id="4-6-随机字节"><a href="#4-6-随机字节" class="headerlink" title="4.6 随机字节"></a>4.6 随机字节</h2><p><strong><em>ethers</em>.<em>utils</em>.randomBytes( <em>length</em> ) ⇒ <em>Uint8Array</em>：</strong>返回一个新的Uint8Array 长度为<em>length</em>的随机字节。</p>
<p>**<em>ethers</em>.<em>utils</em>.shuffled( <em>array</em> ) ⇒ *Array&lt; any &gt;*：**返回一个使用Fisher-Yates Shuffle打乱后的数组副本。</p>
<h1 id="以太币格式化与转换"><a href="#以太币格式化与转换" class="headerlink" title="以太币格式化与转换"></a>以太币格式化与转换</h1><p><strong>utils  . etherSymbol</strong> </p>
<p>以太坊符号(希腊字母  <em>Xi</em>  ) </p>
<p><strong>utils  . parseEther ( etherString )   &#x3D;&gt;   BigNumber</strong> </p>
<p>将代表 ether 单位数的  <em>etherString</em>  解析为 wei 单位数的 BitNumber 实例。 （译者注：ether、gwei、wei 等是以太坊的货币单位名称，下同。） </p>
<p><strong>utils  . formatEther ( wei )   &#x3D;&gt;   string</strong> </p>
<p>将代表 wei 单位数的  <em>wei</em>  格式化为代表 ether 单位数的十进制字符串。 输出值总是包含至少一个整数和一个小数位，否则将剪除前导和尾随的 0。 </p>
<p><strong>utils  . parseUnits ( valueString , decimalsOrUnitName )   &#x3D;&gt;   BigNumber</strong> </p>
<p>将代表某单位数的  <em>valueString</em>  解析为一个代表 wei 单位数的 BigNumber 实例。 参数  <em>decimalsOrUnitsName</em>  可以是 3 到 18 之间（3 的倍数）的小数位数， 或者是以太币单位名称，如： gwei 。 </p>
<p><strong>utils  . formatUnits ( wei , decimalsOrUnitName )   &#x3D;&gt;   string</strong> </p>
<p>将  <em>wei</em>  单位数格式化为一个代表某单位数的十进制字符串。 输出值总是包含至少一个整数和一个小数位，否则将修剪前导和尾随的 0。 参数  <em>decimalsOrUnitsName</em>  可以是 3 到 18 之间（3 的倍数）的小数位数， 或者是单位名称，如： gwei 。 </p>
<p><strong>utils  . commify ( numberOrString )   &#x3D;&gt;   string</strong> </p>
<p>返回含有千分符的<em>numberOrString</em>。如果  <em>numberOrString</em>  包含小数点， 则输出值将至少具有一位整数和小数。如果不包含小数点，则输出值不会包含小数。 </p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/08/20/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/6-%E5%90%88%E7%BA%A6(contract)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/20/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/6-%E5%90%88%E7%BA%A6(contract)/" class="post-title-link" itemprop="url">6-合约(contract)</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-20 00:00:00" itemprop="dateCreated datePublished" datetime="2022-08-20T00:00:00+08:00">2022-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ether-5-4-js/" itemprop="url" rel="index">
                    <span itemprop="name">ether@5.4.js</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h1><p><strong>new <em>ethers</em>.Contract( <em>address</em> , <em>abi</em> , <em>signerOrProvider</em> )：</strong>如果给定了Provider，那么合约只有<strong>只读</strong>访问权限，而Signer则提供了<strong>对状态操作方法</strong>的访问权限。</p>
<h2 id="1-1-attach"><a href="#1-1-attach" class="headerlink" title="1.1 attach"></a>1.1 attach</h2><p><em>contract</em>.<strong>attach</strong>( <em>addressOrName</em> ) ⇒ <em>合约（<strong>Contract</strong>）</em></p>
<p>返回一个新地址的<strong>Contract</strong>新实例,如果网络上有多个类似的合约副本,并且您希望与它们中的每一个进行交互，那么这是非常有用的。</p>
<h2 id="1-2-connect"><a href="#1-2-connect" class="headerlink" title="1.2 connect"></a>1.2 connect</h2><p><em>contract</em>.<strong>connect</strong>( <em>providerOrSigner</em> ) ⇒ <em>合约（<strong>Contract</strong>）</em></p>
<p>返回合约的一个新实例，但需要连接到<em>providerOrSigner</em>。</p>
<p>通过传入一个Provider，这将返回一个低级的合约实例，它只有只读访问的权限(即常量调用)。</p>
<p>通过传入一个Signer，这将返回一个代表该签名人（signer）的合约实例。</p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>**<em>contract</em>.address ⇒ *string&lt; 地址(Address) &gt;*：**这是构建合约时使用的地址(或ENS名称)。</p>
<p>**<em>contract</em>.resolvedAddress ⇒ *string&lt; 地址(Address) &gt;*：**这是一个合约对象将解析合约地址的promise。 如果一个地址(Address)被提供	给构造函数，它将解析成这个地址; 如果提供的是ENS名称，这将解析成对应的地址。</p>
<p><strong><em>contract</em>.deployTransaction ⇒ <em>TransactionResponse</em>：</strong>如果<strong>Contract</strong>是ContractFactory部署后返回的对象， deployTransaction返	回的数据就是部署这个合约的交易信息（transaction）。</p>
<p><strong><em>contract</em>.interface ⇒ <em>Interface</em>：</strong>这是作为Interface接口的ABI。</p>
<p><strong><em>contract</em>.provider ⇒ <em>Provider</em>：</strong>如果构造函数使用的是provider生成的contract合约对象，那么这个结果就是这个provider，如果使用	的是具有Provider的signer，那么这个结果就是provider。</p>
<p><strong><em>contract</em>.signer ⇒ <em>Signer</em>：</strong>如果构造函数使用的是signer生成的contract合约对象，那么这个结果就是这个signer。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p><em>contract</em>.<strong>deployed</strong>( ) ⇒ <em>Promise&lt; 合约（Contract） &gt;</em></p>
<p><em>Contract</em>.<strong>isIndexed</strong>( <em>value</em> ) ⇒ <em>boolean</em></p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p><em>*<em>contract</em>.queryFilter( <em>event</em> [ , <em>fromBlockOrBlockHash</em> [ , <em>toBlock</em> ] ) ⇒ *Promise&lt; Array&lt; Event &gt; &gt;<em>：**返回与</em>event</em>匹配的事件</p>
<p><strong><em>contract</em>.listenerCount( [ <em>event</em> ] ) ⇒ <em>number</em>：</strong>返回订阅该<em>event</em>的监听器数量。如果没有提供<em>event</em>，则返回所有事件的总数。</p>
<p><em>*<em>contract</em>.listeners( <em>event</em> ) ⇒ *Array&lt; Listener &gt;<em>：**返回订阅该</em>event</em>的监听器列表。</p>
<p><strong><em>contract</em>.off( <em>event</em> , <em>listener</em> ) ⇒ <em>this</em>：</strong>监听器取消订阅<em>event</em>事件。</p>
<p><strong><em>contract</em>.on( <em>event</em> , <em>listener</em> ) ⇒ <em>this</em>：</strong>监听<em>event</em>事件，当事件发生时，会调用<em>listener</em>函数。</p>
<p><em><strong>contract*.once( <em>event</em> , <em>listener</em> ) ⇒ *this：</strong></em>监听<em>event</em>事件，当事件发生时，仅调用一次<em>listener</em>函数。</p>
<p><em><strong>contract*.removeAllListeners( [ <em>event</em> ] ) ⇒ *this：</strong></em>取消所有订阅<em>event</em>事件监听器，如果未提供<em>event</em>事件，则取消订阅所有事件的监听</p>
<h1 id="元类-Meta-Class"><a href="#元类-Meta-Class" class="headerlink" title="元类(Meta-Class)"></a>元类(Meta-Class)</h1><p>元类是在运行时确定其所有属性的类。<strong>Contract</strong>对象使用合约的ABI来确定可使用方法（methods）， 因此下面的部分将描述用一些属性，来与在合约构造函数期间交互的通用方法。</p>
<p>只读的方法 (常量; 如 view 或 pure)</p>
<p>常量方法是只读的，针对当前区块链状态计算少量EVM代码，并可以通过请求单个节点来计算，该节点会返回一个结果。 因此，它是免费的，不需要任何以太币，但不能更改区块链状态。</p>
<h2 id="5-1-METHOD-NAME"><a href="#5-1-METHOD-NAME" class="headerlink" title="5.1 METHOD_NAME"></a>5.1 METHOD_NAME</h2><p><em>contract</em>.<strong>METHOD_NAME</strong>( …<em>args</em> [ , <em>overrides</em> ] ) ⇒ <em>Promise&lt; any &gt;</em></p>
<p>结果的类型取决于ABI。如果方法返回单个值，则将直接返回该值，否则将返回一个Result对象，其中包含每个位置可用的参数， 如果参数被命名，那么就按照命名后的值去执行。</p>
<p>如果返回的值匹配JavaScript中的类型值，如strings字符串类型 和 booleans布尔类型，那么返回的值类型就直接是JavaScript中的类型值。</p>
<p>但对于numbers类型，如果类型在JavaScript的安全范围内(即小于53位，如<code>int24</code>或<code>uint48</code>)，则使用标准的JavaScript number类型。 否则返回大数(BigNumber)类型。</p>
<p>对于字节bytes类型(包括固定长度和动态)，将返回一个DataHexString。</p>
<p>如果call reverts(或runs out of gas)，将抛出一个CALL_EXCEPTION，其中包括:</p>
<ul>
<li><code>error.address</code> - 合约地址</li>
<li><code>error.args</code> - 合约方法中传入的参数</li>
<li><code>error.transaction</code> - 交易</li>
</ul>
<p>只读方法的<em>overrides</em>对象可以包括以下任何一个:</p>
<ul>
<li><p><code>overrides.from</code> - 代码执行期间使用的<code>msg.sender</code> (或 <code>CALLER</code>)</p>
</li>
<li><p><code>overrides.value</code> - 代码执行期间使用的<code>msg.value</code> (或 <code>CALLVALUE</code>)</p>
</li>
<li><p><code>overrides.gasPrice</code> - 每个gas的价格(理论上);因为没有交易，所以不会收取任何费用，但EVM仍然需要向<code>tx.gasprice</code>(或<code>GASPRICE</code>)传递value值; <em>大多数开发人员不需要这样做</em></p>
</li>
<li><p><code>overrides.gasLimit</code> - 在执行代码期间允许节点使用的gas数量(理论上);因为没有交易，所以不会有任何费用，但EVM仍然估计gas总数量，因此会向<code>gasleft</code> (或 <code>GAS</code>) 传递这些值。</p>
</li>
<li><p><code>overrides.blockTag</code> - 一个用来模拟在哪里执行的块标签，可以用于假设性历史分析;注意，许多后端不支持这一点，或者可能需要付费访问，因为节点数据库存储和处理需求费用要高得多</p>
</li>
</ul>
<h2 id="5-2-functions-METHOD-NAME"><a href="#5-2-functions-METHOD-NAME" class="headerlink" title="5.2 functions.METHOD_NAME"></a>5.2 <em>functions</em>.METHOD_NAME</h2><p><em>contract</em>.<em>functions</em>.<strong>METHOD_NAME</strong>( …<em>args</em> [ , <em>overrides</em> ] ) ⇒ <em>Promise&lt; Result &gt;</em></p>
<p>结果将始终是Result，即使只有一个返回值类型。</p>
<p>这简化了期望使用合约（Contract）对象的框架，因为它们不需要检查返回类型来展开简化函数。</p>
<p>此方法的另一个用途是用于错误恢复。例如，如果一个函数的结果是一个无效的UTF-8字符串，使用上述元类函数的普通调用将抛出一个异常。 这允许使用Result access error来访问低级字节以及错误的原因，从而允许使用另一种UTF-8错误策略。</p>
<p>大多数开发人员不需要这样做。</p>
<p><em>overrides</em>与上面的只读操作相同。</p>
<h3 id="Write-Methods-non-constant"><a href="#Write-Methods-non-constant" class="headerlink" title="Write Methods (non-constant)"></a>Write Methods (non-constant)</h3><p>非常量方法要求签名一笔交易，并需要向矿工支付费用。这个交易将由整个网络上的所有节点以及矿工进行验证， 矿工会根据当前状态执行，接着在区块链计算新状态。</p>
<p>它不能返回结果。如果需要一个结果，那么应该使用Solidity事件(或EVM日志)对其进行记录，然后可以从交易收据中查询该事件。</p>
<h2 id="5-3-METHOD-NAME"><a href="#5-3-METHOD-NAME" class="headerlink" title="5.3 METHOD_NAME"></a>5.3 METHOD_NAME</h2><p><em>contract</em>.<strong>METHOD_NAME</strong>( …<em>args</em> [ , <em>overrides</em> ] ) ⇒ <em>Promise&lt; TransactionResponse &gt;</em></p>
<p>交易被发送到网络后，返回交易的TransactionResponse。 <strong>Contract</strong>合约对象需要signer。</p>
<p>重写方法的<em>overrides</em>对象可以是以下任何一个:</p>
<ul>
<li><code>overrides.gasPrice</code> - 每个gas的价格</li>
<li><code>overrides.gasLimit</code> - 该笔交易允许使用的gas的最大数量，未被使用的gas按照gasPrice退还</li>
<li><code>overrides.value</code> - 调用中转账的ether (wei格式)数量</li>
<li><code>overrides.nonce</code> - Signer使用的nonce值</li>
</ul>
<p>如果返回的TransactionResponse使用了<code>wait()</code>方法，那么在收据上将会有额外的属性:</p>
<ul>
<li><code>receipt.events</code> - 带有附加属性的日志数组(如果ABI包含事件的描述)</li>
<li><code>receipt.events[n].args</code> - 解析后的参数</li>
<li><code>receipt.events[n].decode</code> - 可以用来解析日志主题（topics）和数据的方法(用于计算<code>args</code>)</li>
<li><code>receipt.events[n].event</code> - 事件的名称</li>
<li><code>receipt.events[n].eventSignature</code> - 这个事件完整的签名</li>
<li><code>receipt.removeListener()</code> - 用于移除触发此事件的监听器的方法</li>
<li><code>receipt.getBlock()</code> - 返回发生触发此事件的Block</li>
<li><code>receipt.getTransaction()</code> - 返回发生触发此事件的Transaction</li>
<li><code>receipt.getTransactionReceipt()</code> - 返回发生触发此事件的Transaction Receipt</li>
</ul>
<h2 id="Write-Methods-Analysis"><a href="#Write-Methods-Analysis" class="headerlink" title="Write Methods Analysis"></a>Write Methods Analysis</h2><p>在不实际执行的情况下，有几个选项可以分析write method的属性和结果。</p>
<h2 id="5-4-estimateGas-METHOD-NAME"><a href="#5-4-estimateGas-METHOD-NAME" class="headerlink" title="5.4 estimateGas.METHOD_NAME"></a>5.4 estimateGas.METHOD_NAME</h2><p><em>contract</em>.<em>estimateGas</em>.<strong>METHOD_NAME</strong>( …<em>args</em> [ , <em>overrides</em> ] ) ⇒ <em>Promise&lt; 大数(BigNumber) &gt;</em></p>
<p>返回使用 <em>args</em>和<em>overrides</em>执行<em>METHOD_NAME</em>所需的gas的估计单位。</p>
<p><em>overrides</em>与上面针对只读或写方法的overrides相同，具体取决于 <em>METHOD_NAME</em>调用的类型。</p>
<h2 id="5-5-populateTransaction-METHOD-NAME"><a href="#5-5-populateTransaction-METHOD-NAME" class="headerlink" title="5.5 populateTransaction.METHOD_NAME"></a>5.5 populateTransaction.METHOD_NAME</h2><p><em>contract</em>.<em>populateTransaction</em>.<strong>METHOD_NAME</strong>( …<em>args</em> [ , <em>overrides</em> ] ) ⇒ <em>Promise&lt; UnsignedTx &gt;</em></p>
<p>返回一个未签名交易(UnsignedTransaction)，它表示需要签名并提交给网络的交易，以执行带有<em>args</em>和<em>overrides</em>的<em>METHOD_NAME</em>。</p>
<p><em>overrides</em>与上面针对只读或写方法的overrides相同，具体取决于 <em>METHOD_NAME</em>调用的类型。</p>
<h2 id="5-6-callStatic-METHOD-NAME"><a href="#5-6-callStatic-METHOD-NAME" class="headerlink" title="5.6 callStatic.METHOD_NAME"></a>5.6 callStatic.METHOD_NAME</h2><p><em>contract</em>.<em>callStatic</em>.<strong>METHOD_NAME</strong>( …<em>args</em> [ , <em>overrides</em> ] ) ⇒ <em>Promise&lt; any &gt;</em></p>
<p>比起执行交易状态更改，更可能是会要求节点<em>尝试</em>调用不进行状态的更改并返回结果。</p>
<p>这实际上并不改变任何状态，而是免费的。在某些情况下，这可用于确定交易是失败还是成功。</p>
<p>otherwise函数与Read-Only Method相同。</p>
<p><em>overrides</em>与上面的只读操作相同。</p>
<h2 id="Event-Filters"><a href="#Event-Filters" class="headerlink" title="Event Filters"></a>Event Filters</h2><p>事件过滤器由主题（topics）组成，这些主题是Bloom Filter中记录的值，允许对匹配过滤器的条目进行有效搜索。</p>
<h2 id="5-7-filters-EVENT-NAME"><a href="#5-7-filters-EVENT-NAME" class="headerlink" title="5.7 filters.EVENT_NAME"></a>5.7 filters.EVENT_NAME</h2><p><em>contract</em>.<em>filters</em>.<strong>EVENT_NAME</strong>( …<em>args</em> ) ⇒ <em>Filter</em></p>
<p>返回<em>EVENT_NAME</em>的过滤器，可以通过增加其他约束进行过滤。</p>
<p>只有<code>indexed</code>索引的事件参数可以被过滤。如果参数为空(或未提供)，则该字段中的任何值都匹配。</p>
<h1 id="Example-ERC-20-Contract"><a href="#Example-ERC-20-Contract" class="headerlink" title="Example:ERC-20 Contract"></a>Example:ERC-20 Contract</h1><h2 id="6-1-部署合约"><a href="#6-1-部署合约" class="headerlink" title="6.1 部署合约"></a>6.1 部署合约</h2><p>**new <em>ethers</em>.ContractFactory( <em>abi</em> , <em>bytecode</em> , <em>signer</em> )**：创建一个新的ContractFactory，它可以将合约部署到区块链。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bytecode = <span class="string">&quot;0x60806040523480156100105760008......&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个人类可读（Human-Readable）的ABI;我们只需要指定相关的部分内容，在这里我们用到了构造函数</span></span><br><span class="line"><span class="keyword">const</span> abi = [</span><br><span class="line">    <span class="string">&quot;constructor(uint totalSupply)&quot;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factory = <span class="keyword">new</span> ethers.<span class="title class_">ContractFactory</span>(abi, bytecode, signer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部署，设置token的total supply为100，分配给部署人（deployer）</span></span><br><span class="line"><span class="keyword">const</span> contract = <span class="keyword">await</span> factory.<span class="title function_">deploy</span>(<span class="title function_">parseUnits</span>(<span class="string">&quot;100&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//链上现在虽然我们还没有这个合约，但是这个合约地址我们是预先经过计算后得到的</span></span><br><span class="line">contract.<span class="property">address</span></span><br><span class="line"><span class="comment">// &#x27;0xa22aB6748282B3125dC26dAFb79e38B7eb24EAcC&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在交易被挖出来之前(即合约被部署)等待（Wait）</span></span><br><span class="line"><span class="comment">//  - 部署后，交易会返回receipt</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="property">deployTransaction</span>.<span class="title function_">wait</span>();</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   blockHash: &#x27;0xe9b244958d066490c46a826a9733c1a43210316777185353b3ecbc2ec362ea87&#x27;,</span></span><br><span class="line"><span class="comment">//   blockNumber: 22,</span></span><br><span class="line"><span class="comment">//   byzantium: true,</span></span><br><span class="line"><span class="comment">//   confirmations: 1,</span></span><br><span class="line"><span class="comment">//   contractAddress: &#x27;0xa22aB6748282B3125dC26dAFb79e38B7eb24EAcC&#x27;,</span></span><br><span class="line">	 ......</span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-2-Meta-Class-Methods"><a href="#6-2-Meta-Class-Methods" class="headerlink" title="6.2 Meta-Class Methods"></a>6.2 <strong>Meta-Class Methods</strong></h2><blockquote>
<p>因为合约是元类，这里面可用的方法取决于传入<strong>合约</strong>的ABI</p>
</blockquote>
<p>**<em>erc20</em>.decimals( [ <em>overrides</em> ] ) ⇒ *Promise&lt; number &gt;*：**返回此ERC-20 token所使用的小数位数。在前端界面，当从用户获取输入时，	可以使用parseUnits转化后传入合约； 从合约获得token后可以通过[formatUnits](utils-formatunits]转化后再显示给用户。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> erc20.<span class="title function_">decimals</span>(); </span><br><span class="line"><span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<p>**<em>erc20</em>.balanceOf( <em>owner</em> [ , <em>overrides</em> ] ) ⇒ *Promise&lt; 大数(BigNumber) &gt;<em>：**返回持有这个ERC-20 token的</em>持有者(owner)*的余额。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> erc20.<span class="title function_">balanceOf</span>(signer.<span class="title function_">getAddress</span>()) </span><br><span class="line"><span class="comment">// &#123; BigNumber: &quot;100000000000000000000&quot; &#125;</span></span><br></pre></td></tr></table></figure>

<p>**<em>erc20</em>.symbol( [ <em>overrides</em> ] ) ⇒ *Promise&lt; string &gt;*：**返回token的symbol。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> erc20.<span class="title function_">symbol</span>(); </span><br><span class="line"><span class="comment">// &#x27;MyToken&#x27;</span></span><br></pre></td></tr></table></figure>

<p><em>*<em>erc20_rw</em>.transfer( <em>target</em> , <em>amount</em> [ , <em>overrides</em> ] ) ⇒ *Promise&lt; TransactionResponse &gt;<em>：**从当前的signer将数量为</em>amount</em>的tokens	转给接收者<em>target</em>。 在交易处于写入操作时，返回值(布尔类型)是得不到的。 如果需要这个值，则需要其他方法(如事件)。链上合约调	用<code>transfer</code>函数可以得到这个结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这之前先转化格式</span></span><br><span class="line"><span class="title function_">formatUnits</span>(<span class="keyword">await</span> erc20_rw.<span class="title function_">balanceOf</span>(signer.<span class="title function_">getAddress</span>()));</span><br><span class="line"><span class="comment">// &#x27;100.0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转 1.23 tokens 到 ENS name 为 &quot;ricmoo.eth&quot; 的地址</span></span><br><span class="line">tx = <span class="keyword">await</span> erc20_rw.<span class="title function_">transfer</span>(<span class="string">&quot;ricmoo.eth&quot;</span>, <span class="title function_">parseUnits</span>(<span class="string">&quot;1.23&quot;</span>));</span><br><span class="line"><span class="comment">//TransactionRequest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待交易所在的区块被挖出打包</span></span><br><span class="line"><span class="keyword">await</span> tx.<span class="title function_">wait</span>();</span><br><span class="line"><span class="comment">//TransactionResponse </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功后转化格式</span></span><br><span class="line"><span class="title function_">formatUnits</span>(<span class="keyword">await</span> erc20_rw.<span class="title function_">balanceOf</span>(signer.<span class="title function_">getAddress</span>()));</span><br><span class="line"><span class="comment">// &#x27;98.77&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">formatUnits</span>(<span class="keyword">await</span> erc20_rw.<span class="title function_">balanceOf</span>(<span class="string">&quot;ricmoo.eth&quot;</span>));</span><br><span class="line"><span class="comment">// &#x27;1.23</span></span><br></pre></td></tr></table></figure>

<p><em>*<em>erc20</em>.<em>callStatic</em>.transfer( <em>target</em> , <em>amount</em> [ , <em>overrides</em> ] ) ⇒ <em>Promise&lt; boolean &gt;</em>:*<em>执行一次从当前signer向</em>target<em>地址转移</em>amount</em>数量的token的演练，而不实际签名或发送交易,这可以用于检查真实的转账前，交易是否能成功。</p>
<p><em>*<em>erc20</em>.<em>estimateGas</em>.transfer( <em>target</em> , <em>amount</em> [ , <em>overrides</em> ] ) ⇒ <em>Promise&lt; 大数(BigNumber) &gt;</em>:*<em>返回估计的“将</em>amount<em>数量的tokens发送</em>target</em>地址”所需的多少gas值。</p>
<p><em>*<em>erc20</em>.<em>populateTransaction</em>.transfer( <em>target</em> , <em>amount</em> [ , <em>overrides</em> ] ) ⇒ <em>Promise&lt; UnsignedTx &gt;</em>:*<em>返回一个未签名交易，它可以被签名并提交给网络，达成“将</em>amount<em>数量的tokens发送</em>target</em>地址”的目的。</p>
<h2 id="6-3-Meta-Class-Fileters"><a href="#6-3-Meta-Class-Fileters" class="headerlink" title="6.3 Meta-Class Fileters"></a>6.3 Meta-Class Fileters</h2><p><strong><em>erc20</em>.<em>filters</em>.Transfer( [ <em>fromAddress</em> [ , <em>toAddress</em> ] ] ) ⇒ <em>Filter</em>：</strong>返回一个新的Filter用于查询或者去subscribe&#x2F;unsubscribe to 	events，如果<em>fromAddress</em> 是空的或者没有填写，将匹配任何发送人的地址。 如果 <em>toAddress</em>是空的或者没有填写，将匹配任何接受人的地址。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">filterFrom = erc20.<span class="property">filters</span>.<span class="title class_">Transfer</span>(signer.<span class="property">address</span>);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   address: &#x27;0xa22aB6748282B3125dC26dAFb79e38B7eb24EAcC&#x27;,</span></span><br><span class="line"><span class="comment">//   topics: [</span></span><br><span class="line"><span class="comment">//     &#x27;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&#x27;,</span></span><br><span class="line"><span class="comment">//     &#x27;0x000000000000000000000000894ed91b666facce5a4d2ff8261924b4754a5759&#x27;</span></span><br><span class="line"><span class="comment">//   ]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在最新的10个区块内查询我发送的交易</span></span><br><span class="line">logsFrom = <span class="keyword">await</span> erc20.<span class="title function_">queryFilter</span>(filterFrom, -<span class="number">10</span>, <span class="string">&quot;latest&quot;</span>);</span><br><span class="line"><span class="comment">//Array&lt;TransactionResponse&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听signer的发送的event事件:</span></span><br><span class="line">erc20.<span class="title function_">on</span>(filterFrom, <span class="function">(<span class="params"><span class="keyword">from</span>, to, amount, event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// The `from` will always be the signer address</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听signer的接受转账的event事件:</span></span><br><span class="line">erc20.<span class="title function_">on</span>(filterTo, <span class="function">(<span class="params"><span class="keyword">from</span>, to, amount, event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// The `to` will always be the signer address</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听所有的转账交易event事件:</span></span><br><span class="line">erc20.<span class="title function_">on</span>(<span class="string">&quot;Transfer&quot;</span>, <span class="function">(<span class="params"><span class="keyword">from</span>, to, amount, event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/08/14/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/5-Singers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/14/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/5-Singers/" class="post-title-link" itemprop="url">5-Singers</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-14 00:00:00" itemprop="dateCreated datePublished" datetime="2022-08-14T00:00:00+08:00">2022-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ether-5-4-js/" itemprop="url" rel="index">
                    <span itemprop="name">ether@5.4.js</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Singer"><a href="#Singer" class="headerlink" title="Singer"></a>Singer</h1><p><strong>Signer</strong>类是抽象的，<strong>不能直接实例化，而是应该使用一个具体的子类</strong>，如 Wallet, VoidSigner 或 JsonRpcSigner。</p>
<h2 id="1-1-属性"><a href="#1-1-属性" class="headerlink" title="1.1 属性"></a>1.1 属性</h2><p><em><strong>signer*.connect( <em>provider</em> ) ⇒ *Signer</strong></em>:子类<strong>必须</strong>实现这个，如果更改后的providers是不被支持的话，它们可能仅仅只抛出一个错误。</p>
<p><em><strong>signer*.getAddress( ) ⇒ *Promise&lt; string&lt; 地址(Address) &gt; &gt;</strong></em>:返回一个解析为帐户地址的Promise。</p>
<p>​	子类<strong>必须</strong>实现这个,这是一个Promise，因此一个<strong>Signer</strong>可以围绕一个异步源进行设计，如硬钱包。</p>
<p><em><strong>Signer*.isSigner( <em>object</em> ) ⇒ *boolean</strong></em>:当且仅当 <em>object</em> 是一个<strong>Signer</strong>时返回true。</p>
<h2 id="1-2-Blockchain-方法"><a href="#1-2-Blockchain-方法" class="headerlink" title="1.2 Blockchain 方法"></a>1.2 <strong>Blockchain</strong> 方法</h2><h3 id="1-2-1-getBalance"><a href="#1-2-1-getBalance" class="headerlink" title="1.2.1 getBalance"></a>1.2.1 getBalance</h3><p><em>signer</em>.<strong>getBalance</strong>( [ <em>blockTag</em> &#x3D; “<em>latest</em>“ ] ) ⇒ <em>Promise&lt; 大数(**BigNumber**) &gt;</em></p>
<p>在指定的<em>blockTag</em>下返回这个钱包的余额。</p>
<h3 id="1-2-2-getChainId"><a href="#1-2-2-getChainId" class="headerlink" title="1.2.2  getChainId"></a>1.2.2  getChainId</h3><p><em>signer</em>.<strong>getChainId</strong>( ) ⇒ <em>Promise&lt; **number** &gt;</em></p>
<p>返回这个钱包连接的链 ID。</p>
<h3 id="1-2-3-getGasPrice"><a href="#1-2-3-getGasPrice" class="headerlink" title="1.2.3 getGasPrice"></a>1.2.3 getGasPrice</h3><p><em>signer</em>.<strong>getGasPrice</strong>( ) ⇒ <em>Promise&lt; 大数(**BigNumber**) &gt;</em></p>
<p>返回当前的gas price。</p>
<h3 id="1-2-4-getTransactionCount"><a href="#1-2-4-getTransactionCount" class="headerlink" title="1.2.4 getTransactionCount"></a>1.2.4 getTransactionCount</h3><p><em>signer</em>.<strong>getTransactionCount</strong>( [ <em>blockTag</em> &#x3D; “<em>latest</em>“ ] ) ⇒ <em>Promise&lt; **number** &gt;</em></p>
<p>返回此帐户曾经发送的交易数量，交易中的中nonce依赖这个值。</p>
<h3 id="1-2-5-call"><a href="#1-2-5-call" class="headerlink" title="1.2.5 call"></a>1.2.5 call</h3><p><em>signer</em>.<strong>call</strong>( <em>transactionRequest</em> ) ⇒ <em>Promise&lt; string&lt; **DataHexString** &gt; &gt;</em></p>
<p>返回<em>transactionRequest</em>调用的结果，此帐户地址用作<code>from</code> 字段。</p>
<h3 id="1-2-6-estimateGas"><a href="#1-2-6-estimateGas" class="headerlink" title="1.2.6 estimateGas"></a>1.2.6 estimateGas</h3><p><em>signer</em>.<strong>estimateGas</strong>( <em>transactionRequest</em> ) ⇒ <em>Promise&lt; 大数(**BigNumber**) &gt;</em></p>
<p>返回发送<em>transactionRequest</em>的估算费用，在使用这个方法之前先用账户地址填充<code>from</code>字段。</p>
<h3 id="1-2-7-resolveName"><a href="#1-2-7-resolveName" class="headerlink" title="1.2.7 resolveName"></a>1.2.7 resolveName</h3><p><em>signer</em>.<strong>resolveName</strong>( <em>ensName</em> ) ⇒ <em>Promise&lt; string&lt; 地址(**Address**) &gt; &gt;</em></p>
<p>返回与<em>ensName</em>关联的地址。</p>
<h2 id="1-3-Signing方法"><a href="#1-3-Signing方法" class="headerlink" title="1.3 Signing方法"></a>1.3 <strong>Signing</strong>方法</h2><h3 id="1-3-1-signMessage"><a href="#1-3-1-signMessage" class="headerlink" title="1.3.1 signMessage"></a>1.3.1 signMessage</h3><p><em>signer</em>.<strong>signMessage</strong>( <em>message</em> ) ⇒ <em>Promise&lt; string&lt; **RawSignature** &gt; &gt;</em></p>
<p>这将返回一个解析为消息的Raw Signature Promise。</p>
<p>由于使用的是hashMessage方法，因此它是EIP-191兼容的。 如果在Solidity中恢复地址，则需要这个前缀来创建一个匹配的哈希。</p>
<p>子类<strong>必须</strong>实现这个方法。 如果不支持签名消息可能会抛出错误，比如在基于合约的钱包或基于元交易的钱包中使用时。</p>
<h3 id="1-3-2-signTransaction"><a href="#1-3-2-signTransaction" class="headerlink" title="1.3.2 signTransaction"></a>1.3.2 signTransaction</h3><p><em>signer</em>.<strong>signTransaction</strong>( <em>transactionRequest</em> ) ⇒ <em>Promise&lt; string&lt; **DataHexString** &gt; &gt;</em></p>
<p>返回一个解析为<em>transactionRequest</em>中<strong>已签名的交易</strong>的Promise。 此方法不填充任何缺少的字段。</p>
<p>子类<strong>必须</strong>实现这个，如果不支持签名消息可能会抛出错误，出于安全这在许多客户端中是常见的。</p>
<h3 id="1-3-3-sendTransaction"><a href="#1-3-3-sendTransaction" class="headerlink" title="1.3.3 sendTransaction"></a>1.3.3 sendTransaction</h3><p><em>signer</em>.<strong>sendTransaction</strong>( <em>transactionRequest</em> ) ⇒ <em>Promise&lt; **TransactionResponse** &gt;</em></p>
<p>该方法使用populate Transaction填充缺少字段的transactionRequest，并返回一个解析成交易的Promise。</p>
<h3 id="1-3-4-signTypedData"><a href="#1-3-4-signTypedData" class="headerlink" title="1.3.4 _signTypedData"></a>1.3.4 _signTypedData</h3><p><em>signer</em>.<strong>_signTypedData</strong>( <em>domain</em> , <em>types</em> , <em>value</em> ) ⇒ <em>Promise&lt; string&lt; **RawSignature** &gt; &gt;</em></p>
<blockquote>
<p>实验中的功能。如果使用它，请<strong>指定</strong>您正在使用的ethers的确切版本(例如指定<code>&quot;5.0.18&quot;</code>，而不是<code>&quot;^5.0.18&quot;</code>)， 因为方法名将从<code>_signTypedData</code>重命名为<code>signTypedData</code>。</p>
</blockquote>
<h2 id="1-4-Sub-Classes"><a href="#1-4-Sub-Classes" class="headerlink" title="1.4 Sub-Classes"></a>1.4 <strong>Sub-Classes</strong></h2><p><strong>Signer</strong>的所有重要属性都是不可变的，这一点非常重要。由于以太坊是异步的，并处理关键数据(如ether和其他潜在有价值的加密资产)， 整个Signer的生命周期中保持<em>provider</em>和 <em>address</em>等属性是静态的有助于防止严重的问题的出现， 而且许多其他类和库也是认定<em>provider</em>和 <em>address</em>等属性是静态的。</p>
<p>子类<strong>必须</strong>扩展Signer，并且<strong>必须</strong>调用<code>super()</code>。</p>
<h3 id="1-4-1-checkTransaction"><a href="#1-4-1-checkTransaction" class="headerlink" title="1.4.1 checkTransaction"></a>1.4.1 <strong>checkTransaction</strong></h3><p><em>signer</em>.<strong>checkTransaction</strong>( <em>transactionRequest</em> ) ⇒ <em><strong>TransactionRequest</strong></em></p>
<p>这应该返回一个<em>transactionRequest</em>的副本，包含<code>call</code>、<code>estimateGas</code>和<code>populateTransaction</code> (sendTransaction使用的)所需的任何属性。 如果指定了任何未知的key，它会抛出一个错误。</p>
<p>默认的实现只<strong>验证有效的TransactionRequest属性是否存在</strong>，如果不存在，则将<code>from</code>添加到交易中。</p>
<p>如果存在<code>from</code>字段，则<strong>必须</strong>验证它与 Signer的地址是否相等。</p>
<h3 id="1-4-2-populateTransaction"><a href="#1-4-2-populateTransaction" class="headerlink" title="1.4.2 populateTransaction"></a>1.4.2 <strong>populateTransaction</strong></h3><p><em>signer</em>.<strong>populateTransaction</strong>( <em>transactionRequest</em> ) ⇒ <em>Promise&lt; **TransactionRequest** &gt;</em></p>
<p>这应该返回一个<em>transactionRequest</em>的副本，遵循与<code>checkTransaction</code>相同的过程， 并填写发送交易所需的任何属性。</p>
<p>返回的结果都是promises，可以使用<strong>resolvePropertiesutility</strong>函数来解析。</p>
<p>默认实现调用<code>checkTransaction</code>，如果它是一个ENS name就会解析它，并根据Signer上的相关操作添加<code>gasPrice</code>, <code>nonce</code>, <code>gasLimit</code>和<code>chainId</code></p>
<h1 id="Wallet"><a href="#Wallet" class="headerlink" title="Wallet"></a>Wallet</h1><p>Wallet类继承了Signer，可以使用私钥作为外部拥有帐户(EOA)的标准对交易和消息进行签名</p>
<p><strong>new <em>ethers</em>.Wallet( <em>privateKey</em> [ , <em>provider</em> ] )</strong></p>
<p>为<em>privateKey</em>创建一个新的钱包实例，并可选地连接到<em>provider</em>。</p>
<h2 id="2-1-方法"><a href="#2-1-方法" class="headerlink" title="2.1 方法"></a>2.1 方法</h2><h3 id="2-1-1-createRandom"><a href="#2-1-1-createRandom" class="headerlink" title="2.1.1 createRandom"></a>2.1.1 createRandom</h3><p><em>ethers</em>.<em>Wallet</em>.<strong>createRandom</strong>( [ <em>options</em> &#x3D; {} ] ) ⇒ <em><strong>Wallet</strong></em></p>
<p>返回一个带有随机私钥的新钱包，由加密安全的熵源生成。如果当前环境没有安全的熵源，则会抛出错误。</p>
<p>使用此方法创建的钱包将具有助记词。</p>
<h3 id="2-1-2-fromEncryptedJson"><a href="#2-1-2-fromEncryptedJson" class="headerlink" title="2.1.2 fromEncryptedJson"></a>2.1.2 fromEncryptedJson</h3><p><em>ethers</em>.<em>Wallet</em>.<strong>fromEncryptedJson</strong>( <em>json</em> , <em>password</em> [ , <em>progress</em> ] ) ⇒ <em>Promise&lt; **Wallet** &gt;</em></p>
<p>从加密的JSON钱包创建一个实例。</p>
<p>如果提供了<em>进度</em>，它将在解密期间被调用，其值介于0到1之间，表示一个完成进度。</p>
<h3 id="2-1-3-fromEncryptedJsonSync"><a href="#2-1-3-fromEncryptedJsonSync" class="headerlink" title="2.1.3 fromEncryptedJsonSync"></a>2.1.3 fromEncryptedJsonSync</h3><p><em>ethers</em>.<em>Wallet</em>.<strong>fromEncryptedJsonSync</strong>( <em>json</em> , <em>password</em> ) ⇒ <em><strong>Wallet</strong></em></p>
<p>从加密的JSON钱包创建一个实例。</p>
<p>此操作将同步操作，从而锁定用户界面一段时间。 大多数应用程序应该使用异步的<code>fromEncryptedJson</code>。</p>
<h3 id="2-1-4-fromMnemonic"><a href="#2-1-4-fromMnemonic" class="headerlink" title="2.1.4 fromMnemonic"></a>2.1.4 fromMnemonic</h3><p><em>ethers</em>.<em>Wallet</em>.<strong>fromMnemonic</strong>( <em>mnemonic</em> [ , <em>path</em> , [ <em>wordlist</em> ] ] ) ⇒ <em><strong>Wallet</strong></em></p>
<p>从助记短语中创建实例如果没有指定path，则使用的默认path路径(<code>m/44&#39;/60&#39;/0&#39;/0/0</code>),如果不指定wordlist，则使用English Wordlist</p>
<h3 id="2-1-5-encrypt"><a href="#2-1-5-encrypt" class="headerlink" title="2.1.5 encrypt"></a>2.1.5 encrypt</h3><p><em>wallet</em>.<strong>encrypt</strong>( <em>password</em> , [ <em>options</em> &#x3D; {} , [ <em>progress</em> ] ] ) ⇒ <em>Promise&lt; **string** &gt;</em></p>
<p>加密钱包，使用<em>password</em>返回一个解析为JSON钱包的Promise。</p>
<p>如果提供了<em>进度</em>，它将在解密期间被调用，其值介于0到1之间，表示一个完成进度。</p>
<h2 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="2.2 属性"></a>2.2 属性</h2><p>**<em>wallet</em>.address ⇒ *string&lt; 地址(Address) &gt;*：**此钱包表示的帐户的地址。</p>
<p><strong><em>wallet</em>.provider ⇒ <em>Provider</em>：</strong>这个钱包所连接的provider，它将用于任何Blockchain Methods的方法，它也可以是null。</p>
<blockquote>
<p>一个<strong>钱包</strong>实例是不可变的，因此如果您希望更改Provider，您可以使用connect方法创建一个连接到所需的provider的新实例。</p>
</blockquote>
<p>**<em>wallet</em>.publicKey ⇒ *string&lt; DataHexString&lt; 65 &gt; &gt;***：此钱包的未压缩的公钥</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过助记词创建一个钱包实例</span></span><br><span class="line">mnemonic = <span class="string">&quot;announce room limb pattern dry unit scale effort smooth jazz weasel alcohol&quot;</span></span><br><span class="line">walletMnemonic = <span class="title class_">Wallet</span>.<span class="title function_">fromMnemonic</span>(mnemonic)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者通过私钥创建一个钱包实例</span></span><br><span class="line">walletPrivateKey = <span class="keyword">new</span> <span class="title class_">Wallet</span>(walletMnemonic.<span class="property">privateKey</span>)</span><br><span class="line"></span><br><span class="line">walletMnemonic.<span class="property">address</span> === walletPrivateKey.<span class="property">address</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有着每个Signer API的地址，是一个Promise对象</span></span><br><span class="line"><span class="keyword">await</span> walletMnemonic.<span class="title function_">getAddress</span>()</span><br><span class="line"><span class="comment">// &#x27;0x71CB05EE1b1F506fF321Da3dac38f25c0c9ce6E1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个钱包地址，也可用同步的方式获得</span></span><br><span class="line">walletMnemonic.<span class="property">address</span></span><br><span class="line"><span class="comment">// &#x27;0x71CB05EE1b1F506fF321Da3dac38f25c0c9ce6E1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部加密组件</span></span><br><span class="line">walletMnemonic.<span class="property">privateKey</span></span><br><span class="line"><span class="comment">// &#x27;0x1da6847600b0ee25e9ad9a52abbd786dd2502fa4005dd5af9310b7cc7a3b25db&#x27;</span></span><br><span class="line">walletMnemonic.<span class="property">publicKey</span></span><br><span class="line"><span class="comment">// &#x27;0x04b9e72dfd423bcf95b3801ac93f4392be5ff22143f9980eb78b3a860c4843bfd04829ae61cdba4b3b1978ac5fc64f5cc2f4350e35a108a9c9a92a81200a60cd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 钱包助记词</span></span><br><span class="line">walletMnemonic.<span class="property">mnemonic</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   locale: &#x27;en&#x27;,</span></span><br><span class="line"><span class="comment">//   path: &quot;m/44&#x27;/60&#x27;/0&#x27;/0/0&quot;,</span></span><br><span class="line"><span class="comment">//   phrase: &#x27;announce room limb pattern dry unit scale effort smooth jazz weasel alcohol&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: 通过私钥创建的钱包实例没有助记词，因为从数学上无法推导</span></span><br><span class="line">walletPrivateKey.<span class="property">mnemonic</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 签名消息</span></span><br><span class="line"><span class="keyword">await</span> walletMnemonic.<span class="title function_">signMessage</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"><span class="comment">// &#x27;0x14280e5885a19f60e536de50097e96e3738c7acae4e9e62d67272d794b8127d31c03d9cd59781d4ee31fb4e1b893bd9b020ec67dfa65cfb51e2bdadbb1de26d91c&#x27;</span></span><br><span class="line"></span><br><span class="line">tx = &#123;</span><br><span class="line">  <span class="attr">to</span>: <span class="string">&quot;0x8ba1f109551bD432803012645Ac136ddd64DBA72&quot;</span>,</span><br><span class="line">  <span class="attr">value</span>: utils.<span class="title function_">parseEther</span>(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 签名交易</span></span><br><span class="line"><span class="keyword">await</span> walletMnemonic.<span class="title function_">signTransaction</span>(tx)</span><br><span class="line"><span class="comment">// &#x27;0xf865808080948ba1f109551bd432803012645ac136ddd64dba72880de0b6b3a7640000801ca0918e294306d177ab7bd664f5e141436563854ebe0a3e523b9690b4922bbb52b8a01181612cec9c431c4257a79b8c9f0c980a2c49bb5a0e6ac52949163eeb565dfc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// connect方法返回一个连接到provider的新钱包实例</span></span><br><span class="line">wallet = walletMnemonic.<span class="title function_">connect</span>(provider)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从网络中查询</span></span><br><span class="line"><span class="keyword">await</span> wallet.<span class="title function_">getBalance</span>();</span><br><span class="line"><span class="comment">// &#123; BigNumber: &quot;6846&quot; &#125;</span></span><br><span class="line"><span class="keyword">await</span> wallet.<span class="title function_">getTransactionCount</span>();</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 ether</span></span><br><span class="line"><span class="keyword">await</span> wallet.<span class="title function_">sendTransaction</span>(tx)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   accessList: [],</span></span><br><span class="line"><span class="comment">//   chainId: 31337,</span></span><br><span class="line"><span class="comment">//   confirmations: 0,</span></span><br><span class="line"><span class="comment">//   data: &#x27;0x&#x27;,</span></span><br><span class="line"><span class="comment">//   from: &#x27;0x894ed91B666FacCe5a4D2FF8261924b4754A5759&#x27;,</span></span><br><span class="line"><span class="comment">//   gasLimit: &#123; BigNumber: &quot;21001&quot; &#125;,</span></span><br><span class="line"><span class="comment">//   gasPrice: null,</span></span><br><span class="line"><span class="comment">//   hash: &#x27;0x1b4a95e9d23bd96d5429c535148eb3eaed326d89118b118e44cc05c26703224e&#x27;,</span></span><br><span class="line"><span class="comment">//   maxFeePerGas: &#123; BigNumber: &quot;1572346688&quot; &#125;,</span></span><br><span class="line"><span class="comment">//   maxPriorityFeePerGas: &#123; BigNumber: &quot;1500000000&quot; &#125;,</span></span><br><span class="line"><span class="comment">//   nonce: 5,</span></span><br><span class="line"><span class="comment">//   r: &#x27;0x5e32c2741700a9120cfa186bc74e88b3d9488393be796a5124fddf08ffdbfdc6&#x27;,</span></span><br><span class="line"><span class="comment">//   s: &#x27;0x2431f3e3274cd22d6de63ed6e23a5c6839c1fabeb97b6683fb15584b9bf1f29d&#x27;,</span></span><br><span class="line"><span class="comment">//   to: &#x27;0x8ba1f109551bD432803012645Ac136ddd64DBA72&#x27;,</span></span><br><span class="line"><span class="comment">//   type: 2,</span></span><br><span class="line"><span class="comment">//   v: 0,</span></span><br><span class="line"><span class="comment">//   value: &#123; BigNumber: &quot;1000000000000000000&quot; &#125;,</span></span><br><span class="line"><span class="comment">//   wait: [Function]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="VoidSinger"><a href="#VoidSinger" class="headerlink" title="VoidSinger"></a>VoidSinger</h1><p>一个<strong>VoidSigner</strong>是一个简单的Signer，它不能签名。</p>
<p>当API需要signer作为参数时，它作为只读的signer是有用的，但它只能携带只读的操作。</p>
<p>比如，在<code>call</code>函数调用期间会自动传递所提供的地址。</p>
<p><strong>new <em>ethers</em>.VoidSigner( <em>address</em> [ , <em>provider</em> ] ) ⇒ <em>VoidSigner</em>：**为一个地址创建</strong>VoidSigner**实例。</p>
<p>**<em>voidSigner</em>.address ⇒ *string&lt; 地址(Address) &gt;<em><strong>：</strong>VoidSigner</em>*的地址。</p>
<h1 id="ExternallyOwnedAccount"><a href="#ExternallyOwnedAccount" class="headerlink" title="ExternallyOwnedAccount"></a><strong>ExternallyOwnedAccount</strong></h1><p>这个接口包含外部拥有帐户（EOA）所需的最小属性集，可以执行某些操作，比如将其编码为JSON钱包。</p>
<p><em><strong>eoa*.address ⇒ *string&lt; 地址(Address) &gt;：</strong></em>地址(Address)EOA的地址</p>
<p><em><strong>eoa*.privateKey ⇒ *string&lt; DataHexString&lt; 32 &gt; &gt;：</strong></em>EOA的私钥</p>
<p><strong><em>eoa</em>.mnemonic ⇒ <em>助记词</em>：</strong>帐户HD的助记词，如果有的话可以打印出来。EOA账户源不编码助记符，如HD extended keys。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/08/09/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/4-Types/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/09/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/4-Types/" class="post-title-link" itemprop="url">4-Types</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-09 00:00:00" itemprop="dateCreated datePublished" datetime="2022-08-09T00:00:00+08:00">2022-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ether-5-4-js/" itemprop="url" rel="index">
                    <span itemprop="name">ether@5.4.js</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="BlockTag"><a href="#BlockTag" class="headerlink" title="BlockTag"></a>BlockTag</h1><p><strong>BlockTag</strong> 在区块链中指定了一个特定的区块位置</p>
<ul>
<li><strong><code>&quot;latest&quot;</code></strong> - 最新挖出的区块</li>
<li><strong><code>&quot;earliest&quot;</code></strong> - 创世区块</li>
<li><strong><code>&quot;pending&quot;</code></strong> - 目前正在挖的区块;不是所有的操作和后端都支持这个BlockTag属性</li>
<li><strong><code>&quot;number&quot;</code></strong>- 区块高度</li>
<li><strong><code>&quot;a negative number&quot;</code></strong> - 几个区块前的区块</li>
<li><strong><code>&quot;hex string&quot;</code></strong> - 区块高度(十六进制表示)</li>
</ul>
<h1 id="Networkish"><a href="#Networkish" class="headerlink" title="Networkish"></a>Networkish</h1><p><strong>Networkish</strong>可以是以下任意一种:</p>
<ul>
<li><p>一个Network 对象</p>
<p><em>network</em>.<strong>name</strong> ⇒ <em>string</em>，可读的网络名称，如<code>homestead</code>。如果网络的name未指定，将会是<code>&quot;unknown&quot;</code>。</p>
<p><em>network</em>.<strong>chainId</strong> ⇒ <em>number</em>，网络的Chain ID。</p>
<p><em>network</em>.<strong>ensAddress</strong> ⇒ *string&lt; 地址(Address) &gt;*，部署在这个网络上的ENS注册表的地址。</p>
</li>
<li><p>字符串形式的常见网络 (如<code>&quot;homestead&quot;</code>)</p>
</li>
<li><p>number类型的网络chain ID， 如果chain ID 是常见网络的一种,<code>name</code> 和 <code>ensAddress</code> 会自动填充, 否则 name 会是<code>&quot;unknown&quot;</code> 且不使用任何的 <code>ensAddress</code>。</p>
</li>
</ul>
<h1 id="FeeData"><a href="#FeeData" class="headerlink" title="FeeData"></a>FeeData</h1><p><strong>FeeData</strong>对象根据最好且可用建议，去封装发送交易所需的费用数据。</p>
<p>**<em>feeData</em>.gasPrice ⇒ *大数(BigNumber):***gasPrice用于那些不支持EIP-1559的遗留交易或网络。</p>
<p><strong><em>feeData</em>.maxFeePerGas ⇒ <em>大数(BigNumber)</em>:</strong><code>maxFeePerGas</code>用于交易。这基于最近产出区块的<code>baseFee</code>。</p>
<p>**<em>feeData</em>.maxPriorityFeePerGas ⇒ <em>大数(BigNumber)</em>:**用于交易的“最大优先的Gas”</p>
<h1 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h1><p>**<em>block</em>.hash ⇒ <em>string&lt; DataHexString&lt; 32 &gt; &gt;</em>:**这个区块的哈希。</p>
<p>**<em>block</em>.parentHash ⇒ <em>string&lt; DataHexString&lt; 32 &gt; &gt;</em>:**上个区块的哈希。</p>
<p>**<em>block</em>.number ⇒ <em>number</em>:**当前区块的高度（数量）。</p>
<p>**<em>block</em>.timestamp ⇒ numbe:**r当前区块的时间戳。</p>
<p>**<em>block</em>.nonce ⇒ <em>string&lt; DataHexString &gt;<em>nonce:</em></em> 用在基于工作量证明（PoW）机制挖取区块</p>
<p>**<em>block</em>.difficulty ⇒ *number:***该区块的矿工需要达到的难度指标。 开发人员通常对这个属性不感兴趣。</p>
<p>**<em>block</em>.gasLimit ⇒ *大数(BigNumber):***这个区块允许使用的最大gas数量,该值可以由矿工投票决定要变大还是变小</p>
<p>**<em>block</em>.gasUsed ⇒ *大数(BigNumber):***当前区块所有的交易已使用的gas总数量。</p>
<p>**<em>block</em>.miner ⇒ *string:***当前区块的coinbase 地址，这个地址表示挖出这个区块的矿工想要接受这笔开采奖励的地址。</p>
<p>**<em>block</em>.extraData ⇒ *string:***该数据表示的是当挖出一个区块时，这个矿工可以选择包含的额外数据。 </p>
<p>**<em>block</em>.transactions ⇒ <em>Array&lt; string&lt; DataHexString&lt; 32 &gt; &gt; &gt;</em>:**一个当前区块包含的每一条交易哈希的列表。</p>
<p>**<em>block</em>.transactions ⇒ *Array&lt; TransactionResponse &gt;:***当前区块包含的交易列表。</p>
<h1 id="Events-and-Logs"><a href="#Events-and-Logs" class="headerlink" title="Events and Logs"></a>Events and Logs</h1><h2 id="5-1-EventFilter"><a href="#5-1-EventFilter" class="headerlink" title="5.1 EventFilter"></a><strong>5.1 EventFilter</strong></h2><p>**<em>filter</em>.address ⇒ <em>string&lt; 地址(Address) &gt;</em>:**想要筛选的地址， <code>null</code> 表示匹配任何用户的地址。</p>
<p>**<em>filter</em>.topics ⇒ <em>Array&lt; string&lt; Data&lt; 32 &gt; &gt; | Array&lt; string&lt; Data&lt; 32 &gt; &gt; &gt; &gt;</em>:**要筛选的主题，<code>null</code>示匹配任何用户的主题。</p>
<p>每一个 entry 表示一个<strong>AND</strong>匹配条件，entry 也可以是<code>null</code>来匹配所有的内容。 如果给定的 entry 是一个数组，那么这个 entry 是被视为 <strong>OR</strong>匹配条件来匹配entry里面的内容。 有关指定复杂过滤器的详细信息和示例，请参阅Filters。</p>
<h2 id="5-2-Filter"><a href="#5-2-Filter" class="headerlink" title="5.2 Filter"></a>5.2 Filter</h2><p>**<em>filter</em>.fromBlock ⇒ <em>BlockTag</em>:**用于搜索匹配过滤条件的日志的起始区块(包含在内)。</p>
<p>**<em>filter</em>.toBlock ⇒ <em>BlockTag</em>:**用于搜索匹配过滤条件的日志的结束区块(包含在内)。</p>
<h2 id="5-3-FilterByBlockHash"><a href="#5-3-FilterByBlockHash" class="headerlink" title="5.3 FilterByBlockHash"></a>5.3 FilterByBlockHash</h2><p>**<em>filter</em>.blockHash ⇒ *string&lt; DataHexString&lt; 32 &gt; &gt;:***指定区块(按这个区块哈希值)搜索符合过滤条件的日志。</p>
<h2 id="5-4-Log"><a href="#5-4-Log" class="headerlink" title="5.4 Log"></a>5.4 Log</h2><p>**<em>log</em>.blockNumber ⇒ *number:***包含该日志的交易的区块高度(区块数)。</p>
<p>**<em>log</em>.blockHash ⇒ <em>string&lt; DataHexString&lt; 32 &gt; &gt;</em>:**包含该日志的交易的区块的哈希值。</p>
<p>**<em>log</em>.removed ⇒ <em>boolean</em>:**在区块重组期间，如果一个交易是孤立的，它将被设置为true，表示Log entry已被删除; 在不久的将来，当使用包含该日志的交易被另一个区块挖出时，可能会再次触发此日志，但请记住，值可能会更改。</p>
<p>**<em>log</em>.transactionLogIndex ⇒ <em>number</em>:**该日志在交易中的索引。</p>
<p>**<em>log</em>.address ⇒ <em>string&lt; 地址(Address) &gt;</em>:**生成这条日志的合约地址。</p>
<p>**<em>log</em>.data ⇒ <em>string&lt; DataHexString &gt;</em>:**日志的数据。</p>
<p>**<em>log</em>.topics ⇒ <em>Array&lt; string&lt; DataHexString&lt; 32 &gt; &gt; &gt;</em>:**日志的主题(索引属性)列表。</p>
<p>**<em>log</em>.transactionHash ⇒ <em>string&lt; DataHexString&lt; 32 &gt; &gt;</em>:**包含这条日志的交易的哈希值。</p>
<p>**<em>log</em>.transactionIndex ⇒ <em>number</em>:**区块中包含这条日志的交易的索引。</p>
<p><strong><em>log</em>.logIndex ⇒ <em>number</em>:<strong>在整个</strong>区块中</strong>所有的日志集合里，该条日志的索引。</p>
<h1 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h1><h2 id="6-1-TransactionRequest"><a href="#6-1-TransactionRequest" class="headerlink" title="6.1 TransactionRequest"></a>6.1 TransactionRequest</h2><p>描述了一笔将要被发送到网络或以其他方式处理的交易，所有字段都是可选的，并且可以是一个能被解析为所需类型的promise。</p>
<p>**<em>transactionRequest</em>.to ⇒ <em>string | Promise&lt; string &gt;</em>:**接受这笔交易的地址(or ENS name)。</p>
<p>**<em>transactionRequest</em>.from ⇒ <em>string&lt; 地址(Address) &gt; | Promise&lt; string&lt; 地址(Address) &gt; &gt;</em>:**发送这笔交易的地址。</p>
<p>**<em>transactionRequest</em>.nonce ⇒ *number | Promise&lt; number &gt;:***交易的 nonce 值。 <strong>发送</strong>这笔交易要设置这个值，是number类型的。</p>
<p>**<em>transactionRequest</em>.data ⇒ <em>DataHexString | Promise&lt; DataHexString &gt;</em>:**交易的数据。</p>
<p>**<em>transactionRequest</em>.value ⇒ <em>大数(BigNumber) | Promise&lt; 大数(BigNumber) &gt;</em>:**这笔交易要发送的数量(以wei为单位)。</p>
<p>**<em>transactionRequest</em>.gasLimit ⇒ <em>大数(BigNumber) | Promise&lt; 大数(BigNumber) &gt;</em>:**这笔交易允许使用的最大gas值。</p>
<p>如果未指定，ethers将使用<code>estimateGas</code>来确定要使用的gas值。对于无法预测的gas的交易，可能需要这样做显式地指定。</p>
<p>**<em>transactionRequest</em>.gasPrice ⇒ <em>大数(BigNumber) | Promise&lt; 大数(BigNumber) &gt;</em>:**这笔交易将支付的每个gas的价格(以wei为单位)。</p>
<p>这个属性不适用于这笔交易的<code>type</code>设置为<code>1</code> 或者 <code>2</code>的情形，也不适用于交易已指定了<code>maxFeePerGas</code> 或者 <code>maxPriorityFeePerGas</code>的情形。</p>
<p>**<em>transactionRequest</em>.maxFeePerGas ⇒ *大数(BigNumber) | Promise&lt; 大数(BigNumber) &gt;:***这笔交易将支付EIP-1559基础费用的每个gas的价格的最高价格(以wei为单位)。</p>
<p>大多数开发人员不应该指定该参数，而应该使用网络决定的默认值。 这个属性不适用于这笔交易的<code>type</code>设置为<code>0</code>的情形，也不适用于交易已指定了<code>gasPrice</code>的情形。</p>
<p><strong><em>transactionRequest</em>.maxPriorityFeePerGas ⇒ <em>大数(BigNumber) | Promise&lt; 大数(BigNumber) &gt;</em>:<strong>这笔交易将支付EIP-1559优先费用的每个gas的价格的价格(以wei为单位)。 这包含在<code>maxFeePerGass</code>中，所以这</strong>不会影响</strong><code>maxFeePerGas</code>设置的总最大价格。</p>
<p>大多数开发人员应该不指定该参数，而应该使用网络决定的默认值。 这个属性不适用于这笔交易的<code>type</code>设置为<code>0</code>的情形，也不适用于交易已指定了<code>gasPrice</code>的情形。</p>
<p><strong><em>transactionRequest</em>.chainId ⇒ <em>number | Promise&lt; number &gt;</em>:<strong>已被授权交易的chain ID，由EIP-155指定。 如果chain ID为0将禁用EIP-155，交易将在任何网络上有效。这可能</strong>很危险</strong>，应该小心，因为它允许交易在可能不是你想指定的网络上复现。 在最新版本的Geth中，有意重现的交易在默认情况下是禁用的，需要配置才能启用。</p>
<p><strong><em>transactionRequest</em>.type ⇒ <em>null | number</em>:</strong> 这笔交易envelope的EIP-2718类型，在网络上这个默认值是<code>null</code>。要强制使用没有envelope的lagacy交易，请使用type <code>0</code>。</p>
<p>**<em>transactionRequest</em>.accessList ⇒ <em>AccessListish</em>:**要包含的AccessList;仅适用于EIP-2930和EIP-1559的交易。</p>
<h2 id="6-2-TransactionResponse"><a href="#6-2-TransactionResponse" class="headerlink" title="6.2 TransactionResponse"></a>6.2 TransactionResponse</h2><p><strong>TransactionResponse</strong>包括交易的所有属性，以及等区块被挖出来后就很有用的几个属性。</p>
<p>**<em>transaction</em>.blockNumber ⇒ <em>number</em>:**这笔交易所在区块被挖出来时的高度(区块数量)如果区块还没有被挖出，这个值为<code>null</code>。</p>
<p>**<em>transaction</em>.blockHash ⇒ *string&lt; DataHexString&lt; 32 &gt; &gt;:***交易所在区块挖出来时的哈希值,如果区块还没有被挖出，这个值为<code>null</code>。</p>
<p>**<em>transaction</em>.timestamp ⇒ <em>number</em>:**这笔交易所在区块被挖出来时的时间戳。如果区块还没有被挖出，这个值为<code>null</code>。</p>
<p>**<em>transaction</em>.confirmations ⇒ *number:***当这笔交易所在的区块被挖出来时，所有已挖出的区块数量(包括初始块)。</p>
<p>**<em>transaction</em>.raw ⇒ *string&lt; DataHexString &gt;:<em><strong>序列化交易。如果一些后端不重新填充它时可能是null。 如果你需要这个属性，可以使用this cookbook recipe从</strong>TransactionResponse</em>*对象中计算。</p>
<p>**<em>transaction</em>.wait( [ <em>confirms</em> &#x3D; <em>1</em> ] ) ⇒ <em>Promise&lt; TransactionReceipt &gt;</em>:*<em>confirms</em>属性表示你愿意等待的挖出区块数量，一旦满足这个值将返回一个待解析的TransactionReceipt。 如果*confirms为0，并且交易还没有被挖出，则返回<code>null</code>。</p>
<p>如果交易执行失败(即接收状态为<code>0</code>)，将会生成一个<strong>CALL_EXCEPTION</strong>，其属性如下:</p>
<ul>
<li><code>error.transaction</code> - 这笔交易</li>
<li><code>error.transactionHash</code> - 这笔交易的哈希值<ul>
<li><code>error.receipt</code> - the actual receipt, 状态是 <code>0</code></li>
</ul>
</li>
</ul>
<p>如果这笔交易被另一个交易替换，将会生成一个<strong>TRANSACTION_REPLACED</strong>，其属性如下:</p>
<ul>
<li><code>error.hash</code> - 被替换的交易的哈希值</li>
<li><code>error.reason</code> - string类型的错误原因; 是 <code>&quot;repriced&quot;</code>或 <code>&quot;cancelled&quot;</code>或 <code>&quot;replaced&quot;</code>其中一个</li>
<li><code>error.cancelled</code> - boolean类型; <code>&quot;repriced&quot;</code>表示不视为cancelled, 但<code>&quot;cancelled&quot;</code> 和<code>&quot;replaced&quot;</code>视为cancelled。</li>
<li><code>error.replacement</code> - the replacement transaction (a <strong>TransactionResponse</strong>)</li>
<li><code>error.receipt</code> - replacement transaction的收据 (a <strong>TransactionReceipt</strong>)</li>
</ul>
<p>当用户在客户端相同的帐户中发送一笔新的交易，这笔交易与之前一笔交易的<code>nonce</code>相同时，之前的那笔交易将被替换。 这通常是为了加快交易或取消交易，新交易可以给矿工更多的费用，让他们更喜欢新交易，而不是原来的交易。</p>
<p>**<em>transactionRequest</em>.type ⇒ <em>number</em>:**这笔交易的EIP-2718类型。如果事务是没有envelope的legacy交易，则其类型为<code>0</code>。</p>
<p><strong><em>transactionRequest</em>.accessList ⇒ <em>AccessList</em>:<strong>包含的</strong>AccessList</strong>，对于不支持访问列表的交易类型时该值为空。</p>
<h2 id="6-3-TransactionReceipt"><a href="#6-3-TransactionReceipt" class="headerlink" title="6.3 TransactionReceipt"></a>6.3 TransactionReceipt</h2><p>**<em>receipt</em>.to ⇒ <em>string&lt; 地址(Address) &gt;</em>:**接受这笔交易的地址。如果交易是用于部署合约，则为<code>null</code>。</p>
<p>**<em>receipt</em>.from ⇒ <em>string&lt; 地址(Address) &gt;</em>:**发起这笔交易的地址。</p>
<p>**<em>receipt</em>.contractAddress ⇒ *string&lt; 地址(Address) &gt;:<em><strong>如果这笔交易是转去一个<code>null</code>的地址，它是表示一个</strong>init transaction</em>*用于部署合约。在这种情况下，这个属性就代表所创建的合约的地址。 要计算合约地址，getContractAddress的utility function还可以与TransactionResponse对象一起使用，该对象需要交易的nonce值和发送人的地址。</p>
<p>**<em>receipt</em>.transactionIndex ⇒ <em>number</em>:**当前区块包含所有交易列表中，此交易的索引。</p>
<p>**<em>receipt</em>.type ⇒ *number:***此交易的EIP-2718类型。如果事务是没有envelope的legacy事务，则其type 为<code>0</code>。</p>
<p>**<em>receipt</em>.root ⇒ <em>string</em>:**收据的中间状态根</p>
<p>只有在Byzantium Hard Fork之前包含在区块中的交易才有这个属性，因为它被<code>status</code>属性取代了。</p>
<p>这些属性通常对开发者没什么用处。仅考虑单笔交易的防伪性的时候可以用于验证状态转换;如果没有它，则必须考虑整个区块。</p>
<p>**<em>receipt</em>.gasUsed ⇒ <em>大数(BigNumber)</em>:**该交易实际使用的gas值。</p>
<p>**<em>receipt</em>.logsBloom ⇒ *string&lt; DataHexString &gt;:***一个bloom-filter，包含此交易中所有日志中包含的全部地址和主题。</p>
<p>**<em>receipt</em>.blockHash ⇒ *string&lt; DataHexString&lt; 32 &gt; &gt;:***包含该交易的区块的区块哈希值。</p>
<p>**<em>receipt</em>.transactionHash ⇒ *string&lt; DataHexString&lt; 32 &gt; &gt;:***这笔交易的哈希值。</p>
<p>**<em>receipt</em>.logs ⇒ *Array&lt; Log &gt;:***这笔交易触发的所有日志。</p>
<p>**<em>receipt</em>.blockNumber ⇒ *number:***包含这笔交易的区块的高度（区块数量）。</p>
<p>**<em>receipt</em>.confirmations ⇒ *number:***当这笔交易所在的区块被挖出来时，所有已挖出的区块数量(包括这笔刚挖出的区块)。</p>
<p>**<em>receipt</em>.cumulativeGasUsed ⇒ 大数(BigNumber):**对包含该交易的块，这是截至(该交易的有序交易列表中每个交易使用的gas的总和</p>
<p>**<em>receipt</em>.byzantium ⇒ <em>boolean</em>:**如果区块是在post-Byzantium Hard Fork区块，这个值是true。</p>
<p>**<em>receipt</em>.status ⇒ *boolean:***如果交易成功，这个值为1；如果交易被reverted，这个值为为0。 只有post-Byzantium Hard Fork中包含的交易才有这个属性。</p>
<h1 id="Access-Lists"><a href="#Access-Lists" class="headerlink" title="Access Lists"></a>Access Lists</h1><p>Access List是可选的，它包含一个地址列表和地址的存储槽，这些地址应该是<em>warmed</em>或pre-fetched的，以便在这个交易的执行中使用。 一个<em>warmed</em>值有一个额外的预先支付访问的成本，但在整个读取和写入代码的执行过程中会被降低。</p>
<h2 id="7-1-AccessListish"><a href="#7-1-AccessListish" class="headerlink" title="7.1 AccessListish"></a>7.1 AccessListish</h2><p>AccessList的一个更宽松的描述，它将在内部使用accessListify进行转换。</p>
<p>他可以是以下的任意一种:</p>
<ul>
<li>任意的AccessList</li>
<li>一个包含两个元素的数组，第一个元素是地址，第二个是数组在storage中的key</li>
<li>一个对象, 所以的key表示地址，相应的value表示数组在storage中的key</li>
</ul>
<p>当使用对象形式(上述最后一个选项)时，地址和存储槽将被排序。 如果需要access list的显式顺序，则必须使用方式。 大多数开发人员不需要明确的顺序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Option 1:</span></span><br><span class="line"><span class="comment">// AccessList</span></span><br><span class="line"><span class="comment">// see below</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 2:</span></span><br><span class="line"><span class="comment">// Array&lt; [ Address, Array&lt;Bytes32&gt; ] &gt;</span></span><br><span class="line">accessList = [</span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;0x0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e&quot;</span>,</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000004&quot;</span>,</span><br><span class="line">      <span class="string">&quot;0x0bcad17ecf260d6506c6b97768bdc2acfb6694445d27ffd3f9c1cfbee4a9bd6d&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;0x5FfC014343cd971B7eb70732021E26C35B744cc4&quot;</span>,</span><br><span class="line">    [</span><br><span class="line">        <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 3:</span></span><br><span class="line"><span class="comment">// Record&lt;Address, Array&lt;Bytes32&gt;&gt;</span></span><br><span class="line">accessList = &#123;</span><br><span class="line">  <span class="string">&quot;0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000004&quot;</span>,</span><br><span class="line">    <span class="string">&quot;0x0bcad17ecf260d6506c6b97768bdc2acfb6694445d27ffd3f9c1cfbee4a9bd6d&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;0x5FfC014343cd971B7eb70732021E26C35B744cc4&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;equivalent to the <span class="title class_">AccessList</span> example below</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 1:</span></span><br><span class="line"><span class="comment">// AccessList</span></span><br><span class="line"><span class="comment">// see below</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 2:</span></span><br><span class="line"><span class="comment">// Array&lt; [ Address, Array&lt;Bytes32&gt; ] &gt;</span></span><br><span class="line">accessList = [</span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;0x0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e&quot;</span>,</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000004&quot;</span>,</span><br><span class="line">      <span class="string">&quot;0x0bcad17ecf260d6506c6b97768bdc2acfb6694445d27ffd3f9c1cfbee4a9bd6d&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;0x5FfC014343cd971B7eb70732021E26C35B744cc4&quot;</span>,</span><br><span class="line">    [</span><br><span class="line">        <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 3:</span></span><br><span class="line"><span class="comment">// Record&lt;Address, Array&lt;Bytes32&gt;&gt;</span></span><br><span class="line">accessList = &#123;</span><br><span class="line">  <span class="string">&quot;0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000004&quot;</span>,</span><br><span class="line">    <span class="string">&quot;0x0bcad17ecf260d6506c6b97768bdc2acfb6694445d27ffd3f9c1cfbee4a9bd6d&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;0x5FfC014343cd971B7eb70732021E26C35B744cc4&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-AccessList"><a href="#7-2-AccessList" class="headerlink" title="7.2 AccessList"></a>7.2 AccessList</h2><p>一个EIP-2930交易允许一个可选的<strong>AccessList</strong>，它会导致交易<em>warm</em>（预缓存）另一个地址状态和指定的storage key。</p>
<p>这会使得交易的内在成本变大，但在整个事务执行过程中给存储和状态访问带来了好处。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array of objects with the form:</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   address: Address,</span></span><br><span class="line"><span class="comment">//   storageKey: Array&lt; DataHexString&lt; 32 &gt; &gt;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">accessList = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">address</span>: <span class="string">&quot;0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e&quot;</span>,</span><br><span class="line">    <span class="attr">storageKeys</span>: [</span><br><span class="line">        <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000004&quot;</span>,</span><br><span class="line">        <span class="string">&quot;0x0bcad17ecf260d6506c6b97768bdc2acfb6694445d27ffd3f9c1cfbee4a9bd6d&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">address</span>: <span class="string">&quot;0x5FfC014343cd971B7eb70732021E26C35B744cc4&quot;</span>,</span><br><span class="line">    <span class="attr">storageKeys</span>: [</span><br><span class="line">        <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/08/08/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/3-Providers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/08/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/3-Providers/" class="post-title-link" itemprop="url">3-Providers</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-08 00:00:00" itemprop="dateCreated datePublished" datetime="2022-08-08T00:00:00+08:00">2022-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ether-5-4-js/" itemprop="url" rel="index">
                    <span itemprop="name">ether@5.4.js</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JsonRpcProvider"><a href="#JsonRpcProvider" class="headerlink" title="JsonRpcProvider"></a>JsonRpcProvider</h1><p>JSON-RPC API是与以太坊交互比较流行的方法，在主要的以太坊节点实现(如Geth 和 Parity)以及许多第三方web服务中都可以用。</p>
<p><strong>new <em>ethers</em>.<em>providers</em>.JsonRpcProvider( [ <em>urlOrConnectionInfo</em> [ ，<em>networkish</em> ] ] )</strong></p>
<p>使用 URL 或者 urlOrConnectionInfo 作为一个一个 JSON-RPC HTTP API 连接到 <em>networkish</em> 网络。</p>
<p>如果 <em>urlOrConnectionInfo</em> 没有被指定， 默认值是<code>http://localhost:8545</code>。 如果网络没有被指定， 它将会自动使用 <code>eth_chaindId</code>查询网络节点并返回 <code>eth_networkId</code>从而确定网络。</p>
<h2 id="1-1-getSigner"><a href="#1-1-getSigner" class="headerlink" title="1.1 getSigner"></a>1.1 getSigner</h2><p><em>jsonRpcProvider</em>.<strong>getSigner</strong>( [ <em>addressOrIndex</em> ] ) ⇒ <em><strong>JsonRpcSigner</strong></em></p>
<p>返回由该以太坊节点管理的JsonRpcSigner，地址为<em>addressOrIndex</em>。如果没有提供<em>addressOrIndex</em>，则使用第一个帐户(account #0)。</p>
<h2 id="1-2-listAccounts"><a href="#1-2-listAccounts" class="headerlink" title="1.2 listAccounts"></a>1.2 listAccounts</h2><p><em>jsonRpcProvider</em>.<strong>listAccounts</strong>( ) ⇒ <em>Promise&lt; Array&lt; **string** &gt; &gt;</em></p>
<p>返回此provider管理的所有帐户地址的列表。</p>
<h2 id="1-3-send"><a href="#1-3-send" class="headerlink" title="1.3 send"></a>1.3 send</h2><p><em>jsonRpcProvider</em>.<strong>send</strong>( <em>method</em>，<em>params</em> ) ⇒ <em>Promise&lt; **any** &gt;</em></p>
<p>允许向provider发送原始消息,这可以用于后端特定的调用，比如调试或特定的帐户管理。</p>
<p>获取不常见的或特定于某些以太坊节点(例如Parity 与 Geth)才有的</p>
<h2 id="1-4-getUncheckedSigner"><a href="#1-4-getUncheckedSigner" class="headerlink" title="1.4 getUncheckedSigner"></a>1.4 <strong>getUncheckedSigner</strong></h2><p><em>jsonRpcProvider</em>.<strong>getUncheckedSigner</strong>( [ <em>addressOrIndex</em> ] ) ⇒ <em><strong>JsonRpcUncheckedSigner</strong></em></p>
<p><strong>JsonRpcUncheckedSigner</strong>:JSON-RPC API仅在发送交易时提供交易哈希作为响应，但ether Provider要求在返回交易之前填充交易的所有细节。 例如，燃料价格（gas price）和燃料限制（gas limit）可能由节点或自动包含在内的nonce调整。</p>
<p>为了解决这个问题，<strong>JsonRpcSigner</strong>立即查询provider的详细信息，用返回的交易哈希来填充<strong>TransactionResponse</strong>对象。</p>
<p><strong>UncheckedSigner</strong>不填充任何附加信息，并将一个模拟的类似<strong>TransactionResponse</strong>的对象作为立即返回的结果， 其中大部分属性设置为null，但如果只需要这些，则可以快速获得交易哈希。</p>
<h2 id="1-5-StaticJsonRpcProvider"><a href="#1-5-StaticJsonRpcProvider" class="headerlink" title="1.5 StaticJsonRpcProvider"></a>1.5 StaticJsonRpcProvider</h2><p>ethers Provider将频繁执行<code>getNetwork</code>调用，以确保网络调用和网络通信是一致的(<strong>MetaMask</strong>)</p>
<p>在某些情况下网络不能改变，如当连接到一个INFURA端点，在这种情况下，可以使用<strong>StaticJsonRpcProvider</strong>来将一直缓存链ID，可以减少网络流量和往返查询chain ID的次数。</p>
<h1 id="JsonRpcSinger"><a href="#JsonRpcSinger" class="headerlink" title="JsonRpcSinger"></a>JsonRpcSinger</h1><p><strong>JsonRpcSigner</strong>是一个简单的Signer，它由一个连接的JsonRpcProvider支持。</p>
<h2 id="2-1-provider"><a href="#2-1-provider" class="headerlink" title="2.1 provider"></a>2.1 provider</h2><p><em>signer</em>.<strong>provider</strong> ⇒ <em><strong>JsonRpcProvider</strong></em></p>
<p>创建这个signer的provider</p>
<h2 id="2-2-connectUnchecked"><a href="#2-2-connectUnchecked" class="headerlink" title="2.2 connectUnchecked"></a>2.2 connectUnchecked</h2><p><em>signer</em>.<strong>connectUnchecked</strong>( ) ⇒ <em><strong>JsonRpcUncheckedSigner</strong></em></p>
<p>返回一个新的Signer对象，该对象在发送交易时不执行额外的检查。详情请参阅getUncheckedSigner。</p>
<h2 id="2-3-sendUncheckedTransaction"><a href="#2-3-sendUncheckedTransaction" class="headerlink" title="2.3 sendUncheckedTransaction"></a>2.3 sendUncheckedTransaction</h2><p><em>signer</em>.<strong>sendUncheckedTransaction</strong>( <em>transaction</em> ) ⇒ <em>Promise&lt; string&lt; **DataHexString**&lt; 32 &gt; &gt; &gt;</em></p>
<p>发送<em>交易</em>并返回一个解析为不透明交易哈希的Promise。</p>
<h2 id="2-4-unlock"><a href="#2-4-unlock" class="headerlink" title="2.4 unlock"></a>2.4 unlock</h2><p><em>signer</em>.<strong>unlock</strong>( <em>password</em> ) ⇒ <em>Promise&lt; **boolean** &gt;</em></p>
<p>使用<em>密码</em>请求节点解除锁定（如果被锁了）。</p>
<h1 id="API-Proviers"><a href="#API-Proviers" class="headerlink" title="API Proviers"></a>API Proviers</h1><p>很多服务提供了访问以太坊区块链的web API,这些提供商允许连接到它们，因为你不需要运行你自己的实例或以太坊节点集群，这就简化了开发。这种对第三方服务的依赖会降低弹性和安全性，并增加所需的信任度。为了缓解这些问题，建议您使用 <strong>Default</strong> <strong>Provider</strong>。</p>
<h2 id="3-1-EtherscanProvider"><a href="#3-1-EtherscanProvider" class="headerlink" title="3.1 EtherscanProvider"></a>3.1 EtherscanProvider</h2><p><strong>new</strong> <em>ethers</em>.<em>providers</em>.<strong>EtherscanProvider</strong>( [ <em>network</em> &#x3D; “<em>homestead</em>“ , [ <em>apiKey</em> ] ] )</p>
<p>使用可选的<em>apiKey</em>创建一个新的<strong>EtherscanProvider</strong>连接到<em>网络</em>。</p>
<p>这个<em>网络</em>可以被指定为一个<strong>字符串</strong>类型的网络名称、或<strong>number</strong>类型的链ID，或[网络对象]provider-(network)。</p>
<p>如果没有提供<em>apiKey</em>,将使用一个共享的API key,可能导致性能降低和请求受限,推荐在生产环境中使用您在Etherscan上注册的API密钥。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接主网 (homestead)</span></span><br><span class="line">provider = <span class="keyword">new</span> <span class="title class_">EtherscanProvider</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接 rinkeby 测试网(以下这两种方式是等价的)</span></span><br><span class="line">provider = <span class="keyword">new</span> <span class="title class_">EtherscanProvider</span>(<span class="string">&quot;goerli&quot;</span>);</span><br><span class="line">provider = <span class="keyword">new</span> <span class="title class_">EtherscanProvider</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">provider = <span class="keyword">new</span> <span class="title class_">EtherscanProvider</span>(network);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过API key 连接主网(homestead)</span></span><br><span class="line">provider = <span class="keyword">new</span> <span class="title class_">EtherscanProvider</span>(<span class="literal">null</span>, apiKey);</span><br><span class="line">provider = <span class="keyword">new</span> <span class="title class_">EtherscanProvider</span>(<span class="string">&quot;homestead&quot;</span>, apiKey);</span><br></pre></td></tr></table></figure>

<h2 id="3-2-InfuraProvider"><a href="#3-2-InfuraProvider" class="headerlink" title="3.2 InfuraProvider"></a>3.2 InfuraProvider</h2><p><strong>new <em>ethers</em>.<em>providers</em>.InfuraProvider( [ <em>network</em> &#x3D; “<em>homestead</em>“ , [ <em>apiKey</em> ] ] )</strong></p>
<p><em>apiKey</em>可以是一个<strong>string</strong>类型的Project ID，也可以是一个带有<code>projectId</code>和<code>projectSecret</code>属性<strong>对象</strong>， 用于指定一个可以在非公共源(如服务器)上使用的Project Secret， 以进一步保护你的API access 和 quotas。</p>
<p><em><strong>InfuraProvider*.getWebSocketProvider( [ <em>network</em> [ , <em>apiKey</em> ] ] ) ⇒ *WebSocketProvider</strong></em></p>
<p>Create a new WebSocketProvider 使用 INFURA web-socket 端点创建一个新的WebSocketProvider，并使用可选的<em>apiKey</em>连接到网络。 网络和apiKey的设定与构造函数相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一个Project ID连接到主网(以下这两种方式是等价的)</span></span><br><span class="line">provider = <span class="keyword">new</span> <span class="title class_">InfuraProvider</span>(<span class="literal">null</span>, projectId);</span><br><span class="line">provider = <span class="keyword">new</span> <span class="title class_">InfuraProvider</span>(<span class="string">&quot;homestead&quot;</span>, projectId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Project ID 和 Project Secret 连接到主网</span></span><br><span class="line">provider = <span class="keyword">new</span> <span class="title class_">InfuraProvider</span>(<span class="string">&quot;homestead&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">projectId</span>: projectId,</span><br><span class="line">    <span class="attr">projectSecret</span>: projectSecret</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个 WebSocketProvider 连接到 INFURA WebSocket 端点</span></span><br><span class="line">provider = <span class="title class_">InfuraProvider</span>.<span class="title function_">getWebSocketProvider</span>()</span><br></pre></td></tr></table></figure>

<h2 id="3-3-AlchemyProvider"><a href="#3-3-AlchemyProvider" class="headerlink" title="3.3 AlchemyProvider"></a>3.3 AlchemyProvider</h2><h2 id="3-4-CloundfalreProvier"><a href="#3-4-CloundfalreProvier" class="headerlink" title="3.4 CloundfalreProvier"></a>3.4 CloundfalreProvier</h2><h1 id="其他的Providers"><a href="#其他的Providers" class="headerlink" title="其他的Providers"></a>其他的Providers</h1><h2 id="4-1-FallbackProvider"><a href="#4-1-FallbackProvider" class="headerlink" title="4.1 FallbackProvider"></a>4.1 <strong>FallbackProvider</strong></h2><p><strong>FallbackProvider</strong> 是ethers中可用的且最高级的Provider。</p>
<p>它使用一个quorum并连接到多个Providers作为后端，每个Providers都配置了一个<em>优先级</em>和<em>权重</em>。</p>
<p>当发出一个请求时，请求被分配给多个随机选择的后端(优先级较低的后端总是被先选中)， 并将每个请求的结果与其他请求进行比较。只有达到quorum规定的数量后，该结果才会被接受并返回给调用方。</p>
<p><strong>new</strong> <em>ethers</em>.<em>providers</em>.<strong>FallbackProvider</strong>( <em>providers</em> [ , <em>quorum</em> ] )</p>
<p>创建一个连接到<em>providers</em>的FallbackProvider的新实例。 如果quorum未指定，则默认为provider权重总和的一半。</p>
<p><em>providers</em>可以是<strong>Provider</strong> 或 <strong>FallbackProviderConfig</strong>的数组。 如果提供了Provider，默认的优先级为1，权重为1。</p>
<p>描述后端的Provider配置列表:<strong>providerConfigs ⇒ <em>Array&lt; FallbackProviderConfig &gt;</em></strong></p>
<p>在得到结果之前，后端响应的quorum必须达成一致:<em><strong>provider*.quorum ⇒ *number</strong></em></p>
<h3 id="FallbackProviderConfig"><a href="#FallbackProviderConfig" class="headerlink" title="FallbackProviderConfig"></a>FallbackProviderConfig</h3><p>该配置的provider:<em><strong>fallbackProviderConfig*.provider ⇒ *Provider</strong></em></p>
<p>表示provider使用的优先级:<em><strong>fallbackProviderConfig*.priority ⇒ *number</strong></em></p>
<p>超时后(以ms为单位)将会尝试其他的Provider:<em><strong>fallbackProviderConfig*.stallTimeout ⇒ *number</strong></em></p>
<p>表示这个provider响应的权重:<strong>fallbackProviderConfig.weight ⇒ <em>number</em></strong></p>
<h2 id="4-2-IpcProvider"><a href="#4-2-IpcProvider" class="headerlink" title="4.2 IpcProvider"></a>4.2 IpcProvider</h2><p><strong>IpcProvider</strong> 允许JSON-RPC API在文件系统的本地文件名上使用。 Geth, Parity和其他节点都会开放了这个功能。</p>
<p>这只能在<em>node.js</em>中使用，因为它需要访问文件系统，并且由于文件权限可能有增加额外的复杂性。(请参阅相关节点实现的文档)</p>
<p>这个Provider要连接的路径:<strong>ipcProvider.path ⇒ <em>string</em></strong></p>
<h2 id="4-3-UrlJsonRpcProvider"><a href="#4-3-UrlJsonRpcProvider" class="headerlink" title="4.3 UrlJsonRpcProvider"></a>4.3 <strong>UrlJsonRpcProvider</strong></h2><p>这个类打算作为子类而不是直接使用。只需要额外生成一个JSON-RPC URL后，就能通过JsonRpcProvider创建一个Provider。</p>
<p><strong>new</strong> <em>ethers</em>.<em>providers</em>.<strong>UrlJsonRpcProvider</strong>( [ <em>network</em> [ , <em>apiKey</em> ] ] )</p>
<p>子类通常不需要重写这一部分。相反应该重写静态的方法 <code>getUrl</code> 和可选的<code>getApiKey</code>。</p>
<p><em><strong>urlJsonRpcProvider*.apiKey ⇒ *any</strong></em></p>
<p>从<code>InheritedClass.getApiKey</code>返回的apiKey的值。</p>
<p><em><strong>InheritingClass*.getApiKey( <em>apiKey</em> ) ⇒ *any</strong></em></p>
<p>这个函数应该检查<em>apiKey</em>以确保它是有效的，并返回一个(可能修改过的)值在<code>getUrl</code>函数中使用。</p>
<p><em><strong>InheritingClass*.getUrl( <em>network</em> , <em>apiKey</em> ) ⇒ *string</strong></em></p>
<p>这个URL在JsonRpcProvider 实例中使用。</p>
<h2 id="4-4-Web3Provider"><a href="#4-4-Web3Provider" class="headerlink" title="4.4 Web3Provider"></a>4.4 <strong>Web3Provider</strong></h2><h2 id="4-5-ExternalProvider"><a href="#4-5-ExternalProvider" class="headerlink" title="4.5 ExternalProvider"></a>4.5 <strong>ExternalProvider</strong></h2><h2 id="4-6-WebSocketProvider"><a href="#4-6-WebSocketProvider" class="headerlink" title="4.6 WebSocketProvider"></a>4.6 WebSocketProvider</h2><p><strong>WebSocketProvider</strong> 连接到一个JSON-RPC websocket兼容的后端，它允许持久连接、多路复用请求和发布-子事件，以实现更即时的事件调度。WebSocket API是较新的，如果运行自己的基础设施，请注意WebSockets对服务器资源的占用会很大， 因为它们必须管理和维护每个客户端的状态。由于这个原因，许多服务也可能会为使用他们的WebSocket端点而收取额外的费用。</p>
<p><strong>new <em>ethers</em>.<em>providers</em>.WebSocketProvider( [ <em>url</em> [ , <em>network</em> ] ] )</strong></p>
<p>通过一个<em>url</em>连接到<em>网络</em>，返回一个新的WebSocketProvider。</p>
<p>如果<em>url</em>未指定，默认值是<code>&quot;ws://localhost:8546&quot;</code>。 如果<em>network</em>未被指定，它将会从网络中查询。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/08/07/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/2-Provider%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/07/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/2-Provider%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">2-Provider方法</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-07 00:00:00" itemprop="dateCreated datePublished" datetime="2022-08-07T00:00:00+08:00">2022-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ether-5-4-js/" itemprop="url" rel="index">
                    <span itemprop="name">ether@5.4.js</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Providers"><a href="#Providers" class="headerlink" title="Providers"></a>Providers</h1><p><strong>提供者</strong>(<strong>Provider</strong>)是以太坊网络连接的抽象,为标准以太坊节点功能提供简洁、一致的接口.</p>
<p>ethers.js 库 提供了几种选项应该涵盖了绝大多数用例,但如果需要个性化配置,也包括了子类化所需的函数和类.</p>
<p>大多数用户应该使用默认的Provider.</p>
<h2 id="1-1-默认的Provider"><a href="#1-1-默认的Provider" class="headerlink" title="1.1 默认的Provider"></a>1.1 默认的Provider</h2><p>默认的 provider 是在<em>Ethereum</em>上最简单、最安全的方法方式,而且它也具备足够强的鲁棒性,可以在生产环境中使用.</p>
<p>它创建一个连接到尽可能多的后端服务的FallbackProvider.当发出一个请求时,它会同时发送到多个后端.当从每个后端返回响应时,会检查它们是否同意. 一旦达到规定数量(即足够多的后端同意),你的应用程序就会得到相应.它确保后端不同步或者被破坏,那么会放弃这个响应,选择接受而支持大多数认同的响应.</p>
<p><em><strong>ethers*.getDefaultProvider( [ <em>network</em> , [ <em>options</em> ] ] ) ⇒ *Provider</strong></em></p>
<p>返回一个新的Provider,由多个服务支持连接到 <em>网络</em>.如果没有提供<em>网络</em>,那么将会使用 <strong>homestead</strong> (例如mainnet) .</p>
<p><em>网络</em> 也可以作为 URL 来连接,比如 <code>http://localhost:8545</code> 或 <code>wss://example.com</code>.</p>
<p><em><strong>options</strong></em> 参数是一个对象,有以下几个属性:</p>
<table>
<thead>
<tr>
<th><strong>Property</strong></th>
<th><strong>Description</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><em>alchemy</em></td>
<td>Alchemy API Token</td>
<td></td>
</tr>
<tr>
<td><em>etherscan</em></td>
<td>Etherscan API Token</td>
<td></td>
</tr>
<tr>
<td><em>infura</em></td>
<td>INFURA Project ID 或 <code>&#123; projectId, projectSecret &#125;</code></td>
<td></td>
</tr>
<tr>
<td><em>pocket</em></td>
<td>Pocket Network Application ID 或 <code>&#123; applicationId, applicationSecretKey &#125;</code></td>
<td></td>
</tr>
<tr>
<td><em>quorum</em></td>
<td>必须满足规定的后端同意数量 <em>(默认: 2 for mainnet, 1 for testnets)</em></td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-2-网络"><a href="#1-2-网络" class="headerlink" title="1.2 网络"></a>1.2 网络</h2><p>任何接收Networkish 的API都可以传递一个通用名称(如 <code>&quot;mainnet&quot;</code> or <code>&quot;ropsten&quot;</code>) 或者 chain ID、自定义的参数来定义网络.</p>
<p><em>ethers</em>.<em>providers</em>.<strong>getNetwork</strong>( <em>Networkish</em> ) ⇒ <em>Network.</em></p>
<p>通过给定标准规范的Networkish,返回完整的 Network .</p>
<p>这对于希望接受Networkish作为输入参数的函数和类非常有用.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过链名</span></span><br><span class="line"><span class="title function_">getNetwork</span>(<span class="string">&quot;homestead&quot;</span>);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   chainId: 1,</span></span><br><span class="line"><span class="comment">//   ensAddress: &#x27;0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e&#x27;,</span></span><br><span class="line"><span class="comment">//   name: &#x27;homestead&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过链ID</span></span><br><span class="line"><span class="title function_">getNetwork</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   chainId: 1,</span></span><br><span class="line"><span class="comment">//   ensAddress: &#x27;0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e&#x27;,</span></span><br><span class="line"><span class="comment">//   name: &#x27;homestead&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-自定义的-ENS-合约"><a href="#1-3-自定义的-ENS-合约" class="headerlink" title="1.3 自定义的 ENS 合约"></a>1.3 <strong>自定义的 ENS 合约</strong></h2><p>这是因为通常需要在为Network 指定自定义属性来覆盖root ENS registry,或者是在一个通用的网络中拦截ENS 方法,又或者是在一个开发环境的网络中（绝大多数开发环境中的网络中的ENS合约需要你手动部署)指定ENS registry.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> network = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;dev&quot;</span>,</span><br><span class="line">    <span class="attr">chainId</span>: <span class="number">1337</span>,</span><br><span class="line">    <span class="attr">ensAddress</span>: customEnsAddress</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-Provider"><a href="#1-4-Provider" class="headerlink" title="1.4 Provider"></a>1.4 <strong>Provider</strong></h2><p>在ethers里面,<strong>Provider</strong> 是访问区块链数据的只读抽象.</p>
<blockquote>
<p>如果你用过Web3.js,以下是与ethers.js最大不同点:ethers library 在 <strong>Provider</strong>和<strong>Signer</strong>可执行的操作之间创建了一个强大的划分,而Web3.js将二者结合在一起.这种划分的关注点在于Provider严格的操作子集允许更多的后端、更一致的API,并确保其他库可以在不依赖任何潜在假设的情况下运行.</p>
</blockquote>
<h1 id="账户的方法"><a href="#账户的方法" class="headerlink" title="账户的方法"></a>账户的方法</h1><h2 id="2-1-getBalance"><a href="#2-1-getBalance" class="headerlink" title="2.1 getBalance"></a>2.1 <strong>getBalance</strong></h2><p><em>provider</em>.<strong>getBalance</strong>( <em>address</em> [ , <em>blockTag</em> &#x3D; <em>latest</em> ] ) ⇒ <em>Promise&lt; 大数(**BigNumber**) &gt;</em></p>
<p>返回给定的<em>blockTag</em> 区块高度下<strong>地址的余额</strong></p>
<h2 id="2-2-getCode"><a href="#2-2-getCode" class="headerlink" title="2.2 getCode"></a>2.2 <strong>getCode</strong></h2><p><em>provider</em>.<strong>getCode</strong>( <em>address</em> [ , <em>blockTag</em> &#x3D; <em>latest</em> ] ) ⇒ <em>Promise&lt; string&lt; **DataHexString** &gt; &gt;</em></p>
<p>返回给定的<em>blockTag</em> 区块高度下的<strong>合约源代码</strong>,如果当前没有合约被部署, 将返回 <code>0x</code>.</p>
<h2 id="2-3-getStorageAt"><a href="#2-3-getStorageAt" class="headerlink" title="2.3 getStorageAt"></a>2.3 <strong>getStorageAt</strong></h2><p><em>provider</em>.<strong>getStorageAt</strong>( <em>addr</em> , <em>pos</em> [ , <em>blockTag</em> &#x3D; <em>latest</em> ] ) ⇒ <em>Promise&lt; string&lt; **DataHexString** &gt; &gt;</em></p>
<p>在当前的<em>blockTag</em>下,输入address参数addr和position(位置)参数pos,返回类型为<code>Bytes32</code>的值.</p>
<h2 id="2-4-getTransactionCount"><a href="#2-4-getTransactionCount" class="headerlink" title="2.4 getTransactionCount"></a>2.4 <strong>getTransactionCount</strong></h2><p><em>provider</em>.<strong>getTransactionCount</strong>( <em>address</em> [ , <em>blockTag</em> &#x3D; <em>latest</em> ] ) ⇒ <em>Promise&lt; **number** &gt;</em></p>
<p>在当前的<em>blockTag</em>下,返回已经发送的交易的数量,这个值是用来提供给<strong>发送</strong>到网络的下一个交易的<strong>nonce值</strong>.</p>
<h1 id="区块的方法"><a href="#区块的方法" class="headerlink" title="区块的方法"></a>区块的方法</h1><h2 id="3-1-getBlock"><a href="#3-1-getBlock" class="headerlink" title="3.1 getBlock"></a>3.1 <strong>getBlock</strong></h2><p><em>provider</em>.<strong>getBlock</strong>( <em>block</em> ) ⇒ <em>Promise&lt; **Block** &gt;</em></p>
<p>从网络中得到某个<strong>区块信息</strong>, <code>result.transactions</code> 是一串交易集合的哈希值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> provider.<span class="title function_">getBlock</span>(<span class="params"><span class="number">99</span></span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">_difficulty</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;3849295379889&quot;</span> &#125;,</span><br><span class="line">  <span class="attr">difficulty</span>: <span class="number">3849295379889</span>,</span><br><span class="line">  <span class="attr">extraData</span>: <span class="string">&#x27;0x476574682f76312e302e312d39383130306634372f6c696e75782f676f312e34&#x27;</span>,</span><br><span class="line">  <span class="attr">gasLimit</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;3141592&quot;</span> &#125;,</span><br><span class="line">  <span class="attr">gasUsed</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;21000&quot;</span> &#125;,</span><br><span class="line">  <span class="attr">hash</span>: <span class="string">&#x27;0xf93283571ae16dcecbe1816adc126954a739350cd1523a1559eabeae155fbb63&#x27;</span>,</span><br><span class="line">  <span class="attr">miner</span>: <span class="string">&#x27;0x909755D480A27911cB7EeeB5edB918fae50883c0&#x27;</span>,</span><br><span class="line">  <span class="attr">nonce</span>: <span class="string">&#x27;0x1a455280001cc3f8&#x27;</span>,</span><br><span class="line">  <span class="attr">number</span>: <span class="number">100004</span>,</span><br><span class="line">  <span class="attr">parentHash</span>: <span class="string">&#x27;0x73d88d376f6b4d232d70dc950d9515fad3b5aa241937e362fdbfd74d1c901781&#x27;</span>,</span><br><span class="line">  <span class="attr">timestamp</span>: <span class="number">1439799168</span>,</span><br><span class="line">  <span class="attr">transactions</span>: [</span><br><span class="line">    <span class="string">&#x27;0x6f12399cc2cb42bed5b267899b08a847552e8c42a64f5eb128c1bcbd1974fb0c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0x7f12399cc2cb42bed5b267899b08a847552e8c42a64f5eb128c1bcbd1974fb0c&#x27;</span>,</span><br><span class="line">    ....</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-getBlockWithTransactions"><a href="#3-2-getBlockWithTransactions" class="headerlink" title="3.2 getBlockWithTransactions"></a>3.2 <strong>getBlockWithTransactions</strong></h2><p><em>provider</em>.<strong>getBlockWithTransactions</strong>( <em>block</em> ) ⇒ <em>Promise&lt; **BlockWithTransactions** &gt;</em></p>
<p>从网络中得到某个<strong>区块信息</strong>, <code>result.transactions</code> 是 一个<strong>TransactionResponse</strong> 对象的数组集合.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> provider.<span class="title function_">getBlock</span>(<span class="params"><span class="number">99</span></span>)</span><br><span class="line">&#123;</span><br><span class="line">  ...(参考上面)</span><br><span class="line">  <span class="attr">transactions</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">accessList</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">blockHash</span>: <span class="string">&#x27;0xf93283571ae16dcecbe1816adc126954a739350cd1523a1559eabeae155fbb63&#x27;</span>,</span><br><span class="line">        <span class="attr">blockNumber</span>: <span class="number">100004</span>,</span><br><span class="line">        <span class="attr">chainId</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">confirmations</span>: <span class="number">16283837</span>,</span><br><span class="line">        <span class="attr">creates</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">data</span>: <span class="string">&#x27;0x&#x27;</span>,</span><br><span class="line">        <span class="attr">from</span>: <span class="string">&#x27;0xcf00A85f3826941e7A25BFcF9Aac575d40410852&#x27;</span>,</span><br><span class="line">        <span class="attr">gasLimit</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;90000&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">gasPrice</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;54588778004&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">hash</span>: <span class="string">&#x27;0x6f12399cc2cb42bed5b267899b08a847552e8c42a64f5eb128c1bcbd1974fb0c&#x27;</span>,</span><br><span class="line">        <span class="attr">nonce</span>: <span class="number">25</span>,</span><br><span class="line">        <span class="attr">r</span>: <span class="string">&#x27;0xb23adc880d3735e4389698dddc953fb02f1fa9b57e84d3510a2a4b3597ac2486&#x27;</span>,</span><br><span class="line">        <span class="attr">s</span>: <span class="string">&#x27;0x4e856f95c4e2828933246fb4765a5bfd2ca5959840643bef0e80b4e3a243d064&#x27;</span>,</span><br><span class="line">        <span class="attr">to</span>: <span class="string">&#x27;0xD9666150A9dA92d9108198a4072970805a8B3428&#x27;</span>,</span><br><span class="line">        <span class="attr">transactionIndex</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">v</span>: <span class="number">27</span>,</span><br><span class="line">        <span class="attr">value</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;5000000000000000000&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">wait</span>: [<span class="title class_">Function</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    ....</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="以太坊域名服务-ENS-方法"><a href="#以太坊域名服务-ENS-方法" class="headerlink" title="以太坊域名服务 (ENS) 方法"></a><strong>以太坊域名服务 (ENS) 方法</strong></h1><p><strong>以太坊域名服务 (ENS)</strong> 允许一个简短且易于记忆的ENS名称附加到任何一组键和值.</p>
<p>最常见的用法之一是使用一个简单的命名来<strong>引用以太坊地址</strong>.</p>
<h2 id="4-1-lookupAddress"><a href="#4-1-lookupAddress" class="headerlink" title="4.1 lookupAddress"></a>4.1 <strong>lookupAddress</strong></h2><p><em>provider</em>.<strong>lookupAddress</strong>( <em>address</em> ) ⇒ <em>Promise&lt; **string** &gt;</em></p>
<p>使用<em>反向注册器</em>对<strong>ENS中的地址进行反向查找</strong>.如果名称不存在,或者正向查找不匹配,则返回<code>null</code>.</p>
<p>ENS名称需要额外的配置来设置反向记录,它们不会自动设置.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">await</span> provider.<span class="title function_">lookupAddress</span>(<span class="string">&quot;0x5555763613a12D8F3e73be831DFf8598089d3dCa&quot;</span>);</span><br><span class="line">&gt; <span class="string">&#x27;ricmoo.eth&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-resolveName"><a href="#4-2-resolveName" class="headerlink" title="4.2 resolveName"></a>4.2 <strong>resolveName</strong></h2><p><em>provider</em>.<strong>resolveName</strong>( <em>name</em> ) ⇒ <em>Promise&lt; string&lt; **Address** &gt; &gt;</em></p>
<p><strong>查找一个名称的地址</strong>,如果这个<em>名称</em>没有被拥有,或者没有配置一个解析器,或者解析器没有配置一个地址,则返回<code>null</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">await</span> provider.<span class="title function_">resolveName</span>(<span class="string">&quot;ricmoo.eth&quot;</span>);</span><br><span class="line">&gt; <span class="string">&#x27;0x5555763613a12D8F3e73be831DFf8598089d3dCa&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-3-getResolver"><a href="#4-3-getResolver" class="headerlink" title="4.3 getResolver"></a>4.3 <strong>getResolver</strong></h2><p><em>provider</em>.<strong>getResolver</strong>( <em>name</em> ) ⇒ <em>Promise&lt; **EnsResolver** &gt;</em></p>
<p><strong>返回一个EnsResolver实例,该实例可用于进一步查询ENS命名的特定实体.</strong></p>
<h2 id="4-4-EnsResolver"><a href="#4-4-EnsResolver" class="headerlink" title="4.4 EnsResolver"></a>4.4 EnsResolver</h2><p><strong>Resolver 的名称</strong>:<em>resolver</em>.<strong>name</strong> ⇒ <em>string</em></p>
<p><strong>Resolver 的地址</strong>:<em>resolver</em>.<strong>address</strong> ⇒ <em>string&lt; 地址(**Address**) &gt;</em></p>
<h3 id="4-4-1-getAddress"><a href="#4-4-1-getAddress" class="headerlink" title="4.4.1 getAddress"></a>4.4.1 <strong>getAddress</strong></h3><p><em>resolver</em>.<strong>getAddress</strong>( [ <em>cointType</em> &#x3D; <em>60</em> ] ) ⇒ <em>Promise&lt; **string** &gt;</em></p>
<p>返回一个解析的类型为EIP-2304 <em>多币地址</em>的 Promise,默认情况下,<strong>返回一个以太坊的地址(Address)</strong>(<code>coinType = 60</code>).</p>
<h3 id="4-4-2-getContentHash"><a href="#4-4-2-getContentHash" class="headerlink" title="4.4.2 getContentHash"></a>4.4.2 <strong>getContentHash</strong></h3><p><em>resolver</em>.<strong>getContentHash</strong>( ) ⇒ <em>Promise&lt; **string** &gt;</em></p>
<p>返回一个Promise,解析为任何<strong>存储的EIP-1577内容哈希</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">await</span> resolver.<span class="title function_">getContentHash</span>();</span><br><span class="line">&gt; <span class="string">&#x27;ipfs://QmdTPkMMBWQvL8t7yXogo7jq5pAcWg8J7RkLrDsWZHT82y&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-3-getText"><a href="#4-4-3-getText" class="headerlink" title="4.4.3 getText"></a>4.4.3 <strong>getText</strong></h3><p><em>resolver</em>.<strong>getText</strong>( <em>key</em> ) ⇒ <em>Promise&lt; **string** &gt;</em></p>
<p>返回一个Promise,解析为任何<strong>存储的EIP-634作为key的文本实体</strong>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">await</span> resolver.<span class="title function_">getText</span>(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">&gt; <span class="string">&#x27;me@ricmoo.com&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">await</span> resolver.<span class="title function_">getText</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">&gt; <span class="string">&#x27;https://www.ricmoo.com/&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">await</span> resolver.<span class="title function_">getText</span>(<span class="string">&quot;com.twitter&quot;</span>);</span><br><span class="line">&gt; <span class="string">&#x27;@ricmoo&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="Logs方法"><a href="#Logs方法" class="headerlink" title="Logs方法"></a>Logs方法</h1><p><em>provider</em>.<strong>getLogs</strong>( <em>filter</em> ) ⇒ <em>Promise</em><em>&lt; Array&lt; Log &gt;</em>* &gt;*</p>
<p>返回<strong>匹配筛选器的 Log数组</strong>.</p>
<blockquote>
<p>许多后端会丢弃旧的事件,并且请求范围太广可能也会被丢弃,因为它们需要太多的资源来执行查询.</p>
</blockquote>
<h1 id="网络状态方法"><a href="#网络状态方法" class="headerlink" title="网络状态方法"></a><strong>网络状态方法</strong></h1><h2 id="6-1-getNetwork"><a href="#6-1-getNetwork" class="headerlink" title="6.1 getNetwork"></a>6.1 getNetwork</h2><p><em>provider</em>.<strong>getNetwork</strong>( ) ⇒ <em>Promise&lt; **Network** &gt;</em></p>
<p>返回这个 Provider 所<strong>连接的 Network</strong>.</p>
<h2 id="6-2-getBlockNumber"><a href="#6-2-getBlockNumber" class="headerlink" title="6.2 getBlockNumber"></a>6.2 getBlockNumber</h2><p><em>provider</em>.<strong>getBlockNumber</strong>( ) ⇒ <em>Promise&lt; **number** &gt;</em></p>
<p>返回<strong>最近挖出的区块的序号(或高度</strong>).</p>
<h2 id="6-3-getGasPrice"><a href="#6-3-getGasPrice" class="headerlink" title="6.3 getGasPrice"></a>6.3 getGasPrice</h2><p><em>provider</em>.<strong>getGasPrice</strong>( ) ⇒ <em>Promise&lt; 大数(**BigNumber**) &gt;</em></p>
<p>返回一个 关于这个交易中的 <strong>gas price的<em>最准预测</em></strong>.</p>
<h2 id="6-4-getFeeData"><a href="#6-4-getFeeData" class="headerlink" title="6.4 getFeeData"></a>6.4 getFeeData</h2><p><em>provider</em>.<strong>getFeeData</strong>( ) ⇒ <em>Promise&lt; **FeeDatba** &gt;</em></p>
<p>返回在一笔交易中当前的<strong>建议 FeeData</strong>.</p>
<p>对于 EIP-1559 的交易, 应该使用 <code>maxFeePerGas</code> 和 <code>maxPriorityFeePerGas</code>.</p>
<p>对于不支持 EIP-1559 中被遗留的交易和网络,应该使用 <code>gasPrice</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 燃料价格 (单位: wei)...</span></span><br><span class="line">feeData = <span class="keyword">await</span> provider.<span class="title function_">getFeeData</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">gasPrice</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;16674318809&quot;</span> &#125;,</span><br><span class="line">   <span class="attr">lastBaseFeePerGas</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;16492712329&quot;</span> &#125;,</span><br><span class="line">   <span class="attr">maxFeePerGas</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;34485424658&quot;</span> &#125;,</span><br><span class="line">   <span class="attr">maxPriorityFeePerGas</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;1500000000&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通常来说燃料的价格用 gwei 会更好理解</span></span><br><span class="line">utils.<span class="title function_">formatUnits</span>(feeData.<span class="property">maxFeePerGas</span>, <span class="string">&quot;gwei&quot;</span>)</span><br><span class="line"><span class="string">&#x27;34.485424658&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-5-ready"><a href="#6-5-ready" class="headerlink" title="6.5 ready"></a>6.5 ready</h2><p><em>provider</em>.<strong>ready</strong> ⇒ <em>Promise&lt; **Network** &gt;</em></p>
<p>返回一个 Promise ,直到网络建立就失效,忽略由于目标节点还未激活而出现的错误. </p>
<p>这可以用于测试或附上脚本,以等待节点启动并顺利运行.</p>
<h1 id="交易方法"><a href="#交易方法" class="headerlink" title="交易方法"></a>交易方法</h1><h2 id="7-1-call"><a href="#7-1-call" class="headerlink" title="7.1 call"></a>7.1 call</h2><p><em>provider</em>.<strong>call</strong>( <em>transaction</em> [ , <em>blockTag</em> &#x3D; <em>latest</em> ] ) ⇒ <em>Promise&lt; string&lt; **DataHexString** &gt; &gt;</em></p>
<p>使用<em>call</em>返回<strong>执行交易的结果</strong>,调用不需要任何的以太,但不能改变任何状态.这在合约上调用getter方法是非常有用的.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">await</span> provider.<span class="title function_">call</span>(&#123;</span><br><span class="line">  <span class="comment">// ENS public resovler address</span></span><br><span class="line">  <span class="attr">to</span>: <span class="string">&quot;0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `function addr(namehash(&quot;ricmoo.eth&quot;)) view returns (address)`</span></span><br><span class="line">  <span class="attr">data</span>: <span class="string">&quot;0x3b3b57debf074faa138b72c65adbdcfb329847e4f2c04bde7f7dd7fcad5a52d2f395a558&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line">&gt; <span class="string">&#x27;0x0000000000000000000000005555763613a12d8f3e73be831dff8598089d3dca&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="7-2-estimateGas"><a href="#7-2-estimateGas" class="headerlink" title="7.2 estimateGas"></a>7.2 estimateGas</h2><p><em>provider</em>.<strong>estimateGas</strong>( <em>transaction</em> ) ⇒ <em>Promise&lt; 大数(**BigNumber**) &gt;</em></p>
<p>返回向网络提交<strong>交易所需的预估gas值</strong>.</p>
<blockquote>
<p>估计的gas值可能不准确,因为网络上可能有另一个交易没有被计算在内,但在被挖出来之后就会影响相关状态.</p>
</blockquote>
<h2 id="7-3-getTransaction"><a href="#7-3-getTransaction" class="headerlink" title="7.3 getTransaction"></a>7.3 getTransaction</h2><p><em>provider</em>.<strong>getTransaction</strong>( <em>hash</em> ) ⇒ <em>Promise&lt; **TransactionResponse** &gt;</em></p>
<p>返回<strong>带有哈希值的交易</strong>,如果交易未知,则返回null.</p>
<p>如果一个交易还没有被挖出,这个方法将搜索交易池.各种后端可能有更多的限制交易池访问(例如,燃料价格太低或交易最近才发送,还没有索引),在这种情况下,这个方法也可能返回null.</p>
<h2 id="7-4-getTransactionReceipt"><a href="#7-4-getTransactionReceipt" class="headerlink" title="7.4 getTransactionReceipt"></a>7.4 getTransactionReceipt</h2><p><em>provider</em>.<strong>getTransactionReceipt</strong>( <em>hash</em> ) ⇒ <em>Promise&lt; **TransactionReceipt** &gt;</em></p>
<p>返回<strong>交易收据的哈希值</strong>,如果交易还没有被挖出则返回null.</p>
<p>如果需要等待交易被挖出,请考虑下面的<code>waitForTransaction</code>方法.</p>
<h2 id="7-5-sendTransaction"><a href="#7-5-sendTransaction" class="headerlink" title="7.5 sendTransaction"></a>7.5 sendTransaction</h2><p><em>provider</em>.<strong>sendTransaction</strong>( <em>transaction</em> ) ⇒ <em>Promise&lt; **TransactionResponse** &gt;</em></p>
<p>向在挖区块的网络提交交易,<strong>交易必须经过签名</strong>,并且需要合法(例如:nonce值需要正确并且账户要有足够的余额来进行该笔交易的支付）</p>
<h2 id="7-6-waitForTransaction"><a href="#7-6-waitForTransaction" class="headerlink" title="7.6 waitForTransaction"></a>7.6 waitForTransaction</h2><p><em>provider</em>.<strong>waitForTransaction</strong>( <em>hash</em> [ , <em>confirms</em> &#x3D; <em>1</em> [ , <em>timeout</em> ] ] ) ⇒ <em>Promise&lt; **TxReceipt** &gt;</em></p>
<p>返回一个Promise,直到transactionHash被挖出来,才能够被解析.</p>
<p>如果<em>confirms</em>参数为0,这个方法是非阻塞的,如果交易还没有被挖出,则返回null. </p>
<p>否则,该方法是阻塞的,直到这个包含该交易的、被<em>confirms</em>标识的区块被挖出.</p>
<h1 id="事件方法"><a href="#事件方法" class="headerlink" title="事件方法"></a>事件方法</h1><h2 id="eventName参数"><a href="#eventName参数" class="headerlink" title="eventName参数"></a>eventName参数</h2><p><strong>Log Filter</strong>:一个过滤器是一个对象.表示合约log Filter它具有可选的<code>address</code> (合约地址) 和 <code>topics</code> (一个要匹配的主题集).</p>
<p>如果参数<code>address</code>未被指定.则过滤器匹配任何合约地址.</p>
<p><strong>Topic-Set Filter</strong>:<strong>主题集过滤器</strong>的值是一个主题集数组.</p>
<p>此事件与日志过滤器相同.但参数<code>address</code>可以不用填(匹配任何合约).</p>
<p><strong>Transaction Filter</strong>:<strong>交易过滤器</strong>的值是交易的哈希值.</p>
<p>这个事件会在任何给定的交易挖出的链上区块中触发. 使用once方法比使用on方法要普遍地多.</p>
<p><strong>除了交易和过滤事件外.还有几个命名事件:</strong></p>
<table>
<thead>
<tr>
<th><strong>EventName</strong></th>
<th><strong>Arguments</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;block&quot;</code></td>
<td><em>blockNumber</em></td>
<td>当一个区块被挖出时触发</td>
</tr>
<tr>
<td><code>&quot;error&quot;</code></td>
<td><em>error</em></td>
<td>只要有错误就触发</td>
</tr>
<tr>
<td><code>&quot;pending&quot;</code></td>
<td><em>pendingTransaction</em></td>
<td>当一个新交易进入内存池时触发;只有特定的providers提供此事件.从而在运行在自己的节点上获得可靠的数据</td>
</tr>
<tr>
<td><code>&quot;willPoll&quot;</code></td>
<td><em>pollId</em></td>
<td>在一个polling loop开始之前触发;<em>(大多数开发者很少使用)</em></td>
</tr>
<tr>
<td><code>&quot;poll&quot;</code></td>
<td><em>pollId</em>, <em>blockNumber</em></td>
<td>在每个poll cycle中.<code>blockNumber</code>更新之后(如果改变了).以及与在poll loop中任何其他的事件(如果有)之前触发; <em>(大多数开发者很少使用)</em></td>
</tr>
<tr>
<td><code>&quot;didPoll&quot;</code></td>
<td><em>pollId</em></td>
<td>在polling loop中的所有事件被触发后触发;(<em>大多数开发者很少使用</em>)</td>
</tr>
<tr>
<td><code>&quot;debug&quot;</code></td>
<td>provider dependent</td>
<td>每个Provider可以使用它来发出有用的调试信息.格式由开发者决定;<em>(大多数开发者很少使用)</em> <em>(very rarely used by most developers)</em></td>
</tr>
</tbody></table>
<h2 id="8-1-on"><a href="#8-1-on" class="headerlink" title="8.1 on"></a>8.1 on</h2><p><em>provider</em>.<strong>on</strong>( <em>eventName</em> , <em>listener</em> ) ⇒ <em><strong>this</strong></em></p>
<p>为<strong>每一个参数为<em>eventName</em>的 事件添加<em>监听器</em></strong>.</p>
<h2 id="8-2-once"><a href="#8-2-once" class="headerlink" title="8.2 once"></a>8.2 once</h2><p><em>provider</em>.<strong>once</strong>( <em>eventName</em> , <em>listener</em> ) ⇒ <em><strong>this</strong></em></p>
<p>为参数<strong>为<em>eventName</em>的 事件添加<em>监听器</em>,监听使用过后将会被移除</strong>.</p>
<h2 id="8-3-emit"><a href="#8-3-emit" class="headerlink" title="8.3 emit"></a>8.3 emit</h2><p><em>provider</em>.<strong>emit</strong>( <em>eventName</em> , …<em>args</em> ) ⇒ <em><strong>boolean</strong></em></p>
<p><strong>通知所有的<em>eventName</em> event监听器,并把参数传递给它们,这通常只在内部使用.</strong></p>
<h2 id="8-4-off"><a href="#8-4-off" class="headerlink" title="8.4 off"></a>8.4 off</h2><p><em>provider</em>.<strong>off</strong>( <em>eventName</em> [ , <em>listener</em> ] ) ⇒ <em><strong>this</strong></em></p>
<p><strong>移除一个参数为<em>eventName</em>的事件<em>监听器</em></strong>,如果没有提供<em>listener</em>参数,则移除所有关于<em>eventName</em>的监听器.</p>
<h2 id="8-5-removeAllListeners"><a href="#8-5-removeAllListeners" class="headerlink" title="8.5 removeAllListeners"></a><strong>8.5</strong> removeAllListeners</h2><p><em>provider</em>.<strong>removeAllListeners</strong>( [ <em>eventName</em> ] ) ⇒ <em><strong>this</strong></em></p>
<p><strong>移除所有参数为<em>eventName</em>的事件监听器</strong>,如果没有提供<em>eventName</em>参数,则移除<strong>所有</strong>事件.</p>
<h2 id="8-6-listenerCount"><a href="#8-6-listenerCount" class="headerlink" title="8.6 listenerCount"></a>8.6 listenerCount</h2><p><em>provider</em>.<strong>listenerCount</strong>( [ <em>eventName</em> ] ) ⇒ <em><strong>number</strong></em></p>
<p><strong>返回所有参数为<em>eventName</em>事件的监听器数量</strong>,如果没有提供<em>eventName</em>参数,返回所有监听器的数量.</p>
<h2 id="8-7-listeners"><a href="#8-7-listeners" class="headerlink" title="8.7 listeners"></a>8.7 listeners</h2><p><em>provider</em>.<strong>listeners</strong>( <em>eventName</em> ) ⇒ <em>Array&lt; **Listener** &gt;</em></p>
<p><strong>返回参数为<em>eventName</em>事件监听器的list集合.</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">provider.<span class="title function_">on</span>(<span class="string">&quot;block&quot;</span>, <span class="function">(<span class="params">blockNumber</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有有一个区块改变就会触发</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">provider.<span class="title function_">once</span>(txHash, <span class="function">(<span class="params">transaction</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当含有交易的区块被挖出就会触发</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个过滤器也可以通过Contract或接口API生成。</span></span><br><span class="line"><span class="comment">// 如果不指定address，则默认匹配任何地址，</span></span><br><span class="line"><span class="comment">// 如果不指定topics，则默认匹配任何日志。</span></span><br><span class="line">filter = &#123;</span><br><span class="line">    <span class="attr">address</span>: <span class="string">&quot;dai.tokens.ethers.eth&quot;</span>,</span><br><span class="line">    <span class="attr">topics</span>: [</span><br><span class="line">        utils.<span class="title function_">id</span>(<span class="string">&quot;Transfer(address,address,uint256)&quot;</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">provider.<span class="title function_">on</span>(filter, <span class="function">(<span class="params">log, event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当 DAI token 发生转账时触发</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，这是一个主题集数组，与使用没有address参数的过滤器相同(即匹配任何地址)</span></span><br><span class="line">topicSets = [</span><br><span class="line">    utils.<span class="title function_">id</span>(<span class="string">&quot;Transfer(address,address,uint256)&quot;</span>),</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    [</span><br><span class="line">        <span class="title function_">hexZeroPad</span>(myAddress, <span class="number">32</span>),</span><br><span class="line">        <span class="title function_">hexZeroPad</span>(myOtherAddress, <span class="number">32</span>)</span><br><span class="line">    ]</span><br><span class="line">]</span><br><span class="line">provider.<span class="title function_">on</span>(topicSets, <span class="function">(<span class="params">log, event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当任何一个token 发送到我的或者我的其他的地址时触发</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">provider.<span class="title function_">on</span>(<span class="string">&quot;pending&quot;</span>, <span class="function">(<span class="params">tx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当有一笔pending交易被捕获时触发</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">provider.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="function">(<span class="params">tx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只要有错误就会触发</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="校验方法"><a href="#校验方法" class="headerlink" title="校验方法"></a>校验方法</h1><p><em>Provider</em>.<strong>isProvider</strong>( <em>object</em> ) ⇒ <em><strong>boolean</strong></em></p>
<p>当且仅<strong>当参数<em>object</em>是Provider返回 true .</strong></p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/08/02/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/1-%E5%BC%80%E5%A7%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/02/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/1-%E5%BC%80%E5%A7%8B/" class="post-title-link" itemprop="url">1-开始</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-02 00:00:00" itemprop="dateCreated datePublished" datetime="2022-08-02T00:00:00+08:00">2022-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ether-5-4-js/" itemprop="url" rel="index">
                    <span itemprop="name">ether@5.4.js</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save ethers</span><br></pre></td></tr></table></figure>

<h1 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node.js </span></span><br><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">&quot;ethers&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6 或 TypeScript</span></span><br><span class="line"><span class="keyword">import</span> &#123; ethers &#125; <span class="keyword">from</span> <span class="string">&quot;ethers&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Web-浏览器"><a href="#Web-浏览器" class="headerlink" title="Web 浏览器"></a>Web 浏览器</h3><p>出于安全，通常较好的方式是将这个库复制到你的web服务器中来进行各种操作。</p>
<p>但若想快速构建实例展示，可以将我们的CDN加载到你的web应用程序中。</p>
<p>在浏览器中通过ES6的方式</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在浏览器中通过ES6的方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; ethers &#125; <span class="keyword">from</span> <span class="string">&quot;https://cdn.ethers.io/lib/ethers-5.2.esm.min.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// Your code here...</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在浏览器中通过ES3 (UMD)的方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.ethers.io/lib/ethers-5.2.umd.min.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接 MetaMask</span></span><br><span class="line"><span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.<span class="property">providers</span>.<span class="title class_">Web3Provider</span>(<span class="variable language_">window</span>.<span class="property">ethereum</span>)</span><br><span class="line"><span class="keyword">const</span> singer = provider.<span class="title function_">getSigner</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接一个 RPC 客户端</span></span><br><span class="line"><span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.<span class="property">providers</span>.<span class="title class_">JsonRpcProvider</span>();</span><br><span class="line"><span class="keyword">const</span> singer = provider.<span class="title function_">getSigner</span>()</span><br></pre></td></tr></table></figure>

<h1 id="Provider-API-Keys"><a href="#Provider-API-Keys" class="headerlink" title="Provider API Keys"></a>Provider API Keys</h1><p><strong>获得自己的API密钥，以提高您的应用程序性能</strong>：</p>
<p>当使用由API服务商(例如Alchemy,Etherscan 或 INFURA)支持的<strong>Provider</strong>时, 他们都需要一个API密钥，从而能够跟踪每个项目及其使用和权限。</p>
<p>ethers.js 库 为上述的API服务商提供了默认的API密钥，因此每个<strong>Provider</strong>都可以轻松地连接-开箱即用。</p>
<p>这些API密钥是由后端服务作为社区资源提供的，用于低流量项目和早期原型开发。因为这些API键是由所有用户共享的(没有获得自己的API密钥)，所以它们被经常被使用，这意味着重新请求发生得更频繁，响应也更慢。</p>
<p><strong>强烈建议</strong>你从下列的API服务商注册一个免费的API密钥，这有很多好处（可能有些差别，这取决于具体的API服务商）:</p>
<ul>
<li>更<strong>高</strong>的请求速率和并发请求限制</li>
<li>更<strong>快</strong>的响应，更少的重连和超时</li>
<li>在用于性能调优和分析客户行为具有更<strong>优秀</strong>的指标追踪</li>
<li>更<strong>高级</strong>的api，例如归档数据或高级日志查询</li>
</ul>
<blockquote>
<p>ethers提供的默认的API Keys是所有用户之间共享的，在大量服务加载的时候可能默认的API key服务会有所被限制，需要提前意识到这一点。</p>
<p>许多服务还具有监视和使用指标，这些指标只有在指定了API Key时才可用。这允许跟踪有多少请求正在被发送，以及哪些方法被使用得最多。</p>
<p>有些服务还提供额外的付费功能，这些功能只有在指定API Key时才可用。</p>
</blockquote>
<h2 id="Etherscan-以太坊区块浏览器-免费注册一个-API-key"><a href="#Etherscan-以太坊区块浏览器-免费注册一个-API-key" class="headerlink" title="Etherscan(以太坊区块浏览器)免费注册一个 API key"></a>Etherscan(以太坊区块浏览器)<a target="_blank" rel="noopener" href="https://etherscan.io/apis">免费注册一个 API key</a></h2><p>Etherscan 是以太坊区块资源管理器，它可能是最有用的构建和调试以太坊应用程序的开发工具。</p>
<p>Etherscan提供了大量的 API endpoints 集合， 包含了所有能够用来与以太坊区块链交互的操作。</p>
<p>**优点:**更高的速率限制 (因为没有共享速率限制)、客户使用指标</p>
<h2 id="INFURA在-INFURA-免费注册一个-Project-ID"><a href="#INFURA在-INFURA-免费注册一个-Project-ID" class="headerlink" title="INFURA在 INFURA 免费注册一个 Project ID"></a>INFURA<a target="_blank" rel="noopener" href="https://infura.io/register">在 INFURA 免费注册一个 Project ID</a></h2><p>INFURA服务已经存在相当一段时间了，鲁棒性强、可靠性高，强烈推荐。</p>
<p>它们提供了一个标准的JSON-RPC接口和一个WebSocket接口，这使得与标准工具的交互更加通用、简单和直接。</p>
<p>**优点:**更高的速率限制、客户使用指标、访问归档数据 (需要付费升级)</p>
<h2 id="Alchemy在-Alchemy-免费注册一个-API-key"><a href="#Alchemy在-Alchemy-免费注册一个-API-key" class="headerlink" title="Alchemy在 Alchemy 免费注册一个 API key"></a>Alchemy<a target="_blank" rel="noopener" href="https://dashboard.alchemyapi.io/signup?referral=55a35117-028e-4b7c-9e47-e275ad0acc6d">在 Alchemy 免费注册一个 API key</a></h2><p>Alchemy服务已经有几年的历史了，它也具备强鲁棒性和高可靠性。</p>
<p>它们提供了一个标准的JSON-RPC接口和一个WebSocket接口，以及一组用于与通证（tokens）交互和帮助调试的高级API。</p>
<p>**优点:**更高的速率限制、客户使用指标、能够访问高级通证余额和元数据API、能够进行高级调试跟踪和恢复reason APIs</p>
<h2 id="Pocket-Gateway在-Pocket-免费注册一个-API-key"><a href="#Pocket-Gateway在-Pocket-免费注册一个-API-key" class="headerlink" title="Pocket Gateway在 Pocket 免费注册一个 API key"></a>Pocket Gateway<a target="_blank" rel="noopener" href="https://pokt.network/pocket-gateway-ethereum-mainnet/">在 Pocket 免费注册一个 API key</a></h2><p>**优点:**客户使用指标、使用去中心化区块链基础设施、入股而不是按月付费、受加密经济激励的高度冗余的全局节点集合</p>
<h2 id="创建默认的-Provider"><a href="#创建默认的-Provider" class="headerlink" title="创建默认的 Provider"></a><strong>创建默认的 Provider</strong></h2><p>默认的提供者连接到多个后端，并在内部验证它们的结果，这使得对第三方服务的高度信任变得很简单。</p>
<p>第二个可选参数允许为每个内部创建的Provider指定API keys，任何被遗漏的API keys将返回使用该服务的默认API keys。</p>
<p><strong>极度推荐</strong> 您为每个服务提供一个API，让您的应用程序性能实现最大化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用主网</span></span><br><span class="line"><span class="keyword">const</span> network = <span class="string">&quot;homestead&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定你的API keys</span></span><br><span class="line"><span class="comment">// 每个都是可选的，如果省略它，则为默认值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> provider = ethers.<span class="title function_">getDefaultProvider</span>(network, &#123;</span><br><span class="line">    <span class="attr">etherscan</span>: <span class="variable constant_">YOUR_ETHERSCAN_API_KEY</span>,</span><br><span class="line">    <span class="attr">infura</span>: <span class="variable constant_">YOUR_INFURA_PROJECT_ID</span>,</span><br><span class="line">    <span class="comment">// 或者使用项目私钥:</span></span><br><span class="line">    <span class="comment">// infura: &#123;</span></span><br><span class="line">    <span class="comment">//   projectId: YOUR_INFURA_PROJECT_ID,</span></span><br><span class="line">    <span class="comment">//   projectSecret: YOUR_INFURA_PROJECT_SECRET,</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="attr">alchemy</span>: <span class="variable constant_">YOUR_ALCHEMY_API_KEY</span>,</span><br><span class="line">    <span class="attr">pocket</span>: <span class="variable constant_">YOUR_POCKET_APPLICATION_KEY</span></span><br><span class="line">    <span class="comment">// 或者使用应用私钥:</span></span><br><span class="line">    <span class="comment">// pocket: &#123;</span></span><br><span class="line">    <span class="comment">//   applicationId: ,</span></span><br><span class="line">    <span class="comment">//   applicationSecretKey:</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/07/28/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/solidity%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/28/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/solidity%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">solidity总结</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-28 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-28T00:00:00+08:00">2022-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><h3 id="1-receive-和-fallback-共存的调用"><a href="#1-receive-和-fallback-共存的调用" class="headerlink" title="1.receive 和 fallback 共存的调用"></a>1.receive 和 fallback 共存的调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    调用时发送了ETH</span><br><span class="line">            |</span><br><span class="line">判断 msg.data 是否为空</span><br><span class="line">          /     \</span><br><span class="line">        是       否</span><br><span class="line">是否存在 receive   fallbak()</span><br><span class="line">      /   \</span><br><span class="line">    存在   不存在</span><br><span class="line">    /        \</span><br><span class="line">receive()   fallbak()</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h3 id="2-即便一个合约的代码中没有显式地调用-selfdestruct，它仍然有可能通过-delegatecall-或-callcode-执行自毁操作。"><a href="#2-即便一个合约的代码中没有显式地调用-selfdestruct，它仍然有可能通过-delegatecall-或-callcode-执行自毁操作。" class="headerlink" title="2.即便一个合约的代码中没有显式地调用 selfdestruct，它仍然有可能通过 delegatecall 或 callcode 执行自毁操作。"></a>2.即便一个合约的代码中没有显式地调用 <code>selfdestruct</code>，它仍然有可能通过 <code>delegatecall</code> 或 <code>callcode</code> 执行自毁操作。</h3><hr>
<h3 id="3-合约进行selfdestruct后，还可以调用状态变量和函数么？"><a href="#3-合约进行selfdestruct后，还可以调用状态变量和函数么？" class="headerlink" title="3.合约进行selfdestruct后，还可以调用状态变量和函数么？"></a>3.合约进行<code>selfdestruct</code>后，还可以调用状态变量和函数么？</h3><blockquote>
<p>可以调用，但是返回默认值。如果想调用，也可以在存档节点里指定未删除的高度进行调用。</p>
</blockquote>
<hr>
<h3 id="4-三种-call-的总结-call-delegatecall-staticcall"><a href="#4-三种-call-的总结-call-delegatecall-staticcall" class="headerlink" title="4.三种 call 的总结(call&#x2F;delegatecall&#x2F;staticcall)"></a>4.三种 call 的总结(call&#x2F;delegatecall&#x2F;staticcall)</h3><p>为了与不知道 ABI 的合约进行交互，Solidity 提供了函数 <code>call</code>&#x2F;<code>delegatecall</code>&#x2F;<code>staticcall</code> 直接控制编码。它们都带有一个 <code>bytes memory</code> 参数和返回执行<strong>成功状态</strong>（bool）和<strong>数据</strong>（bytes memory）。</p>
<p>函数 <code>abi.encode</code>，<code>abi.encodePacked</code>，<code>abi.encodeWithSelector</code> 和 <code>abi.encodeWithSignature</code> 可用于编码结构化数据。</p>
<p><strong>它们可以接受任意类型，任意数量的参数</strong>。这些参数会被打包到以 32 字节为单位的连续区域中存放。其中一个<strong>例外是当第一个参数被编码成正好 4 个字节的情况</strong>。 在这种情况下，这个参数后边不会填充后续参数编码，以允许使用函数签名。</p>
<p>下面具体的介绍三种 call。</p>
<h4 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h4><p>用给定的有效载荷（payload）发出低级 <code>CALL</code> 调用，并<strong>返回交易成功状态和返回数据</strong>（调用合约的方法并转账）, 格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.call(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>低级CALL调用：不需要 payable address, 普通地址即可</p>
<ol>
<li>注意: 调用 <code>call</code> 的时候，地址可以不具备 payable 属性</li>
</ol>
</li>
<li><p>返回两个参数，一个 <code>bool</code> 值代表成功或者失败，另外一个是可能存在的 <code>data</code></p>
</li>
<li><p>发送所有可用 gas，也可以自己调节 gas。</p>
<ol>
<li>如果 <code>fallback</code> 和 <code>receive</code> 内的代码相对复杂也可以，但是如果是恶意代码，需要考虑消耗的 gas 是否值得执行。</li>
<li><code>_ads.call&#123;value: msg.value,gas:2300&#125;(data)</code></li>
</ol>
</li>
<li><p>当合约调用合约时，不知道对方源码和 ABI 时候，可以使用 call 调用对方合约</p>
</li>
<li><p>推荐使用 call 转账 ETH，但是不推荐使用 call 来调用其他合约。</p>
<ol>
<li>原因是: call 调用的时候，将合约控制权交给对方，如果碰到恶意代码，或者不安全的代码就很容易凉凉。</li>
</ol>
</li>
<li><p>当调用不存在的合约方法时候，会触发对方合约内的fallback或receive</p>
<ol>
<li>我们的合约也可以在 <code>fallback</code> &#x2F; <code>receive</code> 这两个方法内抛出事件，查看是否有人对其做了什么操作。</li>
</ol>
</li>
<li><p>三种方法都提供 <code>gas</code> 选项，而 <code>value</code> 选项仅 <code>call</code> 支持 。三种 call 里只有 <code>call</code> 可以进行 ETH 转账，其他两种不可以进行转账。</p>
</li>
</ol>
<p><strong>例子 （重要）：调用其他合约方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test1 &#123;</span><br><span class="line">    string public name;</span><br><span class="line">    uint256 public age;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function setNameAndAge(string memory name_, uint256 age_)</span><br><span class="line">        external</span><br><span class="line">        payable</span><br><span class="line">        returns (string memory __name, uint256 __age)</span><br><span class="line">    &#123;</span><br><span class="line">        name = name_;</span><br><span class="line">        age = age_;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        return (name_, age_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CallTest &#123;</span><br><span class="line">    // 需要一个网页，动态的解析 _bys</span><br><span class="line">    bytes public bys;</span><br><span class="line"></span><br><span class="line">    function call_Test1_setNameAndAge(</span><br><span class="line">        address ads_,</span><br><span class="line">        string memory name_,</span><br><span class="line">        uint256 age_</span><br><span class="line">    ) external payable &#123;</span><br><span class="line">        bytes memory data = abi.encodeWithSignature(</span><br><span class="line">            &quot;setNameAndAge(string,uint256)&quot;,</span><br><span class="line">            name_,</span><br><span class="line">            age_</span><br><span class="line">        );</span><br><span class="line">        (bool success, bytes memory _bys) = ads_.call&#123;value: msg.value&#125;(data);</span><br><span class="line">        require(success, &quot;Call Failed&quot;);</span><br><span class="line">        bys = _bys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说下这个例子的原理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    普通调用:用户A 调用 callB 合约, 发送 100 wei ; </span><br><span class="line">    callB 调用 Test1, 发送 50 wei此时在 Test1 合约内部</span><br><span class="line">        msg.sender = B</span><br><span class="line">        msg.value = 50</span><br><span class="line">        Test1 内部如果有状态变量修改，则会被修改</span><br><span class="line">        发送到 Test1 内的ETH主币也会被留在Test1内</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h4 id="delegatecall-委托调用"><a href="#delegatecall-委托调用" class="headerlink" title="delegatecall() 委托调用"></a>delegatecall() 委托调用</h4><p>发出低级函数 <code>DELEGATECALL</code>，失败时返回 false，发送所有可用 gas，也可以自己调节 gas。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.delegatecall(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure>

<p><code>delegatecall</code> 使用方法和 <code>call</code> 完全一样。区别在于，<code>delegatecall</code> 只调用给定地址的代码（函数），其他状态属性如（存储，余额 …）都来自当前合约。<code>delegatecall</code> 的目的是使用另一个合约中的库代码。</p>
<p>委托调用是：<strong>委托对方调用自己数据的</strong>。类似授权转账，比如我部署一个 Bank 合约， 授权 ContractA 使用 Bank 地址内的资金，ContractA 只拥有控制权，但是没有拥有权。</p>
<ul>
<li>委托调用后，所有变量修改都是发生在委托合约内部，并不会保存在被委托合约中。<ul>
<li>利用这个特性，可以通过更换被委托合约，来升级委托合约。</li>
</ul>
</li>
<li>委托调用合约内部，需要和被委托合约的内部参数完全一样，否则容易导致数据混乱<ul>
<li>可以通过顺序来避免这个问题，但是推荐完全一样</li>
</ul>
</li>
</ul>
<p><strong>例子 1（重要）</strong></p>
<p>代码如下:</p>
<ul>
<li><code>DelegateCall</code> 是委托合约</li>
<li><code>TestVersion1</code> 是第 1 次被委托合约</li>
<li><code>TestVersion2</code> 是第 2 次被委托合约</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 合约版本 V.1</span><br><span class="line">contract TestVersion1 &#123;</span><br><span class="line">    address public sender;</span><br><span class="line">    uint256 public value;</span><br><span class="line">    uint256 public num;</span><br><span class="line"></span><br><span class="line">    function set(uint256 num_) external payable &#123;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">        value = msg.value;</span><br><span class="line">        num = num_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 合约版本 V.2</span><br><span class="line">contract TestVersion2 &#123;</span><br><span class="line">    address public sender;</span><br><span class="line">    uint256 public value;</span><br><span class="line">    uint256 public num;</span><br><span class="line"></span><br><span class="line">    function set(uint256 num_) external payable &#123;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">        value = msg.value;</span><br><span class="line">        num = num_ * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 委托调用测试</span><br><span class="line">contract DelegateCall &#123;</span><br><span class="line">    address public sender;</span><br><span class="line">    uint256 public value;</span><br><span class="line">    uint256 public num;</span><br><span class="line"></span><br><span class="line">    function set(address _ads, uint256 num_) external payable &#123;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">        value = msg.value;</span><br><span class="line">        num = num_;</span><br><span class="line">        // 第1种 encode</span><br><span class="line">        // 不需知道合约名字，函数完全自定义</span><br><span class="line">        bytes memory data1 = abi.encodeWithSignature(&quot;set(uint256)&quot;, num_);</span><br><span class="line">        // 第2种 encode</span><br><span class="line">        // 需要合约名字，可以避免函数和参数写错</span><br><span class="line">        bytes memory data2 = abi.encodeWithSelector(TestVersion1.set.selector, num_);</span><br><span class="line"></span><br><span class="line">        (bool success, bytes memory _data) = _ads.delegatecall(data2);</span><br><span class="line"></span><br><span class="line">        require(success, &quot;DelegateCall set failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说下这个例子的原理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    委托调用</span><br><span class="line">    用户A 调用 DelegateCall 合约, 发送 100 wei ; DelegateCall 委托调用 Test1</span><br><span class="line">    此时在 Test1 合约内部</span><br><span class="line">        msg.sender = A</span><br><span class="line">        msg.value = 100</span><br><span class="line">        Test1 内部如果有状态变量修改，也不会被修改，会在DelegateCallB 内改变</span><br><span class="line">        发送到 Test1 内的ETH主币，会被留在 DelegateCallB 内，不会在Test1 内</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h4 id="staticcall-静态调用"><a href="#staticcall-静态调用" class="headerlink" title="staticcall() 静态调用"></a>staticcall() 静态调用</h4><p>用给定的有效载荷（payload）发出低级 <code>STATICCALL</code> 调用，并<strong>返回交易成功状态和返回数据</strong>（调用合约的方法并转账）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.staticcall(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure>

<p>它与 call 基本相同，发送所有可用 gas，也可以自己调节 gas，<strong>但如果被调用的函数以任何方式修改状态变量，都将回退</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 被调用的合约</span><br><span class="line">contract Hello1 &#123;</span><br><span class="line">    function echo() external pure returns (string memory) &#123;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hello2 &#123;</span><br><span class="line">    uint8 public a;</span><br><span class="line">    function echo() external returns (string memory) &#123;</span><br><span class="line">        a = 1;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用者合约</span><br><span class="line">contract SoldityTest &#123;</span><br><span class="line">    function callHello(address ads_) external view returns (string memory) &#123;</span><br><span class="line">        // 编码被调用者的方法签名</span><br><span class="line">        bytes4 methodId = bytes4(keccak256(&quot;echo()&quot;));</span><br><span class="line"></span><br><span class="line">        // 调用合约</span><br><span class="line">        (bool success, bytes memory data) = ads_.staticcall(</span><br><span class="line">            abi.encodeWithSelector(methodId)</span><br><span class="line">        );</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            return abi.decode(data, (string));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;error&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>call</code> ， <code>delegatecall</code> 和 <code>staticcall</code> 是非常低级的函数，应该把它们当作最后一招来使用，破坏了 Solidity 的类型安全性。</li>
<li>三种方法都提供 <code>gas</code> 选项，而 <code>value</code> 选项仅 <code>call</code> 支持 。三种 call 里只有 <code>call</code> 可以进行 ETH 转账，其他两种不可以进行转账</li>
<li>如果在通过低级函数 <code>delegatecall</code> 发起调用时需要访问存储中的变量，那么这两个合约的存储布局需要一致，以便被调用的合约代码可以正确地通过变量名访问合约的存储变量。 这不是指在库函数调用（高级的调用方式）时所传递的存储变量指针需要满足那样情况。</li>
</ol>
<hr>
<h3 id="5-调用合约时，不知道对方源码和-ABI-时候，可以使用-call-调用对方合约"><a href="#5-调用合约时，不知道对方源码和-ABI-时候，可以使用-call-调用对方合约" class="headerlink" title="5.调用合约时，不知道对方源码和 ABI 时候，可以使用 call 调用对方合约"></a>5.调用合约时，不知道对方源码和 ABI 时候，可以使用 call 调用对方合约</h3><hr>
<h3 id="6-transfer-send-call-三种转账的总结"><a href="#6-transfer-send-call-三种转账的总结" class="headerlink" title="6.transfer &#x2F; send &#x2F; call 三种转账的总结"></a>6.transfer &#x2F; send &#x2F; call 三种转账的总结</h3><p>低级CALL调用<strong>不需要<code>payable address</code></strong>,ransfer 和 send <strong>只能是 <code>payable address</code></strong></p>
<p>transfer()失败时抛出异常,send()失败时仅会返回false,不会终止执行（合约地址转账）</p>
<p>call的 gas 可以动态调整,transfer 和 send 只能是固定制 <code>2300</code></p>
<p>call除了可以转账外，可以还可以调用不知道 ABI 的方法，还可以调用的时候转账</p>
<ul>
<li>当调用不存在的合约方法时候，会触发对方合约内的 <code>fallback</code> 或者 <code>receive</code>。</li>
<li>如果使用 <code>_to.call&#123;value: 100&#125;(data)</code>，那么<code>data</code>中被调用的方法必须添加 <code>payable</code> 修饰符，否则转账失败！</li>
<li>因为可以调用方法，所以 call 有两个参数，除了一个 <code>bool</code> 值代表成功或者失败，另外一个是可能存在的 <code>data</code>，比如创建合约时候得到部署的地址，调用函数时候得到的函数放回值</li>
</ul>
<hr>
<h3 id="7-所有的引用类型，都有数据位置这个额外的注解来指定存储在哪里，所以一定要掌握好"><a href="#7-所有的引用类型，都有数据位置这个额外的注解来指定存储在哪里，所以一定要掌握好" class="headerlink" title="7.所有的引用类型，都有数据位置这个额外的注解来指定存储在哪里，所以一定要掌握好"></a>7.所有的引用类型，都有数据位置这个额外的注解来指定存储在哪里，所以一定要掌握好</h3><h3 id="7-比较字符串和字节"><a href="#7-比较字符串和字节" class="headerlink" title="7.比较字符串和字节"></a><strong>7.比较字符串和字节</strong></h3><ul>
<li><code>keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))</code></li>
<li><code>keccak256(bytes(s1)) == keccak256(bytes(s2))</code>:更省 gas</li>
</ul>
<hr>
<h3 id="8-堆栈是由-EVM-Ethereum-虚拟机-维护的非持久性数据。EVM-使用堆栈数据位置在执行期间加载变量。堆栈位置最多有-1024-个级别的限制。"><a href="#8-堆栈是由-EVM-Ethereum-虚拟机-维护的非持久性数据。EVM-使用堆栈数据位置在执行期间加载变量。堆栈位置最多有-1024-个级别的限制。" class="headerlink" title="8.堆栈是由 EVM (Ethereum 虚拟机)维护的非持久性数据。EVM 使用堆栈数据位置在执行期间加载变量。堆栈位置最多有 1024 个级别的限制。"></a>8.堆栈是由 EVM (Ethereum 虚拟机)维护的非持久性数据。EVM 使用堆栈数据位置在执行期间加载变量。堆栈位置最多有 1024 个级别的限制。</h3><hr>
<h3 id="9-数据位置总结"><a href="#9-数据位置总结" class="headerlink" title="9.数据位置总结"></a>9.数据位置总结</h3><ul>
<li>storage: 存储区: 状态变量总是储存在<strong>存储区</strong>上</li>
<li>memory: 内存区: 局部变量使用，只在内存中生效。<ul>
<li>值类型的局部变量，存储在<strong>内存</strong>中。</li>
<li><strong>引用类型局部变量，需要显式地指定数据位置</strong>。</li>
<li>函数的输入参数如果是数组或者 string，必须是 <code>memory</code> 或 <code>calldata</code></li>
<li>内存中的数组必须是定长数组（不能使用 push 赋值），动态数组只能储存在状态变量中。</li>
</ul>
</li>
<li>calldata<ul>
<li>和 memory 类似，但是 calldata 只能用在函数的输入参数中。</li>
<li>相比使用 memory ,合约输入参数如果使用 calldata, 可以节约 gas</li>
</ul>
</li>
</ul>
<p>按照函数参数:</p>
<ul>
<li>内部函数参数: (包括返回参数)都存储在<strong>memory（内存）</strong>中。</li>
<li>外部函数参数: (不包括返回参数)存储在 <code>calldata</code> 中</li>
</ul>
<hr>
<h3 id="10-为什么映射不能像哈希表一样遍历？"><a href="#10-为什么映射不能像哈希表一样遍历？" class="headerlink" title="10.为什么映射不能像哈希表一样遍历？"></a>10.为什么映射不能像哈希表一样遍历？</h3><p>映射与哈希表不同的地方：<strong>在映射中,并不存储 key，而是存储它的 <code>keccak256</code> 哈希值，从而便于查询实际的值</strong>。正因为如此，映射是没有长度的，也没有 <code>key 的集合</code>或 <code>value 的集合</code>的概念。映射只能是存储的数据位置，因此只允许作为状态变量或作为函数内的存储引用 或 作为库函数的参数。</p>
<hr>
<h3 id="11-遍历所有-Mapping-内的数据，（Mapping-配合-array-）"><a href="#11-遍历所有-Mapping-内的数据，（Mapping-配合-array-）" class="headerlink" title="11.遍历所有 Mapping 内的数据，（Mapping 配合 array ）"></a>11.遍历所有 Mapping 内的数据，（Mapping 配合 array ）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line">    // 用于检查:地址是否已经存在于 balancesKey</span><br><span class="line">    mapping(address =&gt; bool) public balancesInserted;</span><br><span class="line">    address[] public balancesKey; // 所有地址</span><br><span class="line"></span><br><span class="line">    // 设置</span><br><span class="line">    function set(address ads_,uint256 amount_) external&#123;</span><br><span class="line">        balances[ads_] = amount_;</span><br><span class="line">        // 1.检查</span><br><span class="line">        if(!balancesInserted[ads_])&#123;</span><br><span class="line">            // 2.修改检查条件</span><br><span class="line">            balancesInserted[ads_] = true;</span><br><span class="line">            // 3.正在的操作</span><br><span class="line">            balancesKey.push(ads_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取</span><br><span class="line">    function get(uint256 index_) external view returns(uint256)&#123;</span><br><span class="line">        require(index_&lt;balancesKey.length,&quot;index_ error&quot;);</span><br><span class="line">        return balances[balancesKey[index_]];</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取所有</span><br><span class="line">    function totalAddress() external view returns(uint256)&#123;</span><br><span class="line">        return balancesKey.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取第一个值</span><br><span class="line">    function first() external view returns(uint256)&#123;</span><br><span class="line">        return balances[balancesKey[0]];</span><br><span class="line">    &#125;</span><br><span class="line">    // 最后一个值</span><br><span class="line">    function latest() external view returns(uint256)&#123;</span><br><span class="line">        return balances[balancesKey[balancesKey.length-1]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>更完善的实现: <a target="_blank" rel="noopener" href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol">https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol</a></li>
<li>更新的实现: <a target="_blank" rel="noopener" href="https://learnblockchain.cn/docs/solidity/types.html#iterable-mappings">https://learnblockchain.cn/docs/solidity/types.html#iterable-mappings</a></li>
</ul>
<hr>
<h3 id="12-聊一聊-checked-和-unchecked"><a href="#12-聊一聊-checked-和-unchecked" class="headerlink" title="12.聊一聊 checked 和 unchecked"></a>12.聊一聊 <code>checked</code> 和 <code>unchecked</code></h3><p>0.8.0 开始，算术运算有两种计算模式：一种是<code>checked</code>（检查）模式，另一种是 <code>unchecked</code>（不检查）模式。 默认情况下，算术运算在 <code>checked</code> 模式下，即都会进行溢出检查，如果结果落在取值范围之外，调用会通过 失败异常 回退。 你也可以通过 <code>unchecked&#123; ... &#125;</code> 切换到 “unchecked”模式，更多可参考 <code>unchecked</code> .</p>
<hr>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h3 id="13-constant常量-和-immutable-不可变量总结"><a href="#13-constant常量-和-immutable-不可变量总结" class="headerlink" title="13.constant常量 和 immutable 不可变量总结"></a>13.constant常量 和 immutable 不可变量总结</h3><h4 id="值的确定时机不同"><a href="#值的确定时机不同" class="headerlink" title="值的确定时机不同"></a>值的确定时机不同</h4><p>状态变量声明为 constant (常量)或者 immutable （不可变量），在这两种情况下，合约一旦部署之后，变量将不在修改。</p>
<ul>
<li>对于 constant 常量, 他的值在编译器确定.</li>
<li>对于 immutable, 它的值在部署时确定。</li>
</ul>
<h4 id="gas-不同"><a href="#gas-不同" class="headerlink" title="gas 不同"></a>gas 不同</h4><p>与常规状态变量相比，常量和不可变量的 gas 成本要低得多。</p>
<ul>
<li>对于常量，赋值给它的表达式将复制到所有访问该常量的位置，并且每次都会对其进行重新求值。这样可以进行本地优化。</li>
<li>不可变变量在构造时进行一次求值，并将其值复制到代码中访问它们的所有位置。 对于这些值，将保留 32 个字节，即使它们适合较少的字节也是如此。很多时候常量的 gas 更低。</li>
</ul>
<p>如果可以使用常量的时候，推荐使用常量。</p>
<h4 id="支持的数据不同"><a href="#支持的数据不同" class="headerlink" title="支持的数据不同"></a>支持的数据不同</h4><p>不是所有类型的状态变量都支持用 <code>constant</code> 或 <code>immutable</code> 来修饰</p>
<ul>
<li>当前<code>constant</code>仅支持值类型和引用类型中的 string 和 bytes</li>
<li><code>immutable</code>仅支持值类型</li>
</ul>
<hr>
<h3 id="14-private-external-internal-public"><a href="#14-private-external-internal-public" class="headerlink" title="14.private &#x2F; external &#x2F; internal &#x2F; public"></a>14.<code>private</code> &#x2F; <code>external</code> &#x2F; <code>internal</code> &#x2F; <code>public</code></h3><ul>
<li>函数有四可见型，分别是 <code>private</code> &#x2F; <code>external</code> &#x2F; <code>internal</code> &#x2F; <code>public</code></li>
<li>状态变量可以有三种可见型，分别是 <code>private</code> &#x2F; <code>internal</code> &#x2F; <code>public</code></li>
</ul>
<ol>
<li><strong>private</strong>: 私有，仅在当前合约中可以访问，在继承的合约内不可访问</li>
<li><strong>internal(默认)</strong>: 能在它们所定义的合约和派生合同中访问,它们不能被外部访问,需要注意的是不能加前缀 this，前缀 this 是表示通过外部方式访问</li>
<li><strong>external:</strong> 不能声明在状态变量上，只能标识在函数上,只能从智能合约外部调用。 如果要从智能合约中调用它，则必须使用this</li>
<li><strong>public</strong>: 公开可视(合约内部，被继承的，外部都可以调用)</li>
</ol>
<hr>
<h3 id="15-变量作用域的规则"><a href="#15-变量作用域的规则" class="headerlink" title="15.变量作用域的规则"></a>15.变量作用域的规则</h3><ul>
<li>变量将会从它们被声明之后可见，直到一对 <code>&#123;&#125;</code> 块的结束。</li>
<li>对于参数形式的变量（例如：函数参数、修饰器参数、catch 参数等等）在其后接着的代码块内有效。<ul>
<li>这些代码块是函数的实现，catch 语句块等。</li>
<li>有一个例外，在 for 循环语句中初始化的变量，其可见性仅维持到 <code>for</code> 循环的结束。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="16-extcodesize-操作码来检查要调用的合约是否确实存在"><a href="#16-extcodesize-操作码来检查要调用的合约是否确实存在" class="headerlink" title="16.extcodesize 操作码来检查要调用的合约是否确实存在?"></a>16.extcodesize 操作码来检查要调用的合约是否确实存在?</h3><p>由于 EVM 认为可以调用不存在的合约的调用，因此在 Solidity 语言层面里会使用 extcodesize 操作码来检查要调用的合约是否确实存在（包含代码），如果不存在该合约，则抛出异常。如果返回数据在调用后被解码，则跳过这个检查，因此 ABI 解码器将捕捉到不存在的合约的情况。请注意，这个检查在 <strong>低级 call</strong> 时不被执行，这些调用是对地址而不是合约实例进行操作。</p>
<hr>
<h3 id="17-mutability状态可变性-Pure、view、payable"><a href="#17-mutability状态可变性-Pure、view、payable" class="headerlink" title="17.mutability状态可变性(Pure、view、payable)"></a>17.mutability状态可变性(Pure、view、payable)</h3><ol>
<li><p><strong>pure: 既不读取也不修改状态变量,这种函数被称为纯函数</strong></p>
<ul>
<li>读取状态变量。<ul>
<li>这也意味着读取 <code>immutable</code> 变量也不是一个 <code>pure</code> 操作。</li>
</ul>
</li>
<li>访问 <code>address(this).balance</code> 或 <code>&lt;address&gt;.balance</code></li>
<li>访问 <code>block</code>，<code>tx</code>， <code>msg</code> 中任意成员 （除 <code>msg.sig</code> 和 <code>msg.data</code> 之外）。</li>
<li>调用任何未标记为 <code>pure</code> 的函数。</li>
<li>使用包含特定操作码的内联汇编。<ul>
<li><code>TODO:</code> 这个不了解，需要用例子加深印象。</li>
</ul>
</li>
<li>使用操作码 <code>STATICCALL</code> , 这并不保证状态未被读取, 但至少不被修改。</li>
</ul>
</li>
<li><p><strong>view: 读取状态变量，但是不修改状态变量,这种函数被称为视图函数</strong></p>
<ul>
<li><p>修改状态变量。</p>
</li>
<li><p>触发事件。</p>
</li>
<li><p>创建其它合约。</p>
</li>
<li><p>使用 <code>selfdestruct</code>。</p>
</li>
<li><p>通过调用发送以太币。</p>
</li>
<li><p>调用任何没有标记为 view 或者 pure 的函数。</p>
</li>
<li><p>使用底层调用</p>
<ul>
<li>(TODO:这里是 call 操作么？)</li>
</ul>
</li>
<li><p>使用包含某些操作码的内联程序集。</p>
</li>
<li><p>状态变量的 Getter 方法默认是 view 函数。</p>
</li>
</ul>
</li>
<li><p><strong>payable：用 payable 声明的函数可以接受发送给合约的以太币.</strong></p>
<ul>
<li>如果未指定，该函数将自动拒绝所有发送给它的以太币</li>
</ul>
</li>
</ol>
<hr>
<h3 id="18-函数的构造函数有什么特点？"><a href="#18-函数的构造函数有什么特点？" class="headerlink" title="18.函数的构造函数有什么特点？"></a>18.函数的构造函数有什么特点？</h3><p>它仅能在智能合约部署的时候调用一次，创建之后就不能再次被调用。</p>
<p>构造函数是可选的，只允许有一个构造函数，这意味着不支持重载。（普通函数支持重载）</p>
<p>在合约创建的过程中，它的代码还是空的，所以直到构造函数执行结束，我们都不应该在其中调用合约自己的函数。(可以直接写函数名调用，但是不推荐调用，不可以通过 this 来调用函数，因为此时真实的合约实例还没有被创建。)</p>
<hr>
<h1 id="运算操作符"><a href="#运算操作符" class="headerlink" title="运算操作符"></a>运算操作符</h1><h3 id="19-A-B-如果-A-为-false，B-就不执行了-A-B-如果-A-为-true，B-就不执行了合理的使用短路操作，可以省一些-gas-费。"><a href="#19-A-B-如果-A-为-false，B-就不执行了-A-B-如果-A-为-true，B-就不执行了合理的使用短路操作，可以省一些-gas-费。" class="headerlink" title="19. A &amp;&amp; B,如果 A 为 false，B 就不执行了,A || B,如果 A 为 true，B 就不执行了合理的使用短路操作，可以省一些 gas 费。"></a>19. <code>A &amp;&amp; B</code>,如果 A 为 false，B 就不执行了,<code>A || B</code>,如果 A 为 true，B 就不执行了合理的使用短路操作，可以省一些 gas 费。</h3><hr>
<h3 id="20-三元运算符"><a href="#20-三元运算符" class="headerlink" title="20.三元运算符"></a>20.三元运算符</h3><p>三元运算符的结果类型是由两个操作数的类型决定的，方法与上面一样，如果需要的话，首先转换为它们的最小可容纳类型。</p>
<p>因此， <code>255 + (true ? 1 : 0)</code> 将由于算术溢出而被回退。 原因是 <code>(true ? 1 : 0)</code> 是 uint8 类型，这迫使加法也要在 <code>uint8</code> 中执行。 而 <code>256</code> 超出了这个类型所允许的范围。</p>
<p>另一个结果是，像 <code>1.5 + 1.5</code> 这样的表达式是有效的，但 <code>1.5 + (true ? 1.5 : 2.5)</code> 则无效。 这是因为前者是以无限精度来进行有理表达式运算，只有它的最终结果值才是重要的。 后者涉及到将小数有理数转换为整数，这在目前是不允许的。</p>
<hr>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h3 id="21-require、assert、revert对比"><a href="#21-require、assert、revert对比" class="headerlink" title="21.require、assert、revert对比"></a>21.require、assert、revert对比</h3><p><code>require(false)</code> 会退还所有剩余的 gas，同时可以返回一个自定义的报错信息。</p>
<p><code>assert(false)</code> 会消耗掉所有剩余的 gas，并恢复所有的操作。</p>
<p> <code>revert()</code> 会触发一个没有任何错误数据的回退</p>
<p>以下三个语句的功能完全相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// revert</span><br><span class="line">if(msg.sender != owner) &#123;</span><br><span class="line">   revert error();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">// require</span><br><span class="line">require(msg.sender == owner,&quot;error&quot;);</span><br><span class="line"></span><br><span class="line">// assert</span><br><span class="line">assert(msg.sender == owner);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="22-自定义error"><a href="#22-自定义error" class="headerlink" title="22.自定义error"></a>22.自定义error</h3><p><strong><code>error</code> 只能通过 <code>revert</code> 触发</strong></p>
<p>错误产生的数据，会通过 revert 操作传递给调用者，可以交由链外组件处理或在 try&#x2F;catch 语句 中捕获它。</p>
<p>注意，只有外部调用的错误才能被捕获。发生在内部调用或同一函数内的 revert 不能被捕获。</p>
<hr>
<h3 id="23-try-catch"><a href="#23-try-catch" class="headerlink" title="23.try catch"></a>23.try catch</h3><p>Solidity 如果遇到异常错误，是通过回退状态的方式来进行处理。发生异常时，会撤消当前调用和所有子调用改变的状态变量，同时给调用者返回一个错误标识。</p>
<p>调用者调用某个函数方法，要么成功修改了所有状态变量，要么遇到异常不修改任何状态变量，不存在成功修改部分变量的情况，</p>
<p>Solidity 提供了 <strong>require</strong> 、<strong>assert</strong> 和 <strong>revert</strong> 来处理异常。同时可以使用 <code>error</code> 关键字来实现错误。</p>
<p>跟用错误字符串相比， error 更便宜并且允许你编码额外的数据，还可以用 <code>NatSpec</code> 为用户去描述错误。</p>
<p>Solidity 使用状态恢复异常来处理错误。这种异常将撤消对当前调用（及其所有子调用）中的状态所做的所有更改，并且还向调用者标记错误。</p>
<p>如果异常在子调用发生，那么异常会自动冒泡到顶层（例如：异常会重新抛出），除非他们在 <code>try/catch</code> 语句中捕获了错误。 但是如果是在 <code>send</code> 和 低级 <code>call</code>, <code>delegatecall</code> 和 <code>staticcall</code> 的调用里发生异常时， 他们会返回 <code>false</code> （第一个返回值） 而不是冒泡异常。</p>
<p>警告注意：根据 EVM 的设计，如果被调用的地址不存在，低级别函数 <code>call</code>, <code>delegatecall</code> 和 <code>staticcall</code> 第一个返回值同样是 <code>true</code>。 如果需要，请在调用之前检查账号的存在性。</p>
<p>异常可以包含错误数据，以 error 示例 的形式传回给调用者。 内置的错误 <code>Error(string)</code> 和 <code>Panic(uint256)</code> 被作为特殊函数使用，下面将解释。 <code>Error</code> 用于 “常规” 错误条件，而 <code>Panic</code> 用于在（无 bug）代码中不应该出现的错误。</p>
<p>函数 assert 和 require 可用于检查条件并在条件不满足时抛出异常。</p>
<hr>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h3 id="24-带-indexed-参数名的-event"><a href="#24-带-indexed-参数名的-event" class="headerlink" title="24. 带 indexed 参数名的 event"></a>24. 带 indexed 参数名的 event</h3><p>这种事件也被称为<strong>索引事件</strong></p>
<p>语法:<code>event EventName(TypeName indexed varibleName....);</code></p>
<p>事件中 indexed 标记过的参数，可以在链外进行搜索查询:</p>
<p>主要用在链下服务，可以通过 RPC 获取，比如 web3 的以下方法:</p>
<ul>
<li><pre><code class="js">myContract.once //订阅一个事件并在第一次事件触发或错误发生后立即取消订阅
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```solidity</span><br><span class="line">  myContract.events.MyEvent //订阅指定的合约事件</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="solidity">myContract.getPastEvents //读取合约历史事件
</code></pre>
</li>
</ul>
<p>一个事件中 indexed 标记过的参数最多有 3 个。</p>
<hr>
<h1 id="合约继承"><a href="#合约继承" class="headerlink" title="合约继承"></a>合约继承</h1><h3 id="25-注意："><a href="#25-注意：" class="headerlink" title="25.注意："></a>25.注意：</h3><ul>
<li>父合约必须写在子合约的前面，否则会报错</li>
<li>子类可以访问父类的权限修饰符只有：<code>public/internal</code>，不能是 <code>external/private</code></li>
<li>多重继承中不允许出现相同的<strong>函数名</strong>、<strong>事件名</strong>、<strong>修改器名</strong>以及<strong>状态变量名</strong>等</li>
</ul>
<h3 id="26-virtual-override-abstract"><a href="#26-virtual-override-abstract" class="headerlink" title="26.virtual, override , abstract"></a>26.<code>virtual</code>, <code>override</code> , <code>abstract</code></h3><p>父合约标记为 <code>virtual</code>函数可以在继承合约里重写(overridden)以更改他们的行为。重写的函数需要使用关键字 <code>override</code> 修饰。</p>
<p>基础合约中可以包含没有实现代码的函数，也就是纯虚函数，那么基础合约必须声明为 <code>abstract</code>。</p>
<h1 id="接口Interface"><a href="#接口Interface" class="headerlink" title="接口Interface"></a>接口Interface</h1><h3 id="27-限制"><a href="#27-限制" class="headerlink" title="27.限制"></a>27.限制</h3><ul>
<li><p>无法实现任何功能，没有函数体。</p>
</li>
<li><p>无法定义构造函数。</p>
</li>
<li><p>无法定义状态变量。</p>
</li>
<li><p>无法定义结构（<code>struct</code>）（<code>0.5.0</code> 版本开始接口里可以支持声明 <code>enum</code> 类型）。</p>
</li>
<li><p>不可以声明修改器。</p>
</li>
<li><p>所有声明的函数必须是external的，尽管在合约里可以是 public</p>
</li>
</ul>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/07/27/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/20-%E5%90%88%E7%BA%A6%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/27/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/20-%E5%90%88%E7%BA%A6%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" class="post-title-link" itemprop="url">20-合约编码规范</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-27 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-27T00:00:00+08:00">2022-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>良好统一的编程风格，有助于提高代码的可读性和可维护性。根据风格整理成规范，可以让团队之间更好的配合。</p>
<p>下面是我结合网络上别人分享的内容，以及参考 Vscode 代码格式化整理优化出的；抛砖引玉，仅供参考。</p>
<ul>
<li>如果合约对状态变量进行了修改，需要抛出事件。</li>
<li>构造函数的参数必须是<code>storage</code>或<code>memory</code>，不能使用<code>calldata</code>;</li>
<li>版权注释在文件的任何位置都可以被编译器识别，但建议把它放在文件的顶部第一行。</li>
</ul>
<h2 id="代码布局"><a href="#代码布局" class="headerlink" title="代码布局"></a>代码布局</h2><ul>
<li><p>源码编码</p>
<ul>
<li>UTF-8</li>
</ul>
</li>
<li><p>缩进</p>
<ul>
<li>使用 4 个空格代替制表符作为缩进，避免空格与制表符混用。</li>
</ul>
</li>
<li><p>2 个合约定义之间空 2 行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract LedgerBalance &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Updater &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2 个函数之间空 1 行,在只有声明的情况下，不需要空行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function balance() public pure;</span><br><span class="line">    function account() public pure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract B is A &#123;</span><br><span class="line">    function balance() public pure &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function account() public pure &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单行不要太长，VScode 一行默认不超过 80 个字符。</p>
</li>
<li><p>函数声明如果太长，左括号不换行，每个参数一行并缩进，右括号换行，并对齐左括号所在行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function_with_a_long_name(</span><br><span class="line">    longArgument1,</span><br><span class="line">    longArgument2,</span><br><span class="line">    longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">variable = function_with_a_long_name(</span><br><span class="line">    longArgument1,</span><br><span class="line">    longArgument2,</span><br><span class="line">    longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">event multipleArguments(</span><br><span class="line">    address sender,</span><br><span class="line">    address recipient,</span><br><span class="line">    uint256 publicKey,</span><br><span class="line">    uint256 amount,</span><br><span class="line">    bytes32[] options</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">MultipleArguments(</span><br><span class="line">    sender,</span><br><span class="line">    recipient,</span><br><span class="line">    publicKey,</span><br><span class="line">    amount,</span><br><span class="line">    options</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免在圆括号、方括号或大括号后有空格。</p>
</li>
<li><p>控制结构的大括号左括号不换行，右括号换行，与左括号所在行对齐。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Coin &#123;</span><br><span class="line">    struct Bank &#123;</span><br><span class="line">        address owner;</span><br><span class="line">        uint balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (x &lt; 3) &#123;</span><br><span class="line">    x += 1;</span><br><span class="line">&#125; else if (x &gt; 7) &#123;</span><br><span class="line">    x -= 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    x = 5;</span><br><span class="line">&#125;</span><br><span class="line">if (x &lt; 3)</span><br><span class="line">    x += 1;</span><br><span class="line">else</span><br><span class="line">    x -= 1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数声明，添加可见性标签。可见性标签应该放在自定义修饰符之前。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function kill() public onlyowner &#123;</span><br><span class="line">    selfdestruct(owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明映射变量时避免多余空格。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mapping(uint =&gt; uint) map; // 不是 mapping (uint =&gt; uint) map;</span><br><span class="line">mapping(address =&gt; bool) registeredAddresses;</span><br><span class="line">mapping(uint =&gt; mapping(bool =&gt; Data[])) public data;</span><br><span class="line">mapping(uint =&gt; mapping(uint =&gt; s)) data;</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明数组变量时避免多余空格。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint[] x;  // 不是 unit [] x;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串声明,使用双引号声明字符串，而不是单引号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;foo&quot;;</span><br><span class="line">str = &quot;Hamlet says, &#x27;To be or not to be...&#x27;&quot;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="代码中各部分的顺序"><a href="#代码中各部分的顺序" class="headerlink" title="代码中各部分的顺序"></a>代码中各部分的顺序</h2><p>代码中各部分顺序如下：</p>
<ol>
<li>License</li>
<li>Pragma</li>
<li>import</li>
<li>interface</li>
<li>library</li>
<li>contract</li>
</ol>
<p>在 Interface、库或 Contract 中，各部分顺序应为：</p>
<ol>
<li><p>Type declaration : 类型声明</p>
</li>
<li><p>State variable : 状态变量</p>
</li>
<li><p>Event : 事件</p>
</li>
<li><p>Modifier : 函数修改器</p>
</li>
<li><p>Errors : 自定义错误</p>
</li>
<li><p>Constructor : 构造函数</p>
</li>
<li><p>Function : 函数</p>
<ol>
<li>函数按<strong>visibility:可见性</strong>进行排序: <code>External - Public - Internal - Private</code></li>
<li>同一可见性，按照 <strong>mutability:状态可变性</strong> 排序: <code>payable - 无 - view - pure</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// External functions</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// External view functions</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// External pure functions</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// Public functions</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// Internal functions</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// Private functions</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>Helper : 辅助函数</p>
</li>
</ol>
<h2 id="文件结构分享"><a href="#文件结构分享" class="headerlink" title="文件结构分享"></a>文件结构分享</h2><p>我的文件结构，分享给大家，仅供参考，抛砖引玉。代码块分割主要是让合约的逻辑更清晰，团队合作写代码的时候，都能按照统一的约定来进行编码。</p>
<p>不同功能的代码块使用下面任意一种做明显标记。</p>
<p>第一种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  * ========================================</span><br><span class="line">  * State Variables</span><br><span class="line">  * ========================================</span><br><span class="line">  */</span><br></pre></td></tr></table></figure>

<p>第二种：(两边各 12 个 <code>=</code>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* ============ State Variables ============ */</span><br></pre></td></tr></table></figure>

<p>如果需要写详细的 NetSpec 注释，我比较喜欢使用第一种。如果是不需要这样做，比较喜欢第二种。第一种写法，在第一章<a target="_blank" rel="noopener" href="https://www.axihe.com/source/01.hello.html#id40">同志们好</a> 那里已经演示过了，这里演示第二种写法。如下是写法的演示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// import</span><br><span class="line"></span><br><span class="line">// interface</span><br><span class="line"></span><br><span class="line">// library</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    /* ============ Type Declaration ============ */</span><br><span class="line">    struct Book &#123;</span><br><span class="line">        string title;</span><br><span class="line">        string author;</span><br><span class="line">        uint256 book_id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* ============ State Variables ============ */</span><br><span class="line">    address public immutable owner;</span><br><span class="line">    Book[] public bookcase;</span><br><span class="line"></span><br><span class="line">    /* ============ Events ============ */</span><br><span class="line">    event Hello(string);</span><br><span class="line"></span><br><span class="line">    /* ============ Modifier ============ */</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Only owner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* ============ Errors ============ */</span><br><span class="line">    error MyError(string);</span><br><span class="line"></span><br><span class="line">    /* ============ Constructor ============ */</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* ============ Functions ============ */</span><br><span class="line"></span><br><span class="line">    /* ============ External Functions ============ */</span><br><span class="line">    function hello() external onlyOwner &#123;</span><br><span class="line">        emit Hello(&quot;Hello Comrades&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* ============ Helper ============ */</span><br><span class="line">    function getBalance() external view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><ul>
<li><p>合约和库名: 大驼峰式命名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Owned &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>合约和库名: 匹配它们的文件名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 文件名:Owned.sol</span><br><span class="line">contract Owned &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果文件中有多个合约&#x2F;库，使用核心合约&#x2F;库的名称。🤔️</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 文件名:Owned.sol</span><br><span class="line">contract Owned &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        //....</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferOwnership(address newOwner) public onlyOwner returns(true)&#123;</span><br><span class="line">        //...</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">import &quot;./Owned.sol&quot;;</span><br><span class="line"></span><br><span class="line">// Congress.sol</span><br><span class="line">contract Congress is Owned &#123;</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体名称: 大驼峰式命名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct BookInfo &#123;</span><br><span class="line">    string title;</span><br><span class="line">    string author;</span><br><span class="line">    uint256 book_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件名称: 大驼峰式命名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event AfterTransfer(address ads);</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数名: 小驼峰命名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function balanceOf(address account) external view returns (uint256)&#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>internal</code>函数名:<code>_</code>+小驼峰命名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function _grantRole(address _ads, bytes32 _role) internal &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>internal</code>变量:<code>_</code>+小驼峰</p>
</li>
<li><p>函数参数:小驼峰+<code>_</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor(string memory name_, string memory symbol_) &#123;</span><br><span class="line">    _name = name_;</span><br><span class="line">    _symbol = symbol_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>局部变量和状态变量:小驼峰命名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping(address =&gt; uint256) public balanceOf;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量:大写字母单词用下划线分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address public constant MIN_BLOCKS;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数修改器: 小驼峰命名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modifier onlyOwner()&#123;</span><br><span class="line">    require(msg.sender==owner,&quot;must owner address&quot;);</span><br><span class="line">    _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举的名字:大驼峰式命名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Status &#123;</span><br><span class="line">    None,</span><br><span class="line">    Pending,</span><br><span class="line">    Shiped,</span><br><span class="line">    Completed,</span><br><span class="line">    Rejected,</span><br><span class="line">    Canceled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/07/27/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/mapping%E5%8F%AF%E8%BF%AD%E4%BB%A3%E6%98%A0%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/27/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/mapping%E5%8F%AF%E8%BF%AD%E4%BB%A3%E6%98%A0%E5%B0%84/" class="post-title-link" itemprop="url">mapping可迭代映射</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-27 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-27T00:00:00+08:00">2022-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-09 10:01:35" itemprop="dateModified" datetime="2023-11-09T10:01:35+08:00">2023-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="学校和学生"><a href="#学校和学生" class="headerlink" title="学校和学生"></a>学校和学生</h1><p>我们想创建一个“学校”智能合约来收集学生地址。合约必须具有 3 个主要功能：</p>
<ol>
<li>从合同中添加或删除学生。</li>
<li>询问给定的学生地址是否属于学校。</li>
<li>获取所有学生的列表。</li>
</ol>
<p>我们的<code>School</code>智能合约将如下所示：</p>
<p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/1lY-XnsfdjPztGwztIEBIvQ.png" alt="img"> </p>
<h2 id="简单解决方案-1：使用mapping-address-bool"><a href="#简单解决方案-1：使用mapping-address-bool" class="headerlink" title="简单解决方案 1：使用mapping (address =&gt; bool)"></a>简单解决方案 1：使用<code>mapping (address =&gt; bool)</code></h2><p>我们使用映射来存储每个学生的存在。如果映射到给定地址的值为<code>true</code>，则表示该地址是我们的学生之一。虽然解决方案很简单，但它的局限性在于它不能支持获取所有学生。与大多数其他语言不同，在 Solidity 中，不支持映射迭代。</p>
<h2 id="简单解决方案-2：使用address-students"><a href="#简单解决方案-2：使用address-students" class="headerlink" title="简单解决方案 2：使用address[] students"></a>简单解决方案 2：使用<code>address[] students</code></h2><p>我们使用地址数组而不是映射。现在很明显，我们解决了第三个需求（能够返回所有学生的列表）。但是，查找和删除现有学生变得更加困难。我们必须循环遍历数组中的每个元素以查找地址、检查地址是否存在或删除学生。</p>
<h2 id="更好的解决方案：使用mapping-address-⇒-address"><a href="#更好的解决方案：使用mapping-address-⇒-address" class="headerlink" title="更好的解决方案：使用mapping(address ⇒ address)"></a>更好的解决方案：使用<code>mapping(address ⇒ address)</code></h2><p>激动人心的部分来了！这种数据结构的基础是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linked_list">链表</a>。我们将下一个学生的地址（即指向下一个学生的指针）存储为映射值而不是普通布尔值。听起来很困惑吧？这张图会帮助你理解。</p>
<img src="/noteimg/区块链/Solidity0.8/img/1ybjLvYv-CdGfOinFvFq4vA.png" alt="img" style="zoom:80%;" /> 

<p>顶部：链表数据结构。每个节点指向它的下一个节点，最后一个节点指向 GUARD。底部：使用键值映射的顶部图像的具体表示。</p>
<p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/1eXK0rf5Ec4VQ8a_eSyHtnA.png" alt="img"> </p>
<p>数据结构的初始化是通过将 GUARD 设置为指向 GUARD 来完成的，这意味着列表为空</p>
<p>现在让我们来看看每个功能的实现。</p>
<h3 id="检查学生是否在学校：isStudent"><a href="#检查学生是否在学校：isStudent" class="headerlink" title="检查学生是否在学校：isStudent"></a>检查学生是否在学校：<code>isStudent</code></h3><p><code>mapping</code>我们使用这样一个事实，即学校中特定学生的结构中的值始终指向下一个学生的地址。因此，我们可以通过检查给定地址映射到的值来轻松验证给定地址是否在学校内。如果它指向某个非零地址，则表示该学生地址在学校。</p>
<p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/1Leo2GwdsqhJBpnLxowweWw.png" alt="img"> </p>
<h3 id="向学校添加新学生：addStudent"><a href="#向学校添加新学生：addStudent" class="headerlink" title="向学校添加新学生：addStudent"></a>向学校添加新学生：<code>addStudent</code></h3><p>我们可以在（表示列表的 HEAD 指针）之后添加一个新地址，<code>GUARD</code>方法是将守卫的指针更改为这个新地址，并将这个新地址（New Student）的指针设置为先前的前面地址（Front Student）。</p>
<p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/1h3xft5gEAseZGZEFdkbDHA.png" alt="img"> </p>
<p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/1gd__pHCftvpWsmPbVCQ3Nw.png" alt="img"> </p>
<h3 id="从学校删除学生：removeStudent"><a href="#从学校删除学生：removeStudent" class="headerlink" title="从学校删除学生：removeStudent"></a>从学校删除学生：<code>removeStudent</code></h3><p>这个函数比上面的两个函数更棘手。我们知道地址是否在列表中，但我们无法轻易推导出任何给定学生的先前地址（除非我们使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Doubly_linked_list">双重链接列表</a>，但就存储成本而言，这要昂贵得多）。要删除一个地址，我们需要让它的前一个学生指向删除地址的下一个地址，并将删除地址的指针设置为零。</p>
<p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/1CAAcxCXqJ3zXdNfol-bBCg.png" alt="img"> </p>
<p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/15ziw2ePv1CTuqyp164ZYAQ.png" alt="img"> </p>
<p>请注意，要实现<code>removeStudent</code>，我们还必须引入<code>getPrevStudent</code>有助于在任何给定学生之前找到以前学生地址的功能。</p>
<p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/12oIfywFrb5VoQW1x2UD07w.png" alt="img"> </p>
<h3 id="获取所有学生的列表：getStudents"><a href="#获取所有学生的列表：getStudents" class="headerlink" title="获取所有学生的列表：getStudents"></a>获取所有学生的列表：<code>getStudents</code></h3><p>这很简单。我们从 GUARD 地址开始循环遍历映射，并将当前指针设置为下一个指针，直到它再次指向 GUARD，即迭代完成。</p>
<p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/1Z5KdTBzFq4NFwcq3cRs-Hg.png" alt="img"> </p>
<h3 id="removeStudent进一步优化"><a href="#removeStudent进一步优化" class="headerlink" title="removeStudent进一步优化"></a><code>removeStudent</code>进一步优化</h3><p>请注意，<code>removeStudent</code>我们实现的函数消耗的 gas 与学校的学生人数成正比，因为我们需要遍历整个列表一次才能找到要删除的地址的前一个地址。我们可以通过使用链下计算将先前的地址发送给函数来优化此函数。因此，智能合约只需要验证之前的地址确实指向我们要删除的地址。</p>
<p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/1hFzsKxzbmwYiDWqM7USzNA.png" alt="img"> </p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在本文中，我们探索了<em>Iterable Maps</em>的一种实现，这是一种数据结构，它不仅支持<strong>O(1) 的</strong>添加、删除和查找，类似于传统的<code>mapping</code>，而且还支持集合迭代。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="幺柒YQ"
      src="/images/avater.png">
  <p class="site-author-name" itemprop="name">幺柒YQ</p>
  <div class="site-description" itemprop="description">努力坚持就会有希望</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">232</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kpyaoqi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kpyaoqi" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:18312386077@163.com" title="E-Mail → mailto:18312386077@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat.jpg" title="WeChat → images&#x2F;wechat.jpg"><i class="fa fa-fw fa-wechat"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/qq.jpg" title="QQ → images&#x2F;qq.jpg"><i class="fa fa-fw fa-qq"></i>QQ</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://stackoverflow.com/" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;" rel="noopener" target="_blank">Stackoverflow</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2021-11 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">幺柒YQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">899k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:37</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共379.4k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  


</body>
</html>
