<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://kongpengyq.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="努力坚持就会有希望">
<meta property="og:type" content="website">
<meta property="og:title" content="YQ &amp; 博客">
<meta property="og:url" content="https://kongpengyq.com/page/10/index.html">
<meta property="og:site_name" content="YQ &amp; 博客">
<meta property="og:description" content="努力坚持就会有希望">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="幺柒YQ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://kongpengyq.com/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>YQ & 博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="YQ & 博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YQ & 博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2023/01/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV2/UniswapV2Factory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV2/UniswapV2Factory/" class="post-title-link" itemprop="url">UniswapV2Factory</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-14 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-14T00:00:00+08:00">2023-01-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UniswapV2/" itemprop="url" rel="index">
                    <span itemprop="name">UniswapV2</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UniswapV2Factory"><a href="#UniswapV2Factory" class="headerlink" title="UniswapV2Factory"></a>UniswapV2Factory</h1><p>在构造函数中传入一个设置feeTo的权限者地址，主要用于创建两种token的交易对，并为其部署一个UniswapV2Pair合约用于管理这个交易对，UniswapV2Factory还包含一些手续费的一些设置.</p>
<h2 id="合约当中具有的方法"><a href="#合约当中具有的方法" class="headerlink" title="合约当中具有的方法:"></a>合约当中具有的方法:</h2><ul>
<li>function feeTo() external view returns (address)：返回收取手续费地址</li>
<li>function feeToSetter() external view returns (address)：设置手续费收取地址的权限地址</li>
<li>function getPair(address tokenA, address tokenB) external view returns (address pair)：获取两个token的交易对地址</li>
<li>function allPairs(uint) external view returns (address pair)：返回指定位置的交易对地址</li>
<li>function allPairsLength() external view returns (uint)：返回所有交易对的长度</li>
<li>function createPair(address tokenA, address tokenB) external returns (address pair)：创建两个token的交易对地址</li>
<li>function setFeeTo(address) external：更改收取手续费地址</li>
<li>function setFeeToSetter(address) external：更改设置手续费收取地址的权限地址</li>
</ul>
<p>在 Uniswap 协议中，<code>feeTo</code> 是一个变量，用于指定手续费收取地址。当用户在 Uniswap 上进行交易时，一定比例的交易手续费会被收取，并根据协议的设定进行分配。这个手续费分配的过程包括将一部分手续费发送给流动性提供者，同时还有一部分手续费发送到 <code>feeTo</code> 地址。</p>
<h4 id="createPair-address-tokenA-address-tokenB-returns-address-pair"><a href="#createPair-address-tokenA-address-tokenB-returns-address-pair" class="headerlink" title="createPair:(address tokenA, address tokenB) returns (address pair)"></a>createPair:(address tokenA, address tokenB) returns (address pair)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">bytes memory bytecode = type(UniswapV2Pair).creationCode;</span><br><span class="line">assembly &#123;</span><br><span class="line">	//add(bytecode, 32)：opcode操作码的add方法,将bytecode偏移后32位字节处,因为前32位字节存的是bytecode长度</span><br><span class="line">	//mload(bytecode)：opcode操作码的方法,获得bytecode长度</span><br><span class="line">	pair := create2(0, add(bytecode, 32), mload(bytecode), salt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pair地址是通过<strong>内联汇编assembly做create2</strong>方法创建的，其中<strong>salt</strong>盐值是通过两个两个代币的地址计算</p>
<blockquote>
<p>内联汇编：在 Solidity 源程序中嵌入汇编代码，对 EVM 有更细粒度的控制</p>
</blockquote>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2023/01/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV2/UniswapV2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV2/UniswapV2/" class="post-title-link" itemprop="url">UniswapV2</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-09 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-09T00:00:00+08:00">2023-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-09 10:01:34" itemprop="dateModified" datetime="2023-11-09T10:01:34+08:00">2023-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UniswapV2/" itemprop="url" rel="index">
                    <span itemprop="name">UniswapV2</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>595</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UniswapV2"><a href="#UniswapV2" class="headerlink" title="UniswapV2"></a>UniswapV2</h1><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV2/img/image-20230524155033168.png" alt="image-20230524155033168"> </p>
<p>Uniswap V2是一种基于以太坊的去中心化交易协议，旨在提供快速、安全、无信任的代币交换服务。它是Uniswap协议的第二个版本，是对第一个版本的改进和升级。</p>
<p>Uniswap V2的核心特点包括以下几个方面：</p>
<ol>
<li>去中心化交易：Uniswap V2使用智能合约来执行交易，而不需要传统的中心化交易所。这意味着用户可以直接通过他们的以太坊钱包进行交易，无需信任或依赖第三方中介。</li>
<li>自动化做市商模型：Uniswap V2采用自动化做市商模型，其中流动性提供者可以将资金存入流动性池中，并通过提供资金来帮助形成交易对的市场价格。这种模型使得任何人都可以成为流动性提供者，并从交易手续费中获得奖励。</li>
<li>常量乘积函数：Uniswap V2使用常量乘积函数作为交易价格计算模型。根据这个函数，交易所需的两种代币的数量乘积在交易前后保持不变，从而决定了交易价格。这种机制可以在没有订单簿的情况下进行交易，并保持相对简单和高效。</li>
<li>ERC-20代币支持：Uniswap V2支持以太坊上的ERC-20代币进行交易。用户可以通过选择不同的代币对进行交易，并且任何人都可以创建新的代币对，只需提供相应的流动性即可。</li>
<li>流动性挖矿：Uniswap V2引入了流动性挖矿机制，通过奖励流动性提供者来吸引更多的资金注入流动性池。流动性提供者可以获得代币奖励作为对其提供流动性的补偿，如果市场价格剧烈波动，您存入的资金可能面临损失。</li>
</ol>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2023/01/07/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/6-AAVE%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/07/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/6-AAVE%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">6-AAVE区别</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-07 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-07T00:00:00+08:00">2023-01-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Compound/" itemprop="url" rel="index">
                    <span itemprop="name">Compound</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>534</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>AAVE和Compound都是去中心化金融（DeFi）领域的借贷协议，旨在提供用户借贷和存款的解决方案。尽管它们有相似之处，但也存在一些区别。</p>
<ol>
<li>借贷模型：AAVE采用了一种固定利率模型，即借款人和存款人可以获知在借贷过程中的具体利率。而Compound采用了一种浮动利率模型，利率根据市场供需和协议内部的算法进行调整。</li>
<li>抵押品：在Compound中，借款人必须提供抵押品来获得借款。抵押品的价值必须超过所借款项的价值，以确保借款的安全性。而AAVE引入了闪电贷款功能，允许借款人在没有抵押品的情况下进行借贷，但必须在同一交易中将借款和利息还回。</li>
<li>用户界面：AAVE提供了一种用户友好的界面，使用户可以直接与协议进行交互。它还支持更多的功能和创新，如闪电贷款和利息交易。Compound更加注重协议的底层机制，对于开发者和技术用户更为友好。</li>
<li>支持的资产：Compound和AAVE都支持多种加密货币作为存款和借贷的资产。然而，具体支持的资产可能在两个协议之间有所不同。</li>
</ol>
<p>综上所述，AAVE和Compound在借贷协议的设计和特点上有所不同。AAVE提供了固定利率和闪电贷款等创新功能，而Compound采用了浮动利率和抵押品的模型。用户可以根据自己的需求和偏好选择适合的协议。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2023/01/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/5-%E6%B2%BB%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/5-%E6%B2%BB%E7%90%86/" class="post-title-link" itemprop="url">5-治理</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-04 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-04T00:00:00+08:00">2023-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-09 10:01:35" itemprop="dateModified" datetime="2023-11-09T10:01:35+08:00">2023-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Compound/" itemprop="url" rel="index">
                    <span itemprop="name">Compound</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Compound 协议由 COMP Token 持有者管理和升级，使用三个不同的组件； COMP Token、治理模块（Governor  Alpha）和 Timelock。这些合约一起，允许社区通过 cToken 或 Comproller  的管理功能提出、投票和实时更改。提案可以包括调整利率模型，到增加对新资产的支持等改变。</p>
<p>任何授权超过 10 万 COMP Token 的地址都可以提出治理活动，这些活动都是可执行的代码。提案产生后，社区可以在 3 天的投票期内提交投票。如果投票获得多数、且至少 40 万票以上，就会在 Timlock 中排队，2 天后可以实施。</p>
<p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/img/SuUUgiG761828cb5bc421.png" alt="image.png"></p>
<h2 id="COMP"><a href="#COMP" class="headerlink" title="COMP"></a>COMP</h2><p>COMP 是一个 <a target="_blank" rel="noopener" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md">ERC-20</a> 代币，允许所有者将投票权委托给任何地址，包括自己的地址。所有者的代币余额会自动调整被委托人的投票权。</p>
<h2 id="委托-Delegate"><a href="#委托-Delegate" class="headerlink" title="委托(Delegate)"></a>委托(Delegate)</h2><p>将发送者的投票数委托给被委托人。用户每次可以委托给一个地址，被委托人的投票数相当于用户账号的 COMP 代币余额。投票将从当前区块开始进行委托，直到发送者再次委托或者转移其 COMP。</p>
<p><strong>COMP</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function delegate(address delegatee)</span><br></pre></td></tr></table></figure>

<ul>
<li>delegatee : 发送者希望委托投票的地址；</li>
<li>msg.sender : 试图委托投票的 COMP 代币持有者的地址；</li>
<li>返回值 : 无返回值，错误时恢复。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Comp comp = Comp(0x123...); // contract address</span><br><span class="line">2 comp.delegate(delegateeAddress);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.2.6</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const tx = await comp.methods.delegate(delegateeAddress).send(&#123; from: sender &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="签名委托-Delegate-By-Signature"><a href="#签名委托-Delegate-By-Signature" class="headerlink" title="签名委托(Delegate By Signature)"></a>签名委托(Delegate By Signature)</h2><p>Delegate 投票从签名者到被委托人。这种方法与 Delegate 的目的相同，但它可以离线签名参与Compound 治理投票授权。有关如何创建离线签名的更多细节，请查看 <a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-712">EIP-712</a>。</p>
<p><strong>COMP</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function delegateBySig(address delegateeAddress,uint256 nonce,uint256 expiry,uint256 v,uint256 r,uint256 s);</span><br></pre></td></tr></table></figure>

<ul>
<li>delegatee : 发送者希望委托投票的地址；</li>
<li>nonce : 合约状态要求与签名相匹配。这一点可以从合同的公共 nonce 映射中检索；</li>
<li>expiry : 签名过期时间。以 unix epoch (uint) 后的秒数表示的区块时间戳；</li>
<li>v : 签名恢复字节；</li>
<li>r :  ECDSA 签名对的一部分；</li>
<li>s : ECDSA 签名对的一部分；</li>
<li>返回值 : 无，错误时恢复。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Comp comp = Comp(0x123...); // contract address</span><br><span class="line">2 comp.delegateBySig(delegateeAddress, nonce, expiry, v, r, s);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.2.6</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const tx = await comp.methods.delegateBySig(delegateeAddress, nonce, expiry, v, r, s).send(&#123;&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="获取当前投票数"><a href="#获取当前投票数" class="headerlink" title="获取当前投票数"></a>获取当前投票数</h2><p>获取一个账户当前区块的票数余额。</p>
<p><strong>COMP</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function getCurrentVotes(address account) returns (uint96)</span><br></pre></td></tr></table></figure>

<ul>
<li>account : 检索票数的账户地址；</li>
<li>RETURN : 票数（整型）。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Comp comp = Comp(0x123...); // contract address</span><br><span class="line">2 uint votes = comp.getCurrentVotes(0xabc...);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.2.6</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const account = &#x27;0x123...&#x27;; // contract address</span><br><span class="line">2 const votes = await comp.methods.getCurrentVotes(account).call();</span><br></pre></td></tr></table></figure>

<h2 id="获取先前投票数"><a href="#获取先前投票数" class="headerlink" title="获取先前投票数"></a>获取先前投票数</h2><p>获取一个账户在特定区块上的投票数。传入的区块高度必须是最终确定的区块，否则函数将revert。</p>
<p><strong>COMP</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function getPriorVotes(address account, uint blockNumber) returns (uint96)</span><br></pre></td></tr></table></figure>

<ul>
<li>account : 检索先前的投票数的账户地址；</li>
<li>blockNumber : 取回之前的票数的区块高度；</li>
<li>返回值 : 先前投票数；</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Comp comp = Comp(0x123...); // contract address</span><br><span class="line">2 uint priorVotes = comp.getPriorVotes(account, blockNumber);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.2.6</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const priorVotes = await comp.methods.getPriorVotes(account, blockNumber).call();</span><br></pre></td></tr></table></figure>

<h2 id="Governor-Alpha"><a href="#Governor-Alpha" class="headerlink" title="Governor Alpha"></a>Governor Alpha</h2><p>Governor Alpha 是协议的治理模块；它允许超过 10 万 COMP 代币的地址提出修改建议。在提案开始时，手握投票权（通过调用 getpriorvotes 方法）的地址可以在 3 天的投票期内提交投票。如果提取被投了多数，且至少有 40 万票，则会在 Timelock  中排队，2 两天后实施。</p>
<p>Govern Alpha 合约包含一个守卫者地址，由 Compound 团队控制，可以取消提案，或在紧急情况下禁用治理模块。在最初的沙盒期后，守护者可以放弃权利，标志着 COMP 代币持有者开始完全控制。</p>
<h2 id="法定投票数-Quorum-Votes"><a href="#法定投票数-Quorum-Votes" class="headerlink" title="法定投票数(Quorum Votes)"></a>法定投票数(Quorum Votes)</h2><p>成功支持一项提案的最低票数要求。</p>
<p><strong>Governor Alpha</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function quorumVotes() public pure returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值 : 成功支持一项提案的最低票数。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 uint quorum = gov.quorumVotes();</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.2.6</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const quorum = await gov.methods.quorumVotes().call();</span><br></pre></td></tr></table></figure>

<h2 id="提案门槛-Proposal-Threshold"><a href="#提案门槛-Proposal-Threshold" class="headerlink" title="提案门槛(Proposal Threshold)"></a>提案门槛(Proposal Threshold)</h2><p>账户创建一个提案所需的最低票数；</p>
<p><strong>Governor Alpha</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function proposalThreshold() returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值ETURN : 账户创建一个提案所需的最低票数。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 uint threshold = gov.proposalThreshold();</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.2.6</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const threshold = await gov.methods.proposalThreshold().call();</span><br></pre></td></tr></table></figure>

<h2 id="提案最大操作量-Proposal-Max-Operations"><a href="#提案最大操作量-Proposal-Max-Operations" class="headerlink" title="提案最大操作量(Proposal Max Operations)"></a>提案最大操作量(Proposal Max Operations)</h2><p>提案中可以包含的最大操作数量。操作是指提案成功并执行时将进行的函数调用。</p>
<p><strong>Governor Alpha</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function proposalMaxOperations() returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值 : 提案中可以包含的最大操作数量。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 uint operations = gov.proposalMaxOperations();</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.2.6</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const operations = await gov.methods.proposalMaxOperations().call();</span><br></pre></td></tr></table></figure>

<h2 id="投票延迟-Voting-Delay"><a href="#投票延迟-Voting-Delay" class="headerlink" title="投票延迟(Voting Delay)"></a>投票延迟(Voting Delay)</h2><p>在对一个提案投票前需要等到的以太坊区块数。当创建一个提案时，该值会被添加到当前区块高度上。</p>
<p><strong>Governor Alpha</strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>function <span class="built_in">votingDelay</span>() returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值：在对一个提案投票前需要等到的以太坊区块数。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 uint blocks = gov.votingDelay();</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.2.6</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const blocks = await gov.methods.votingDelay().call();</span><br></pre></td></tr></table></figure>

<h2 id="投票期-Voting-Period"><a href="#投票期-Voting-Period" class="headerlink" title="投票期(Voting Period)"></a>投票期(Voting Period)</h2><p>以以太坊区块为单位，对提案进行投票的持续时间。</p>
<p><strong>Governor Alpha</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function votingPeriod() returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>RETURN : 对提案进行投票的持续时间。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 uint blocks = gov.votingPeriod();</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.2.6</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const blocks = await gov.methods.votingPeriod().call();</span><br></pre></td></tr></table></figure>

<h2 id="提案-Propose"><a href="#提案-Propose" class="headerlink" title="提案(Propose)"></a>提案(Propose)</h2><p>创建一个提案来改变协议。比如：一个提案能在 Comproller 上设置 cToken 的利率模型或者风险参数。</p>
<p>提案将委托投票人进行投票表决。如果在投票期结束前有足够的支持，提案将被自动颁布。已颁布的提案将在 Compound Timelock 合约中排队并执行。</p>
<p>发送者在紧邻的前一个区块中持有的 COMP 代币必须超过当前的提案阈值（proposalThreshold）。如果阈值是 10 万  COMP 代币，则发送者必须被委托超过所有 COMP 的 1% 才能创建一个提案。提案最多有 10 个操作（基于  proposalMaxOperations() ）。</p>
<p>如果提案者当前有待处理或活动中的提案，则他们不能创建另一个提案。不可能在同一个区块中排队两个相同的操作（由于 Timelock 中的限制）。因此一个提案中的操作必须是唯一的，共享一个相同操作的唯一提案必须在不同的区块中排队。</p>
<p><strong>Governor Alpha</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>targets : 在提案执行过程中，将被调用的目标地址的有序列表。这个数组的长度必须和这个方法中所有其他数组参数的长度相同；</li>
<li>values : 在提案执行过程中要传递给调用的值（即msg.value）的有序列表。这个数组的长度必须和这个方法中所有其他数组参数的长度相同；</li>
<li>signatures : 提案执行过程中要传递的方法签名的有序列表。这个数组的长度必须和这个方法中所有其他数组参数的长度相同；</li>
<li>calldatas : 在提案执行过程中要传递给每个方法调用的数据的有序列表。这个数组必须和这个方法中所有其他数组参数的长度相同；</li>
<li>description : 对该提案的可读性说明及其将作出的修改；</li>
<li>返回值 : 新创建的提案 ID。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 uint proposalId = gov.propose(targets, values, signatures, calldatas, description);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.2.6</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1const tx = gov.methods.propose(targets, values, signatures, calldatas, description).send(&#123; from: sender &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h2><p>提案通过后，任何地址可以调用 queue 方法将提案转移到  Timelock 队列中。提案只有在成功通过后，才能被排队。</p>
<p><strong>Governor Alpha</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function queue(uint proposalId)</span><br></pre></td></tr></table></figure>

<ul>
<li>proposalId : 已通过的提案 ID；</li>
<li>返回值 : 无，错误时将 revert。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 gov.queue(proposalId);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.2.6</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const tx = gov.methods.queue(proposalId).send(&#123; from: sender &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="执行-Execute"><a href="#执行-Execute" class="headerlink" title="执行(Execute)"></a>执行(Execute)</h2><p>在 Timelock 延迟期之后，任何账户都可以调用 execu 方法将提案中的更改应用到目标合约中。这将调用提案中描述的每一个操作。</p>
<p>这个功能是可支付(payable)的，所以 Timelock 合约可以调用提案中选择的可支付功能。例如，A 提案可以 像cETH 一样在市场上添加准备金，设置 cToken 的利率模型，或者在 Comptroller上设置风险参数。</p>
<p><strong>Governor Alpha</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1function execute(uint proposalId) payable returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>proposalId : 要执行的成功提案 ID；</li>
<li>返回值 : 无，错误时将 revert。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 gov.execute(proposalId).value(999).gas(999)();</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.2.6</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const tx = gov.methods.execute(proposalId).send(&#123; from: sender, value: 1 &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="取消-Cancel"><a href="#取消-Cancel" class="headerlink" title="取消(Cancel)"></a>取消(Cancel)</h2><p>取消尚未执行的提案。除非提案人没有维持创建提案所需的委托量，否则监护人是唯一可以执行取消的人。如果提案人的委托人数没有超过提案的阈值，任何人都可以取消该提案。</p>
<p><strong>Governor Alpha</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function cancel(uint proposalId)</span><br></pre></td></tr></table></figure>

<ul>
<li>proposalId : 要取消的提案 ID。提案不能重复取消。</li>
<li>RETURN : 无，错误时 revert。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 gov.cancel(proposalId);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.2.6</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const tx = gov.methods.cancel(proposalId).send(&#123; from: sender &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="获取操作-Get-Actions"><a href="#获取操作-Get-Actions" class="headerlink" title="获取操作(Get Actions)"></a>获取操作(Get Actions)</h2><p>获取所选提案的操作列表。传递一个提案 ID，获取该提案的目标对象、值、签名和调用数据。</p>
<p><strong>Governor Alpha</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function getActions(uint proposalId) returns (uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas)</span><br></pre></td></tr></table></figure>

<ul>
<li>proposalId : 拟获取操作的提案 ID。</li>
<li>RETURN : 如果提案 ID 非法，则 revert 。否则成功时返回以下 4 个 参考信息：<ol>
<li>提案调用的合约地址数组；</li>
<li>提案中使用的值 - 无符号整数数组；</li>
<li>提案签名的字符串数组；</li>
<li>提案的 calldata 字节数组。</li>
</ol>
</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 uint proposalId = 123;</span><br><span class="line">3 (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) = gov.getActions(proposalId);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.2.6</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const &#123;0: targets, 1: values, 2: signatures, 3: calldatas&#125; = gov.methods.getActions(proposalId).call();</span><br></pre></td></tr></table></figure>

<h2 id="获取回执-Get-Receipt"><a href="#获取回执-Get-Receipt" class="headerlink" title="获取回执(Get Receipt)"></a>获取回执(Get Receipt)</h2><p>获得指定投票者的提案选票。</p>
<p><strong>Governor Alpha</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function getReceipt(uint proposalId, address voter) returns (Receipt memory)</span><br></pre></td></tr></table></figure>

<ul>
<li>proposalId : 提案ID，以获取投票者的选票收据；</li>
<li>voter : 提案投票者的账户地址；</li>
<li>RETURN : 错误时 revert。成功时返回投票者地址的选票收据结构数据。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 Receipt ballot = gov.getReceipt(proposalId, voterAddress);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.2.6</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">const</span> proposalId = <span class="number">11</span>;</span><br><span class="line"><span class="number">2</span> <span class="keyword">const</span> voterAddress = <span class="string">&#x27;0x123...&#x27;</span>;</span><br><span class="line"><span class="number">3</span> <span class="keyword">const</span> result = <span class="keyword">await</span> gov.methods.getReceipt(proposalId, voterAddress).call();</span><br><span class="line"><span class="number">4</span> <span class="keyword">const</span> &#123; hasVoted, support, votes &#125; = result;</span><br></pre></td></tr></table></figure>

<h2 id="获取提案状态-State"><a href="#获取提案状态-State" class="headerlink" title="获取提案状态(State)"></a>获取提案状态(State)</h2><p>获取指定提案的提案状态。返回值 ProposalState 是一个 Governor Alpha 合约中定义的枚举类型。</p>
<p><strong>Governor Alpha</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function state(uint proposalId) returns (ProposalState)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>proposalId : 提案ID，以获得其状态；</p>
</li>
<li><p>返回值 : 枚举类型 ProposalState。类型有：Pending(等待中)、Active(活动中)、</p>
<p>Canceled(已取消)、Defeated(已败北)、 Succeeded（已成功）、Queued（已排队）、Expired（已过期）和Executed（已执行）。</p>
</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 overnorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 GovernorAlpha.ProposalState state = gov.state(123);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.2.6</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 const proposalStates = [&#x27;Pending&#x27;, &#x27;Active&#x27;, &#x27;Canceled&#x27;, &#x27;Defeated&#x27;, &#x27;Succeeded&#x27;, &#x27;Queued&#x27;, &#x27;Expired&#x27;, &#x27;Executed&#x27;];</span><br><span class="line">2 const proposalId = 123;</span><br><span class="line">3 result = await gov.methods.state(proposalId).call();</span><br><span class="line">4 const proposalState = proposalStates[result];</span><br></pre></td></tr></table></figure>

<h2 id="投票-Cast-Vote"><a href="#投票-Cast-Vote" class="headerlink" title="投票(Cast Vote)"></a>投票(Cast Vote)</h2><p>对某项提案进行投票。该账户的表决权重取决于该账户在提案开始生效时的表决权重。</p>
<p><strong>Governor Alpha</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function castVote(uint proposalId, bool support)</span><br></pre></td></tr></table></figure>

<ul>
<li>proposalId : 提案ID，以进行投票；</li>
<li>support : 布尔值，赞同提案为 true ，反对为 false；</li>
<li>RETURN : 无返回值，错误时 revert。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 gov.castVote(proposalId, true);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.2.6</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const tx = gov.methods.castVote(proposalId, false).send(&#123; from: sender &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="通过签名投票-Cast-Vote-By-Signature"><a href="#通过签名投票-Cast-Vote-By-Signature" class="headerlink" title="通过签名投票(Cast Vote By Signature)"></a>通过签名投票(Cast Vote By Signature)</h2><p>对某项提案进行投票。该账户的投票权重由该账户在该提案状态生效时的投票权重决定。此方法的目的与 “cast vote “相同，但它可以让脱机签名参与 Compound 治理投票。有关如何创建离线签名的详细信息，请查看 EIP-712。</p>
<p><strong>Governor Alpha</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s)</span><br></pre></td></tr></table></figure>

<ul>
<li>proposalId : 提案ID，以进行投票；</li>
<li>support : 布尔值，赞同提案为 true ，反对为 false；</li>
<li>v : 签名恢复字节；</li>
<li>r :  ECDSA 签名对的一部分；</li>
<li>s : ECDSA 签名对的一部分；</li>
<li>返回值 : 无，错误时恢复。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 gov.castVoteBySig(proposalId, true, v, r, s);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.2.6</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const tx = await gov.methods.castVoteBySig(proposalId, false, v, r, s).send(&#123;&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="时间锁-Timelock"><a href="#时间锁-Timelock" class="headerlink" title="时间锁(Timelock)"></a>时间锁(Timelock)</h2><p>每个 cToken 合约和 Comptroller 合约都允许 Timelock 地址修改。Timelock 合约可以修改系统参数、逻辑和合约，以 “延迟时间、选择退出 “ 的升级模式进行修改。</p>
<p>Timelock 有一个 2 天的最小延迟时间硬性规定，这是治理行动的最小通知时间。每项拟采取的治理行动，都会在公告后至少 2 天内公布。重大升级，如变更风险系统等，可能会有 14 天的延迟时间。</p>
<p>时间锁由治理模块控制；待定和已完成的治理行动可以在<a target="_blank" rel="noopener" href="https://app.compound.finance/timelock">时间锁仪表板</a>上监控。</p>
<h2 id="暂停守护者-Pause-Guardian"><a href="#暂停守护者-Pause-Guardian" class="headerlink" title="暂停守护者(Pause Guardian)"></a>暂停守护者(Pause Guardian)</h2><p>Comptroller  合约指定了一个能够禁用协议功能的暂停守护者地址。暂停守护者只有在出现不可预见的漏洞时才会使用，暂停守护者只有一种能力：禁用一组选定的功能。Mint、Borrow、Borrow、Transfer  和 Liquidate。暂停守护者不能解除一个动作，也不能阻止用户调用赎回、偿还借款以平仓和退出协议。</p>
<p>目前，Compound 团队控制了暂停守护者的地址。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2023/01/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/4-%E5%8D%8F%E8%AE%AE%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/4-%E5%8D%8F%E8%AE%AE%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">4-协议风险管理</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-02 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-02T00:00:00+08:00">2023-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Compound/" itemprop="url" rel="index">
                    <span itemprop="name">Compound</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Comptroller 是 Compound 协议的风险管理层；它决定了用户需要维持多少抵押品，以及是否可以（和多少）清算用户。每次用户与 cToken 交互时，Comptroller 都会被要求批准或拒绝交易。</p>
<p>Comptroller 将用户余额映射到价格（通过价格预言机），再映射到风险权重（称为<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3169">抵押系数</a> ）来进行判断。用户通过调用“<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3169">进入市场</a>”和“<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3169">退出市场</a>”，明确列出他们希望在风险评分中包括哪些资产。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Comptroller 作为一个可升级的代理实现。Unitroller 将所有逻辑都代理给 Comptroller 实现，但存储值是在  Unitroller 上设置的。要调用 Comptroller 方法，请使用 Unitroller 地址上的 Comptroller ABI。</p>
<h2 id="进入市场"><a href="#进入市场" class="headerlink" title="进入市场"></a>进入市场</h2><p>进入一个市场的清单 – 重复进入同一个市场，不是错误。要想在一个市场中提供抵押品或借贷，必须先进入市场。</p>
<p><strong>Comptroller</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function enterMarkets(address[] calldata cTokens) returns (uint[] memory)</span><br></pre></td></tr></table></figure>

<ul>
<li>msg.sender : 应进入特定市场的账户。</li>
<li>cTokens : 要进入的 cToken 市场地址。</li>
<li>返回值: 对于每个市场，返回一个错误代码，表示是否已进入市场。成功时为 0，否则返回<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3169">错误代码</a>。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 Comptroller troll = Comptroller(0xABCD...);</span><br><span class="line">2 CToken[] memory cTokens = new CToken[](2);</span><br><span class="line">3 cTokens[0] = CErc20(0x3FDA...);</span><br><span class="line">4 cTokens[1] = CEther(0x3FDB...);</span><br><span class="line">5 uint[] memory errors = troll.enterMarkets(cTokens);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 const troll = Comptroller.at(0xABCD...);</span><br><span class="line">2 const cTokens = [CErc20.at(0x3FDA...), CEther.at(0x3FDB...)];</span><br><span class="line">3 const errors = await troll.methods.enterMarkets(cTokens).send(&#123;from: ...&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="退出市场"><a href="#退出市场" class="headerlink" title="退出市场"></a>退出市场</h2><p>退出一个市场 – 退出当前没有进入的市场，这不是错误。退出市场将不计入账户流动性计算。</p>
<p><strong>Comptroller</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function exitMarket(address cToken) returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>msg.sender : 应退出特定市场的账户。</li>
<li>cTokens : 要退出的市场 cToken 地址。</li>
<li>RETURN : 成功时为 0，否则返回<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3169">错误代码</a>。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1Comptroller troll = Comptroller(0xABCD...);</span><br><span class="line">2uint error = troll.exitMarket(CToken(0x3FDA...));</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const troll = Comptroller.at(0xABCD...);</span><br><span class="line">2 const errors = await troll.methods.exitMarket(CEther.at(0x3FDB...)).send(&#123;from: ...&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Get-Assets-In"><a href="#Get-Assets-In" class="headerlink" title="Get Assets In"></a>Get Assets In</h2><p>获取一个账户目前进入的市场列表。要在市场上提供抵押品或借款，必须先进入市场。已进入的市场计入账户流动性计算中。</p>
<p><strong>Comptroller</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function getAssetsIn(address account) view returns (address[] memory)</span><br></pre></td></tr></table></figure>

<ul>
<li>account : 应查询其进入市场清单的账户；</li>
<li>RETURN : 目前进入的每个市场的地址。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Comptroller troll = Comptroller(0xABCD...);</span><br><span class="line">2 address[] memory markets = troll.getAssetsIn(0xMyAccount);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const troll = Comptroller.at(0xABCD...);</span><br><span class="line">2 const markets = await troll.methods.getAssetsIn(cTokens).call();</span><br></pre></td></tr></table></figure>

<h2 id="抵押系数"><a href="#抵押系数" class="headerlink" title="抵押系数"></a>抵押系数</h2><p>一个 cToken 的抵押系数(Collateral factors)可以在 0-90% 之间，代表账户通过铸造 cToken 获得的流动性（借款限额）的比例增加。</p>
<p>一般来说，大额资产或流动性较强的资产抵押系数较高，而小额资产或流动性较差的资产抵押系数较低。如果一项资产的抵押系数为 0%，则不能作为抵押品（或在清算时被扣押），但仍可借入。</p>
<p>随着市场情况的变化，可以通过 Compound 治理，提高（或降低）抵押品系数。</p>
<p><strong>Comptroller</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function markets(address cTokenAddress) view returns (bool, uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>cTokenAddress : 检查特定的 cToken 是否上市，并获得其抵押系数。</li>
<li>RETURN : 值元祖（isListed, collateralFactorMantissa）；isListed  代表审计是否承认这个cToken；collateralFactorMantissa 代表（抵押系数），按 1e18  比例乘以一个供给余额来确定可以借入多少资产。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Comptroller troll = Comptroller(0xABCD...);</span><br><span class="line">2 (bool isListed, uint collateralFactorMantissa) = troll.markets(0x3FDA...);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 const troll = Comptroller.at(0xABCD...);</span><br><span class="line">2 const result = await troll.methods.markets(0x3FDA...).call();</span><br><span class="line">3 const &#123;0: isListed, 1: collateralFactorMantissa&#125; = result;</span><br></pre></td></tr></table></figure>

<h2 id="获取账户流动性"><a href="#获取账户流动性" class="headerlink" title="获取账户流动性"></a>获取账户流动性</h2><p>在 Compound 协议中，账户流动性被定义为账户抵押品的预估以太值（供应余额乘以协议<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3169">抵押系数</a>，减去账户借款余额的总价值）。这些价值仅使用账户<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3169">已进入</a>的市场计算。</p>
<p>没有正账户流动性的用户在没有提供更多的资产或者偿还未偿还的借款，使其账户流动性恢复到正值之前，没有能力提取或借入任何资产。</p>
<p><strong>Comptroller</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function getAccountLiquidity(address account) view returns (uint, uint, uint)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>account : 应计算其流动性的账户；</p>
</li>
<li><p>RETURN : 数组值（error、liquidity、shortfall）。成功时错误为0，否则为<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3169">错误代码</a>。非零</p>
<p>liquidity 表示该账户有可用的账户流动性。非零 shortfall 表示该账户目前低于其抵押品要求，需要清算。 liquidity 和 shortfall 最多只有一个不为零。</p>
</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 Comptroller troll = Comptroller(0xABCD...);</span><br><span class="line">2 (uint error, uint liquidity, uint shortfall) = troll.getAccountLiquidity(msg.caller); </span><br><span class="line">3 require(error == 0, &quot;join the Discord&quot;); </span><br><span class="line">4 require(shortfall == 0, &quot;account underwater&quot;); </span><br><span class="line">5 require(liquidity &gt; 0, &quot;account has excess collateral&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 const troll = Comptroller.at(0xABCD...);</span><br><span class="line">2 const result = await troll.methods.getAccountLiquidity(0xBorrower).call();</span><br><span class="line">3 const &#123;0: error, 1: liquidity, 2: shortfall&#125; = result;</span><br></pre></td></tr></table></figure>

<h2 id="关闭系数"><a href="#关闭系数" class="headerlink" title="关闭系数"></a>关闭系数</h2><p>可清偿借款的账户中，可在一次清算交易中偿还的借款的百分比，范围从 0% 到 100%。如果一个用户有多个借款资产，则 closeFactor 适用于任何单一的借款资产，而不是用户未清偿借款的总价值。</p>
<p><strong>Comptroller</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function closeFactorMantissa() view returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值 : 关闭系数，按 1e18 比例计算，乘以未偿还的借款余额，确定可以结清多少借款。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Comptroller troll = Comptroller(0xABCD...);</span><br><span class="line">2 uint closeFactor = troll.closeFactorMantissa();</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const troll = Comptroller.at(0xABCD...);</span><br><span class="line">2 const closeFactor = await troll.methods.closeFactoreMantissa().call();</span><br></pre></td></tr></table></figure>

<h2 id="清算奖励"><a href="#清算奖励" class="headerlink" title="清算奖励"></a>清算奖励</h2><p>给予清算人的额外抵押品，作为清算水下账户的奖励。例如，如果清算奖励是 1.1 ，那么清算人每关闭一个单位，就能额外获得借款人抵押品的 10%。</p>
<p><strong>Comptroller</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function liquidationIncentiveMantissa() view returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值 : 清算奖励，按 1e18 比例计算，再乘以清算人的平仓借款金额，以确定可以扣押多少抵押品。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Comptroller troll = Comptroller(0xABCD...);</span><br><span class="line">2 uint closeFactor = troll.liquidationIncentiveMantissa();</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const troll = Comptroller.at(0xABCD...);</span><br><span class="line">2 const closeFactor = await troll.methods.liquidationIncentiveMantissa().call();</span><br></pre></td></tr></table></figure>

<h2 id="主要事件"><a href="#主要事件" class="headerlink" title="主要事件"></a>主要事件</h2><table>
<thead>
<tr>
<th>Event</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>MarketEntered(CToken cToken, address account)</td>
<td>成功<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3169">进入市场</a>时发生</td>
</tr>
<tr>
<td>MarketExited(CToken cToken, address account)</td>
<td>成功<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3169">退出市场</a>时发生</td>
</tr>
</tbody></table>
<h2 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h2><table>
<thead>
<tr>
<th>Code</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>NO_ERROR</td>
<td>不算错误</td>
</tr>
<tr>
<td>1</td>
<td>UNAUTHORIZED</td>
<td>The sender is not authorized to perform this action.</td>
</tr>
<tr>
<td>2</td>
<td>COMPTROLLER_MISMATCH</td>
<td>Liquidation cannot be performed in markets with different comptrollers.</td>
</tr>
<tr>
<td>3</td>
<td>INSUFFICIENT_SHORTFALL</td>
<td>The account does not have sufficient shortfall to perform this action.</td>
</tr>
<tr>
<td>4</td>
<td>INSUFFICIENT_LIQUIDITY</td>
<td>The account does not have sufficient liquidity to perform this action.</td>
</tr>
<tr>
<td>5</td>
<td>INVALID_CLOSE_FACTOR</td>
<td>The close factor is not valid.</td>
</tr>
<tr>
<td>6</td>
<td>INVALID_COLLATERAL_FACTOR</td>
<td>The collateral factor is not valid.</td>
</tr>
<tr>
<td>7</td>
<td>INVALID_LIQUIDATION_INCENTIVE</td>
<td>The liquidation incentive is invalid.</td>
</tr>
<tr>
<td>8</td>
<td>MARKET_NOT_ENTERED</td>
<td>The market has not been entered by the account.</td>
</tr>
<tr>
<td>9</td>
<td>MARKET_NOT_LISTED</td>
<td>The market is not currently listed by the comptroller.</td>
</tr>
<tr>
<td>10</td>
<td>MARKET_ALREADY_LISTED</td>
<td>An admin tried to list the same market more than once.</td>
</tr>
<tr>
<td>11</td>
<td>MATH_ERROR</td>
<td>A math calculation error occurred.</td>
</tr>
<tr>
<td>12</td>
<td>NONZERO_BORROW_BALANCE</td>
<td>The action cannot be performed since the account carries a borrow balance.</td>
</tr>
<tr>
<td>13</td>
<td>PRICE_ERROR</td>
<td>The comptroller could not obtain a required price of an asset.</td>
</tr>
<tr>
<td>14</td>
<td>REJECTION</td>
<td>The comptroller rejects the action requested by the market.</td>
</tr>
<tr>
<td>15</td>
<td>SNAPSHOT_ERROR</td>
<td>The comptroller could not get the account borrows and exchange rate from the market.</td>
</tr>
<tr>
<td>16</td>
<td>TOO_MANY_ASSETS</td>
<td>Attempted to enter more markets than are currently supported.</td>
</tr>
<tr>
<td>17</td>
<td>TOO_MUCH_REPAY</td>
<td>Attempted to repay more than is allowed by the protocol.</td>
</tr>
</tbody></table>
<h2 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><table>
<thead>
<tr>
<th>Code</th>
<th>Name</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>ACCEPT_ADMIN_PENDING_ADMIN_CHECK</td>
</tr>
<tr>
<td>1</td>
<td>ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK</td>
</tr>
<tr>
<td>2</td>
<td>EXIT_MARKET_BALANCE_OWED</td>
</tr>
<tr>
<td>3</td>
<td>EXIT_MARKET_REJECTION</td>
</tr>
<tr>
<td>4</td>
<td>SET_CLOSE_FACTOR_OWNER_CHECK</td>
</tr>
<tr>
<td>5</td>
<td>SET_CLOSE_FACTOR_VALIDATION</td>
</tr>
<tr>
<td>6</td>
<td>SET_COLLATERAL_FACTOR_OWNER_CHECK</td>
</tr>
<tr>
<td>7</td>
<td>SET_COLLATERAL_FACTOR_NO_EXISTS</td>
</tr>
<tr>
<td>8</td>
<td>SET_COLLATERAL_FACTOR_VALIDATION</td>
</tr>
<tr>
<td>9</td>
<td>SET_COLLATERAL_FACTOR_WITHOUT_PRICE</td>
</tr>
<tr>
<td>10</td>
<td>SET_IMPLEMENTATION_OWNER_CHECK</td>
</tr>
<tr>
<td>11</td>
<td>SET_LIQUIDATION_INCENTIVE_OWNER_CHECK</td>
</tr>
<tr>
<td>12</td>
<td>SET_LIQUIDATION_INCENTIVE_VALIDATION</td>
</tr>
<tr>
<td>13</td>
<td>SET_MAX_ASSETS_OWNER_CHECK</td>
</tr>
<tr>
<td>14</td>
<td>SET_PENDING_ADMIN_OWNER_CHECK</td>
</tr>
<tr>
<td>15</td>
<td>SET_PENDING_IMPLEMENTATION_OWNER_CHECK</td>
</tr>
<tr>
<td>16</td>
<td>SET_PRICE_ORACLE_OWNER_CHECK</td>
</tr>
<tr>
<td>17</td>
<td>SUPPORT_MARKET_EXISTS</td>
</tr>
<tr>
<td>18</td>
<td>SUPPORT_MARKET_OWNER_CHECK</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/12/31/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/3-%E4%B8%8EcToken%E5%90%88%E7%BA%A6%E4%BA%A4%E4%BA%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/31/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/3-%E4%B8%8EcToken%E5%90%88%E7%BA%A6%E4%BA%A4%E4%BA%92/" class="post-title-link" itemprop="url">3-与cToken合约交互</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-31 00:00:00" itemprop="dateCreated datePublished" datetime="2022-12-31T00:00:00+08:00">2022-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Compound/" itemprop="url" rel="index">
                    <span itemprop="name">Compound</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Compound 协议所支持的每项资产都通过 <strong>cToken 合约</strong>进行整合，cToken 合约是提供给协议的余额的 <a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-20">EIP-20</a> 合格表示。通过铸造 cToken，用户（1）通过 cToken 的汇率赚取利息，该汇率相对于标的资产的价值增加，以及（2）获得试用 <strong>cToken 作为抵押品的能力</strong>。</p>
<p>cToken 是与 Compound 协议交互的主要手段；当用户在使用 cToken 合约时，会**使用 cToken  合约来进行铸币(mint)、赎回(redeem)、借款(borrow)、偿还借款(repay)、清算借款(liquidate)或者划转  cToken (transfer)**。</p>
<p>目前有两种类型的 cToken ： CErc20 和 CEther。尽管两者都暴露了 EIP-20 接口，但 CErc20 封装了  ERC-20 标的资产，而 CEther 只是封装了 Ether  本身。因此，根据类型的不同，涉及将资产传输到协议中的核心功能的接口也略有不同，每种类型的接口如下所示。</p>
<h2 id="铸币-Mint"><a href="#铸币-Mint" class="headerlink" title="铸币(Mint)"></a>铸币(Mint)</h2><p>mint 方法将一个资产转移到协议中，协议开始根据该资产的当前<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">供应率</a>开始累积利息。用户收到的 cToken 数量等于标的代币数量除以当前<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">汇率</a>。</p>
<p><strong>CErc20</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function mint(uint mintAmount) returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>msg.sender : 供应资产并拥有已铸 cToken 的账户。</li>
<li>mintAmount : 供应的资产金额，单位为标的资产的单位。</li>
<li>RETURN : 成功时为0，否则是<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">错误代码</a>。</li>
</ul>
<p>供应资产前，用户必须先 <a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-20#approve">批准(approve)</a>， cToken 才能访问其代币余额。</p>
<p><strong>CEther</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">function</span> <span class="title function_">mint</span>(<span class="params"></span>) payable</span><br></pre></td></tr></table></figure>

<ul>
<li>msg.value :  供应的 ETH 数量，单位 wei。</li>
<li>msg.sender : 供应 ETH 并拥有已铸 cToken 的账户。</li>
<li>RETURN : 无返回值，错误时还原。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 Erc20 underlying = Erc20(0xToken...);     // 获取标的资产合约句柄 </span><br><span class="line">2 CErc20 cToken = CErc20(0x3FDA...);        // 获取相应 cToken 合约的句柄 </span><br><span class="line">3 underlying.approve(address(cToken), 100); // 批准划转 </span><br><span class="line">4 assert(cToken.mint(100) == 0);            // 铸 cToken 币，并断言是否有错误</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...); </span><br><span class="line">2 await cToken.methods.mint().send(&#123;from: myAccount, value: 50&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="赎回-Redeem"><a href="#赎回-Redeem" class="headerlink" title="赎回(Redeem)"></a>赎回(Redeem)</h2><p>redeem 方法将指定数量的 cToken 转换为标的资产，并将其返还给用户。收到的标的数量等于赎回的 cToken 数量乘以当前<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">汇率</a>。赎回额必须小于用户的<a target="_blank" rel="noopener" href="https://compound.finance/docs/comptroller#account-liquidity">账户流动性</a>和市场可用的流动性。</p>
<p><strong>CErc20 &#x2F; CEther</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function redeem(uint redeemTokens) returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>msg.sender : 应将赎回的标的资产转入的账户。</li>
<li>redeemTokens : 将被赎回的 cToken 数量。</li>
<li>RETURN : 成功时为0，否则是<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">错误代码</a>。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CEther cToken = CEther(0x3FDB...);</span><br><span class="line">2 require(cToken.redeem(7) == 0, &quot;something went wrong&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="赎回标的-Redeem-Underlying"><a href="#赎回标的-Redeem-Underlying" class="headerlink" title="赎回标的(Redeem Underlying)"></a>赎回标的(Redeem Underlying)</h2><p>redeem underlying 方法将 cToken兑换成指定数量的标的资产，并返回给用户。赎回的 cToken的数量等于收到的标的数量除以当前<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">汇率</a>。赎回额必须小于用户的<a target="_blank" rel="noopener" href="https://compound.finance/docs/comptroller#account-liquidity">账户流动性</a>和市场可用的流动性。</p>
<p><strong>CErc20 &#x2F; CEther</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function redeemUnderlying(uint redeemAmount) returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>msg.sender : 应将赎回的标的资产转入的账户。</li>
<li>redeemAmount : 将被赎回的标的资产数量。</li>
<li>RETURN : 成功时为0，否则是<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">错误代码</a>。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CEther cToken = CEther(0x3FDB...);</span><br><span class="line">2 require(cToken.redeemUnderlying(50) == 0, &quot;something went wrong&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CErc20.at(0x3FDA...);</span><br><span class="line">2 cToken.methods.redeemUnderlying(10).send(&#123;from: ...&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="借款-Borrow"><a href="#借款-Borrow" class="headerlink" title="借款(Borrow)"></a>借款(Borrow)</h2><p>borrow 方法<strong>将协议中的资产转移给用户</strong>，并创建一个借款余额，根据该资产的<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">借款利率</a>开始累积利息。借款额必须小于用户的<a target="_blank" rel="noopener" href="https://compound.finance/docs/comptroller#account-liquidity">账户流动性</a>和市场可用的流动性。</p>
<p>要想借入以太，借款人必须是 ‘payable’ （Solidity）。</p>
<p><strong>CErc20 &#x2F; CEther</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function borrow(uint borrowAmount) returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>msg.sender : 应将借款资金转入的账户。</li>
<li>borrowAmount :  标的资产借款数量。</li>
<li>ETURN : 成功时为0，否则是<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">错误代码</a>。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CErc20(0x3FDA...);</span><br><span class="line">2 require(cToken.borrow(100) == 0, &quot;got collateral?&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...);</span><br><span class="line">2 await cToken.methods.borrow(50).send(&#123;from: 0xMyAccount&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="偿还借款-Repay-Borrow"><a href="#偿还借款-Repay-Borrow" class="headerlink" title="偿还借款(Repay Borrow)"></a>偿还借款(Repay Borrow)</h2><p>repay 方法将资产转移到协议中，并减少用户的借款余额。</p>
<p><strong>CErc20</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function repayBorrow(uint repayAmount) returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>msg.sender : 借入资产的账户，应偿还借款。</li>
<li>repayAmount : 拟偿还的标的资产借款金额。值为-1（即2256-1）表示偿还全部借款额。</li>
<li>RETURN : 成功时为0，否则是<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">错误代码</a>。</li>
</ul>
<p>偿还资产前，用户必须先 <a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-20#approve">批准(approve)</a>， cToken 才能访问其代币余额。</p>
<p><strong>CEther</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">function</span> <span class="title function_">repayBorrow</span>(<span class="params"></span>) payable</span><br></pre></td></tr></table></figure>

<ul>
<li>msg.value : 用于偿还的 ETH 数量，单位 wei。</li>
<li>msg.sender : 借入资产的账户，应偿还借款。</li>
<li>RETURN : 无返回值，错误时还原。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 CEther cToken = CEther(0x3FDB...);</span><br><span class="line"></span><br><span class="line">2 require(cToken.repayBorrow.value(100)() == 0, &quot;transfer approved?&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CErc20.at(0x3FDA...);</span><br><span class="line"></span><br><span class="line">2 cToken.methods.repayBorrow(10000).send(&#123;from: ...&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="代偿还借款-Repay-Borrow-Behalf"><a href="#代偿还借款-Repay-Borrow-Behalf" class="headerlink" title="代偿还借款(Repay Borrow Behalf)"></a>代偿还借款(Repay Borrow Behalf)</h2><p>repay 方法将资产转移到协议中，并减少目标用户的借款余额。</p>
<p><strong>CErc20</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function repayBorrowBehalf(address borrower, uint repayAmount) returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>msg.sender : 偿还借款的账户。</li>
<li>borrower : 借入资产要偿还的账户。</li>
<li>repayAmount : 拟偿还的标的资产借款金额。值为-1（即2256-1）表示偿还全部借款额。</li>
<li>RETURN : 成功时为0，否则是<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">错误代码</a>。</li>
</ul>
<p>偿还资产前，用户必须先 <a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-20#approve">批准(approve)</a>， cToken 才能访问其代币余额。</p>
<p><strong>CEther</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function repayBorrowBehalf(address borrower) payable</span><br></pre></td></tr></table></figure>

<ul>
<li>msg.value : 用于偿还的 ETH 数量，单位 wei。</li>
<li>msg.sender : 偿还借款的账户。</li>
<li>borrower : 借入资产要偿还的账户。</li>
<li>RETURN : 无返回值，错误时还原。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CEther cToken = CEther(0x3FDB...);</span><br><span class="line">2 require(cToken.repayBorrowBehalf.value(100)(0xBorrower) == 0, &quot;transfer approved?&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CErc20.at(0x3FDA...);</span><br><span class="line">2 await cToken.methods.repayBorrowBehalf(0xBorrower, 10000).send(&#123;from: 0xPayer&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="清算借款-Liquidate-Borrow"><a href="#清算借款-Liquidate-Borrow" class="headerlink" title="清算借款(Liquidate Borrow)"></a>清算借款(Liquidate Borrow)</h2><p><a target="_blank" rel="noopener" href="https://compound.finance/docs/comptroller#account-liquidity">账户流动性</a>为负值的用户，由协议的其他用户进行<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">清算</a>，使其账户流动性恢复到正值（即高于抵押品要求）。当发生清算时，清算人(liquidator)可以代表借款人偿还部分或全部未偿还的借款，作为回报，可以获得借款人持有的抵押品的折价；这种折价被定义为清算奖励。</p>
<p>清算人可将水下账户的任何一个未偿还借款以一定的固定比例（即结算系数）进行结算。与 V1 中不同的是，清算者必须与每一个 cToken  合约中偿还借款并扣押另一项资产作为抵押品的 cToken 进行交互。当抵押品被扣押时，清算人会被转移 cToken，他们可以赎回这些  cToken，就像他们自己提供资产一样。用户必须在调用清算前批准每个 cToken  合约（即在他们要偿还的借款资产上），因为他们正在将资金转移到合约中。</p>
<p><strong>CErc20</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function liquidateBorrow(address borrower, uint amount, address collateral) returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>msg.sender : 应通过偿还借款人的债务和扣押抵押品来结算借款人的账户。</li>
<li>borrower : 应予清算的负<a target="_blank" rel="noopener" href="https://compound.finance/docs/comptroller#account-liquidity">账户流动性</a>账户。</li>
<li>repayAmount : 借款资产的偿还和转换为抵押品的金额，以标的抵押资产的单位为单位。</li>
<li>cTokenCollateral : 清算人应扣押借款人目前作为抵押品持有的 cToken 地址。</li>
<li>RETURN : 成功时为0，否则是<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">错误代码</a>。</li>
</ul>
<p>偿还资产前，用户必须先 <a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-20#approve">批准(approve)</a>， cToken 才能访问其代币余额。</p>
<p><strong>CEther</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function liquidateBorrow(address borrower, address cTokenCollateral) payable</span><br></pre></td></tr></table></figure>

<ul>
<li>msg.value : 转换为抵押品的 ETH 金额，单位 wei 。</li>
<li>msg.sender : 应通过偿还借款人的债务和扣押抵押品来结算借款人的账户。</li>
<li>borrower : 应予清算的负<a target="_blank" rel="noopener" href="https://compound.finance/docs/comptroller#account-liquidity">账户流动性</a>账户。</li>
<li>cTokenCollateral : 清算人应扣押借款人目前作为抵押品持有的 cToken 地址。</li>
<li>RETURN : 成功时为0，否则是<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">错误代码</a>。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 CEther cToken = CEther(0x3FDB...); </span><br><span class="line">2 CErc20 cTokenCollateral = CErc20(0x3FDA...);</span><br><span class="line">3  require(cToken.liquidateBorrow.value(100)(0xBorrower, cTokenCollateral) == 0, &quot;borrower underwater??&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CErc20.at(0x3FDA...); </span><br><span class="line">2 const cTokenCollateral = CEther.at(0x3FDB...);</span><br><span class="line">3  await cToken.methods.liquidateBorrow(0xBorrower, 33, cTokenCollateral).send(&#123;from: 0xLiquidator&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="主要事件-Key-Events"><a href="#主要事件-Key-Events" class="headerlink" title="主要事件(Key Events)"></a>主要事件(Key Events)</h2><table>
<thead>
<tr>
<th>Event</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Mint(address minter, uint mintAmount, uint mintTokens)</td>
<td><a target="_blank" rel="noopener" href="https://compound.devdapp.cn/kai-fa-zhe-wen-dang/ctoken#zhu-bi-mint">铸币</a>成功后发出</td>
</tr>
<tr>
<td>Redeem(address redeemer, uint redeemAmount, uint redeemTokens)</td>
<td><a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">赎回</a>成功后发出</td>
</tr>
<tr>
<td>Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows)</td>
<td><a target="_blank" rel="noopener" href="https://compound.devdapp.cn/kai-fa-zhe-wen-dang/ctoken#jie-kuan-borrow">借款</a>成功后发出</td>
</tr>
<tr>
<td>RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows)</td>
<td><a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">偿还借款</a>成功后发出</td>
</tr>
<tr>
<td>LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens)</td>
<td><a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">借款清算</a>成功后发出</td>
</tr>
</tbody></table>
<h2 id="错误代码-Error-Codes"><a href="#错误代码-Error-Codes" class="headerlink" title="错误代码(Error Codes)"></a>错误代码(Error Codes)</h2><table>
<thead>
<tr>
<th>Code</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>NO_ERROR</td>
<td>不是失败。</td>
</tr>
<tr>
<td>1</td>
<td>UNAUTHORIZED</td>
<td>发件人无权实施这一操作。</td>
</tr>
<tr>
<td>2</td>
<td>BAD_INPUT</td>
<td>调用者提供了一个无效参数。</td>
</tr>
<tr>
<td>3</td>
<td>COMPTROLLER_REJECTION</td>
<td>该操作将违反审计官政策。</td>
</tr>
<tr>
<td>4</td>
<td>COMPTROLLER_CALCULATION_ERROR</td>
<td>审计内部计算失败 。</td>
</tr>
<tr>
<td>5</td>
<td>INTEREST_RATE_MODEL_ERROR</td>
<td>利率模型返回了一个无效值。</td>
</tr>
<tr>
<td>6</td>
<td>INVALID_ACCOUNT_PAIR</td>
<td>指定的账户组合是无效的。</td>
</tr>
<tr>
<td>7</td>
<td>INVALID_CLOSE_AMOUNT_REQUESTED</td>
<td>清算金额无效。</td>
</tr>
<tr>
<td>8</td>
<td>INVALID_COLLATERAL_FACTOR</td>
<td>抵押因子无效。</td>
</tr>
<tr>
<td>9</td>
<td>MATH_ERROR</td>
<td>出现了数学计算错误。</td>
</tr>
<tr>
<td>10</td>
<td>MARKET_NOT_FRESH</td>
<td>利息没有正确产生。</td>
</tr>
<tr>
<td>11</td>
<td>MARKET_NOT_LISTED</td>
<td>目前，市场没有由审计员列出。</td>
</tr>
<tr>
<td>12</td>
<td>TOKEN_INSUFFICIENT_ALLOWANCE</td>
<td>ERC-20 合约必须**允许(allow)**货币市场合约调用<code>transferForm</code>。当前 allow 额为0或小于请求的供给、偿还借款或清算金额。</td>
</tr>
<tr>
<td>13</td>
<td>TOKEN_INSUFFICIENT_BALANCE</td>
<td>调用者在 ERC-20 合约中没有足够的余额来完成所需的操作。</td>
</tr>
<tr>
<td>14</td>
<td>TOKEN_INSUFFICIENT_CASH</td>
<td>市场上没有足够的现金金额来完成交易。您可以稍后再尝试此项交易。</td>
</tr>
<tr>
<td>15</td>
<td>TOKEN_TRANSFER_IN_FAILED</td>
<td>在 ERC-20 代币转入市场时失败。</td>
</tr>
<tr>
<td>16</td>
<td>TOKEN_TRANSFER_OUT_FAILED</td>
<td>在 ERC-20 代币转出市场时失败。</td>
</tr>
</tbody></table>
<h2 id="失败信息-Failure-Info"><a href="#失败信息-Failure-Info" class="headerlink" title="失败信息(Failure Info)"></a>失败信息(Failure Info)</h2><table>
<thead>
<tr>
<th>Code</th>
<th>Name</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>ACCEPT_ADMIN_PENDING_ADMIN_CHECK</td>
</tr>
<tr>
<td>1</td>
<td>ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED</td>
</tr>
<tr>
<td>2</td>
<td>ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED</td>
</tr>
<tr>
<td>3</td>
<td>ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED</td>
</tr>
<tr>
<td>4</td>
<td>ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED</td>
</tr>
<tr>
<td>5</td>
<td>ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED</td>
</tr>
<tr>
<td>6</td>
<td>ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED</td>
</tr>
<tr>
<td>7</td>
<td>BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED</td>
</tr>
<tr>
<td>8</td>
<td>BORROW_ACCRUE_INTEREST_FAILED</td>
</tr>
<tr>
<td>9</td>
<td>BORROW_CASH_NOT_AVAILABLE</td>
</tr>
<tr>
<td>10</td>
<td>BORROW_FRESHNESS_CHECK</td>
</tr>
<tr>
<td>11</td>
<td>BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED</td>
</tr>
<tr>
<td>12</td>
<td>BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED</td>
</tr>
<tr>
<td>13</td>
<td>BORROW_MARKET_NOT_LISTED</td>
</tr>
<tr>
<td>14</td>
<td>BORROW_COMPTROLLER_REJECTION</td>
</tr>
<tr>
<td>15</td>
<td>LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED</td>
</tr>
<tr>
<td>16</td>
<td>LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED</td>
</tr>
<tr>
<td>17</td>
<td>LIQUIDATE_COLLATERAL_FRESHNESS_CHECK</td>
</tr>
<tr>
<td>18</td>
<td>LIQUIDATE_COMPTROLLER_REJECTION</td>
</tr>
<tr>
<td>19</td>
<td>LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED</td>
</tr>
<tr>
<td>20</td>
<td>LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX</td>
</tr>
<tr>
<td>21</td>
<td>LIQUIDATE_CLOSE_AMOUNT_IS_ZERO</td>
</tr>
<tr>
<td>22</td>
<td>LIQUIDATE_FRESHNESS_CHECK</td>
</tr>
<tr>
<td>23</td>
<td>LIQUIDATE_LIQUIDATOR_IS_BORROWER</td>
</tr>
<tr>
<td>24</td>
<td>LIQUIDATE_REPAY_BORROW_FRESH_FAILED</td>
</tr>
<tr>
<td>25</td>
<td>LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED</td>
</tr>
<tr>
<td>26</td>
<td>LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED</td>
</tr>
<tr>
<td>27</td>
<td>LIQUIDATE_SEIZE_COMPTROLLER_REJECTION</td>
</tr>
<tr>
<td>28</td>
<td>LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER</td>
</tr>
<tr>
<td>29</td>
<td>LIQUIDATE_SEIZE_TOO_MUCH</td>
</tr>
<tr>
<td>30</td>
<td>MINT_ACCRUE_INTEREST_FAILED</td>
</tr>
<tr>
<td>31</td>
<td>MINT_COMPTROLLER_REJECTION</td>
</tr>
<tr>
<td>32</td>
<td>MINT_EXCHANGE_CALCULATION_FAILED</td>
</tr>
<tr>
<td>33</td>
<td>MINT_EXCHANGE_RATE_READ_FAILED</td>
</tr>
<tr>
<td>34</td>
<td>MINT_FRESHNESS_CHECK</td>
</tr>
<tr>
<td>35</td>
<td>MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED</td>
</tr>
<tr>
<td>36</td>
<td>MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED</td>
</tr>
<tr>
<td>37</td>
<td>MINT_TRANSFER_IN_FAILED</td>
</tr>
<tr>
<td>38</td>
<td>MINT_TRANSFER_IN_NOT_POSSIBLE</td>
</tr>
<tr>
<td>39</td>
<td>REDEEM_ACCRUE_INTEREST_FAILED</td>
</tr>
<tr>
<td>40</td>
<td>REDEEM_COMPTROLLER_REJECTION</td>
</tr>
<tr>
<td>41</td>
<td>REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED</td>
</tr>
<tr>
<td>42</td>
<td>REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED</td>
</tr>
<tr>
<td>43</td>
<td>REDEEM_EXCHANGE_RATE_READ_FAILED</td>
</tr>
<tr>
<td>44</td>
<td>REDEEM_FRESHNESS_CHECK</td>
</tr>
<tr>
<td>45</td>
<td>REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED</td>
</tr>
<tr>
<td>46</td>
<td>REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED</td>
</tr>
<tr>
<td>47</td>
<td>REDEEM_TRANSFER_OUT_NOT_POSSIBLE</td>
</tr>
<tr>
<td>48</td>
<td>REDUCE_RESERVES_ACCRUE_INTEREST_FAILED</td>
</tr>
<tr>
<td>49</td>
<td>REDUCE_RESERVES_ADMIN_CHECK</td>
</tr>
<tr>
<td>50</td>
<td>REDUCE_RESERVES_CASH_NOT_AVAILABLE</td>
</tr>
<tr>
<td>51</td>
<td>REDUCE_RESERVES_FRESH_CHECK</td>
</tr>
<tr>
<td>52</td>
<td>REDUCE_RESERVES_VALIDATION</td>
</tr>
<tr>
<td>53</td>
<td>REPAY_BEHALF_ACCRUE_INTEREST_FAILED</td>
</tr>
<tr>
<td>54</td>
<td>REPAY_BORROW_ACCRUE_INTEREST_FAILED</td>
</tr>
<tr>
<td>55</td>
<td>REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED</td>
</tr>
<tr>
<td>56</td>
<td>REPAY_BORROW_COMPTROLLER_REJECTION</td>
</tr>
<tr>
<td>57</td>
<td>REPAY_BORROW_FRESHNESS_CHECK</td>
</tr>
<tr>
<td>58</td>
<td>REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED</td>
</tr>
<tr>
<td>59</td>
<td>REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED</td>
</tr>
<tr>
<td>60</td>
<td>REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE</td>
</tr>
<tr>
<td>61</td>
<td>SET_COLLATERAL_FACTOR_OWNER_CHECK</td>
</tr>
<tr>
<td>62</td>
<td>SET_COLLATERAL_FACTOR_VALIDATION</td>
</tr>
<tr>
<td>63</td>
<td>SET_COMPTROLLER_OWNER_CHECK</td>
</tr>
<tr>
<td>64</td>
<td>SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED</td>
</tr>
<tr>
<td>65</td>
<td>SET_INTEREST_RATE_MODEL_FRESH_CHECK</td>
</tr>
<tr>
<td>66</td>
<td>SET_INTEREST_RATE_MODEL_OWNER_CHECK</td>
</tr>
<tr>
<td>67</td>
<td>SET_MAX_ASSETS_OWNER_CHECK</td>
</tr>
<tr>
<td>68</td>
<td>SET_ORACLE_MARKET_NOT_LISTED</td>
</tr>
<tr>
<td>69</td>
<td>SET_PENDING_ADMIN_OWNER_CHECK</td>
</tr>
<tr>
<td>70</td>
<td>SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED</td>
</tr>
<tr>
<td>71</td>
<td>SET_RESERVE_FACTOR_ADMIN_CHECK</td>
</tr>
<tr>
<td>72</td>
<td>SET_RESERVE_FACTOR_FRESH_CHECK</td>
</tr>
<tr>
<td>73</td>
<td>SET_RESERVE_FACTOR_BOUNDS_CHECK</td>
</tr>
<tr>
<td>74</td>
<td>TRANSFER_COMPTROLLER_REJECTION</td>
</tr>
<tr>
<td>75</td>
<td>TRANSFER_NOT_ALLOWED</td>
</tr>
<tr>
<td>76</td>
<td>TRANSFER_NOT_ENOUGH</td>
</tr>
<tr>
<td>77</td>
<td>TRANSFER_TOO_MUCH</td>
</tr>
</tbody></table>
<h2 id="汇率-Exchange-Rate"><a href="#汇率-Exchange-Rate" class="headerlink" title="汇率(Exchange Rate)"></a>汇率(Exchange Rate)</h2><p>每个cToken 都可以兑换成数量不断增加的标的资产，因为在市场上会产生利息。cToken 与相关资产之间的汇率等于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 exchangeRate = (getCash() + totalBorrows() - totalReserves()) / totalSupply()</span><br></pre></td></tr></table></figure>

<p><strong>CErc20 &#x2F; CEther</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function exchangeRateCurrent() returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值 : 当前的汇率，为无符号整数，按 1e18 缩放；</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2 uint exchangeRateMantissa = cToken.exchangeRateCurrent();</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...); </span><br><span class="line">2 const exchangeRate = (await cToken.methods.exchangeRateCurrent().call()) / 1e18;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请注意，对比 send 使用 <code>call</code> 是在链外调用方法，而不需要导致 Gas 成本。</p>
</blockquote>
<h2 id="获取现金-Get-Cash"><a href="#获取现金-Get-Cash" class="headerlink" title="获取现金(Get Cash)"></a>获取现金(Get Cash)</h2><p>现金是指该 cToken 合约所拥有的标的资产余额。人民可以查询到目前这个市场上的现金总量。</p>
<p><strong>CErc20 &#x2F; CEther</strong></p>
<p>1 function getCash() returns (uint)</p>
<ul>
<li>返回值 : 该 cToken 合约所拥有的标的资产数量。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2 uint cash = cToken.getCash();</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...);</span><br><span class="line">2 const cash = (await cToken.methods.getCash().call());</span><br></pre></td></tr></table></figure>

<h2 id="总借款-Total-Borrow"><a href="#总借款-Total-Borrow" class="headerlink" title="总借款(Total Borrow)"></a>总借款(Total Borrow)</h2><p>总借贷额是指目前市场上借出的标的额，以及累计向市场上的供应商支付的利息。</p>
<p><strong>CErc20 &#x2F; CEther</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function totalBorrowsCurrent() returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值：借出的标的总额与利息。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2 uint borrows = cToken.totalBorrowsCurrent();</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...);</span><br><span class="line">2 const borrows = (await cToken.methods.totalBorrowsCurrent().call());</span><br></pre></td></tr></table></figure>

<h2 id="借款余额-Borrow-Balance"><a href="#借款余额-Borrow-Balance" class="headerlink" title="借款余额(Borrow Balance)"></a>借款余额(Borrow Balance)</h2><p>从协议中借入资产的用户要根据借款利率进行累计利息。利息是每块都要累计的，集成商可以通过这个功能来获得用户的借款余额的当前价值与利息。</p>
<p><strong>CErc20 &#x2F; CEther</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function borrowBalanceCurrent(address account) returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>account : 借入资产的账户。</li>
<li>返回值 : 用户的当前借款余额（与利息），单位是标的资产的单位。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2 uint borrows = cToken.borrowBalanceCurrent(msg.caller);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...);</span><br><span class="line">2 const borrows = await cToken.methods.borrowBalanceCurrent(account).call();</span><br></pre></td></tr></table></figure>

<h2 id="借款利率-Borrow-Rate"><a href="#借款利率-Borrow-Rate" class="headerlink" title="借款利率(Borrow Rate)"></a>借款利率(Borrow Rate)</h2><p>在任何时候，任何人都可以通过查询合约来获取当前每个区块的借款利率。</p>
<p><strong>CErc20 &#x2F; CEther</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function borrowRatePerBlock() returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值 : 当前借款利率，为一个无符号整数，按 1e18 缩放。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2 uint borrowRateMantissa = cToken.borrowRatePerBlock();</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...);</span><br><span class="line">2 const borrowRate = (await cToken.methods.borrowRatePerBlock().call()) / 1e18;</span><br></pre></td></tr></table></figure>

<h2 id="总供应量-Total-Supply"><a href="#总供应量-Total-Supply" class="headerlink" title="总供应量(Total Supply)"></a>总供应量(Total Supply)</h2><p>总供应量是指目前在 cToken 市场上流通的代币数量。它是 cToken 合约的 EIP-20 接口的一部分 。</p>
<p><strong>CErc20 &#x2F; CEther</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function totalSupply() returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值 : 在市场上流通的代币总数量。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2  uint tokens = cToken.totalSupply();</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...);</span><br><span class="line">2 const tokens = (await cToken.methods.totalSupply().call());</span><br></pre></td></tr></table></figure>

<h2 id="标的余额-Balance"><a href="#标的余额-Balance" class="headerlink" title="标的余额 Balance"></a>标的余额 Balance</h2><p>用户的标的月，代币他们在协议中的资产，等于用户的 cToken 余额乘以<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">汇率</a>。</p>
<p><strong>CErc20 &#x2F; CEther</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function balanceOfUnderlying(address account) returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>account : 获取标的余额的账户。</li>
<li>返回值 : 该账户当前拥有的标的数量。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2 uint tokens = cToken.balanceOfUnderlying(msg.caller);</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...);</span><br><span class="line">2 const tokens = await cToken.methods.balanceOfUnderlying(account).call();</span><br></pre></td></tr></table></figure>

<h2 id="供给率-Supply-Rate"><a href="#供给率-Supply-Rate" class="headerlink" title="供给率(Supply Rate)"></a>供给率(Supply Rate)</h2><p>在任何时候，人们都可以通过查询合约来获取当前每块的供给率。供给率是由<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">借款利率</a>、准备金系数(<a target="_blank" rel="noopener" href="https://compound.finance/docs/ctokens#reserve-factor">reserve factor</a>)和<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3168">总借款额</a>得出的。</p>
<p><strong>CErc20 &#x2F; CEther</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function supplyRatePerBlock() returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值 : 当前供给率，为一个无符号整数，按 1e18 缩放。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2 uint supplyRateMantissa = cToken.supplyRatePerBlock();</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...);</span><br><span class="line">2 const supplyRate = (await cToken.methods.supplyRatePerBlock().call()) / 1e18;</span><br></pre></td></tr></table></figure>

<h2 id="总储备金-Total-Reserves"><a href="#总储备金-Total-Reserves" class="headerlink" title="总储备金(Total Reserves)"></a>总储备金(Total Reserves)</h2><p>储备金是每个 cToken 合约中的会计分录，代币历史利息的一部分，作为现金预留，可以通过协议的治理来提取或转移。借款人利息的一小部分应计入协议中，由准备金系数 <a target="_blank" rel="noopener" href="https://compound.finance/docs/ctokens#reserve-factor">reserve factor</a>决定。</p>
<p><strong>CErc20 &#x2F; CEther</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function totalReserves() returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值 : 市场上持有的储备金总额。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2 uint reserves = cToken.totalReserves();</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...);</span><br><span class="line">2 const reserves = (await cToken.methods.totalReserves().call());</span><br></pre></td></tr></table></figure>

<h2 id="储备金系数-Reserve-Factor"><a href="#储备金系数-Reserve-Factor" class="headerlink" title="储备金系数(Reserve Factor)"></a>储备金系数(Reserve Factor)</h2><p>准备金系数确定了借款人利息中转化为准备金的部分。</p>
<p><strong>CErc20 &#x2F; CEther</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function reserveFactorMantissa() returns (uint)</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值 : 当前市场准备金系数，为一个无符号整数，按 1e18 缩放。</li>
</ul>
<p><strong>Solidity</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2uint reserveFactorMantissa = cToken.reserveFactorMantissa();</span><br></pre></td></tr></table></figure>

<p><strong>Web3 1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...); </span><br><span class="line">2 const reserveFactor = (await cToken.methods.reserveFactorMantissa().call()) / 1e18;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/12/27/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/2-%E5%BC%80%E5%8F%91%E8%80%85%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/27/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/2-%E5%BC%80%E5%8F%91%E8%80%85%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">2-开发者入门</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-27 00:00:00" itemprop="dateCreated datePublished" datetime="2022-12-27T00:00:00+08:00">2022-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Compound/" itemprop="url" rel="index">
                    <span itemprop="name">Compound</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Compound-开发者入门"><a href="#Compound-开发者入门" class="headerlink" title="Compound 开发者入门"></a>Compound 开发者入门</h1><p>Compound 协议已经部署在以下网络中：networks:Mainnet、Rinkeby、Kovan、Ropsten、Goerli</p>
<h2 id="应计利息计算"><a href="#应计利息计算" class="headerlink" title="应计利息计算"></a>应计利息计算</h2><p>在每个市场上的任何一个区块的<strong>借款资产和供给资产的比例发生变化时，市场的利息率就会发送变化</strong>。利率的变化量取决于市场所实施的利率模型智能合约，以及市场上的借款资产与供应资产的比例变化量。</p>
<p>请看  <a target="_blank" rel="noopener" href="https://observablehq.com/@jflatow/compound-interest-rates">Observable</a> 上的利率数据可视化笔记本，可以直观的了解到目前每个市场上应用的利率模型是哪个利率模型。</p>
<p>历史利率可以从  <a target="_blank" rel="noopener" href="https://compound.finance/docs/api#MarketHistoryService">MarketHistoryService API</a> 中检索。</p>
<p>当任何以太坊地址和市场上的 cToken  合约交互，调用这些方法中的一个时，利息就会累积到市场的所有供应商和借款人身上：mint、redeem、borrow 或 repay。  <strong>成功执行其中一个方法就会触发 accrueInterest 方法</strong>，导致<strong>利息被添加到市场上没个供应商和借款人的基础余额中</strong>。当前区块以及之前没有触发 accrueInterest 方法的每个区块（没用户与 cToken 合约交互）都会产生利息。<strong>只有在 cToken  合约调用了上述方法之一的区块中，才会产生利息。</strong></p>
<p>这里以供给应计利息为例：</p>
<p>张三向 Compound 协议供应 1 个 ETH。供给时， supplyRatePerBlock 是 37893605 wei，或每块  0.000000000037893605 ETH。在 3 个以太坊区块中，没人与 cETH 合约交互。在随后的第 4 个区块上，李四借了一些  ETH。现在，张三的底层资产余额是 1.000000000151574420 ETH（也就是 37893605 wei 乘以 4  个区块，加上原来的 1 ETH）。张三在后续区块中的底层 ETH 余额将根据 1.000000000151574420 ETH  新值计息，而不是最初的 1 ETH。请注意，supplyRatePerBlock的值可能会随时发生变化。</p>
<h3 id="使用每块利率计算年利率"><a href="#使用每块利率计算年利率" class="headerlink" title="使用每块利率计算年利率"></a>使用每块利率计算年利率</h3><p>每个市场中的供应或借款的年收益率（APY）可以用本公式中的 supplyRatePerBlock（求供应年收益率）或 borrowRatePerBlock （求借款年收益率）的值来计算：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> Rate <span class="operator">=</span> cToken.supplyRatePerBlock(); <span class="operator">/</span><span class="operator">/</span> 整数</span><br><span class="line"><span class="number">2</span> Rate <span class="operator">=</span> <span class="number">37893566</span></span><br><span class="line"><span class="number">3</span> ETH Mantissa <span class="operator">=</span> <span class="number">1</span> <span class="operator">*</span> <span class="number">10</span> <span class="operator">^</span> <span class="number">18</span> <span class="operator">/</span><span class="operator">/</span> ETH 是 <span class="number">18</span> 个小数点</span><br><span class="line"><span class="number">4</span> Blocks <span class="keyword">Per</span> <span class="keyword">Day</span> <span class="operator">=</span> <span class="number">4</span> <span class="operator">*</span> <span class="number">60</span> <span class="operator">*</span> <span class="number">24</span> <span class="operator">/</span><span class="operator">/</span> 按每分钟 <span class="number">4</span> 个区块计算</span><br><span class="line"><span class="number">5</span> Days <span class="keyword">Per</span> <span class="keyword">Year</span> <span class="operator">=</span> <span class="number">365</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span> APY <span class="operator">=</span> ((((Rate <span class="operator">/</span> ETH Mantissa <span class="operator">*</span> Blocks <span class="keyword">Per</span> <span class="keyword">Day</span> <span class="operator">+</span> <span class="number">1</span>) <span class="operator">^</span> Days <span class="keyword">Per</span> <span class="keyword">Year</span> <span class="operator">-</span> <span class="number">1</span>)) <span class="operator">-</span> <span class="number">1</span>) <span class="operator">*</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>用 Web3.js JavaScript 计算供应和借款年收益率示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 const ethMantissa = 1e18;</span><br><span class="line">2 const blocksPerDay = 4 * 60 * 24;</span><br><span class="line">3 const daysPerYear = 365;</span><br><span class="line">4</span><br><span class="line">5 const cToken = new web3.eth.Contract(cEthAbi, cEthAddress);</span><br><span class="line">6 const supplyRatePerBlock = await cToken.methods.supplyRatePerBlock().call();</span><br><span class="line">7 const borrowRatePerBlock = await cToken.methods.borrowRatePerBlock().call();</span><br><span class="line">8 const supplyApy = (((Math.pow((supplyRatePerBlock / ethMantissa * blocksPerDay) + 1, daysPerYear - 1))) - 1) * 100;</span><br><span class="line">9 const borrowApy = (((Math.pow((borrowRatePerBlock / ethMantissa * blocksPerDay) + 1, daysPerYear - 1))) - 1) * 100;</span><br><span class="line">10 console.log(`Supply APY for ETH $&#123;supplyApy&#125; %`);</span><br><span class="line">11 console.log(`Borrow APY for ETH $&#123;borrowApy&#125; %`);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/12/24/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/1-%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/24/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/1-%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">1-介绍</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-24 00:00:00" itemprop="dateCreated datePublished" datetime="2022-12-24T00:00:00+08:00">2022-12-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Compound/" itemprop="url" rel="index">
                    <span itemprop="name">Compound</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>939</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Compound-介绍"><a href="#Compound-介绍" class="headerlink" title="Compound 介绍"></a>Compound 介绍</h1><h2 id="什么是-Compound"><a href="#什么是-Compound" class="headerlink" title="什么是 Compound"></a>什么是 Compound</h2><p>Compound 是一个<strong>允许用户借贷代币的智能合约</strong>，它与你的银行类似，Compound  <strong>把你的钱借给借款人，并随着时间的推移赚取利息</strong>。但与银行不同的是，<strong>你的利息是从你存入 Compound  的智能合约后开始复利计算的。</strong>因为这是一个智能合约，整个流程中没有中间人，因此利息会比传统银行要高。</p>
<p>Compound 的贷款是通过<strong>超额担保</strong>确立的。借贷者将代币存入 Compound 中以增加他们的 <strong>“借款能力”</strong>，如果借贷者的<strong>借款能力低于 0</strong>，他们的<strong>抵押品将被出售以偿还债务</strong>。另外，<strong>每个资产的贷款利率是不同的，这根据资产的需求而决定</strong>。</p>
<h2 id="Compound的运作机制"><a href="#Compound的运作机制" class="headerlink" title="Compound的运作机制"></a>Compound的运作机制</h2><p>Compound 协议让开发者可以基于以太坊建立各种各样的货币市场（money market）。</p>
<p>所谓的<strong>「货币市场」，其实就是一个个的独立币池单元</strong>，每个币池里只有一种代币，协议<strong>通过算法来决定这个池子里的币借贷的利率</strong>是多少。<strong>简单点说，这个算法会基于人们对这个币借贷的供需关系自动计算出利率。</strong></p>
<p>而在 Compound 协议里，每个代币（比如 Ether、Dai、USDC）<strong>都有一个属于自己的借贷市场</strong>，里面包含<strong>每个用户在这个市场里的余额，以及各笔生效的借贷交易，乃至每段时期的历史利率</strong>，等等。</p>
<p>用户可以通<strong>过抵押品的信贷额度无缝地从协议上借钱</strong>，你只需要看自己要借哪个币，不需要和别人沟通还款日期、利率，就能马上借钱。借款是实时且可预测的。<strong>每个货币市场都有一个由市场决定的浮动利率。</strong></p>
<h2 id="Compound-清算保证"><a href="#Compound-清算保证" class="headerlink" title="Compound 清算保证"></a>Compound 清算保证</h2><p>Compound 协议强制应用了一条规则，即<strong>每个账户必须拥有足够的余额能够偿还借款的额度</strong>，叫做<strong>抵押率</strong>。每个账户无法做出任何会使「余额／借款额度」低于「抵押率」的行为。比如<strong>再借更多的钱或者把抵押款的余额提现。要增大或者重置抵押率，用户可以全额或者部分偿还借款</strong>。<strong>任何被 Compound 持有的余额，包括用户用来做抵押品的余额，同时也会产生正常的应计利息。</strong></p>
<p><strong>如果一个用户提供的抵押资产，除以他们信用额度所借的款项，低于抵押率，那他们的抵押资产就会（通过借款资产）被出售</strong>，出售的价格是当前市场价格减去清算折扣（liquidation discount）。这个机制会激励系统里的套利者，去快速减少借款人还不了的借款资产的短缺，从而降低协议的风险。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/12/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">数据库</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-21 00:00:00" itemprop="dateCreated datePublished" datetime="2022-12-21T00:00:00+08:00">2022-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index">
                    <span itemprop="name">区块链知识</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>940</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库索引，hash索引与B-树索引的适用场景，为什么用B-树索引"><a href="#数据库索引，hash索引与B-树索引的适用场景，为什么用B-树索引" class="headerlink" title="数据库索引，hash索引与B+树索引的适用场景，为什么用B+树索引"></a>数据库索引，hash索引与B+树索引的适用场景，为什么用B+树索引</h1><p>hash索引适用于等值查询，即查询条件为精确匹配的情况。相比于B+树索引，hash索引在等值查询方面更加高效，但是在范围查询和排序等操作上性能较差。</p>
<p>B+树索引适用于范围查询和排序等操作，相比于hash索引在这些操作上更加高效。此外，B+树索引还支持多列联合索引和覆盖索引等高级功能。</p>
<h1 id="主键与非主键和索引的关系"><a href="#主键与非主键和索引的关系" class="headerlink" title="主键与非主键和索引的关系"></a>主键与非主键和索引的关系</h1><p>主键是一种唯一标识表中每一行数据的列，它可以用来保证数据的唯一性和完整性。</p>
<p>非主键则是除主键以外的其他列，它们可以用来描述数据的其他属性和特征。</p>
<p>索引是一种用于加速数据查询的数据结构，它可以提高查询效率和减少查询时间，主键和非主键都可以被用作索引列。</p>
<h1 id="Redis为什么快（内存数据库，单线程IO多路复用）"><a href="#Redis为什么快（内存数据库，单线程IO多路复用）" class="headerlink" title="Redis为什么快（内存数据库，单线程IO多路复用）"></a>Redis为什么快（内存数据库，单线程IO多路复用）</h1><ol>
<li>内存存储：Redis<strong>将数据存储在内存中</strong>，而不是磁盘上，因此可以实现非常快的读写速度。</li>
<li>单线程模型：Redis采用单线程模型，避免了多线程之间的竞争和锁等问题，从而<strong>提高了并发性能。</strong></li>
<li>高效的数据结构：Redis<strong>支持多种高效的数据结构</strong>，如字符串、哈希表、列表、集合和有序集合等，可以满足不同的数据存储和查询需求。</li>
<li>异步IO：Redis<strong>采用异步IO模型</strong>，可以在等待IO操作的同时处理其他请求，从而提高了系统的并发性能。</li>
<li>持久化机制：Redis支持<strong>多种持久化机制</strong>，如RDB和AOF等，可以保证数据的可靠性和持久性。</li>
</ol>
<h1 id="MySQL的B-树"><a href="#MySQL的B-树" class="headerlink" title="MySQL的B+树"></a>MySQL的B+树</h1><p>MySQL的B+树是一种基于B+树的索引结构，用于加速数据查询和范围查询等操作。MySQL的B+树索引与一般的B+树索引相似，但是在实现上有一些特殊的优化和限制，以适应MySQL的特殊需求。</p>
<p>MySQL的B+树索引的特点包括：</p>
<ol>
<li>支持多列联合索引：MySQL的B+树索引支持多列联合索引，可以根据多个列的组合来进行查询和排序等操作。</li>
<li>支持覆盖索引：MySQL的B+树索引支持覆盖索引，可以在索引中包含所有需要查询的列，从而避免了对数据表的访问，提高了查询效率。</li>
<li>支持前缀索引：MySQL的B+树索引支持前缀索引，可以只对列的前缀进行索引，从而减少索引的大小和查询的时间。</li>
<li>支持自适应哈希索引：MySQL的B+树索引支持自适应哈希索引，可以根据数据的分布情况自动选择使用哈希索引或B+树索引，从而提高查询效率。</li>
</ol>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/12/18/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/18/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">共识算法</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-18 00:00:00" itemprop="dateCreated datePublished" datetime="2022-12-18T00:00:00+08:00">2022-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index">
                    <span itemprop="name">区块链知识</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="PBFT的3f-1，证明为什么是2f"><a href="#PBFT的3f-1，证明为什么是2f" class="headerlink" title="PBFT的3f+1，证明为什么是2f"></a>PBFT的3f+1，证明为什么是2f</h1><p>主节点的选举和每个阶段的消息确认都需要至少f+1个节点的支持，这样总共就需要2f个节点的参与和确认</p>
<h1 id="HotStuff怎么满足safe-vote"><a href="#HotStuff怎么满足safe-vote" class="headerlink" title="HotStuff怎么满足safe vote"></a>HotStuff怎么满足safe vote</h1><p>HotStuff确保了只有在多数验证者的确认下，一个候选区块才能被标记为已被证明，从而达到了”safe vote”的目标。</p>
<h1 id="Raft的非对称分区是怎么解决的"><a href="#Raft的非对称分区是怎么解决的" class="headerlink" title="Raft的非对称分区是怎么解决的"></a>Raft的非对称分区是怎么解决的</h1><p>Leader选举：在非对称分区的情况下，<strong>如果一个节点无法与大多数节点通信，它将无法成为Leader，</strong>因为它无法获得大多数节点的投票。因此，<strong>Raft算法可以保证在非对称分区的情况下，只有大多数节点可以成为Leader</strong>，从而保证系统的一致性和可用性。</p>
<h1 id="对称分区的prevote是怎么做的"><a href="#对称分区的prevote是怎么做的" class="headerlink" title="对称分区的prevote是怎么做的"></a>对称分区的prevote是怎么做的</h1><p>在prevote机制中，<strong>每个节点可以先进行预投票，然后再进行正式投票</strong>。预投票的目的是<strong>为了避免出现由于网络延迟等原因导致的选举过程中的竞争情况</strong>，从而提高选举的效率和准确性。具体来说，<strong>当一个节点收到来自候选人的请求时，它会先进行prevote，向其他节点询问它们是否同意该候选人成为Leader。如果大多数节点都同意，那么该节点就会进行正式投票，将自己的票投给该候选人。</strong>通过prevote机制，可以避免出现由于网络延迟等原因导致的选举过程中的竞争情况，从而提高选举的效率和准确性。</p>
<h1 id="PBFT与Raft的区别（拜占庭容错与崩溃容错）"><a href="#PBFT与Raft的区别（拜占庭容错与崩溃容错）" class="headerlink" title="PBFT与Raft的区别（拜占庭容错与崩溃容错）"></a>PBFT与Raft的区别（拜占庭容错与崩溃容错）</h1><ol>
<li>拜占庭容错性质：<ul>
<li>PBFT旨在实现拜占庭容错，<strong>可以容忍拜占庭错误节点的存在</strong>。它<strong>通过投票和多个消息阶段的协商来确保一致性</strong>。</li>
<li>Raft是一种<strong>基于领导者（Leader）选举的共识算法</strong>，旨在<strong>解决崩溃错误节点（即停止响应）的问题</strong>，<strong>并不直接解决拜占庭错误</strong>。</li>
</ul>
</li>
<li>容错性能：<ul>
<li>PBFT需要至少2f+1个节点来容忍f个拜占庭错误节点，即<strong>节点数量至少为3f+1</strong>。它在正常情况下具有高性能，但拜占庭错误的存在会影响性能。</li>
<li>Raft<strong>需要大多数节点的参与（即至少半数+1）来达成共识。它对于崩溃错误具有容错性能</strong></li>
</ul>
</li>
<li>消息复制：<ul>
<li>PBFT中的消息复制需要经过多个消息阶段，节点通过互相发送消息来达成共识。</li>
<li>Raft中的消息复制是通过领导者发送日志条目给跟随者来实现的。一旦多数节点复制了日志，就可以达成共识</li>
</ul>
</li>
</ol>
<h1 id="PoS、PoW、Raft、Pbft等共识算法定义、区别"><a href="#PoS、PoW、Raft、Pbft等共识算法定义、区别" class="headerlink" title="PoS、PoW、Raft、Pbft等共识算法定义、区别"></a>PoS、PoW、Raft、Pbft等共识算法定义、区别</h1><ol>
<li>PoS：PoS是一种<strong>基于持有货币数量的共识算法</strong>，它<strong>通过随机选择持有货币的节点来验证交易和生成新的区块</strong>。持有货币数量越多的节点，获得验证和生成区块的机会就越大。相比于PoW，PoS算法更加节能和环保，但是容易出现寡头垄断的问题。</li>
<li>PoW：PoW是一种<strong>基于计算能力的共识算法</strong>，它<strong>通过解决数学难题来验证交易和生成新的区块</strong>。计算能力越强的节点，获得验证和生成区块的机会就越大。相比于PoS，PoW算法更加安全和去中心化，但是需要大量的计算资源和能源消耗。</li>
<li>Raft：Raft是一种<strong>基于领导者选举和日志复制的共识算法</strong>，它通过<strong>选举一个Leader节点来协调各个节点之间的数据同步和一致性</strong>。Raft算法相对于PBFT算法更加简单和高效，但是对于节点故障或者恶意行为的容忍度较低。</li>
<li>PBFT：PBFT是一种<strong>基于拜占庭将军问题的共识算法</strong>，它<strong>可以容忍一定数量的节点故障或者恶意行为</strong>，从而保证系统的一致性和可用性。PBFT算法需要进行多轮消息交互和数字签名验证，因此在性能方面相对较低，但是对于安全性和容错性要求较高的场景比较适用。</li>
</ol>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="幺柒YQ"
      src="/images/avater.png">
  <p class="site-author-name" itemprop="name">幺柒YQ</p>
  <div class="site-description" itemprop="description">努力坚持就会有希望</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">232</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kpyaoqi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kpyaoqi" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:18312386077@163.com" title="E-Mail → mailto:18312386077@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat.jpg" title="WeChat → images&#x2F;wechat.jpg"><i class="fa fa-fw fa-wechat"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/qq.jpg" title="QQ → images&#x2F;qq.jpg"><i class="fa fa-fw fa-qq"></i>QQ</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://stackoverflow.com/" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;" rel="noopener" target="_blank">Stackoverflow</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2021-11 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">幺柒YQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">899k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:37</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共379.4k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  


</body>
</html>
