<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://kongpengyq.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="努力坚持就会有希望">
<meta property="og:type" content="website">
<meta property="og:title" content="YQ &amp; 博客">
<meta property="og:url" content="https://kongpengyq.com/page/16/index.html">
<meta property="og:site_name" content="YQ &amp; 博客">
<meta property="og:description" content="努力坚持就会有希望">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="幺柒YQ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://kongpengyq.com/page/16/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>YQ & 博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="YQ & 博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YQ & 博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/07/27/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/19-%E5%8F%98%E9%87%8F%E7%9A%84%E5%B8%83%E5%B1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/27/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/19-%E5%8F%98%E9%87%8F%E7%9A%84%E5%B8%83%E5%B1%80/" class="post-title-link" itemprop="url">19-变量的布局</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-27 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-27T00:00:00+08:00">2022-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="状态变量在-storge-中的布局"><a href="#状态变量在-storge-中的布局" class="headerlink" title="状态变量在 storge 中的布局"></a>状态变量在 storge 中的布局</h1><p>合约的状态变量以一种紧凑的方式存储在区块链存储中，以这样的方式，<strong>有时多个值会使用同一个存储槽</strong>。</p>
<p>除了动态大小的数组和 mapping，数据的存储方式是从位置 <code>0</code> 开始连续放置在 storage 中。对于每个变量，根据其类型确定字节大小。</p>
<p>存储大小少于 32 字节的多个变量会被打包到一个存储插槽(storage slot)中，规则如下：</p>
<ul>
<li>存储插槽的第一项会以低位对齐的方式储存。</li>
<li>值类型仅使用存储它们所需的字节。</li>
<li>如果存储插槽中的剩余空间不足以储存一个值类型，那么它会被存入下一个存储插槽。</li>
<li>结构体（struct）和数组数据总是会开启一个新插槽（但结构体或数组中的各元素，则按规则紧密打包）。</li>
<li>结构体和数组之后的数据也或开启一个新插槽。</li>
</ul>
<p>对于使用继承的合约，状态变量的排序由 C3 线性化合约顺序（顺序从最基类合约开始）确定。如果上述规则成立，那么来自不同的合约的状态变量会共享一个存储插槽。</p>
<p>结构体和数组中的成员变量会存储在一起，就像它们单独声明时一样。</p>
<h2 id="1-1-使用时候的注意"><a href="#1-1-使用时候的注意" class="headerlink" title="1.1 使用时候的注意"></a>1.1 使用时候的注意</h2><p>⚠️ 注意: 在使用小于 32 字节的变量时，合约的 gas 使用量可能会高于使用 32 字节的元素。这是因为 EVM 每次操作 32 个字节，所以如果元素比 32 字节小，EVM 必须执行额外的操作以便将其大小缩减到到所需的大小。</p>
<p>当我们在处理状态变量时，利用编译器会将多个元素（变量）缩减的存储大小打包到一个 存储插槽中，也许是有益，因为可以合并多次读写为单个操作。如果你不是在同一时间读或写一个槽中的所有值，这可能会适得其反。当一个值被写入一个多值存储槽时，必须先读取该存储槽，然后将其与新值合并，避免破坏同一槽中的其他数据，再写入。</p>
<p>当处理函数参数或 memory(内存)中的值时，因为编译器不会打包这些值，所以没有什么额外的益处。</p>
<h2 id="1-2-书写时的注意"><a href="#1-2-书写时的注意" class="headerlink" title="1.2 书写时的注意"></a>1.2 书写时的注意</h2><p>最后，为了允许 evm 对此进行优化，请确保 storage 中的变量和 <code>struct</code> 成员的书写顺序允许它们被紧密地打包。例如，应该按照 <code>uint128，uint128，uint256</code> 的顺序来声明状态变量，而不是使用 <code>uint128，uint256，uint128</code>，因为前者只占用两个存储插槽，而后者将占用三个。</p>
<p>⚠️ 注意: storage 中状态变量的布局被认为是 solidity 外部接口的一部分， 因此 storage 变量指针可以传递给库（library）函数。这意味着，本节所述规则的任何变更均被视为语言破坏性变更，并且由于其关键性质，在执行之前应该非常仔细地考虑，在发生这种破坏性变化的情况下，我们希望发布一种兼容模式，在这种模式下，编译器将生成支持旧布局的字节码。</p>
<h2 id="1-3-mapping-和动态数组"><a href="#1-3-mapping-和动态数组" class="headerlink" title="1.3 mapping 和动态数组"></a>1.3 mapping 和动态数组</h2><p>由于 mapping 和动态数组不可预知大小，不能在状态变量之间存储他们。相反，他们自身根据以上规则仅占用 32 个字节，然后他们包含的元素的存储的起始位置，则是通过 Keccak-256 哈希计算来确定。</p>
<h2 id="1-4-起始位置"><a href="#1-4-起始位置" class="headerlink" title="1.4 起始位置"></a>1.4 起始位置</h2><p>假设 mapping 或动态数组根据上述存储规则最终可确定某个位置 <code>p</code> 。</p>
<ul>
<li>对于动态数组，此插槽中会存储数组中元素的数量（字节数组和字符串除外，见下文）。</li>
<li>对于 mapping，该插槽未被使用（为空），但它仍是需要的，以确保两个彼此挨着 mapping，他们的内容在不同的位置上。</li>
</ul>
<p>数组的元素会从 <code>keccak256(p)</code> 开始；它的布局方式与静态大小的数组相同。一个元素接着一个元素，如果元素的长度不超过 16 字节，就有可能共享存储槽。</p>
<p>动态数组的数组会递归地应用这一规则，例如，如何确定 <code>x[i][j]</code>元素的位置，其中 <code>x</code> 的类型是 <code>uint24[][]</code>，计算方法如下（假设<code>x</code>本身存储在槽 <code>p</code>）: 槽位于 <code>keccak256(keccak256(p) + i) + floor(j / floor(256 / 24))</code>，且可以从槽数据 <code>v</code>得到元素内容，使用 <code>(v &gt;&gt; ((j % floor(256 / 24)) * 24)) &amp; type(uint24).max</code>.</p>
<p>mapping 中的键 <code>k</code> 所对应的槽会位于 <code>keccak256(h(k) . p)</code> ，其中 <code>.</code>是连接符， <code>h</code> 是一个函数，根据键的类型：</p>
<ul>
<li>值类型， <code>h</code> 与在内存中存储值的方式相同的方式将值填充为 32 字节。</li>
<li>对于字符串和字节数组， <code>h(k)</code> 只是未填充的数据。</li>
</ul>
<p>如果映射值是一个非值类型，计算槽位置标志着数据的开始位置。例如，如果值是结构类型，你必须添加一个与结构成员相对应的偏移量才能到达该成员。</p>
<h4 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    struct S &#123;</span><br><span class="line">        uint16 a;</span><br><span class="line">        uint16 b;</span><br><span class="line">        uint256 c;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 x;</span><br><span class="line">    mapping(uint256 =&gt; mapping(uint256 =&gt; S)) data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们计算一下 <code>data[4][9].c</code> 的存储位置。映射本身的位置是 <code>1</code>（前面有 32 字节变量 <code>x</code> ）。 因此 <code>data[4]</code> 存储在<code>keccak256(uint256(4) . uint256(1))</code>。 <code>data[4]</code> 的类型又是一个映射，<code>data[4][9]</code> 的数据开始于槽位<code>keccak256(uint256(9). keccak256(uint256(4). uint256(1))</code>。</p>
<p>在结构 <code>S</code> 的成员 <code>c</code> 中的槽位偏移是 <code>1</code>，因为 <code>a</code> 和<code>b</code>被装在一个槽位中。 最后 <code>data[4][9].c</code> 的插槽位置是<code>keccak256(uint256(9) . keccak256(uint256(4) . uint256(1)) + 1</code>.该值的类型是 <code>uint256</code>，所以它使用一个槽。</p>
<h2 id="1-5-bytes-和-string"><a href="#1-5-bytes-和-string" class="headerlink" title="1.5 bytes 和 string"></a>1.5 <code>bytes</code> 和 <code>string</code></h2><p><code>bytes</code> 和 <code>string</code> 编码是一样的。</p>
<p>一般来说，编码与 <code>bytes1[]</code>类似，即有一个槽用于存放数组本身同时还有一个数据区，数据区位置使用槽的<br><code>keccak256</code> hash 计算。然而，对于短字节数组（短于 32 字节），数组元素与长度一起存储在同一个槽中。</p>
<p>具体地说：如果数据长度小于等于 <code>31</code>字节，则元素存储在高位字节（左对齐），最低位字节存储值 <code>length * 2</code>。如果数据长度大于等于 32 字节，则在主插槽 <code>p</code> 存储 <code>length * 2 + 1</code>，数据照常存储在 <code>keccak256(p)</code> 中。因此，可以通过检查是否设置了最低位：短（未设置最低位）和长（设置最低位）来区分短数组和长数组。</p>
<p>⚠️ 注意: 目前不支持处理无效编码的插槽，但可能在将来添加。如果你通过 IR 编译，读取一个无效的编码槽会导致 <code>Panic(0x22)</code> 错误。</p>
<h2 id="1-6-JSON-输出"><a href="#1-6-JSON-输出" class="headerlink" title="1.6 JSON 输出"></a>1.6 JSON 输出</h2><p>合约的存储布局可以通过 standard JSON interface 获取到。 输出 JSON 对象包含 2 个字段 <code>storage</code> 和 <code>types</code> 。<code>storage</code> 对象是一个数组。</p>
<p>文件： <code>fileA</code> 合约： <code>contract A &#123; uint x; &#125;</code>存储布局，它的每个元素有如下的形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;astId&quot;: 2,</span><br><span class="line">    &quot;contract&quot;: &quot;fileA:A&quot;,</span><br><span class="line">    &quot;label&quot;: &quot;x&quot;,</span><br><span class="line">    &quot;offset&quot;: 0,</span><br><span class="line">    &quot;slot&quot;: &quot;0&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;t_uint256&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个字段说明如下：</p>
<ul>
<li><code>astId</code> 是状态变量声明的 AST 节点的 id。</li>
<li><code>contract</code> 是合约的名称，包括其路径作为前缀。</li>
<li><code>label</code> 是状态变量的名称。</li>
<li><code>offset</code> 是根据编码在存储槽内以字节为单位的偏移量。</li>
<li><code>slot</code> 是状态变量所在或开始的存储槽。这个数字可能非常大，因此它的 JSON 值被表示为一个字符串。</li>
<li><code>type</code> 是一个标识符，作为变量类型信息的关键(如下所述)。</li>
</ul>
<p>给定的 <code>type</code>，在本例中 <code>t_uint256</code> 代表 <code>types</code>中的一个元素，其形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;encoding&quot;: &quot;inplace&quot;,</span><br><span class="line">    &quot;label&quot;: &quot;uint256&quot;,</span><br><span class="line">    &quot;numberOfBytes&quot;: &quot;32&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而</p>
<ul>
<li><pre><code>encoding
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  数据在存储中如何编码，可能的数值是：</span><br><span class="line"></span><br><span class="line">  - `inplace`: 数据在存储中连续排列 (见 前面状态变量储存结构`).</span><br><span class="line">  - `mapping`: Keccak-256 基于哈希的方法 (见 前面前面映射和动态数组`).</span><br><span class="line">  - `dynamic_array`: Keccak-256 基于哈希的方法 (见 前面映射和动态数组`).</span><br><span class="line">  - `bytes`: 单槽或基于 Keccak-256 哈希的方法，取决于数据大小 (见 前面 bytes).</span><br><span class="line"></span><br><span class="line">- `label` 是规范的类型名称 。</span><br><span class="line"></span><br><span class="line">- `numberOfBytes` 是使用的字节数(十进制字符串) 注意，如果`numberOfBytes&gt;32` 意味着使用了一个以上的槽。</span><br><span class="line"></span><br><span class="line">除了上述四个外，有些类型还有额外的信息。映射包含其 `key` 和 `value`类型(再次引用该类型映射中元素类型)，数组有其 `base` 类型，结构以与顶层`storage` 相同的格式列出其 `members` (见:ref:`前面JSON 输出`).</span><br><span class="line"></span><br><span class="line">⚠️ 注意: 合约的存储布局的 JSON 输出格式仍被认为是实验性的，即使在 Solidity 的非突破性版本更新中也可能会发生变化。</span><br><span class="line"></span><br><span class="line">#### 例子</span><br><span class="line"></span><br><span class="line">下面的例子显示了一个合约和它的存储布局，包含值类型和引用类型、被编码打包的类型和嵌套类型。</span><br><span class="line"></span><br><span class="line">```solidity</span><br><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.4.0 &lt;0.9.0;</span><br><span class="line">contract A &#123;</span><br><span class="line">    struct S &#123;</span><br><span class="line">        uint128 a;</span><br><span class="line">        uint128 b;</span><br><span class="line">        uint[2] staticArray;</span><br><span class="line">        uint[] dynArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint x;</span><br><span class="line">    uint y;</span><br><span class="line">    S s;</span><br><span class="line">    address addr;</span><br><span class="line">    mapping (uint =&gt; mapping (address =&gt; bool)) map;</span><br><span class="line">    uint[] array;</span><br><span class="line">    string s1;</span><br><span class="line">    bytes b1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;storage&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">15</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;x&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_uint256&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">17</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;y&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_uint256&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_struct(S)13_storage&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">22</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;addr&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_address&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">28</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;map&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_mapping(t_uint256,t_mapping(t_address,t_bool))&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">31</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;array&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_array(t_uint256)dyn_storage&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">33</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s1&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;9&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_string_storage&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">35</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b1&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_bytes_storage&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;t_address&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inplace&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;address&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;20&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;t_array(t_uint256)2_storage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;base&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_uint256&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inplace&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256[2]&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;64&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;t_array(t_uint256)dyn_storage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;base&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_uint256&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dynamic_array&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256[]&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;32&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;t_bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inplace&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bool&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;t_bytes_storage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bytes&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bytes&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;32&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;t_mapping(t_address,t_bool)&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mapping&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_address&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mapping(address =&gt; bool)&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;32&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_bool&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;t_mapping(t_uint256,t_mapping(t_address,t_bool))&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mapping&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_uint256&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mapping(uint256 =&gt; mapping(address =&gt; bool))&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;32&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_mapping(t_address,t_bool)&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;t_string_storage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bytes&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;32&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;t_struct(S)13_storage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inplace&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;struct A.S&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;members&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">				<span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_uint128&quot;</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_uint128&quot;</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;staticArray&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_array(t_uint256)2_storage&quot;</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dynArray&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_array(t_uint256)dyn_storage&quot;</span></span><br><span class="line">				<span class="punctuation">&#125;</span></span><br><span class="line">			<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;128&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;t_uint128&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inplace&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint128&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;16&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;t_uint256&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inplace&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;32&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="变量在-memory-布局"><a href="#变量在-memory-布局" class="headerlink" title="变量在 memory 布局"></a>变量在 memory 布局</h1><p>Solidity 保留了四个 32 字节的插槽，字节范围(包括端点)特定用途如下：</p>
<ul>
<li><code>0x00</code> - <code>0x3f</code> (64 字节): 用于哈希方法的<strong>暂存空间</strong>（临时空间）</li>
<li><code>0x40</code> - <code>0x5f</code> (32 字节): 当前分配的内存大小(也作为<strong>空闲内存指针</strong>)</li>
<li><code>0x60</code> - <code>0x7f</code> (32 字节): <strong>零位插槽</strong></li>
</ul>
<p><strong>暂存空间</strong>可以在语句之间使用 (例如在内联汇编中)。<strong>零位插槽</strong>用作动态内存数组的初始值，并且永远不应写入（空闲内存指针最初指向<code>0x80</code>）.Solidity 总是将新对象放在<strong>空闲内存指针</strong>上，并且内存永远不会被释放(将来可能会改变)。</p>
<p>Solidity 中的内存数组中的元素始终占据 32 字节的倍数（对于 <code>bytes1[]</code>总是这样，但不适用与 <code>bytes</code> 和 <code>string</code> ）。</p>
<p>多维内存数组是指向内存数组的指针，动态数组的长度存储在数组的第一个插槽中，然后是数组元素。</p>
<p>⚠️ 警告: Solidity 中有一些需要临时存储区的操作需要大于 64 个字节，因此无法放入暂存空间。它们将被放置在空闲内存指向的位置，但是由于使用寿命短，指针不会更新。内存可以归零，也可以不归零。因此，不应指望空闲内存指针指向归零内存区域。</p>
<p>尽管使用 <code>msize</code>到达绝对归零的内存区域似乎是一个好主意，但使用此类非临时指针而不更新空闲内存指针可能会产生意外结果。</p>
<h3 id="与存储中布局的不同"><a href="#与存储中布局的不同" class="headerlink" title="与存储中布局的不同"></a>与存储中布局的不同</h3><p>如上所述，在内存中的布局与在 <strong>存储中</strong> 有一些不同。下面是一些例子：</p>
<h4 id="数组的不同"><a href="#数组的不同" class="headerlink" title="数组的不同"></a>数组的不同</h4><p>下面的数组在存储中占用 32 字节（1 个槽），但在内存中占用 128 字节（4 个元素，每个 32 字节）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint8[4] a;</span><br></pre></td></tr></table></figure>

<h4 id="结构体的不同"><a href="#结构体的不同" class="headerlink" title="结构体的不同"></a>结构体的不同</h4><p>下面的结构体在存储中占用 96 (1 个槽，每个 32 字节) ，但在内存中占用 128<br>个字节（4 个元素每个 32 字节）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct S &#123;</span><br><span class="line">    uint a;</span><br><span class="line">    uint b;</span><br><span class="line">    uint8 c;</span><br><span class="line">    uint8 d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Call-Data-布局"><a href="#Call-Data-布局" class="headerlink" title="Call Data 布局"></a>Call Data 布局</h1><p>假定：函数调用的输入数据采用 ABI 规范。</p>
<p>其中，ABI 规范要求将参数填充为 32 的倍数 个字节。内部函数调用使用不同的约定。</p>
<p>合约构造函数的参数直接附加在合约代码的末尾，也采用 ABI 编码。构造函数将通过硬编码偏移量，而不是通过使用 <code>codesize</code> 操作码来访问它们，因为在将数据追加到代码时，它就会会改变。</p>
<h1 id="清理变量"><a href="#清理变量" class="headerlink" title="清理变量"></a>清理变量</h1><p>当一个值短于 256 位时，在某些情况下，剩余位必须被清理。编译器在设计时，会在操作数据之前清理这些剩余位，以避免剩余位中潜在垃圾数据在操作产生任何不利影响。</p>
<ul>
<li>在将一个值写入存储器之前，需要清除剩余的位，因为存储器的内容可以用于计算哈希值或作为消息调用的数据发送。</li>
<li>同样，在将一个值存储到存储器中之前，也需要清除剩余的位，因为否则可以观察到垃圾数据。</li>
<li>如果紧接着的操作不受影响，就不会清理位。例如，由于任何非零值都会被 <code>JUMPI</code> 指令认为是 <code>true</code>，所以在布尔值被用作条件判断之前，不需要清理它们。 <code>JUMPI</code>。</li>
<li>编译器会在将输入数据（input data）加载到堆栈时，会对其进行清理。</li>
</ul>
<p>⚠️ 注意：通过内联汇编的访问数据没有此操作。如果使用内联汇编来访问短于 256 位的 Solidity 变量，编译器不保证该值被正确清理。</p>
<p>不同的类型有不同的清理无效值的规则：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Valid Values</th>
<th>Invalid Values Mean</th>
</tr>
</thead>
<tbody><tr>
<td>enum of nmembers</td>
<td>0 until n - 1</td>
<td>exception</td>
</tr>
<tr>
<td>bool</td>
<td>0 or 1</td>
<td>1</td>
</tr>
<tr>
<td>signed integers</td>
<td>sign-extended word</td>
<td>currently silently wraps; in the future exceptions will be thrown</td>
</tr>
<tr>
<td>unsigned integers</td>
<td>higher bits zeroed</td>
<td>currently silently wraps; in the future exceptions will be thrown</td>
</tr>
</tbody></table>
<h1 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h1><ul>
<li>存储大小少于 32 字节的多个变量会被打包到一个存储插槽(storage slot)中，规则是什么？<ul>
<li>存储插槽的第一项会以低位对齐的方式储存。</li>
<li>值类型仅使用存储它们所需的字节。</li>
<li>如果存储插槽中的剩余空间不足以储存一个值类型，那么它会被存入下一个存储插槽。</li>
<li>结构体（struct）和数组数据总是会开启一个新插槽（但结构体或数组中的各元素，则按规则紧密打包）。</li>
<li>结构体和数组之后的数据也或开启一个新插槽。</li>
</ul>
</li>
<li>在使用小于 32 字节的变量时，合约的 gas 使用量可能会高于使用 32 字节的元素。为什么？<ul>
<li>这是因为 EVM 每次操作 32 个字节，所以如果元素比 32 字节小，EVM 必须执行额外的操作以便将其大小缩减到到所需的大小。</li>
</ul>
</li>
<li>Solidity 保留了四个 32 字节的插槽，分别是什么，用来做什么？<ul>
<li><code>0x00</code> - <code>0x3f</code> (64 字节): 用于哈希方法的<strong>暂存空间</strong>（临时空间）</li>
<li><code>0x40</code> - <code>0x5f</code> (32 字节): 当前分配的内存大小(也作为<strong>空闲内存指针</strong>)</li>
<li><code>0x60</code> - <code>0x7f</code> (32 字节): <strong>零位插槽</strong></li>
<li><strong>暂存空间</strong>可以在语句之间使用 (例如在内联汇编中)。<strong>零位插槽</strong>用作动态内存数组的初始值，并且永远不应写入（空闲内存指针最初指向<code>0x80</code>）.Solidity 总是将新对象放在<strong>空闲内存指针</strong>上，并且内存永远不会被释放(将来可能会改变)。</li>
</ul>
</li>
<li>memory 与 storge 之间不同之处有哪些？<ul>
<li>数组的不同</li>
<li>结构体的不同</li>
<li>原因都是因为内存中每条数据都单独占 32 字节，而在 storge 里，可以储存在一个存储插槽中。</li>
</ul>
</li>
<li>calldata 布局<ul>
<li>函数调用的输入数据采用 ABI 规范。</li>
<li>ABI 规范要求将参数填充为 32 的倍数 个字节。</li>
<li>合约构造函数的参数直接附加在合约代码的末尾，也采用 ABI 编码。构造函数将通过硬编码偏移量，而不是通过使用 <code>codesize</code> 操作码来访问它们，因为在将数据追加到代码时，它就会会改变。</li>
</ul>
</li>
<li>聊一聊清理变量<ul>
<li>当一个值短于 256 位时，在某些情况下，剩余位必须被清理。编译器在设计时，会在操作数据之前清理这些剩余位，以避免剩余位中潜在垃圾数据在操作产生任何不利影响。</li>
<li>在将一个值写入存储器之前，需要清除剩余的位，因为存储器的内容可以用于计算哈希值或作为消息调用的数据发送。</li>
<li>同样，在将一个值存储到存储器中之前，也需要清除剩余的位，因为否则可以观察到垃圾数据。</li>
<li>如果紧接着的操作不受影响，就不会清理位。例如，由于任何非零值都会被 <code>JUMPI</code> 指令认为是 <code>true</code>，所以在布尔值被用作条件判断之前，不需要清理它们。 <code>JUMPI</code>。</li>
<li>编译器会在将输入数据（input data）加载到堆栈时，会对其进行清理。</li>
<li>⚠️ 注意：通过内联汇编的访问数据没有此操作。如果使用内联汇编来访问短于 256 位的 Solidity 变量，编译器不保证该值被正确清理。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/07/26/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/18-ABI%E7%BC%96%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/26/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/18-ABI%E7%BC%96%E7%A0%81/" class="post-title-link" itemprop="url">18-ABI编码</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-26 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-26T00:00:00+08:00">2022-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ABI 是应用二进制接口，ABI 是从区块链外部与合约进行交互以及合约与合约间进行交互的一种标准方式。数据会根据其类型进行编码。需要一种特定的概要（schema）来进行解码。</p>
<p>对于一些没有开源的代码，我们可以通过区块链上传入的参数，来反推数据结构，根据方法的结果，来反推内部实现逻辑。经常听到一些没有开源的合约被盗，基本就是被别人通过 ABI 编码反推来寻找漏洞的。</p>
<h1 id="ABI-类型编码"><a href="#ABI-类型编码" class="headerlink" title="ABI 类型编码"></a>ABI 类型编码</h1><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><ul>
<li><code>uint&lt;M&gt;</code>： <code>M</code> 位的无符号整数， <code>0 &lt; M &lt;= 256</code>、<code>M % 8 == 0</code>。例如： <code>uint32</code>， <code>uint8</code>， <code>uint256</code>。</li>
<li><code>int&lt;M&gt;</code>：以 2 的补码作为符号的 <code>M</code> 位整数， <code>0 &lt; M &lt;= 256</code>、<code>M % 8 == 0</code>。</li>
<li><code>address</code>：除了字面上的意思和语言类型的区别以外，等价于<code>uint160</code>。在计算和 函数选择器(function selector) 中，通常使用 <code>address</code>。</li>
<li><code>uint</code>、 <code>int</code>： <code>uint256</code>、 <code>int256</code> 各自的同义词。在计算和函数选择器(function selector) 中，通常使用 <code>uint256</code> 和 <code>int256</code>。</li>
<li><code>bool</code>：等价于 <code>uint8</code>，取值限定为 0 或 1 。在计算和函数选择器(function selector) 中，通常使用 <code>bool</code>。</li>
<li><code>fixed&lt;M&gt;x&lt;N&gt;</code>： <code>M</code> 位的有符号的固定小数位的十进制数字<code>8 &lt;= M &lt;= 256</code>、 <code>M % 8 == 0</code>、且 <code>0 &lt; N &lt;= 80</code>。其值 <code>v</code> 即是<code>v / (10 ** N)</code>。</li>
<li><code>ufixed&lt;M&gt;x&lt;N&gt;</code>：无符号的 <code>fixed&lt;M&gt;x&lt;N&gt;</code>。</li>
<li><code>fixed</code>、 <code>ufixed</code>： <code>fixed128x18</code>、 <code>ufixed128x18</code>各自的同义词。在计算和 函数选择器(function selector) 中，通常使用<code>fixed128x18</code> 和 <code>ufixed128x18</code>。</li>
<li><code>bytes&lt;M&gt;</code>： <code>M</code> 字节的二进制类型， <code>0 &lt; M &lt;= 32</code>。</li>
<li><code>function</code>：一个地址（20 字节）之后紧跟一个 函数选择器(function selector)（4 字节）。编码之后等价于 <code>bytes24</code>。</li>
</ul>
<h3 id="定长数组类型"><a href="#定长数组类型" class="headerlink" title="定长数组类型"></a>定长数组类型</h3><ul>
<li><type>[M]：有M个元素的定长数组，M &gt;&#x3D; 0，数组元素为给定类型。<ul>
<li>⚠️：尽管此 ABI 规范可以表示零个元素的定长数组，但编译器不支持它们。</li>
</ul>
</li>
</ul>
<h3 id="非定长类型："><a href="#非定长类型：" class="headerlink" title="非定长类型："></a>非定长类型：</h3><ul>
<li><p><code>bytes</code>：动态大小的字节序列。</p>
</li>
<li><p><code>string</code>：动态大小的 unicode 字符串，通常呈现为 UTF-8 编码。</p>
</li>
<li><p><type>[]：元素为给定类型的变长数组。</p>
<ul>
<li>可以将若干类型放到一对括号中，用逗号分隔开，以此来构成一个 元组(tuple)：</li>
</ul>
</li>
<li><p><code>(T1,T2,...,Tn)</code>：由 <code>T1</code>，…， <code>Tn</code>， <code>n &gt;= 0</code> 构成的 元组(tuple)。</p>
</li>
</ul>
<p>用 元组(tuple) 构成 元组(tuple)、用 元组(tuple)构成数组等等也是可能的。另外也可以构成”零元组（zero-tuples）”，就是<br><code>n = 0</code> 的情况。</p>
<h3 id="不支持-ABI-的-Solidity-类型"><a href="#不支持-ABI-的-Solidity-类型" class="headerlink" title="不支持 ABI 的 Solidity 类型"></a>不支持 ABI 的 Solidity 类型</h3><p>Solidity 支持上面介绍的所有同名称的类型，除元组外。 另一方面，一些 Solidity 类型不被 ABI 支持。下表在左栏显示了不支持 ABI 的 Solidity 类型，以及在右栏显示可以代表它们的 ABI 类型。</p>
<table>
<thead>
<tr>
<th>Solidity</th>
<th>ABI</th>
</tr>
</thead>
<tbody><tr>
<td>address payable</td>
<td><code>address</code></td>
</tr>
<tr>
<td>contract</td>
<td><code>address</code></td>
</tr>
<tr>
<td>enum</td>
<td><code>uint8</code></td>
</tr>
<tr>
<td>user defined value types</td>
<td>its underlying value type</td>
</tr>
<tr>
<td>struct</td>
<td><code>tuple</code></td>
</tr>
</tbody></table>
<p>⚠️: 在 <code>0.8.0</code> 版本之前，枚举（enums） 可以多余 256 个成员并且可以使用最小可保存的整型来保存他们。</p>
<h1 id="ABI编码的设计准则"><a href="#ABI编码的设计准则" class="headerlink" title="ABI编码的设计准则"></a>ABI编码的设计准则</h1><p>我们现在来正式讲述编码，它具有如下属性，如果参数是嵌套的数组，这些属性非常有用：</p>
<ol>
<li>读取的次数取决于参数数组结构中的最大深度；也就是说，要取得<code>a_i[k][l][r]</code> 需要读取 4 次。</li>
<li>变量或数组元素的数据不与其他数据交错，并且它是可以再定位的。它们只会使用相对的”地址”。</li>
</ol>
<h1 id="编码的形式化说明"><a href="#编码的形式化说明" class="headerlink" title="编码的形式化说明"></a>编码的形式化说明</h1><p>我们需要区分静态和动态类型。静态类型会被直接编码，动态类型则会在当前数据块之后单独分配的位置被编码。</p>
<p><strong>定义：</strong> 以下类型被称为”动态”：</p>
<ul>
<li><code>bytes</code></li>
<li><code>string</code></li>
<li>任意类型 <code>T</code> 的变长数组 <code>T[]</code></li>
<li>任意动态类型 <code>T</code> 的定长数组 <code>T[k]</code> （ <code>k &gt;= 0</code>）</li>
<li>由动态的 <code>Ti</code> （ <code>1 &lt;= i &lt;= k</code>）构成的 元组(tuple) <code>(T1,...,Tk)</code></li>
</ul>
<p>所有其他类型都被称为”静态”。</p>
<p><strong>定义：</strong> <code>len(a)</code> 是一个二进制字符串 <code>a</code> 的字节长度。 <code>len(a)</code>的类型被呈现为 <code>uint256</code>。</p>
<p>我们把实际的编码 <code>enc</code>定义为一个由 ABI 类型到二进制字符串的值的映射；因而，当且仅当 <code>X</code>的类型是动态的， <code>len(enc(X))</code> （即 <code>X</code>经编码后的实际长度，译者注）才会依赖于 <code>X</code> 的值。</p>
<p><strong>定义：</strong> 对任意 ABI 值 <code>X</code>，我们根据 <code>X</code> 的实际类型递归地定义 <code>enc(X)</code>。</p>
<ul>
<li><p><code>(T1,...,Tk)</code> 对于 <code>k &gt;= 0</code> 且任意类型 <code>T1</code> ,…, <code>Tk</code></p>
<p><code>enc(X) = head(X(1)) ... head(X(k)) tail(X(1)) ... tail(X(k))</code></p>
<p>这里， <code>X = (X(1), ..., X(k))</code>，并且 当 <code>Ti</code> 为静态类型时， <code>head</code>和 <code>tail</code> 被定义为<code>head(X(i)) = enc(X(i))</code> and <code>tail(X(i)) = &quot;&quot;</code> （空字符串）否则，比如 <code>Ti</code> 是动态类型时，它们被定义为</p>
</li>
</ul>
<p><code>head(X(i)) = enc(len(head(X(1)) ... head(X(k-1)) tail(X(1)) ... tail(X(i-1))))</code><br>  <code>tail(X(i)) = enc(X(i))</code></p>
<p>  注意，在动态类型的情况下，由于 head部分的长度仅取决于类型而非值，所以 <code>head(X(i))</code>是定义明确的。它的值是从 <code>enc(X)</code> 的开头算起的，<code>tail(X(i))</code>的起始位在 <code>enc(X)</code> 中的偏移量。</p>
<ul>
<li><p><code>T[k]</code> 对于任意 <code>T</code> 和 <code>k</code>：<code>enc(X) = enc((X[0], ..., X[k-1]))</code>即是说，它就像是个由相同类型的 <code>k</code> 个元素组成的 元组(tuple)那样被编码的。</p>
</li>
<li><p><code>T[]</code> 当 <code>X</code> 有 <code>k</code> 个元素（ <code>k</code> 被呈现为类型 <code>uint256</code>）：<code>enc(X) = enc(k) enc([X[1], ..., X[k]])</code>即是说，它就像是个由静态大小 <code>k</code>的数组那样被编码的，且由元素的个数作为前缀。</p>
</li>
<li><p>具有 <code>k</code> （呈现为类型 <code>uint256</code>）长度的 <code>bytes</code>：<code>enc(X) = enc(k) pad_right(X)</code>，即是说，字节数被编码为<code>uint256</code>，紧跟着实际的 <code>X</code> 的字节码序列，再在高位（左侧）补上可以使<code>len(enc(X))</code> 成为 32 的倍数的最少数量的 0 值字节数据。</p>
</li>
<li><p><code>string</code>：<code>enc(X) = enc(enc_utf8(X))</code>，即是说， <code>X</code> 被 UFT-8<br>编码，且在后续编码中将这个值解释为 <code>bytes</code>类型。注意，在随后的编码中使用的长度是其 UFT-8编码的字符串的字节数，而不是其字符数。</p>
</li>
<li><p><code>uint&lt;M&gt;</code>： <code>enc(X)</code> 是在 <code>X</code> 的大端序编码的高位（左侧）补充若干 0值字节以使其长度成为 32 字节。</p>
</li>
<li><p><code>address</code>：与 <code>uint160</code> 的情况相同。</p>
</li>
<li><p><code>int&lt;M&gt;</code>： <code>enc(X)</code> 是在 <code>X</code> 的大端序的 2的补码编码的高位（左侧）添加若干字节数据以使其长度成为 32字节；对于负数，添加值为 <code>0xff</code> （即 8 位全为1，译者注）的字节数据，对于非负数，添加 0 值（即 8 位全为0，译者注）字节数据。</p>
</li>
<li><p><code>bool</code>：与 <code>uint8</code> 的情况相同， <code>1</code> 用来表示 <code>true</code>， <code>0</code> 表示<code>false</code>。</p>
</li>
<li><p><code>fixed&lt;M&gt;x&lt;N&gt;</code>： <code>enc(X)</code> 就是 <code>enc(X * 10**N)</code>，其中 <code>X * 10**N</code>可以理解为 <code>int256</code>。</p>
</li>
<li><p><code>fixed</code>：与 <code>fixed128x18</code> 的情况相同。</p>
</li>
<li><p><code>ufixed&lt;M&gt;x&lt;N&gt;</code>： <code>enc(X)</code> 就是 <code>enc(X * 10**N)</code>，其中 <code>X * 10**N</code>可以理解为 <code>uint256</code>。</p>
</li>
<li><p><code>ufixed</code>：与 <code>ufixed128x18</code> 的情况相同。</p>
</li>
<li><p><code>bytes&lt;M&gt;</code>： <code>enc(X)</code> 就是 <code>X</code> 的字节序列加上为使长度成为 32字节而添加的若干 0 值字节。</p>
</li>
</ul>
<p>注意，对于任意的 <code>X</code>， <code>len(enc(X))</code> 都是 32 的倍数。</p>
<h1 id="函数选择器和参数编码"><a href="#函数选择器和参数编码" class="headerlink" title="函数选择器和参数编码"></a>函数选择器和参数编码</h1><p>函数选择器(function selector)：以 <code>a_1, ..., a_n</code> 为参数的对 <code>f</code> 函数的调用，会被编码为<code>function_selector(f) enc((a_1, ..., a_n))</code>，<code>f</code> 的返回值 <code>v_1, ..., v_k</code> 会被编码为 <code>enc((v_1, ..., v_k))</code>，也就是说，返回值会被组合为一个 元组(tuple) 进行编码。</p>
<h3 id="函数选择器-function-selector"><a href="#函数选择器-function-selector" class="headerlink" title="函数选择器 function selector"></a>函数选择器 function selector</h3><p>这个在 <a target="_blank" rel="noopener" href="https://www.axihe.com/source/04.function.html#id19">函数的签名</a> 那里已经详细介绍过，之类做一个小总结。</p>
<p>一个函数调用数据的前 4 字节，指定了要调用的函数。这就是某个函数签名的 Keccak 哈希的前 4 字节（bytes32 类型是从左取值）。</p>
<p>函数签名被定义为基础原型的规范表达，而基础原型是<strong>函数名称加上由括号括起来的参数类型列表，参数类型间由一个逗号分隔开，且没有空格。</strong>.</p>
<p>⚠️ 注意: 函数的返回类型并不是函数签名的一部分。在 <a target="_blank" rel="noopener" href="https://www.axihe.com/source/04.function.html#id21">Solidity 的函数重载</a> 中，返回值并没有被考虑。这是为了使对函数调用的解析保持上下文无关。 然而 metadata 的描述中即包含了输入也包含了输出。（参考 <a target="_blank" rel="noopener" href="https://www.axihe.com/source/17.metadata.html">JSON ABI</a>）。</p>
<h3 id="参数编码"><a href="#参数编码" class="headerlink" title="参数编码"></a>参数编码</h3><p>从第 5 字节开始是被编码的参数。这种编码方式也被用在其他地方，比如，返回值和事件的参数也会被用同样的方式进行编码，而用来指定函数的 4 个字节则不需要再进行编码。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>给定一个合约：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.4.16 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">  function bar(bytes3[2]) public pure &#123;&#125;</span><br><span class="line">  function baz(uint32 x, bool y) public pure returns (bool r) &#123; r = x &gt; 32 || y; &#125;</span><br><span class="line">  function sam(bytes, bool, uint[]) public pure &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用-baz"><a href="#调用-baz" class="headerlink" title="调用 baz"></a>调用 baz</h3><p>这样，对于我们的例子 <code>Foo</code>，如果我们想用 <code>69</code> 和 <code>true</code> 做参数调用 <code>baz</code>，我们总共需要传送 68 字节，可以分解为：</p>
<ul>
<li><code>0xcdcd77c0</code>：方法 ID。这源自 ASCII 格式的 <code>baz(uint32,bool)</code> 签名的<br>Keccak 哈希的前 4 字节。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000045</code>：第一个参数，一个被用<br>0 值字节补充到 32 字节的 uint32 值 <code>69</code>。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：第二个参数，一个被用<br>0 值字节补充到 32 字节的 boolean 值 <code>true</code>。</li>
</ul>
<p>合起来就是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xcdcd77c0</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000045</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000001</span><br></pre></td></tr></table></figure>

<p>它返回一个 <code>bool</code>。比如它返回 <code>false</code>，那么它的输出将是一个字节数组<br><code>0x0000000000000000000000000000000000000000000000000000000000000000</code>，一个 bool 值。</p>
<h3 id="调用-bar"><a href="#调用-bar" class="headerlink" title="调用 bar"></a>调用 bar</h3><p>如果我们想用 <code>[&quot;abc&quot;, &quot;def&quot;]</code> 做参数调用<code>bar</code>，我们总共需要传送 68 字节，可以分解为：</p>
<ul>
<li><code>0xfce353f6</code>：方法 ID。源自 <code>bar(bytes3[2])</code> 的签名。</li>
<li><code>0x6162630000000000000000000000000000000000000000000000000000000000</code>：第一个参数的第一部分，一个<code>bytes3</code> 值 <code>&quot;abc&quot;</code> （左对齐）。</li>
<li><code>0x6465660000000000000000000000000000000000000000000000000000000000</code>：第一个参数的第二部分，一个 <code>bytes3</code> 值 <code>&quot;def&quot;</code> （左对齐）。</li>
</ul>
<p>合起来就是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xfce353f6</span><br><span class="line">6162630000000000000000000000000000000000000000000000000000000000</span><br><span class="line">6465660000000000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure>

<h3 id="调用-sam"><a href="#调用-sam" class="headerlink" title="调用 sam"></a>调用 sam</h3><p>如果我们想用 <code>&quot;dave&quot;</code>、 <code>true</code> 和 <code>[1,2,3]</code> 作为参数调用<code>sam</code>，我们总共需要传送 292 字节，可以分解为：</p>
<ul>
<li><code>0xa5643bf2</code>：方法 ID。源自 <code>sam(bytes,bool,uint256[])</code>的签名。注意， <code>uint</code> 被替换为了它的权威代表 <code>uint256</code>。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000060</code>：第一个参数（动态类型）的数据部分的位置，即从参数编码块开始位置算起的字节数。在这里，是 <code>0x60</code> 。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：第二个参数：boolean 的 true。</li>
<li><code>0x00000000000000000000000000000000000000000000000000000000000000a0</code>：第三个参数（动态类型）的数据部分的位置，由字节数计量。在这里，是<code>0xa0</code>。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000004</code>：第一个参数的数据部分，以字节数组的元素个数作为开始，在这里，是 4。</li>
<li><code>0x6461766500000000000000000000000000000000000000000000000000000000</code>：第一个参数的内容 <code>&quot;dave&quot;</code> 的 UTF-8 编码（在这里等同于 ASCII 编码），并在右侧（低位）用 0 值字节补充到 32 字节。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000003</code>：第三个参数的数据部分，以数组的元素个数作为开始，在这里，是 3。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：第三个参数的第一个数组元素。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000002</code>：第三个参数的第二个数组元素。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000003</code>：第三个参数的第三个数组元素。</li>
</ul>
<p>合起来就是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0xa5643bf2</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000060</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000001</span><br><span class="line">00000000000000000000000000000000000000000000000000000000000000a0</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000004</span><br><span class="line">6461766500000000000000000000000000000000000000000000000000000000</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000003</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000001</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000003</span><br></pre></td></tr></table></figure>

<h1 id="动态类型的使用"><a href="#动态类型的使用" class="headerlink" title="动态类型的使用"></a>动态类型的使用</h1><h3 id="例子-1-静态和动态混合"><a href="#例子-1-静态和动态混合" class="headerlink" title="例子 1:静态和动态混合"></a>例子 1:静态和动态混合</h3><p>用参数 <code>(0x123, [0x456, 0x789], &quot;1234567890&quot;, &quot;Hello, world!&quot;)</code> 进行对函数 <code>f(uint,uint32[],bytes10,bytes)</code> 的调用会通过以下方式进行编码：</p>
<p>取得 <code>sha3(&quot;f(uint256,uint32[],bytes10,bytes)&quot;)</code> 的前 4 字节，也就是 <code>0x8be65246</code>。 然后我们对所有 4 个参数的头部进行编码。对静态类型 <code>uint256</code> 和 <code>bytes10</code> 是可以直接传过去的值；对于动态类型 <code>uint32[]</code> 和 <code>bytes</code>，<strong>我们使用的字节数偏移量是它们的数据区域的起始位置，由需编码的值的开始位置算起</strong>（也就是说，不计算包含了函数签名的前 4 字节），这就是：</p>
<p><strong>基础部分</strong>：</p>
<ul>
<li><code>0x8be65246</code></li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000123</code> <code>0x123</code> 补充到 32 字节）</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000080</code>（第二个参数的数据部分起始位置的偏移量，<code>4*32</code> 字节，正好是头部的大小）</li>
<li><code>0x3132333435363738393000000000000000000000000000000000000000000000</code>（<code>&quot;1234567890&quot;</code> 从右边补充到 32 字节）</li>
<li><code>0x00000000000000000000000000000000000000000000000000000000000000e0</code>（第四个参数的数据部分起始位置的偏移量 &#x3D;<br>第一个动态参数的数据部分起始位置的偏移量 + 第一个动态参数的数据部分的长度 &#x3D; <code>4*32 + 3*32</code>，参考后文）</li>
</ul>
<p><strong>动态部分</strong>：</p>
<p>在此之后，跟着<strong>第一个动态参数</strong>的数据部分 <code>[0x456, 0x789]</code>：</p>
<ul>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000002</code>（数组元素个数，2）</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000456</code>（第一个数组元素）</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000789</code>（第二个数组元素）</li>
</ul>
<p>最后，我们将<strong>第二个动态参数</strong>的数据部分 <code>&quot;Hello, world!&quot;</code> 进行编码：</p>
<ul>
<li><code>0x000000000000000000000000000000000000000000000000000000000000000d</code>（元素个数，在这里是字节数：13）</li>
<li><code>0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000</code>（ <code>&quot;Hello, world!&quot;</code> 从右边补充到 32 字节）</li>
</ul>
<p>最后，合并到一起的编码就是（为了清晰，在 函数选择器(function selector) 和每 32 字节之后加了换行）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x8be65246</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000123</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000080</span><br><span class="line">3132333435363738393000000000000000000000000000000000000000000000</span><br><span class="line">00000000000000000000000000000000000000000000000000000000000000e0</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000456</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000789</span><br><span class="line">000000000000000000000000000000000000000000000000000000000000000d</span><br><span class="line">48656c6c6f2c20776f726c642100000000000000000000000000000000000000</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="例子-2-纯动态参数"><a href="#例子-2-纯动态参数" class="headerlink" title="例子 2: 纯动态参数"></a>例子 2: 纯动态参数</h3><p>让我们使用相同的原理来对一个签名为 <code>g(uint[][],string[])</code>，参数值为<code>([[1, 2], [3]], [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])</code>的函数来进行编码；但从最原子的部分开始：</p>
<p>首先我们将第一个根数组 <code>[[1, 2], [3]]</code> 的第一个嵌入的动态数组 <code>[1, 2]</code>的长度和数据进行编码：</p>
<ul>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000002</code>(第一个数组中的元素数量 2；元素本身是 <code>1</code> 和 <code>2</code>)</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>(第一个元素)</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000002</code>(第二个元素)</li>
</ul>
<p>然后我们将第一个根数组 <code>[[1, 2], [3]]</code> 的第二个潜入的动态数组 <code>[3]</code>的长度和数据进行编码：</p>
<ul>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>(第二个数组中的元素数量 1；元素数据是 <code>3</code>)</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000003</code>(第一个元素)</li>
</ul>
<p>然后我们需要找到动态数组 <code>[1, 2]</code> 和 <code>[3]</code>的偏移量。要计算这个偏移量，我们可以来看一下第一个根数组 <code>[[1, 2], [3]]</code>编码后的具体数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 - a                                                                - [1, 2] 的偏移量</span><br><span class="line">1 - b                                                                - [3] 的偏移量</span><br><span class="line">2 - 0000000000000000000000000000000000000000000000000000000000000002 - [1, 2] 的计数</span><br><span class="line">3 - 0000000000000000000000000000000000000000000000000000000000000001 - 1 的编码</span><br><span class="line">4 - 0000000000000000000000000000000000000000000000000000000000000002 - 2 的编码</span><br><span class="line">5 - 0000000000000000000000000000000000000000000000000000000000000001 - [3] 的计数</span><br><span class="line">6 - 0000000000000000000000000000000000000000000000000000000000000003 - 3 的编码</span><br></pre></td></tr></table></figure>

<p>偏移量 <code>a</code> 指向数组 <code>[1, 2]</code> 内容的开始位置，即第 2 行的开始（64 字节）；所以 <code>a = 0x0000000000000000000000000000000000000000000000000000000000000040</code>。</p>
<p>偏移量 <code>b</code> 指向数组 <code>[3]</code> 内容的开始位置，即第 5 行的开始（160 字节）；所以 <code>b = 0x00000000000000000000000000000000000000000000000000000000000000a0</code>。</p>
<p>然后我们对第二个根数组的嵌入字符串进行编码：</p>
<ul>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000003</code>(单词 <code>&quot;one&quot;</code> 中的字符个数)</li>
<li><code>0x6f6e650000000000000000000000000000000000000000000000000000000000</code>(单词 <code>&quot;one&quot;</code> 的 utf8 编码)</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000003</code>(单词 <code>&quot;two&quot;</code> 中的字符个数)</li>
<li><code>0x74776f0000000000000000000000000000000000000000000000000000000000</code>(单词 <code>&quot;two&quot;</code> 的 utf8 编码)</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000005</code>(单词 <code>&quot;three&quot;</code> 中的字符个数)</li>
<li><code>0x7468726565000000000000000000000000000000000000000000000000000000</code>(单词 <code>&quot;three&quot;</code> 的 utf8 编码)</li>
</ul>
<p>作为与第一个根数组的并列，因为字符串也属于动态元素，我们也需要找到它们的偏移量 <code>c</code>, <code>d</code> 和 <code>e</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 - c                                                                - &quot;one&quot; 的偏移量</span><br><span class="line">1 - d                                                                - &quot;two&quot; 的偏移量</span><br><span class="line">2 - e                                                                - &quot;three&quot; 的偏移量</span><br><span class="line">3 - 0000000000000000000000000000000000000000000000000000000000000003 - &quot;one&quot; 的字符计数</span><br><span class="line">4 - 6f6e650000000000000000000000000000000000000000000000000000000000 - &quot;one&quot; 的编码</span><br><span class="line">5 - 0000000000000000000000000000000000000000000000000000000000000003 - &quot;two&quot; 的字符计数</span><br><span class="line">6 - 74776f0000000000000000000000000000000000000000000000000000000000 - &quot;two&quot; 的编码</span><br><span class="line">7 - 0000000000000000000000000000000000000000000000000000000000000005 - &quot;three&quot; 的字符计数</span><br><span class="line">8 - 7468726565000000000000000000000000000000000000000000000000000000 - &quot;three&quot; 的编码</span><br></pre></td></tr></table></figure>

<p>偏移量 <code>c</code> 指向字符串 <code>&quot;one&quot;</code> 内容的开始位置，即第 3 行的开始（96 字节）；所以<code>c = 0x0000000000000000000000000000000000000000000000000000000000000060</code>。</p>
<p>偏移量 <code>d</code> 指向字符串 <code>&quot;two&quot;</code> 内容的开始位置，即第 5 行的开始（160 字节）；所以<code>d = 0x00000000000000000000000000000000000000000000000000000000000000a0</code>。</p>
<p>偏移量 <code>e</code> 指向字符串 <code>&quot;three&quot;</code> 内容的开始位置，即第 7 行的开始（224 字节）；所以<code>e = 0x00000000000000000000000000000000000000000000000000000000000000e0</code>。</p>
<p>注意，根数组的嵌入元素的编码并不互相依赖，且具有对于函数签名<code>g(string[],uint[][])</code> 所相同的编码。</p>
<p>然后我们对第一个根数组的长度进行编码：</p>
<ul>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000002</code>(第一个根数组的元素数量 2；这些元素本身是 <code>[1, 2]</code> 和 <code>[3]</code>)</li>
</ul>
<p>而后我们对第二个根数组的长度进行编码：</p>
<ul>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000003</code>(第二个根数组的元素数量 3；这些字符串本身是 <code>&quot;one&quot;</code>、<code>&quot;two&quot;</code> 和<code>&quot;three&quot;</code>)</li>
</ul>
<p>最后，我们找到根动态数组元素 <code>[[1, 2], [3]]</code> 和<code>[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</code> 的偏移量 <code>f</code> 和 <code>g</code>。汇编数据的正确顺序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0x2289b18c                                                            - 函数签名</span><br><span class="line"> 0 - f                                                                - [[1, 2], [3]] 的偏移量</span><br><span class="line"> 1 - g                                                                - 第二个参数的偏移量</span><br><span class="line"> 2 - 0000000000000000000000000000000000000000000000000000000000000002 - [[1, 2], [3]] 元素计数</span><br><span class="line"> 3 - 0000000000000000000000000000000000000000000000000000000000000040 - [1, 2] 的偏移量</span><br><span class="line"> 4 - 00000000000000000000000000000000000000000000000000000000000000a0 - [3] 的偏移量</span><br><span class="line"> 5 - 0000000000000000000000000000000000000000000000000000000000000002 - [1, 2] 的元素计数</span><br><span class="line"> 6 - 0000000000000000000000000000000000000000000000000000000000000001 - 1 的编码</span><br><span class="line"> 7 - 0000000000000000000000000000000000000000000000000000000000000002 - 2 的编码</span><br><span class="line"> 8 - 0000000000000000000000000000000000000000000000000000000000000001 - [3] 的元素计数</span><br><span class="line"> 9 - 0000000000000000000000000000000000000000000000000000000000000003 - 3 的编码</span><br><span class="line">10 - 0000000000000000000000000000000000000000000000000000000000000003 - 第二个参数元素计数</span><br><span class="line">11 - 0000000000000000000000000000000000000000000000000000000000000060 - &quot;one&quot; 的偏移量</span><br><span class="line">12 - 00000000000000000000000000000000000000000000000000000000000000a0 - &quot;two&quot; 的偏移量</span><br><span class="line">13 - 00000000000000000000000000000000000000000000000000000000000000e0 - &quot;three&quot; 的偏移量</span><br><span class="line">14 - 0000000000000000000000000000000000000000000000000000000000000003 - &quot;one&quot; 的字符计数</span><br><span class="line">15 - 6f6e650000000000000000000000000000000000000000000000000000000000 - &quot;one&quot; 的编码</span><br><span class="line">16 - 0000000000000000000000000000000000000000000000000000000000000003 - &quot;two&quot; 的字符计数</span><br><span class="line">17 - 74776f0000000000000000000000000000000000000000000000000000000000 - &quot;two&quot; 的编码</span><br><span class="line">18 - 0000000000000000000000000000000000000000000000000000000000000005 - &quot;three&quot; 的字符计数</span><br><span class="line">19 - 7468726565000000000000000000000000000000000000000000000000000000 - &quot;three&quot; 的编码</span><br></pre></td></tr></table></figure>

<p>偏移量 <code>f</code> 指向数组 <code>[[1, 2], [3]]</code> 内容的开始位置，即第 2 行的开始（64 字节）；所以<code>f = 0x0000000000000000000000000000000000000000000000000000000000000040</code>。</p>
<p>偏移量 <code>g</code> 指向数组 <code>[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</code> 内容的开始位置，即第 10 行的开始（320 字节）；所以 <code>g = 0x0000000000000000000000000000000000000000000000000000000000000140</code>。</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>事件是以太坊的日志，事件是监视协议的一个抽象。日志项提供了合约的地址、一系列的<code>indexed</code>（最多 4 项）和一些任意长度的二进制数据。为了使用合适的类型数据结构来演绎这些功能，事件沿用了既存的 ABI 函数。</p>
<p>给定了事件名称和事件参数之后，我们将其分解为两个子集：已索引的和未索引的。已索引的部分，最多有 3 个（对于非匿名事件）或 4 个（对于匿名事件），被用来与事件签名的 Keccak 哈希一起组成日志项的主题。未索引的部分就组成了事件的字节数组。</p>
<p>这样，一个使用 ABI 的日志项就可以描述为：</p>
<ul>
<li><p><code>address</code>：合约地址（由 以太坊 真正提供）；</p>
</li>
<li><p>topics[0]：keccak(EVENT_NAME+”(“+EVENT_ARGS.map(canonical_type_of).join(“,”)+”)”)</p>
<ul>
<li>（ <code>canonical_type_of</code> 是一个可以返回给定参数的权威类型的函数，例如，对 <code>uint indexed foo</code> 它会返回 <code>uint256</code>）。</li>
<li>如果事件被声明为 <code>anonymous</code>，那么 <code>topics[0]</code> 不会被生成；</li>
</ul>
</li>
<li><p>topics[n]：</p>
<ul>
<li>如果不是匿名事件，为 <code>abi_encode(EVENT_INDEXED_ARGS[n - 1])</code></li>
<li>否则则为 <code>abi_encode(EVENT_INDEXED_ARGS[n])</code>（ <code>EVENT_INDEXED_ARGS</code> 是已索引的 <code>EVENT_ARGS</code>）；</li>
</ul>
</li>
<li><p>data：abi_serialise(EVENT_NON_INDEXED_ARGS)</p>
<ul>
<li>（<code>EVENT_NON_INDEXED_ARGS</code> 是未索引的 <code>EVENT_ARGS</code>， <code>abi_serialise</code> 是一个用来从某个函数返回一系列类型值的 ABI 序列化函数，就像上文所讲的那样）。</li>
</ul>
</li>
</ul>
<p>对于所有定长的 Solidity 类型， <code>EVENT_INDEXED_ARGS</code> 数组会直接包含 32 字节的编码值。</p>
<p>然而，对于 <em>动态长度的类型</em> ，包含<code>string</code>、 <code>bytes</code> 和数组， <code>EVENT_INDEXED_ARGS</code> 会包含编码值的 <em>Keccak 哈希</em>,而不是直接包含编码值。这样就允许应用程序更有效地查询动态长度类型的值（通过把编码值的哈希设定为主题），但也使应用程序不能对它们还没查询过的已索引的值进行解码。</p>
<p>对于动态长度的类型，应用程序开发者面临在对预先设定的值（如果参数已被索引）的快速检索和对任意数据的清晰处理（需要参数不被索引）之间的权衡。</p>
<p>开发者们可以通过定义两个参数（一个已索引、一个未索引）保存同一个值的方式来解决这种权衡，从而既获得高效的检索又能清晰地处理任意数据。</p>
<h3 id="事件索引参数的编码"><a href="#事件索引参数的编码" class="headerlink" title="事件索引参数的编码"></a>事件索引参数的编码</h3><p>对于不是值类型的事件索引参数，如：数组和结构，是不直接存储的，而是存储一个 keccak256-hash 编码。这个编码被定义如下：</p>
<ul>
<li><code>bytes</code> 和 <code>string</code> 的编码只是字符串的内容，没有任何填充或长度前缀。</li>
<li>结构体的编码是其成员编码的拼接，总是填充为 32 字节的倍数（即便是 <code>bytes</code> 和 <code>string</code> 类型）。</li>
<li>数组(包含动态和静态大小的数组)的编码是其元素的编码的拼接，总是填充为 32 字节的倍数（即便是 <code>bytes</code> 和 <code>string</code> 类型），并且没有长度前缀</li>
</ul>
<p>上面的规范，像往常一样，负数会符号扩展填充，而不是零填充。 <code>bytesNN</code>类型在右边填充，而 <code>uintNN</code> &#x2F; <code>intNN</code> 在左边填充。</p>
<p>⚠️ 警告: 如果一个结构体包含一个以上的动态大小的数组，那么其编码会模糊有歧义。正因为如此，要经常重新检查事件数据，不能仅仅依靠索引参数的结果。</p>
<h1 id="错误编码"><a href="#错误编码" class="headerlink" title="错误编码"></a>错误编码</h1><p>在合约内部发生错误的情况下，合约可以使用一个特殊的操作码来中止执行，并恢复所有的状态变化。除了这些效果之外，可以返回描述性数据给调用者。这种描述性数据是对错误及其参数的编码，其方式与函数调用的数据相同。</p>
<p>例如，让我们考虑以下合约，其 <code>transfer</code> 功能在出现”余额不足”时，提示自定义错误:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract TestToken &#123;</span><br><span class="line">    error InsufficientBalance(uint256 available, uint256 required);</span><br><span class="line">    function transfer(address to, uint amount) public pure &#123;</span><br><span class="line">        revert InsufficientBalance(0, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回错误数据是以函数调用相同的方式编码， <code>InsufficientBalance(0, amount)</code> 与函数 <code>InsufficientBalance(uint256,uint256)</code> 编码一样。 例如为：<code>0xcf479181</code>, <code>uint256(0)</code>, <code>uint256(amount)</code>.</p>
<p>⚠️ 注意：错误的选择器 <code>0x00000000</code> 和 <code>0xffffffff</code> 被保留将来使用。</p>
<p>⚠️ 注意：永远不要相信错误数据。默认情况下，错误数据会通过外部调用链向上冒泡，这意味着一个合约可能会收到一个它直接调用的任何合约中没有定义的错误。此外，任何合约都可以通过返回与错误签名相匹配的数据来伪造任何错误，即使该错误没有在任何地方定义。</p>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>合约接口的 JSON 格式是用来描述函数，事件或错误描述的一个数组。</p>
<h3 id="函数的-JSON"><a href="#函数的-JSON" class="headerlink" title="函数的 JSON"></a>函数的 JSON</h3><p>一个函数的描述是一个有如下字段的 JSON 对象：</p>
<ul>
<li><p><code>type</code>： <code>&quot;function&quot;</code>、 <code>&quot;constructor&quot;</code> 或 <code>&quot;fallback&quot;</code></p>
</li>
<li><p><code>name</code>：函数名称；</p>
</li>
<li><p>inputs：对象数组，每个数组对象会包含：</p>
<ul>
<li><code>name</code>：参数名称；</li>
<li><code>type</code>：参数的权威类型（详见下文）</li>
<li><code>components</code>：供 元组(tuple) 类型使用（详见下文）</li>
</ul>
</li>
<li><p><code>outputs</code>：一个类似于 <code>inputs</code>的对象数组，如果函数无返回值时可以被省略；</p>
</li>
<li><p><code>payable</code>：如果函数接受 以太币 ，为 <code>true</code>；缺省为 <code>false</code>；</p>
</li>
<li><p><code>stateMutability</code>：为下列值之一： <code>pure</code> ， <code>view</code>， <code>nonpayable</code> 和 <code>payable</code>。</p>
</li>
</ul>
<p><code>type</code> 可以被省略，缺省为 <code>&quot;function&quot;</code>。</p>
<p>⚠️ 注意：构造函数 constructor 和 fallback 函数没有 <code>name</code> 或 <code>outputs</code>。fallback 函数也没有 <code>inputs</code>。</p>
<ul>
<li>向 non-payable（即不接受 以太币 ）的函数发送非零值的以太币 会回退交易。</li>
<li>状态可变性 <code>nonpayable</code> 是默认的，不用显示指定。</li>
</ul>
<h3 id="事件的-JSON"><a href="#事件的-JSON" class="headerlink" title="事件的 JSON"></a>事件的 JSON</h3><p>一个事件描述是一个有极其相似字段的 JSON 对象：</p>
<ul>
<li><p><code>type</code>：总是 <code>&quot;event&quot;</code>；</p>
</li>
<li><p><code>name</code>：事件名称；</p>
</li>
<li><p>inputs：对象数组，每个数组对象会包含：</p>
<ul>
<li><code>name</code>：参数名称；</li>
<li><code>type</code>：参数的权威类型（相见下文）；</li>
<li><code>components</code>：供 元组(tuple) 类型使用（详见下文）；</li>
<li><code>indexed</code>：如果此字段是日志的一个主题，则为 <code>true</code>；否则为<code>false</code>。</li>
</ul>
</li>
<li><p><code>anonymous</code>：如果事件被声明为 <code>anonymous</code>，则为 <code>true</code>。</p>
</li>
</ul>
<h3 id="错误的-JSON"><a href="#错误的-JSON" class="headerlink" title="错误的 JSON"></a>错误的 JSON</h3><p>错误这是一下类似的形式：</p>
<ul>
<li><p><code>type</code>: 为 <code>&quot;error&quot;</code></p>
</li>
<li><p><code>name</code>: 错误的名称。</p>
</li>
<li><p>inputs: 对象数组，每个元素包含：</p>
<ul>
<li><code>name</code>: 参数名称。</li>
<li><code>type</code>: 参数的规范类型（更多详细内容见下文）。</li>
<li><code>components</code>: 用于元组类型 (更多详细内容见下文).</li>
</ul>
</li>
</ul>
<p>⚠️ 注意：在 JSON 数组中可能有多个名称相同、甚至签名相同的错误。例如，如果错误来自智能合约中的不同文件，或引用自另一个智能合约。</p>
<p>对于 ABI 来说，它仅取决于错误的名称，而不是它的定义位置。</p>
<h3 id="例子演示"><a href="#例子演示" class="headerlink" title="例子演示"></a>例子演示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    bytes32 b;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        b = &quot;0x12&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Event(uint256 indexed a, bytes32 b);</span><br><span class="line">    error InsufficientBalance(uint256 available, uint256 required);</span><br><span class="line"></span><br><span class="line">    function foo(uint256 a) public &#123;</span><br><span class="line">        emit Event(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可由如下 JSON 来表示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">	<span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;inputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;stateMutability&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nonpayable&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;constructor&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;inputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="punctuation">&#123;</span> <span class="attr">&quot;internalType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;available&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="punctuation">&#123;</span> <span class="attr">&quot;internalType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;required&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;InsufficientBalance&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;anonymous&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;inputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="punctuation">&#123;</span> <span class="attr">&quot;indexed&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="attr">&quot;internalType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="punctuation">&#123;</span> <span class="attr">&quot;indexed&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="attr">&quot;internalType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bytes32&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bytes32&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Event&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;event&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;inputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;internalType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;foo&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;outputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;stateMutability&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nonpayable&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;function&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h3 id="处理-元组-tuple-类型"><a href="#处理-元组-tuple-类型" class="headerlink" title="处理 元组(tuple) 类型"></a>处理 元组(tuple) 类型</h3><p>尽管名称被有意地不作为 ABI 编码的一部分，但将它们包含进 JSON 来显示给最终用户是非常合理的。其结构会按下列方式进行嵌套：</p>
<p>一个拥有 <code>name</code>、 <code>type</code> 和潜在的 <code>components</code>成员的对象描述了某种类型的变量。 直至到达一个 元组(tuple)类型且到那点的存储在 <code>type</code> 属性中的字符串以 <code>tuple</code>为前缀，也就是说，在 <code>tuple</code> 之后紧跟一个 <code>[]</code> 或有整数 <code>k</code> 的<code>[k]</code>，才能确定一个 元组(tuple)。 元组(tuple) 的组件元素会被存储在成员<code>components</code>中，它是一个数组类型，且与顶级对象具有同样的结构，只是在这里不允许已索引的（<code>indexed</code>）数组元素。</p>
<p>作为例子，代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.7.5 &lt;0.9.0;</span><br><span class="line">pragma abicoder v2;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">  struct S &#123; uint a; uint[] b; T[] c; &#125;</span><br><span class="line">  struct T &#123; uint x; uint y; &#125;</span><br><span class="line">  function f(S memory, T memory, uint) public pure &#123; &#125;</span><br><span class="line">  function g() public pure returns (S memory, T memoryt, uint) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可由如下 JSON 来表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;f&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;function&quot;,</span><br><span class="line">    &quot;inputs&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;s&quot;,</span><br><span class="line">        &quot;type&quot;: &quot;tuple&quot;,</span><br><span class="line">        &quot;components&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;a&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;b&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256[]&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;c&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;tuple[]&quot;,</span><br><span class="line">            &quot;components&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;name&quot;: &quot;x&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;name&quot;: &quot;y&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;t&quot;,</span><br><span class="line">        &quot;type&quot;: &quot;tuple&quot;,</span><br><span class="line">        &quot;components&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;x&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;y&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;a&quot;,</span><br><span class="line">        &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;outputs&quot;: []</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="严格编码模式"><a href="#严格编码模式" class="headerlink" title="严格编码模式"></a>严格编码模式</h1><p>严格的编码模式与上述正式规范中定义的编码完全相同，但使偏移量必须尽可能小，同时不能在数据区域产生重叠，也不允许有间隙。</p>
<p>通常，ABI 解码器是以直接的方式编写的，只是遵循偏移量指针，但有些解码器可能强制执行严格模式。Solidity ABI 解码器目前并不强制执行严格模式，但编码器总是以严格模式创建数据。</p>
<h1 id="非标准打包模式"><a href="#非标准打包模式" class="headerlink" title="非标准打包模式"></a>非标准打包模式</h1><p>Non-standard Packed Mode 被称为非标准打包模式，通过 <code>abi.encodePacked()</code>, Solidity 支持一种非标准打包模式处理以下情形：</p>
<ul>
<li>长度低于 32 字节的类型，会直接拼接，既不会进行补 0 操作，也不会进行符号扩展</li>
<li>动态类型会直接进行编码，并且不包含长度信息。</li>
<li>数组元素会填充，但仍旧会就地编码。</li>
</ul>
<p>例如，对 <code>int1, bytes1, uint16, string</code> 用数值<code>-1, 0x42, 0x2424, &quot;Hello, world!&quot;</code> 进行编码将生成如下结果 ::</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0xff42242448656c6c6f2c20776f726c6421</span><br><span class="line">  ^^                                 int1(-1)</span><br><span class="line">    ^^                               bytes1(0x42)</span><br><span class="line">      ^^^^                           uint16(0x2424)</span><br><span class="line">          ^^^^^^^^^^^^^^^^^^^^^^^^^^ string(&quot;Hello, world!&quot;) without a length field</span><br></pre></td></tr></table></figure>

<p>更具体地说:</p>
<ul>
<li>在编码过程中，所有内容均是就地编码，因此在编码中，没有头和尾的区别，而且数组的长度也不会被编码。</li>
<li><code>abi.encodePacked</code> 的参数以不填充的方式编码，只要它们不是数组（或<code>string</code> 或 <code>bytes</code>）。</li>
<li>数组的编码是由其元素的编码及其填充（padding）的拼接</li>
<li>动态大小的类型如 <code>string</code>, <code>bytes</code> 或 <code>uint[]</code> 在编码时，不包含长度字段</li>
<li><code>string</code> 或 <code>bytes</code> 的编码不会在末尾进行填充（padding），除非它是一个数组或结构的一部分（此时会填充为<br>32 个自己的整数倍 ）</li>
</ul>
<p>一般来说，只要有两个动态大小的元素，因为缺少长度字段，编码就会模糊有歧义。</p>
<p>如果需要填充，可以使用明确的类型转换：<code>abi.encodePacked(uint16(0x12)) == hex&quot;0012&quot;</code>.</p>
<p>由于在调用函数时没有使用打包模式编码，所以没有特别支持预留函数选择器。由于编码是模糊有歧义的，所以也没有解码方法。</p>
<p>警告:如果你使用 <code>keccak256(abi.encodePacked(a, b))</code> 并且 <code>a</code> 和 <code>b</code> 都是动态类型， 很容易通过把 <code>a</code> 的一部分移到 <code>b</code>中，从而发生哈希碰撞，反之亦然。</p>
<p>更具体地说， <code>abi.encodePacked(&quot;a&quot;, &quot;bc&quot;) == abi.encodePacked(&quot;ab&quot;, &quot;c&quot;)</code> 。如果你使用 <code>abi.encodePacked</code> 进行签名，认证或数据完整性检验，请确保总是使用相同的类型并且其中只有最多一个动态类型。除非有令人信服的理由，否则应首选 <code>abi.encode</code> 。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/07/25/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/17-metadata%E5%85%83%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/25/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/17-metadata%E5%85%83%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">17-metadata元数据</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-25 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-25T00:00:00+08:00">2022-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Solidity 编译器在编译的时候自动生成<code>xx_metadata.json</code>的 JSON 文件，中文叫合约的元数据，其中包含了当前合约的相关信息。</p>
<h1 id="metadata-包含信息"><a href="#metadata-包含信息" class="headerlink" title="metadata 包含信息"></a>metadata 包含信息</h1><p>元数据文件具有以下格式。 下面的例子将以人类可读的方式呈现。正确格式化的元数据应正确使用引号，将空白减少到最小，并对所有对象的键值进行排序以得到唯一的格式。（下面的代码注释是不允许的，这里仅用于解释目的。）</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// 必选：元数据格式的版本(注意和Solidity版本不是同一个version )</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 必选：源代码的编程语言，一般会选择规范的“子版本”</span></span><br><span class="line">  <span class="attr">&quot;language&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Solidity&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 必选：编译器的细节，内容视语言而定。</span></span><br><span class="line">  <span class="attr">&quot;compiler&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 对 Solidity 来说是必须的：编译器的版本</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.8.7+commit.e28d00a7&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 可选： 生成此输出的编译器二进制文件的哈希值</span></span><br><span class="line">    <span class="attr">&quot;keccak256&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x123...&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 必选：合约的生成信息</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 必选：合约的 ABI 定义</span></span><br><span class="line">    <span class="attr">&quot;abi&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">/*...*/</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 必选：合约的 NatSpec 用户文档</span></span><br><span class="line">    <span class="attr">&quot;userdoc&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">/*...*/</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 必选：合约的 NatSpec 开发者文档</span></span><br><span class="line">    <span class="attr">&quot;devdoc&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">/*...*/</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 必选：编译器的设置</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;compilationTarget&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;a.sol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Sum&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;evmVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;london&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;libraries&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="comment">// Reflects the setting used in the input json, defaults to false</span></span><br><span class="line">      <span class="attr">&quot;useLiteralContent&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// Reflects the setting used in the input json, defaults to &quot;ipfs&quot;</span></span><br><span class="line">      <span class="attr">&quot;bytecodeHash&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ipfs&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 可选： 优化器的设置（ enabled 默认设为 false ）</span></span><br><span class="line">    <span class="attr">&quot;optimizer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;runs&quot;</span><span class="punctuation">:</span> <span class="number">200</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 对 Solidity 来说是必须的： 已排序的重定向列表</span></span><br><span class="line">    <span class="attr">&quot;remappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;:g/dir&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 必选：编译的源文件／源单位，键值为文件名</span></span><br><span class="line">  <span class="attr">&quot;sources&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;myFile.sol&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="comment">// 必选：源文件的 keccak256 哈希值</span></span><br><span class="line">      <span class="attr">&quot;keccak256&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x123...&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Optional: 在源文件中定义的 SPDX license 标识</span></span><br><span class="line">      <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MIT&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// 必选（除非定义了 content，详见下文）：</span></span><br><span class="line">      <span class="comment">// 已排序的源文件的URL，URL的协议可以是任意的，但建议使用 Swarm 的URL</span></span><br><span class="line">      <span class="attr">&quot;urls&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;bzz-raw://fd33d...&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;dweb:/ipfs/Qme8Vrt&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 可选</span></span><br><span class="line">    <span class="attr">&quot;mortal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="comment">// 必选：源文件的 keccak256 哈希值</span></span><br><span class="line">      <span class="attr">&quot;keccak256&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x234...&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// 必选（除非定义了“urls”）： 源文件的字面内容</span></span><br><span class="line">      <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;contract mortal is owned &#123; function kill() &#123;</span></span><br><span class="line"><span class="string">        if (msg.sender == owner) selfdestruct(owner); &#125; &#125;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="metadata-的作用"><a href="#metadata-的作用" class="headerlink" title="metadata 的作用"></a>metadata 的作用</h3><p>metadata 主要是为了更安全地与合约进行交互并验证其源代码。</p>
<ul>
<li>查询编译器版本</li>
<li>所使用的源代码</li>
<li>ABI</li>
<li>natspec 文档</li>
</ul>
<p>编译器会将元数据文件的 Swarm 哈希值附加到每个合约的字节码末尾（详情请参阅下文），以便你可以以认证的方式获取该文件，而不必求助于中心化的数据提供者。当然，你必须将元数据文件发布到 Swarm（或其他服务），以便其他人可以访问它。 该文件可以通过使用<code>solc --metadata</code> 来生成，并被命名为 <code>ContractName_meta.json</code> 。 它将包含源代码的在 Swarm 上的引用，因此你必须上传所有源文件和元数据文件。</p>
<hr>
<p>⚠️ 警告: 由于生成的合约的字节码包含元数据的哈希值，因此对元数据的任何更改都会导致字节码的更改。<br>此外，由于元数据包含所有使用的源代码的哈希值，所以任何源代码中的，哪怕是一个空格的变化都将导致不同的元数据，并随后产生不同的字节代码。</p>
<p>⚠️ 警告: 需注意，上面的 ABI 没有固定的顺序，随编译器的版本而不同。</p>
<h1 id="字节码中元数据哈希的编码"><a href="#字节码中元数据哈希的编码" class="headerlink" title="字节码中元数据哈希的编码"></a>字节码中元数据哈希的编码</h1><p>由于在将来可能会支持其他方式来获取元数据文件， 类似<code>&#123;&quot;bzzr0&quot;：&lt;Swarm hash&gt;&#125;</code> 的键值对，将会以<br>CBOR (<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7049">https://tools.ietf.org/html/rfc7049</a>) 编码来存储。由于这种编码的起始位不容易找到，因此添加两个字节来表述其长度，以大端方式编码。所以，当前版本的 Solidity 编译器，将以下内容添加到部署的字节码的末尾</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0xa2</span><br><span class="line">0x64 &#x27;i&#x27; &#x27;p&#x27; &#x27;f&#x27; &#x27;s&#x27; 0x58 0x22 &lt;34 bytes IPFS hash&gt;</span><br><span class="line">0x64 &#x27;s&#x27; &#x27;o&#x27; &#x27;l&#x27; &#x27;c&#x27; 0x43 &lt;3 byte version encoding&gt;</span><br><span class="line">0x00 0x33</span><br></pre></td></tr></table></figure>

<p>因此，为了检索数据，可以检查已部署字节码的末尾以匹配该模式，并使用 IPFS 哈希来检索文件。</p>
<p>solc 的发布版本使用如上所示的版本的 3 字节编码（major, minor and patch version number 版本号各一个字节），而预发布版本将使用完整的版本字符串，包括提交哈希和构建日期。</p>
<p>CBOR 映射还可以包含其他密钥，因此最好完全解码数据而不是依赖以 <code>0xa264</code> 开头的数据。 例如，如果使用任何影响代码生成的实验性功能，则映射也将包含 <code>&quot;experimental&quot;：true</code>。</p>
<p>编译器目前默认使用元数据的 IPFS 哈希，但将来也可能使用 bzzr1 哈希或其他一些哈希，因此不要依赖此序列以 <code>0xa2 0x64 &#39;i&#39; &#39;p&#39; &#39;f&#39; &#39;s&#39;</code> 开头 的。 我们可能还会向此 CBOR 结构中添加其他数据，因此最好的选择是使用适当的 CBOR 解析器。</p>
<h1 id="自动化接口生成和-natspec-使用"><a href="#自动化接口生成和-natspec-使用" class="headerlink" title="自动化接口生成和 natspec 使用"></a>自动化接口生成和 natspec 使用</h1><p>元数据以下列方式使用：通过钱包想要与合约交互时检索合约代码，然后检索文件的 IPFS&#x2F;Swarm 哈希。该文件被 JSON 解码为上面的结构。</p>
<p>组件可以使用 ABI 自动为合约生成一个基本的用户界面。</p>
<p>此外，钱包可以使用 NatSpec 用户文档，在用户与合约交互，授权请求签名时候做辅助工作。</p>
<h1 id="源代码如何验证？"><a href="#源代码如何验证？" class="headerlink" title="源代码如何验证？"></a>源代码如何验证？</h1><p>为了验证编译，可以通过元数据文件中的链接从 IPFS&#x2F;Swarm 中获取源代码。获取到的源码，会根据元数据中指定的设置，被正确版本的编译器所处理。处理得到的字节码会与创建交易的数据或者 <code>CREATE</code> 操作码使用的数据进行比较。这会自动验证元数据，因为它的哈希值是字节码的一部分。而额外的数据，则是与基于接口进行编码并展示给用户的构造输入数据相符的。</p>
<p>在 <a target="_blank" rel="noopener" href="https://github.com/ethereum/sourcify">sourcify</a> 库(<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/source-verify">npm package</a>)可以看到如何使用该特性的示例代码。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/07/22/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/16-Assembly%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/22/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/16-Assembly%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/" class="post-title-link" itemprop="url">16-Assembly内联汇编</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-22 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-22T00:00:00+08:00">2022-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>使用内联汇编，可以在 Solidity 源程序中嵌入汇编代码，对 EVM 有更细粒度的控制。内联汇编主要用在编写库函数时很有用，一般用于写工具函数，比如椭圆签名解析等。在项目中用汇编编主要是 opensea 的 <a target="_blank" rel="noopener" href="https://github.com/ProjectOpenSea/seaport">seaport</a> 合约.</p>
<p>在合约的内部使用汇编，是在合约内部包含 <code>assembly</code> 关键字进行编写的，在 Solidity <code>inline assembly</code>(内联汇编) 中的语言被称为 Yul。</p>
<p><a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh/latest/yul.html">Yul</a> 除了在 Solidity 之中作为 inline assembly 的一部分，也能当作独立的直译语言能够被编译成 bytecode 给不同的后端。</p>
<p>注意：内联汇编是一种在底层访问以太坊虚拟机的语言，由于编译器无法对汇编语句进行检查，所以 Solidity 提供的很多重要安全特性都没办法作用于汇编。写汇编代码相对比较困难，很多时候只有在处理一些相对复杂的问题时才需要使用它，并且开发者需要明确知道自己要做什么。</p>
<h1 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h1><p>通过 <code>assembly &#123;&#125;</code> 包裹代码。并且内部每一行语句不需要使用<code>;</code>显示的标注结束。Assembly 也支持注释，可以使用 <code>//</code> 和 <code>/* */</code> 来进行注释。</p>
<p>⚠️ 注意： Inline Assembly 中，代码块之间是不能彼此沟通的，里面声明的变量都是本地变量。</p>
<h3 id="例子-不同代码块无法互相访问"><a href="#例子-不同代码块无法互相访问" class="headerlink" title="例子: 不同代码块无法互相访问"></a>例子: 不同代码块无法互相访问</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public view returns (uint256) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let x := 2</span><br><span class="line">        &#125;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let y := x // DeclarationError: Identifier &quot;x&quot; not found.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>let 指令执行如下任务：</p>
<ul>
<li>创建一个新的堆栈槽位</li>
<li>为变量保留该槽位</li>
<li>当到达代码块结束时自动销毁该槽位</li>
</ul>
<p>因此，使用 let 指令在汇编代码块中定义的变量，在代码块外部是无法访问的。但是内部代码块可以访问外部代码块的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let x := 3</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                let y := x // success</span><br><span class="line">            &#125; // 到此处会销毁y</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例子-简单的加法"><a href="#例子-简单的加法" class="headerlink" title="例子: 简单的加法"></a>例子: 简单的加法</h3><p>下面是一个计算 <code>_x + _y</code> 的两种写法对比，汇编的语法节省了 <code>1.76%</code> 的 gas。 assembly 核心是更细粒度的控制，省 gas 只是它的外在表现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // 输入 1,2 ; 输出 22307 gas</span><br><span class="line">    function addSolidity(uint256 _x, uint256 _y) public pure returns (uint256) &#123;</span><br><span class="line">        return (_x + _y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输入 1,2 ; 输出 21915 gas</span><br><span class="line">    function addAssembly(uint256 _x, uint256 _y) public pure returns (uint256) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // let result 是声明一个变量 result</span><br><span class="line">            // add(_x, _y) 是计算 x + y 的结果</span><br><span class="line">            // := 是将 x + y 的结果赋值给变量 result</span><br><span class="line">            let result := add(_x, _y)</span><br><span class="line"></span><br><span class="line">            // mstore(0x0, result) 在内存 `0x0` 的位置储存 `result`</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line"></span><br><span class="line">            // 从内存索引 0x0 位置返回32字节</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><p>Yul 提供了高级结构，如 <code>for</code> 循环、<code>if</code> 语句 <code>switch</code> 和函数调用等等，下面按照分类进行介绍。</p>
<p>在 Inline Assembly 中，以下几个点很重要：</p>
<ul>
<li>赋值: 使用的是<code>:=</code>，而不是<code>=</code>。</li>
<li>声明变量: 使用 <code>let</code> 声明；（不是正常带有指定类型的强类型方式）</li>
</ul>
<h3 id="声明与赋值"><a href="#声明与赋值" class="headerlink" title="声明与赋值"></a>声明与赋值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (uint256, uint256) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let x := 2  // 声明 x，赋值为2</span><br><span class="line">            let y       // 声明 y，初始化为 0</span><br><span class="line">            y := 5      // 赋值 y 为5</span><br><span class="line"></span><br><span class="line">            mstore(0x0, x) // 内存中储存 x</span><br><span class="line">            mstore(add(0x0, 32), y) // 内存中移动32位，再储存y</span><br><span class="line"></span><br><span class="line">            // 返回内存中 0 - 64 的数据</span><br><span class="line">            return(0x0, 64)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果就是 <code>2,5</code>；</p>
<p>在 Solidity 汇编中字面量的写法与 Solidity 一致。但是 字符串字面量 最多可以包含 32 个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let a := 0x123 // 16进制</span><br><span class="line">            let b := 42 // 10进制</span><br><span class="line">            let c := &quot;hello world&quot; // 字符串</span><br><span class="line">            let d := &quot;very long string more than 32 bytes&quot; // 长度 35 的 字符串，错误！</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="汇编只能读取局部变量"><a href="#汇编只能读取局部变量" class="headerlink" title="汇编只能读取局部变量"></a>汇编只能读取局部变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint256 a = 2;</span><br><span class="line">    function demoAssembly() public pure &#123;</span><br><span class="line">        uint256 b = 5;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // 可以读取 x 和 y</span><br><span class="line">            let x := add(2, 3)</span><br><span class="line">            let y := 10</span><br><span class="line">            let z := add(x, y)</span><br><span class="line">        &#125;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // 可以读取 x 和 b</span><br><span class="line">            let x := add(2, 3)</span><br><span class="line">            let y := mul(x, b)</span><br><span class="line">        &#125;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let x := add(2, 3)</span><br><span class="line"></span><br><span class="line">            // ❌ TypeError: Only local variables are supported.</span><br><span class="line">            // To access storage variables, use the &quot;.slot&quot; and &quot;.offset&quot; suffixes.</span><br><span class="line">            let y := mul(x, a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><ul>
<li>if</li>
<li>switch</li>
</ul>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>特点如下</p>
<ul>
<li>只有 if ，没有 else</li>
<li>if 语句强制要求代码块使用大括号，<code>&#123;&#125;</code>不允许省略</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure &#123;</span><br><span class="line">        uint256 x;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // success</span><br><span class="line">            if iszero(x) &#123;</span><br><span class="line">                x := sub(1, x)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // fail: 没有使用 &#123;&#125; 包裹代码</span><br><span class="line">            // if iszero(x) revert(0, 0)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要在 Solidity 内联汇编中检查多种条件，可以考虑使用 switch 语句。</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch 语句支持 一个默认分支 default，当表达式的值不匹配任何其他分支条件时，将 执行默认分支的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 x) public pure returns (uint256 result) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            switch x</span><br><span class="line">            case 0 &#123;</span><br><span class="line">                result := 0</span><br><span class="line">            &#125;</span><br><span class="line">            case 1 &#123;</span><br><span class="line">                result := 1</span><br><span class="line">            &#125;</span><br><span class="line">            default &#123;</span><br><span class="line">                result := mul(x, x)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h1><p>for 循环也包含 3 个元素</p>
<ul>
<li>初始化：比如<code>let i := 0</code></li>
<li>执行条件：比如<code>lt(i, n)</code> ，必须是函数风格表达式</li>
<li>迭代后续步骤：比如<code>add(i, 1)</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (uint256 result) &#123;</span><br><span class="line">        uint256 leng = 10;</span><br><span class="line"></span><br><span class="line">        assembly &#123;</span><br><span class="line">            for</span><br><span class="line">            &#123; let i := 0 &#125;</span><br><span class="line">            lt(i, leng)</span><br><span class="line">            &#123; i := add(i, 1) &#125;</span><br><span class="line">            &#123;</span><br><span class="line">                result := add(result, i)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 下面可以省略</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for 循环的<strong>初始化部分</strong>和<strong>迭代后续步骤</strong>可以留空 , 改写为下面的格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (uint256 result) &#123;</span><br><span class="line">        uint256 leng = 10;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let i := 0 // 初始条件写在这</span><br><span class="line">            for &#123;&#125; lt(i, leng) &#123;&#125; &#123;</span><br><span class="line">                // 核心部分</span><br><span class="line">                result := add(result, i)</span><br><span class="line"></span><br><span class="line">                // 迭代后续步骤写在这</span><br><span class="line">                i := add(i, 1)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 可以省略</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备注: <code>continue</code> or <code>break</code> 语句只能在 <code>for</code> 循环体内使用</p>
<h1 id="函数的定义和使用"><a href="#函数的定义和使用" class="headerlink" title="函数的定义和使用"></a>函数的定义和使用</h1><p>函数的运行机制如下：</p>
<ul>
<li>从堆栈提取参数</li>
<li>将结果压入堆栈</li>
<li>和 Solidity 函数不同，不需要指定汇编函数的可见性<ul>
<li>例如 public 或 private， 因为汇编函数仅在定义所在的汇编代码块内有效。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (uint256 free_memory_pointer) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // 函数定义</span><br><span class="line">            function allocate(length) -&gt; pos &#123;</span><br><span class="line">                pos := mload(0x40)</span><br><span class="line">                mstore(0x40, add(pos, length))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 函数使用</span><br><span class="line">            free_memory_pointer := allocate(64)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="EVM-内置函数-内置操作码"><a href="#EVM-内置函数-内置操作码" class="headerlink" title="EVM 内置函数&#x2F;内置操作码"></a>EVM 内置函数&#x2F;内置操作码</h1><ul>
<li>算数操作<ul>
<li><code>add</code>: 加法</li>
<li><code>mul</code>:</li>
</ul>
</li>
<li>比较操作<ul>
<li><code>lt</code></li>
<li><code>gt</code></li>
</ul>
</li>
<li>位操作<ul>
<li><code>not</code>:</li>
<li><code>and</code>:</li>
</ul>
</li>
<li>密码学操作，目前仅包含 keccak256</li>
<li>环境操作，主要指与区块链相关的全局信息，例如 blockhash 或 coinbase 收款账号</li>
<li>存储、内存和栈操作</li>
<li>交易与合约调用操作</li>
<li>停机操作</li>
<li>日志操作</li>
</ul>
<p>下面是详细的列表说明，标记为<code>-</code>的操作不返回结果，其他所有操作码只返回一个值。</p>
<p>标有 F、H、B、C 、I 和 L 分别自出现的时间，对应的如下</p>
<ul>
<li><code>F</code>: Frontier</li>
<li><code>H</code>: Homestead</li>
<li><code>B</code>: Byzantium</li>
<li><code>C</code>: Constantinople</li>
<li><code>I</code>: Istanbul</li>
<li><code>L</code>: London</li>
</ul>
<p>常见的常量值是 <code>0x20</code> &#x2F; <code>0x40</code> , 代表十进制的 32 和 64。</p>
<h3 id="数学计算"><a href="#数学计算" class="headerlink" title="数学计算"></a>数学计算</h3><table>
<thead>
<tr>
<th>操作符号</th>
<th>返回值</th>
<th>版本</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>add(x, y)</td>
<td></td>
<td>F</td>
<td><code>x + y</code></td>
</tr>
<tr>
<td>sub(x, y)</td>
<td></td>
<td>F</td>
<td><code>x - y</code></td>
</tr>
<tr>
<td>mul(x, y)</td>
<td></td>
<td>F</td>
<td><code>x * y</code></td>
</tr>
<tr>
<td>div(x, y)</td>
<td></td>
<td>F</td>
<td><code>x / y</code> (如果 y 为 0，则结果为 0)</td>
</tr>
<tr>
<td>mod(x, y)</td>
<td></td>
<td>F</td>
<td><code>x % y</code> (如果 y 为 0，则结果为 0)</td>
</tr>
<tr>
<td>exp(x, y)</td>
<td></td>
<td>F</td>
<td><code>x</code> 的 <code>y</code> 次方</td>
</tr>
<tr>
<td>addmod(x, y, m)</td>
<td></td>
<td>F</td>
<td><code>(x + y) % m</code> 任意精度算术，如果 m &#x3D;&#x3D; 0 则为 0</td>
</tr>
<tr>
<td>mulmod(x, y, m)</td>
<td></td>
<td>F</td>
<td><code>(x * y) % m</code> 任意精度算术，如果 m &#x3D;&#x3D; 0 则为 0</td>
</tr>
<tr>
<td>sdiv(x, y)</td>
<td></td>
<td>F</td>
<td><code>x / y</code>, 以二进制补码作为符号 (如果 y 为 0，则结果为 0)</td>
</tr>
<tr>
<td>smod(x, y)</td>
<td></td>
<td>F</td>
<td><code>x % y</code>, 以二进制补码作为符号 (如果 y 为 0，则结果为 0)</td>
</tr>
</tbody></table>
<h4 id="add-加法"><a href="#add-加法" class="headerlink" title="add: 加法"></a>add: 加法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function demoAssembly(uint256 _x, uint256 _y)</span><br><span class="line">    public</span><br><span class="line">    pure</span><br><span class="line">    returns (uint256)</span><br><span class="line">&#123;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        let result := add(_x, _y)</span><br><span class="line">        mstore(0x0, result)</span><br><span class="line">        return(0x0, 32)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面合约函数，传入参数:<code>1,2</code>，返回<code>3</code>。</p>
<p>这里需要返回<code>uint256</code>类型，assembly 内部返回是，从什么位置开发，返回多少个数据。需要返回两个数据。比如我把 uint256 改为 uint8，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function demoAssembly(uint8 _x, uint8 _y)</span><br><span class="line">    public</span><br><span class="line">    pure</span><br><span class="line">    returns (uint8)</span><br><span class="line">&#123;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        let result := add(_x, _y)</span><br><span class="line">        mstore(0x0, result)</span><br><span class="line">        return(0x0, 2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相同的参数会报错: <code>error:Failed to decode output: Error: data out-of-bounds (length=2, offset=32, code=BUFFER_OVERRUN, version=abi/5.5.0)</code></p>
<h4 id="sub-减法"><a href="#sub-减法" class="headerlink" title="sub: 减法"></a>sub: 减法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 _x, uint256 _y)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let result := sub(_x, _y)</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入参数:<code>2,1</code>，返回<code>1</code>。</p>
<p>注意：这时候如果传参 <code>1,2</code>，会溢出返回，得到的结果不会报错，反而是:<code>115792089237316195423570985008687907853269984665640564039457584007913129639935</code>，因为 assembly 绕过了 solidity 的安全检查。当我们使用 assembly 编码时候，安全问题需要自己控制，不要错误的认为 solidity 的默认机制会保护代码。</p>
<h4 id="mul-乘法"><a href="#mul-乘法" class="headerlink" title="mul: 乘法"></a>mul: 乘法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 _x, uint256 _y)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let result := mul(_x, _y)</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入参数:<code>2,3</code>，返回<code>6</code>。</p>
<h4 id="div-除法"><a href="#div-除法" class="headerlink" title="div: 除法"></a>div: 除法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 _x, uint256 _y)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let result := div(_x, _y)</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>传入参数:<code>3,2</code>，返回<code>1</code>。</li>
<li>传入参数:<code>3,1</code>，返回<code>3</code>。</li>
<li>传入参数:<code>3,0</code>，返回<code>0</code>。</li>
</ul>
<h4 id="mod-求模"><a href="#mod-求模" class="headerlink" title="mod: 求模"></a>mod: 求模</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 _x, uint256 _y)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let result := mod(_x, _y)</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>传入参数:<code>3,2</code>，返回<code>1</code></li>
<li>传入参数:<code>3,1</code>，返回<code>0</code></li>
<li>传入参数:<code>3,0</code>,返回<code>0</code></li>
<li>传入参数:<code>3,30</code>,返回<code>3</code></li>
</ul>
<h4 id="exp-次方"><a href="#exp-次方" class="headerlink" title="exp: 次方"></a>exp: 次方</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 _x, uint256 _y)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let result := exp(_x, _y)</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>传入参数:<code>10,2</code>，返回<code>100</code>。</li>
<li>传入参数:<code>10,3</code>，返回<code>1000</code>。</li>
</ul>
<h4 id="addmod-先求和再求模"><a href="#addmod-先求和再求模" class="headerlink" title="addmod: 先求和再求模"></a>addmod: 先求和再求模</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(</span><br><span class="line">        uint256 _x,</span><br><span class="line">        uint256 _y,</span><br><span class="line">        uint256 _m</span><br><span class="line">    ) public pure returns (uint256) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let result := addmod(_x, _y, _m)</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>传入参数:<code>2,3,3</code>，返回<code>2</code>。</li>
</ul>
<h4 id="mulmod-先相乘再求模"><a href="#mulmod-先相乘再求模" class="headerlink" title="mulmod: 先相乘再求模"></a>mulmod: 先相乘再求模</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(</span><br><span class="line">        uint256 _x,</span><br><span class="line">        uint256 _y,</span><br><span class="line">        uint256 _m</span><br><span class="line">    ) public pure returns (uint256) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let result := mulmod(_x, _y, _m)</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>传入参数:<code>2,3,3</code>，返回<code>0</code>。</li>
</ul>
<h4 id="二进制补码"><a href="#二进制补码" class="headerlink" title="二进制补码"></a>二进制补码</h4><p>下面两个方法，用法基本和 div &#x2F; mod 差不多</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let result := sdiv(_x, _y)</span><br><span class="line">let result := smod(_x, _y)</span><br></pre></td></tr></table></figure>

<h3 id="比较关系"><a href="#比较关系" class="headerlink" title="比较关系"></a>比较关系</h3><table>
<thead>
<tr>
<th>操作符号</th>
<th>返回值</th>
<th>版本</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>gt(x, y)</td>
<td></td>
<td>F</td>
<td>如果 <code>x &gt; y</code> 等于 1, 否则 0</td>
</tr>
<tr>
<td>lt(x, y)</td>
<td></td>
<td>F</td>
<td>如果 <code>x &lt; y</code> 等于 1, 否则 0</td>
</tr>
<tr>
<td>eq(x, y)</td>
<td></td>
<td>F</td>
<td>如果 <code>x == y</code> 等于 1, 否则 0</td>
</tr>
<tr>
<td>iszero(x)</td>
<td></td>
<td>F</td>
<td>如果 <code>x == 0</code> 等于 1, 否则 0</td>
</tr>
<tr>
<td>slt(x, y)</td>
<td></td>
<td>F</td>
<td>如果 <code>x &lt; y</code> 等于 1, 否则 0, 以二进制补码作为符号</td>
</tr>
<tr>
<td>sgt(x, y)</td>
<td></td>
<td>F</td>
<td>如果 <code>x &gt; y</code> 等于 1, 否则 0, 以二进制补码作为符号</td>
</tr>
</tbody></table>
<h4 id="gt-大于"><a href="#gt-大于" class="headerlink" title="gt: 大于"></a>gt: 大于</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 _x, uint256 _y)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bool result)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := gt(_x, _y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>传入参数:<code>1,2</code>，返回 <code>false</code></li>
<li>传入参数:<code>10,3</code>，返回 <code>true</code></li>
</ul>
<h4 id="lt-小于"><a href="#lt-小于" class="headerlink" title="lt: 小于"></a>lt: 小于</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 _x, uint256 _y)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bool result)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := lt(_x, _y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>传入参数:<code>1,2</code>，返回 <code>true</code></li>
<li>传入参数:<code>10,3</code>，返回 <code>false</code></li>
</ul>
<h4 id="eq-等于"><a href="#eq-等于" class="headerlink" title="eq: 等于"></a>eq: 等于</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 _x, uint256 _y)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bool result)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := eq(_x, _y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>传入参数:<code>1,2</code>，返回 <code>false</code></li>
<li>传入参数:<code>2,2</code>，返回 <code>true</code></li>
</ul>
<h4 id="iszero-等于零"><a href="#iszero-等于零" class="headerlink" title="iszero: 等于零"></a>iszero: 等于零</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 _x)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bool result)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := iszero(_x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意该参数只接收一个参数</p>
<ul>
<li>传入参数:<code>1</code>，返回 <code>false</code></li>
<li>传入参数:<code>0</code>，返回 <code>true</code></li>
</ul>
<h3 id="按位-移位"><a href="#按位-移位" class="headerlink" title="按位 &amp; 移位"></a>按位 &amp; 移位</h3><table>
<thead>
<tr>
<th>操作符号</th>
<th>返回值</th>
<th>版本</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>not(x)</td>
<td></td>
<td>F</td>
<td>对 x 按位取反,类似<code>~x</code>;<code>x</code> 的按位非</td>
</tr>
<tr>
<td>and(x, y)</td>
<td></td>
<td>F</td>
<td>x 和 y 的按位与</td>
</tr>
<tr>
<td>or(x, y)</td>
<td></td>
<td>F</td>
<td>x 和 y 的按位或</td>
</tr>
<tr>
<td>xor(x, y)</td>
<td></td>
<td>F</td>
<td>x 和 y 的按位异或</td>
</tr>
<tr>
<td>shl(x, y)</td>
<td></td>
<td>C</td>
<td>y 逻辑左移 x 位</td>
</tr>
<tr>
<td>shr(x, y)</td>
<td></td>
<td>C</td>
<td>y 逻辑右移 x 位</td>
</tr>
<tr>
<td>sar(x, y)</td>
<td></td>
<td>C</td>
<td>将 y 算术右移 x 位</td>
</tr>
</tbody></table>
<h4 id="not-按位非"><a href="#not-按位非" class="headerlink" title="not: 按位非"></a>not: 按位非</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(int256 _x) public pure returns (int256 result) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := not(_x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>传入参数:<code>0</code>，返回 <code>-1</code></li>
<li>传入参数:<code>1</code>，返回 <code>-2</code></li>
<li>传入参数:<code>-1</code>，返回 <code>0</code></li>
<li>传入参数:<code>-11</code>，返回 <code>10</code></li>
</ul>
<h4 id="and-按位与"><a href="#and-按位与" class="headerlink" title="and: 按位与"></a>and: 按位与</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (int256 result) &#123;</span><br><span class="line">        int256 _x = 2;</span><br><span class="line">        int256 _y = 3;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := and(_x, _y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是 2</p>
<h4 id="or-按位或"><a href="#or-按位或" class="headerlink" title="or: 按位或"></a>or: 按位或</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (int256 result) &#123;</span><br><span class="line">        int256 _x = 2;</span><br><span class="line">        int256 _y = 3;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := or(_x, _y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是 3</p>
<h4 id="xor-按位异或"><a href="#xor-按位异或" class="headerlink" title="xor: 按位异或"></a>xor: 按位异或</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (int256 result) &#123;</span><br><span class="line">        int256 _x = 2;</span><br><span class="line">        int256 _y = 3;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := xor(_x, _y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果 1</p>
<h4 id="shl-逻辑左移"><a href="#shl-逻辑左移" class="headerlink" title="shl: 逻辑左移"></a>shl: 逻辑左移</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (uint256 result) &#123;</span><br><span class="line">        uint256 A = 2;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := shl(A, 1) // 4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="shr-逻辑右移"><a href="#shr-逻辑右移" class="headerlink" title="shr: 逻辑右移"></a>shr: 逻辑右移</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (uint256 result) &#123;</span><br><span class="line">        uint256 A = 2;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := shr(A, 1) // 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sar-算术右移"><a href="#sar-算术右移" class="headerlink" title="sar: 算术右移"></a>sar: 算术右移</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (uint256 result) &#123;</span><br><span class="line">        uint256 A = 2;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := sar(A, 1) // 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EVM-区块交易相关"><a href="#EVM-区块交易相关" class="headerlink" title="EVM 区块交易相关"></a>EVM 区块交易相关</h3><table>
<thead>
<tr>
<th>操作符号</th>
<th>返回值</th>
<th>版本</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>address()</td>
<td></td>
<td>F</td>
<td>当前合约地址 &#x2F; execution context</td>
</tr>
<tr>
<td>balance(a)</td>
<td></td>
<td>F</td>
<td>地址 a 的 wei 余额</td>
</tr>
<tr>
<td>selfbalance()</td>
<td></td>
<td>I</td>
<td>相当于 <code>balance(address())</code>，但更便宜</td>
</tr>
<tr>
<td>extcodehash(a)</td>
<td></td>
<td>C</td>
<td>地址 a 的代码哈希</td>
</tr>
<tr>
<td><strong>msg 相关</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>caller()</td>
<td></td>
<td>F</td>
<td>call sender ( 类似<code>msg.sender</code>？) (excluding <code>delegatecall</code>)</td>
</tr>
<tr>
<td>callvalue()</td>
<td></td>
<td>F</td>
<td>wei sent together with the current call（类似<code>msg.value</code>？）</td>
</tr>
<tr>
<td><strong>block 相关</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>chainid()</td>
<td></td>
<td>I</td>
<td>当前网络的链 ID (EIP-1344)</td>
</tr>
<tr>
<td>basefee()</td>
<td></td>
<td>L</td>
<td>当前区块的基本费用 (EIP-3198 and EIP-1559)</td>
</tr>
<tr>
<td>timestamp()</td>
<td></td>
<td>F</td>
<td>当前块的时间戳，自纪元以来的秒数</td>
</tr>
<tr>
<td>coinbase()</td>
<td></td>
<td>F</td>
<td>当前采矿受益人</td>
</tr>
<tr>
<td>number()</td>
<td></td>
<td>F</td>
<td>当前区块号</td>
</tr>
<tr>
<td>difficulty()</td>
<td></td>
<td>F</td>
<td>当前区块的难度</td>
</tr>
<tr>
<td>gaslimit()</td>
<td></td>
<td>F</td>
<td>当前区块的区块 gas limit</td>
</tr>
<tr>
<td><strong>tx 相关</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>origin()</td>
<td></td>
<td>F</td>
<td>交易发送方</td>
</tr>
<tr>
<td>gasprice()</td>
<td></td>
<td>F</td>
<td>交易的 gas 价格</td>
</tr>
<tr>
<td><strong>其它</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>gas()</td>
<td></td>
<td>F</td>
<td>剩余 gas</td>
</tr>
<tr>
<td>blockhash(b)</td>
<td></td>
<td>F</td>
<td>指定 block 的 hash - 仅适用于最后 256 个块，不包括当前块</td>
</tr>
</tbody></table>
<h4 id="address"><a href="#address" class="headerlink" title="address()"></a>address()</h4><p>相当于 <code>address(this)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public view returns (address ads1, address ads2) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            ads1 := address()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ads2 = address(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回</p>
<ul>
<li><code>0:address: ads1 0x3c725134d74D5c45B4E4ABd2e5e2a109b5541288</code></li>
<li><code>1:address: ads2 0x3c725134d74D5c45B4E4ABd2e5e2a109b5541288</code></li>
</ul>
<h4 id="balance-a"><a href="#balance-a" class="headerlink" title="balance(a)"></a>balance(a)</h4><p>相当于 <code>address.balance</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        address sender = msg.sender;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := balance(sender)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result2 = address(sender).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回</p>
<ul>
<li><code>0:uint256: result1 99999999999992173039</code></li>
<li><code>1:uint256: result2 99999999999992173039</code></li>
</ul>
<h4 id="selfbalance"><a href="#selfbalance" class="headerlink" title="selfbalance()"></a>selfbalance()</h4><p>相当于 <code>balance(address())</code>，但更便宜</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    constructor() payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := balance(address())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result2 = address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="extcodehash-a"><a href="#extcodehash-a" class="headerlink" title="extcodehash(a)"></a>extcodehash(a)</h4><p>相当于 <code>address.codehash</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (bytes32 result1, bytes32 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        address sender = msg.sender;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := extcodehash(address())</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = address(this).codehash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>0:bytes32: result1 0xcbefd958c5e7814e7e635b599c5859eb893c410292a7f9f82088c3e84ee3c0e9</code></li>
<li><code>1:bytes32: result2 0xcbefd958c5e7814e7e635b599c5859eb893c410292a7f9f82088c3e84ee3c0e9</code></li>
</ul>
<h4 id="caller"><a href="#caller" class="headerlink" title="caller()"></a>caller()</h4><p>相当于 <code>msg.sender</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public view returns (address ads1, address ads2) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            ads1 := caller()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ads2 = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="callvalue"><a href="#callvalue" class="headerlink" title="callvalue()"></a>callvalue()</h4><p>相当于 <code>msg.value</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        payable</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := callvalue()</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="chainid"><a href="#chainid" class="headerlink" title="chainid()"></a>chainid()</h4><p>相当于 <code>block.chainid</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := chainid() // 1</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = block.chainid; // 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="basefee"><a href="#basefee" class="headerlink" title="basefee()"></a>basefee()</h4><p>相当于 <code>block.basefee</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := basefee()</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = block.basefee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="timestamp"><a href="#timestamp" class="headerlink" title="timestamp()"></a>timestamp()</h4><p>相当于 <code>block.timestamp</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := timestamp()</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = block.timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="coinbase"><a href="#coinbase" class="headerlink" title="coinbase()"></a>coinbase()</h4><p>相当于 <code>block.coinbase</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (address result1, address result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := coinbase()</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = block.coinbase;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="number"><a href="#number" class="headerlink" title="number()"></a>number()</h4><p>相当于 <code>block.number</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := number()</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = block.number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="difficulty"><a href="#difficulty" class="headerlink" title="difficulty()"></a>difficulty()</h4><p>相当于 <code>block.difficulty</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := difficulty()</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = block.difficulty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gaslimit"><a href="#gaslimit" class="headerlink" title="gaslimit()"></a>gaslimit()</h4><p>相当于 <code>block.gaslimit</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := gaslimit()</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = block.gaslimit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="origin"><a href="#origin" class="headerlink" title="origin()"></a>origin()</h4><p>相当于 <code>tx.origin</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (address result1, address result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := origin()</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = tx.origin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gasprice"><a href="#gasprice" class="headerlink" title="gasprice()"></a>gasprice()</h4><p>相当于 <code>tx.gasprice</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := gasprice()</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = tx.gasprice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gas"><a href="#gas" class="headerlink" title="gas()"></a>gas()</h4><p>相当于 <code>gasleft()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := gas() // 2978815</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 与 assembly 之间的顺序不改变最后的值</span><br><span class="line">        // 所以 assembly 优先执行？</span><br><span class="line">        result2 = gasleft(); // 2978808</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="blockhash-b"><a href="#blockhash-b" class="headerlink" title="blockhash(b)"></a>blockhash(b)</h4><p>相当于 <code>blockhash(number)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (bytes32 result1, bytes32 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := blockhash(1)</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = blockhash(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><table>
<thead>
<tr>
<th>操作符号</th>
<th>返回值</th>
<th>版本</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>sload(p)</td>
<td></td>
<td>F</td>
<td><code>storage[p]</code></td>
</tr>
<tr>
<td>mload(p)</td>
<td></td>
<td>F</td>
<td><code>mem[p…(p+32))</code></td>
</tr>
<tr>
<td>sstore(p, v)</td>
<td>-</td>
<td>F</td>
<td><code>storage[p] := v</code></td>
</tr>
<tr>
<td>mstore(p, v)</td>
<td>-</td>
<td>F</td>
<td><code>mem[p…(p+32)) := v</code></td>
</tr>
<tr>
<td>mstore8(p, v)</td>
<td>-</td>
<td>F</td>
<td><code>mem[p] := v</code> &amp; 0xff (只修改单个字节)</td>
</tr>
<tr>
<td>keccak256(p, n)</td>
<td></td>
<td>F</td>
<td><code>keccak(mem[p…(p+n)))</code></td>
</tr>
<tr>
<td>create(v, p, n)</td>
<td></td>
<td>F</td>
<td>create 创建合约</td>
</tr>
<tr>
<td>create2(v, p, n, s)</td>
<td></td>
<td>C</td>
<td>create2 创建合约</td>
</tr>
</tbody></table>
<p>小例子:</p>
<ul>
<li><code>mload(p)</code>: 分配数据</li>
<li><code>mstore(offset, value)</code>: 在 <code>offset</code> 的位置储存 <code>value</code></li>
</ul>
<h4 id="sload-p"><a href="#sload-p" class="headerlink" title="sload(p)"></a>sload(p)</h4><p>sload 是 storage load，<code>sload(key)</code> 是从 storage 的哪个 slot 来 load，详细原理可以在后面介绍的 <strong>状态变量在存储中的布局</strong> 了解更多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint256 public a = 123;</span><br><span class="line">    uint256 public b = 456;</span><br><span class="line"></span><br><span class="line">    function demoAssembly() public view returns (uint256) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // v 是长度是 32 bytes</span><br><span class="line">            // 从 slot #0 读数据 =&gt; 读到的是 123</span><br><span class="line">            // 从 slot #1 读数据 =&gt; 读到的是 456</span><br><span class="line">            let v := sload(0)</span><br><span class="line"></span><br><span class="line">            // 在内存位置 0x80 处储存变量 v 后面的数据</span><br><span class="line">            mstore(0x80, v)</span><br><span class="line"></span><br><span class="line">            // 返回值:从 0x80 位置，返回 32个字节</span><br><span class="line">            return(0x80, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中，<code>slot #0</code> 是 123，<code>slot #1</code> 是 456。</p>
<p>注意: <code>slot #0</code> 可能是多个状态变量公用的。比如把状态变量改为如下类型,读 <code>slot #0</code> ，该位置储存了<code>a+b</code>;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint128 public a = 1;</span><br><span class="line">uint128 public b = 2;</span><br><span class="line">uint256 public c = 456;</span><br></pre></td></tr></table></figure>

<h4 id="mload-p"><a href="#mload-p" class="headerlink" title="mload(p)"></a>mload(p)</h4><p>mload 是 memory load，<code>mload(key)</code> 是从 memory 的哪个 slot 来 load，类似 <code>sload</code>。</p>
<ul>
<li>问题：内存数据 mload 时为什么从第 32 位开始?<ul>
<li>答案：前 32 个字节存储的是数据的长度;</li>
<li>参考: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/wanghui-garcia/p/9592807.html">https://www.cnblogs.com/wanghui-garcia/p/9592807.html</a></li>
</ul>
</li>
</ul>
<h4 id="sstore-p-v"><a href="#sstore-p-v" class="headerlink" title="sstore(p, v)"></a>sstore(p, v)</h4><h4 id="mstore-p-v"><a href="#mstore-p-v" class="headerlink" title="mstore(p, v)"></a>mstore(p, v)</h4><p>下面 name1 和 name2 都返回 “Anbang” 的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // gas 23471</span><br><span class="line">    bytes6 public name1 = &quot;Anbang&quot;; // 0x416e62616e67</span><br><span class="line"></span><br><span class="line">    // gas 21229</span><br><span class="line">    function name2() public pure returns (string memory) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // 在 0x20 处 储存值 0x20</span><br><span class="line">            mstore(0x20, 0x20)</span><br><span class="line"></span><br><span class="line">            // name1 length = 0x06</span><br><span class="line">            // 参数1: 0x40 + length = 0x40 + 0x06 =&gt; 0x46</span><br><span class="line">            // 参数2: length + name1  = 0x46 + 0x416e62616e67 =&gt; 0x06416e62616e67</span><br><span class="line">            mstore(0x46, 0x06416e62616e67)</span><br><span class="line"></span><br><span class="line">            // 返回 memory 从 0x20处之后的 0x60 长度的数据</span><br><span class="line">            return(0x20, 0x60)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是从<code>0x20</code>处开始写数据，这个位置不是强制的，使用<code>0x00</code>也可以的。</p>
<h4 id="mstore8-p-v"><a href="#mstore8-p-v" class="headerlink" title="mstore8(p, v)"></a>mstore8(p, v)</h4><h4 id="keccak256-p-n"><a href="#keccak256-p-n" class="headerlink" title="keccak256(p, n)"></a>keccak256(p, n)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // 0x01</span><br><span class="line">    function solidityKeccak(bytes memory _input) public pure returns (bytes32) &#123;</span><br><span class="line">        return keccak256(abi.encodePacked(_input));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 0x01</span><br><span class="line">    function assemblyKeccak(bytes memory _input)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes32 x)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            x := keccak256(add(_input, 0x20), mload(_input))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="create-v-p-n"><a href="#create-v-p-n" class="headerlink" title="create(v, p, n)"></a>create(v, p, n)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> assembly &#123;</span><br><span class="line">    // create(v,p,n);</span><br><span class="line">    // v 是 发送的ETH值</span><br><span class="line">    // p 是 内存中机器码开始的位置</span><br><span class="line">    // n 是 内存中机器码的大小</span><br><span class="line">    // msg.value 不能使用，需要用 callvalue()</span><br><span class="line">    adds := create(callvalue(), add(_code, 0x20), mload(_code))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="create2-v-p-n-s"><a href="#create2-v-p-n-s" class="headerlink" title="create2(v, p, n, s)"></a>create2(v, p, n, s)</h4><p>下面是 <a target="_blank" rel="noopener" href="https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Factory.sol">UniswapV2Factory</a> 中创建 pair 核心逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Z &#123;</span><br><span class="line">    bytes6 public name1 = &quot;Anbang&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function addr() public returns (address pair) &#123;</span><br><span class="line">        bytes memory bytecode = type(Z).creationCode;</span><br><span class="line">        // bytes32 salt = keccak256(abi.encodePacked(address(0), address(1)));</span><br><span class="line">        uint256 salt = block.number;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="操作数据-大小"><a href="#操作数据-大小" class="headerlink" title="操作数据&#x2F;大小"></a>操作数据&#x2F;大小</h3><table>
<thead>
<tr>
<th>操作符号</th>
<th>返回值</th>
<th>版本</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>msize()</td>
<td></td>
<td>F</td>
<td>内存大小，即最大访问内存索引</td>
</tr>
<tr>
<td>pc()</td>
<td></td>
<td>F</td>
<td>当前在代码中的位置</td>
</tr>
<tr>
<td>codesize()</td>
<td></td>
<td>F</td>
<td>当前合约的代码大小 &#x2F; execution context</td>
</tr>
<tr>
<td>codecopy(t, f, s)</td>
<td>-</td>
<td>F</td>
<td>从位置 f 的代码复制 s 个字节到位置 t 的内存</td>
</tr>
<tr>
<td>extcodesize(a)</td>
<td></td>
<td>F</td>
<td>获取地址 a 的代码大小</td>
</tr>
<tr>
<td>extcodecopy(a, t, f, s)</td>
<td>-</td>
<td>F</td>
<td>像 codecopy(t, f, s) 但在地址 a 处获取代码</td>
</tr>
<tr>
<td>signextend(i, x)</td>
<td></td>
<td>F</td>
<td>sign extend from <code>(i*8+7)</code>th bit counting from least significant</td>
</tr>
<tr>
<td>byte(n, x)</td>
<td></td>
<td>F</td>
<td>x 的第 n 个字节，这个索引是从 0 开始的</td>
</tr>
<tr>
<td>pop(x)</td>
<td>-</td>
<td>F</td>
<td>丢弃值 x</td>
</tr>
</tbody></table>
<h4 id="msize"><a href="#msize" class="headerlink" title="msize()"></a>msize()</h4><p>内存大小，即最大访问内存索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function test() public pure returns (int256) &#123;</span><br><span class="line">        int8 v0 = 1;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            v0 := msize()</span><br><span class="line">        &#125;</span><br><span class="line">        return int256(v0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pc"><a href="#pc" class="headerlink" title="pc()"></a>pc()</h4><h4 id="codesize"><a href="#codesize" class="headerlink" title="codesize()"></a>codesize()</h4><h4 id="codecopy-t-f-s"><a href="#codecopy-t-f-s" class="headerlink" title="codecopy(t, f, s)"></a>codecopy(t, f, s)</h4><h4 id="extcodesize-a"><a href="#extcodesize-a" class="headerlink" title="extcodesize(a)"></a>extcodesize(a)</h4><h4 id="extcodecopy-a-t-f-s"><a href="#extcodecopy-a-t-f-s" class="headerlink" title="extcodecopy(a, t, f, s)"></a>extcodecopy(a, t, f, s)</h4><h4 id="signextend-i-x"><a href="#signextend-i-x" class="headerlink" title="signextend(i, x)"></a>signextend(i, x)</h4><h4 id="byte-n-x"><a href="#byte-n-x" class="headerlink" title="byte(n, x)"></a>byte(n, x)</h4><h4 id="pop-x"><a href="#pop-x" class="headerlink" title="pop(x)"></a>pop(x)</h4><h3 id="call-相关"><a href="#call-相关" class="headerlink" title="call 相关"></a>call 相关</h3><table>
<thead>
<tr>
<th>操作符号</th>
<th>返回值</th>
<th>版本</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>calldataload(p)</td>
<td></td>
<td>F</td>
<td>从位置 p 开始调用数据 (32 bytes)</td>
</tr>
<tr>
<td>calldatasize()</td>
<td></td>
<td>F</td>
<td>调用数据的大小（以字节为单位）</td>
</tr>
<tr>
<td>calldatacopy(t, f, s)</td>
<td>-</td>
<td>F</td>
<td>从位置 f 的 calldata 复制 s 个字节到位置 t 的内存</td>
</tr>
<tr>
<td>call(g, a, v, in, insize, out, outsize)</td>
<td></td>
<td>F</td>
<td>在地址 a 调用合约 <a target="_blank" rel="noopener" href="https://www.axihe.com/#yul-call-return-area">See more</a></td>
</tr>
<tr>
<td>callcode(g, a, v, in, insize, out, outsize)</td>
<td></td>
<td>F</td>
<td>与 <code>call</code> 相同，但仅使用 a 中的代码，否则留在当前合约的上下文中 <a target="_blank" rel="noopener" href="https://www.axihe.com/#yul-call-return-area">See more</a></td>
</tr>
<tr>
<td>delegatecall(g, a, in, insize, out, outsize)</td>
<td></td>
<td>H</td>
<td>与 <code>callcode</code> 相同，但也保留 <code>caller</code> 和 <code>callvalue</code> <a target="_blank" rel="noopener" href="https://www.axihe.com/#yul-call-return-area">See more</a></td>
</tr>
<tr>
<td>staticcall(g, a, in, insize, out, outsize)</td>
<td></td>
<td>B</td>
<td>与 <code>call(g, a, 0, in, insize, out, outsize)</code> 相同，但不允许状态修改 ons <a target="_blank" rel="noopener" href="https://www.axihe.com/#yul-call-return-area">See more</a></td>
</tr>
</tbody></table>
<h3 id="结束执行"><a href="#结束执行" class="headerlink" title="结束执行"></a>结束执行</h3><table>
<thead>
<tr>
<th>操作符号</th>
<th>返回值</th>
<th>版本</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>return(p, s)</td>
<td>-</td>
<td>F</td>
<td>结束执行, return data mem[p…(p+s))</td>
</tr>
<tr>
<td>stop()</td>
<td>-</td>
<td>F</td>
<td>结束执行, 类似 <code>return(0, 0)</code></td>
</tr>
<tr>
<td>revert(p, s)</td>
<td>-</td>
<td>B</td>
<td>结束执行, revert state changes, return data mem[p…(p+s))</td>
</tr>
<tr>
<td>selfdestruct(a)</td>
<td>-</td>
<td>F</td>
<td>结束执行, destroy current contract and send funds to a</td>
</tr>
<tr>
<td>invalid()</td>
<td>-</td>
<td>F</td>
<td>结束执行 with invalid instruction</td>
</tr>
<tr>
<td>returndatasize()</td>
<td></td>
<td>B</td>
<td>最后返回数据的大小</td>
</tr>
<tr>
<td>returndatacopy(t, f, s)</td>
<td>-</td>
<td>B</td>
<td>将 s 个字节从位置 f 的 returndata 复制到位置 t 的 mem</td>
</tr>
</tbody></table>
<h3 id="log-信息"><a href="#log-信息" class="headerlink" title="log 信息"></a>log 信息</h3><table>
<thead>
<tr>
<th>操作符号</th>
<th>返回值</th>
<th>版本</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>log0(p, s)</td>
<td>-</td>
<td>F</td>
<td>log without topics and data mem[p…(p+s))</td>
</tr>
<tr>
<td>log1(p, s, t1)</td>
<td>-</td>
<td>F</td>
<td>log with topic t1 and data mem[p…(p+s))</td>
</tr>
<tr>
<td>log2(p, s, t1, t2)</td>
<td>-</td>
<td>F</td>
<td>log with topics t1, t2 and data mem[p…(p+s))</td>
</tr>
<tr>
<td>log3(p, s, t1, t2, t3)</td>
<td>-</td>
<td>F</td>
<td>log with topics t1, t2, t3 and data mem[p…(p+s))</td>
</tr>
<tr>
<td>log4(p, s, t1, t2, t3, t4)</td>
<td>-</td>
<td>F</td>
<td>log with topics t1, t2, t3, t4 and data mem[p…(p+s))</td>
</tr>
</tbody></table>
<h1 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h1><h3 id="例子-1-一个演示"><a href="#例子-1-一个演示" class="headerlink" title="例子 1:一个演示"></a>例子 1:一个演示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">library VectorSum &#123;</span><br><span class="line">    // 此函数效率较低，因为优化器当前无法删除数组访问中的边界检查。</span><br><span class="line">    function sumSolidity(uint256[] memory data)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256 sum)</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt; data.length; ++i) sum += data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // We know that we only access the array in bounds, so we can avoid the check.</span><br><span class="line">    // 0x20 needs to be added to an array because the first slot contains the</span><br><span class="line">    // array length.</span><br><span class="line">    // 我们知道我们只在边界内访问数组，</span><br><span class="line">    // 所以我们可以避免检查。0x20 需要添加到数组，因为第一个槽包含数组长度。</span><br><span class="line">    function sumAsm(uint256[] memory data) public pure returns (uint256 sum) &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt; data.length; ++i) &#123;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                sum := add(sum, mload(add(add(data, 0x20), mul(i, 0x20))))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Same as above, but accomplish the entire code within inline assembly.</span><br><span class="line">    function sumPureAsm(uint256[] memory data)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256 sum)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // Load the length (first 32 bytes)</span><br><span class="line">            let len := mload(data)</span><br><span class="line"></span><br><span class="line">            // Skip over the length field.</span><br><span class="line">            //</span><br><span class="line">            // Keep temporary variable so it can be incremented in place.</span><br><span class="line">            //</span><br><span class="line">            // NOTE: incrementing data would result in an unusable</span><br><span class="line">            //       data variable after this assembly block</span><br><span class="line">            let dataElementLocation := add(data, 0x20)</span><br><span class="line"></span><br><span class="line">            // Iterate until the bound is not met.</span><br><span class="line">            for &#123;</span><br><span class="line">                let end := add(dataElementLocation, mul(len, 0x20))</span><br><span class="line">            &#125; lt(dataElementLocation, end) &#123;</span><br><span class="line">                dataElementLocation := add(dataElementLocation, 0x20)</span><br><span class="line">            &#125; &#123;</span><br><span class="line">                sum := add(sum, mload(dataElementLocation))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例子-2-获取合约代码"><a href="#例子-2-获取合约代码" class="headerlink" title="例子 2:获取合约代码"></a>例子 2:获取合约代码</h3><p>gas 相差无几，重点看一下 code 的背后原理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // 24310 gas</span><br><span class="line">    function codeBySolidity(address _addr)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (bytes memory o_code)</span><br><span class="line">    &#123;</span><br><span class="line">        return _addr.code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 24286 gas</span><br><span class="line">    function codeByAssembly(address _addr)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (bytes memory o_code)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // 1.使用 extcodesize 获取合约内的代码大小</span><br><span class="line">            let size := extcodesize(_addr)</span><br><span class="line"></span><br><span class="line">            // 2.使用 mload 分配输出字节数组</span><br><span class="line">            // 类似 o_code = new bytes（size）</span><br><span class="line">            o_code := mload(0x40)</span><br><span class="line"></span><br><span class="line">            // 在 0x40 的位置存入数据</span><br><span class="line">            //      add(size, 0x20) :</span><br><span class="line">            //              size 加 0x20</span><br><span class="line">            //      add(add(size, 0x20), 0x1f)</span><br><span class="line">            //              size 加 0x20,再加 0x1f</span><br><span class="line">            //      not(0x1f)</span><br><span class="line">            //              0x1f 的按位非</span><br><span class="line">            //      and(add(add(size, 0x20), 0x1f), not(0x1f))</span><br><span class="line">            //          &quot;size 加 0x20,再加 0x1f&quot; 和 &quot;0x1f的按位非&quot; 的按位与</span><br><span class="line">            mstore(</span><br><span class="line">                0x40,</span><br><span class="line">                add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f)))</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            // 把长度保存到内存中</span><br><span class="line">            mstore(o_code, size)</span><br><span class="line"></span><br><span class="line">            // 实际获取代码，这需要汇编语言</span><br><span class="line">            extcodecopy(_addr, add(o_code, 0x20), 0, size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例子-3-计算数值数组的和"><a href="#例子-3-计算数值数组的和" class="headerlink" title="例子 3:计算数值数组的和"></a>例子 3:计算数值数组的和</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">library VectorSum &#123;</span><br><span class="line">    // 因为目前的优化器在访问数组时无法移除边界检查，</span><br><span class="line">    // 所以这个函数的执行效率比较低。</span><br><span class="line">    function sumSolidity(uint256[] memory _data)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256 o_sum)</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt; _data.length; ++i) o_sum += _data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 我们只能在数组范围内访问数组元素，所以我们可以在内联汇编中不做边界检查。</span><br><span class="line">    // 由于 ABI 编码中数组数据的第一个字（32 字节）的位置保存的是数组长度，</span><br><span class="line">    // 所以我们在访问数组元素时需要加入 0x20 作为偏移量。</span><br><span class="line">    function sumAsm(uint256[] memory _data)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256 o_sum)</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt; _data.length; ++i) &#123;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                o_sum := add(o_sum, mload(add(add(_data, 0x20), mul(i, 0x20))))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 和上面一样，但在内联汇编内完成整个代码。</span><br><span class="line">    function sumPureAsm(uint256[] memory _data)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256 o_sum)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // 取得数组长度（取前 32 字节）</span><br><span class="line">            let len := mload(_data)</span><br><span class="line"></span><br><span class="line">            // 略过长度字段。</span><br><span class="line">            //</span><br><span class="line">            // 保持临时变量以便它可以在原地增加。</span><br><span class="line">            //</span><br><span class="line">            // 注意：对 _data 数值的增加将导致 _data 在这个汇编语句块之后不再可用。</span><br><span class="line">            //      因为无法再基于 _data 来解析后续的数组数据。</span><br><span class="line">            let data := add(_data, 0x20)</span><br><span class="line"></span><br><span class="line">            // 迭代到数组数据结束</span><br><span class="line">            for &#123;</span><br><span class="line">                let end := add(data, mul(len, 0x20))</span><br><span class="line">            &#125; lt(data, end) &#123;</span><br><span class="line">                data := add(data, 0x20)</span><br><span class="line">            &#125; &#123;</span><br><span class="line">                o_sum := add(o_sum, mload(data))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/07/20/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/14-Library%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/20/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/14-Library%E5%BA%93/" class="post-title-link" itemprop="url">14-Library库</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-20 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-20T00:00:00+08:00">2022-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>library 是智能合约的精简版，像智能合约一样，位于区块链上，包含可以被其他合约使用的代码。库合约有两种使用方法，直接调用和 <code>using...for...</code> 使用。</p>
<h1 id="库合约与普通智能合约区别"><a href="#库合约与普通智能合约区别" class="headerlink" title="库合约与普通智能合约区别"></a>库合约与普通智能合约区别</h1><p>库与合约类似，库的目的是只需要在特定的地址部署一次，而它们的代码可以通过EVM 的 <code>DELEGATECALL</code> 特性进行重用。这意味着如果库函数被调用，它的代码在调用合约的上下文中执行，即 <code>this</code> 指向调用合约，特别注意，他访问的是调用合约存储的状态。因为每个库都是一段独立的代码，所以它仅能访问调用合约明确提供的状态变量（否则它就无法通过名字访问这些变量）。</p>
<ul>
<li><p><strong>库不能有任何状态变量</strong></p>
</li>
<li><p><strong>它们也不能继承其他合约</strong>。</p>
</li>
<li><p>库合约函数的可视范围通常为internal，可变性为pure，也就是对所有使用它的合约可见。</p>
<ul>
<li>定义成 <code>external</code> 毫无意义，因为库合约函数只在内部使用，不独立运行。</li>
<li>同样定义成 <code>private</code> 也不行，因为其它合约无法使用。</li>
</ul>
</li>
<li><p>禁止使用 <code>fallback</code> &#x2F; <code>receive</code> 函数，所以导致也不能接收以太币</p>
</li>
<li><p>Library 被销毁后，则所有方法恢复为初始值，功能失效。</p>
</li>
<li><p>使用库 library 的合约，可以将库合约视为隐式的父合约，当然它们不会显式的出现在继承关系中。也就是不用写 <code>is</code> 来继承，直接可以在合约中使用。</p>
</li>
<li><p>按照规范，库合约的名字需要首字母大写（大驼峰命名方式）</p>
</li>
</ul>
<p>可以通过类型转换, 将库类型更改为 <code>address</code> 类型, 例如: 使用<code>address(LibraryName)</code>,由于编译器无法知道库的部署位置，编译器会生成<code>__$30bbc0abd4d6364515865950d3e0d10953$__</code>形式的占位符，该占位符是完整的库名称的 keccak256 哈希的十六进制编码的 34 个字符的前缀，例如：如果该库存储在 libraries 目录中名为 bigint.sol 的文件中，则完整的库名称为<code>libraries/bigint.sol:BigInt</code>。</p>
<p>此类字节码不完整的合约，不应该部署。占位符需要替换为实际地址。你可以通过在编译库时将它们传递给编译器或使用链接器更新已编译的二进制文件来实现。有关如何使用命令行编译器进行链接的信息，请参见 <a target="_blank" rel="noopener" href="https://learnblockchain.cn/docs/solidity/using-the-compiler.html#/library-linking"><code>library-linking</code></a> 。</p>
<h1 id="直接调用库合约方法"><a href="#直接调用库合约方法" class="headerlink" title="直接调用库合约方法"></a>直接调用库合约方法</h1><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例 1"></a>案例 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">library Math &#123;</span><br><span class="line">    function max(uint256 _x, uint256 _y) internal pure returns (uint256) &#123;</span><br><span class="line">        return _x &gt; _y ? _x : _y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function testMax(uint256 _x, uint256 _y) external pure returns (uint256) &#123;</span><br><span class="line">        return Math.max(_x, _y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例 2"></a>案例 2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">library ArrayLib &#123;</span><br><span class="line">    function find(uint256[] storage _arr, uint256 _value)</span><br><span class="line">        internal</span><br><span class="line">        view</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint256 index = 0; index &lt; _arr.length; index++) &#123;</span><br><span class="line">            if (_arr[index] == _value) &#123;</span><br><span class="line">                return index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        revert(&quot;Not Found&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    uint256[] public arr = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19];</span><br><span class="line"></span><br><span class="line">    // 会成功</span><br><span class="line">    function test1() external view returns (uint256) &#123;</span><br><span class="line">        return ArrayLib.find(arr, 15);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 会失败</span><br><span class="line">    function test2() external view returns (uint256) &#123;</span><br><span class="line">        return ArrayLib.find(arr, 99);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="using-for-使用库合约"><a href="#using-for-使用库合约" class="headerlink" title="using...for... 使用库合约"></a><code>using...for...</code> 使用库合约</h1><p>使用库合约还有更方便的方法，那就是 <code>using for</code> 指令。</p>
<p>例如：<code>using A for B</code> 用来将 A 库里定义的函数附着到类型 B。<strong>这些函数将会默认接收调用函数对象的实例作为第一个参数</strong>。<br>using For 可在文件或合约内部及合约级都是有效的。</p>
<p>核心如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using ArrayLib for uint256[];</span><br><span class="line">uint256[] public arr = [10, 11, 12, 13, 14,...];</span><br><span class="line">...</span><br><span class="line">arr.find(15); // 直接使用</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">library ArrayLib &#123;</span><br><span class="line">    function find(uint256[] storage _arr, uint256 _value)</span><br><span class="line">        internal</span><br><span class="line">        view</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint256 index = 0; index &lt; _arr.length; index++) &#123;</span><br><span class="line">            if (_arr[index] == _value) &#123;</span><br><span class="line">                return index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        revert(&quot;Not Found&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    // using for 可以让所有 uint256[] 数据，都具有 ArrayLib 内的方法</span><br><span class="line">    using ArrayLib for uint256[];</span><br><span class="line"></span><br><span class="line">    uint256[] public arr = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19];</span><br><span class="line"></span><br><span class="line">    function test1() external view returns (uint256) &#123;</span><br><span class="line">        // return ArrayLib.find(arr, 15);</span><br><span class="line"></span><br><span class="line">        // 可以直接使用 arr.find，而不需要额外修改 ArrayLib 内的代码</span><br><span class="line">        return arr.find(15);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test2() external view returns (uint256) &#123;</span><br><span class="line">        // return ArrayLib.find(arr, 99);</span><br><span class="line">        return arr.find(99);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="using-for-其他用法"><a href="#using-for-其他用法" class="headerlink" title="using for 其他用法"></a>using for 其他用法</h3><p>第一部分 <code>A</code> 可以是以下之一：</p>
<ul>
<li>一些库或文件级的函数列表(<code>using &#123;f, g, h, L.t&#125; for uint;</code>)，仅是那些函数被附加到类型。</li>
<li>库名称 (<code>using L for uint;</code>) ，库里所有的函数(包括 public 和 internal 函数) 被附加到类型上。</li>
</ul>
<p>在文件级，第二部分 <code>B</code> 必须是一个显式类型（不用指定数据位置）</p>
<p>在合约内，你可以使用 <code>using L for *;</code>， 表示库 <code>L</code>中的函数被附加在所有类型上。</p>
<p>如果你指定一个库，库内所有函数都会被加载，即使它们的第一个参数类型与对象的类型不匹配。类型检查会在函数调用和重载解析时执行。</p>
<p>如果你使用函数列表 (<code>using &#123;f, g, h, L.t&#125; for uint;</code>)， 那么类型<br>(<code>uint</code>) 会隐式的转换为这些函数的第一个参数。<br>即便这些函数中没有一个被调用，这个检查也会进行。</p>
<p><code>using A for B;</code> 指令仅在当前作用域有效（要么是合约中，或当前模块、或源码单元），包括在作用域内的所有函数，在合约或模块之外则无效。</p>
<p>当 <code>using for</code> 指令在文件级别使用，并应用于一个用户定义类型（在用一个文件定义的文件级别的用户类型），<code>global</code> 关键字可以添加到末尾。产生的效果是，这些函数被附加到使用该类型的任何地方（包括其他文件），而不仅仅是声明处所在的作用域。</p>
<p>在下面的例子中，我们将使用库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">library Search &#123;</span><br><span class="line">    function indexOf(uint[] storage self, uint value)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint)</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint i = 0; i &lt; self.length; i++)</span><br><span class="line">            if (self[i] == value) return i;</span><br><span class="line">        return type(uint).max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">using Search for uint[];</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using Search for uint[];</span><br><span class="line">    uint[] data;</span><br><span class="line"></span><br><span class="line">    function append(uint value) public &#123;</span><br><span class="line">        data.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function replace(uint from, uint to) public &#123;</span><br><span class="line">        // 执行库函数调用</span><br><span class="line">        uint index = data.indexOf(from);</span><br><span class="line">        if (index == type(uint).max)</span><br><span class="line">            data.push(to);</span><br><span class="line">        else</span><br><span class="line">            data[index] = to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，所有 external 库调用都是实际的 EVM 函数调用。这意味着如果传递内存或值类型，都将产生一个副本，即使是 <code>self</code> 变量。 引用存储变量或者 internal 库调用 是唯一不会发生拷贝的情况。</p>
<h1 id="直接调用-和-using-for-对比"><a href="#直接调用-和-using-for-对比" class="headerlink" title="直接调用 和 using for 对比"></a>直接调用 和 using for 对比</h1><ul>
<li>using for 更符合语义化</li>
<li>库合约使用 using for 比直接使用更省 gas</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">library Sum &#123;</span><br><span class="line">    function sum(uint256[] memory _data) public pure returns (uint256 temp) &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt; _data.length; ++i) &#123;</span><br><span class="line">            temp += _data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    using Sum for uint256[];</span><br><span class="line">    uint256[] data;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        data.push(1);</span><br><span class="line">        data.push(2);</span><br><span class="line">        data.push(3);</span><br><span class="line">        data.push(4);</span><br><span class="line">        data.push(5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 43874 gas</span><br><span class="line">    function sumA1() external view returns (uint256) &#123;</span><br><span class="line">        return Sum.sum(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 43531 gas</span><br><span class="line">    function sumA2() external view returns (uint256) &#123;</span><br><span class="line">        return data.sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="销毁合约库"><a href="#销毁合约库" class="headerlink" title="销毁合约库"></a>销毁合约库</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">library Math &#123;</span><br><span class="line">    function max(uint256 _x, uint256 _y) internal pure returns (uint256) &#123;</span><br><span class="line">        return _x &gt; _y ? _x : _y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function kill() internal &#123;</span><br><span class="line">        selfdestruct(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Libraries cannot have fallback functions.</span><br><span class="line">    // fallback() external &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // Libraries cannot have receive ether functions.</span><br><span class="line">    // receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function testMax(uint256 _x, uint256 _y) external pure returns (uint256) &#123;</span><br><span class="line">        return Math.max(_x, _y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testKill() external &#123;</span><br><span class="line">        return Math.kill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行 <code>Test.testMax</code></li>
<li>执行 <code>Test.testKill</code></li>
<li>再次执行 <code>Test.testMax</code>，发现结果是默认值</li>
</ul>
<h1 id="扩展-库的调用保护"><a href="#扩展-库的调用保护" class="headerlink" title="扩展:库的调用保护"></a>扩展:库的调用保护</h1><p>如果库的代码是通过 <code>CALL</code> 来执行，而不是 <code>DELEGATECALL</code> 那么执行的结果会被回退，除非是对 <code>view</code> 或者 <code>pure</code> 函数的调用。EVM 没有为合约提供检测是否使用 <code>CALL</code> 的直接方式，但是合约可以使用<code>ADDRESS</code> 操作码找出正在运行的”位置”。生成的代码通过比较这个地址和构造时的地址来确定调用模式。</p>
<p>更具体地说，库的运行时代码总是从一个 push 指令开始，它在编译时是 20 字节的零。当运行部署代码时，这个常数被内存中的当前地址替换，修改后的代码存储在合约中。在运行时，部署时地址就成为了第一个被 push 到堆栈上的常数， 对于任何 non-view 和 non-pure 函数，调度器代码都将对比当前地址与这个常数是否一致。这意味着库在链上存储的实际代码与编译器输出的 <code>deployedBytecode</code> 的编码是不同。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/07/17/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/13-interface%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/17/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/13-interface%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">13-interface接口</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-17 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-17T00:00:00+08:00">2022-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>很多时候，我们需要调用已经部署在链上的已经合约，这时候可以通过接口合约实现部分调用的逻辑，我们只需要写一个与之对应的接口合约，就可以调用了。</p>
<p>在 solidity 语言中，只要某个合约有和接口种相同的函数声明，就可以被此合约所接受。接口就是起到一个桥接的作用；类似手机的接口，只要匹配，可以进行充电，也可以进行听歌。</p>
<p>interface 类似于<a target="_blank" rel="noopener" href="https://www.axihe.com/source/10.inheritance.html#abstract">抽象合约</a> ，但它们不能实现任何功能。还有其他限制。 <code>interface</code>内的函数被隐式标记为virtual</p>
<h1 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h1><ul>
<li><p>无法实现任何功能，没有函数体。</p>
</li>
<li><p>无法定义构造函数。</p>
</li>
<li><p>无法定义状态变量。</p>
</li>
<li><p>无法定义结构（<code>struct</code>）（<code>0.5.0</code> 版本开始接口里可以支持声明 <code>enum</code> 类型）。</p>
</li>
<li><p>不可以声明修改器。</p>
</li>
<li><p>所有声明的函数必须是external的，尽管在合约里可以是 public</p>
<ul>
<li>文档说：将来可能会解除这里的某些限制。</li>
</ul>
</li>
</ul>
<p>⚠️ 注意： interface 可以基于别的 interface，可以继承其他合约。比如 <code>interface IERC20Metadata is IERC20&#123;&#125;</code>,定义 <code>IERC20Metadata</code> 基于 <code>IERC20</code> 接口。</p>
<h1 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h1><p>接口需要有 interface 关键字，并且内部只需要有函数的声明，不用实现。只要某合约中有和词接口相同的函数声明，就可以被此合约所接受。语法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line">    函数声明;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口基本上仅限于合约 ABI 可以表示的内容，并且 ABI 和接口之间的转换不应该丢失任何信息。</p>
<p>在下面的例子中，定义了 cat 合约以及 dog 合约。他们都有 eat 方法.以此他们都可以被上面的 animalEat 接口所接收。</p>
<h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Cat &#123;</span><br><span class="line">    uint256 public age;</span><br><span class="line"></span><br><span class="line">    function eat() public returns (string memory) &#123;</span><br><span class="line">        age++;</span><br><span class="line">        return &quot;cat eat fish&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sleep1() public pure returns (string memory) &#123;</span><br><span class="line">        return &quot;sleep1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Dog &#123;</span><br><span class="line">    uint256 public age;</span><br><span class="line"></span><br><span class="line">    function eat() public returns (string memory) &#123;</span><br><span class="line">        age += 2;</span><br><span class="line">        return &quot;dog miss you&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sleep2() public pure returns (string memory) &#123;</span><br><span class="line">        return &quot;sleep2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface AnimalEat &#123;</span><br><span class="line">    function eat() external returns (string memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Animal &#123;</span><br><span class="line">    function test(address _addr) external returns (string memory) &#123;</span><br><span class="line">        AnimalEat general = AnimalEat(_addr);</span><br><span class="line">        return general.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试流程:</p>
<ol>
<li><p>部署 Cat 合约</p>
</li>
<li><p>部署 Dog 合约</p>
</li>
<li><p>部署 Animal 合约</p>
</li>
<li><p>调用Animal.test,参数是 Cat 合约地址</p>
<ol>
<li>返回 <code>&quot;string: cat eat fish&quot;</code></li>
<li>在 Cat 合约内查看 <code>age</code> 返回的数字</li>
</ol>
</li>
<li><p>调用Animal.test,参数是 Dog 合约地址</p>
<ol>
<li>返回 <code>&quot;string: dog miss you&quot;</code></li>
</ol>
</li>
<li><p>在 Dog 合约内查看 <code>age</code> 返回的数字</p>
</li>
</ol>
<p>在合约 Animal 中，调用函数 test，如果传递的是部署的 Cat 的合约地址，那么我们在调用接口的 eat 方法时，实则调用了 Cat 合约的 eat 方法。 同理，如果传递的是部署的 Dog 的合约地址，那么我们在调用接口的 eat 方法时，实则调用了 dog 合约的 eat 方法。</p>
<h3 id="隐式的标记为virtual"><a href="#隐式的标记为virtual" class="headerlink" title="隐式的标记为virtual"></a>隐式的标记为<code>virtual</code></h3><p>就像继承其他合约一样，合约可以继承接口。接口中的函数都会隐式的标记为<code>virtual</code> ，意味着他们会被重写并不需要 <code>override</code> 关键字。<br>但是不表示重写（overriding）函数可以再次重写，仅仅当重写的函数标记为<code>virtual</code> 才可以再次重写。</p>
<p>接口可以继承其他的接口，遵循同样继承规则。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">interface ParentA &#123;</span><br><span class="line">    function test() external returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ParentB &#123;</span><br><span class="line">    function test() external returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SubInterface is ParentA, ParentB &#123;</span><br><span class="line">    // 必须重新定义 test 函数，以表示兼容父合约含义</span><br><span class="line">    function test() external override(ParentA, ParentB) returns (uint256);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="全局属性-type-I-interfaceId"><a href="#全局属性-type-I-interfaceId" class="headerlink" title="全局属性 type(I).interfaceId"></a>全局属性 <code>type(I).interfaceId</code></h1><p>返回接口<code>I</code> 的 bytes4 类型的接口 ID，接口 ID 参考： EIP-165 定义的， 接口 ID 被定义为 XOR （异或） 接口内所有的函数的函数选择器（除继承的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">interface ParentA &#123;</span><br><span class="line">    function test() external returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function interfaceId() public pure returns (bytes4) &#123;</span><br><span class="line">    	//0xf8a8fd6d</span><br><span class="line">        return type(ParentA).interfaceId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ERC20-标准"><a href="#ERC20-标准" class="headerlink" title="ERC20 标准"></a>ERC20 标准</h1><h3 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h3><p><strong>问题: 如何判断一个 Token 合约是否为标准的 ERC20 合约？</strong></p>
<ul>
<li>只要含有 ERC20 接口规定的所有内容，就算标准的 ERC20 合约。<ul>
<li>至于方法内的逻辑是如何实现的，是不做判断。</li>
</ul>
</li>
</ul>
<p>详情参考: <a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-20">https://eips.ethereum.org/EIPS/eip-20</a></p>
<h3 id="标准-ERC20-接口"><a href="#标准-ERC20-接口" class="headerlink" title="标准 ERC20 接口"></a>标准 ERC20 接口</h3><ul>
<li><p>3 个查询</p>
<ul>
<li><code>balanceOf</code>: 查询指定地址的 Token 数量</li>
<li><code>totalSupply</code>: 查询当前合约的 Token 总量</li>
<li><code>allowance</code>: 查询指定地址对另外一个地址的剩余授权额度</li>
</ul>
</li>
<li><p>2 个交易</p>
<ul>
<li><code>transfer</code>: 从当前调用者地址发送指定数量的 Token 到指定地址,这是一个写入方法，所以还会抛出一个 <code>Transfer</code> 事件。</li>
<li><code>transferFrom</code>: 当向另外一个合约地址存款时，对方合约必须调用 transferFrom 才可以把 Token 拿到它自己的合约中。</li>
</ul>
</li>
<li><p>2 个事件</p>
<ul>
<li><code>Transfer</code></li>
<li><code>Approval</code></li>
</ul>
</li>
<li><p>1 个授权</p>
<ul>
<li><code>approve</code>: 授权指定地址可以操作调用者的最大 Token 数量。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line">    // 1个授权</span><br><span class="line">    function approve(address spender, uint256 amount) external returns (bool);</span><br><span class="line"></span><br><span class="line">    // 2个事件</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 amount);</span><br><span class="line">    event Approval(</span><br><span class="line">        address indexed owner,</span><br><span class="line">        address indexed spender,</span><br><span class="line">        uint256 amount</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 2个交易</span><br><span class="line">    function transfer(address recipient, uint256 amount)</span><br><span class="line">        external</span><br><span class="line">        returns (bool);</span><br><span class="line"></span><br><span class="line">    function transferFrom(</span><br><span class="line">        address sender,</span><br><span class="line">        address recipient,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) external returns (bool);</span><br><span class="line"></span><br><span class="line">    // 3个查询</span><br><span class="line">    function totalSupply() external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    function balanceOf(address account) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    function allowance(address owner, address spender)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (uint256);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ERC20-标准合约实现"><a href="#ERC20-标准合约实现" class="headerlink" title="ERC20 标准合约实现"></a>ERC20 标准合约实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line">    // 1个授权</span><br><span class="line">    function approve(address spender, uint256 amount) external returns (bool);</span><br><span class="line"></span><br><span class="line">    // 2个事件</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 amount);</span><br><span class="line">    event Approval(</span><br><span class="line">        address indexed owner,</span><br><span class="line">        address indexed spender,</span><br><span class="line">        uint256 amount</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 2个交易</span><br><span class="line">    function transfer(address recipient, uint256 amount)</span><br><span class="line">        external</span><br><span class="line">        returns (bool);</span><br><span class="line"></span><br><span class="line">    function transferFrom(</span><br><span class="line">        address sender,</span><br><span class="line">        address recipient,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) external returns (bool);</span><br><span class="line"></span><br><span class="line">    // 3个查询</span><br><span class="line">    function totalSupply() external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    function balanceOf(address account) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    function allowance(address owner, address spender)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ERC20 is IERC20 &#123;</span><br><span class="line">    // 状态变量</span><br><span class="line">    string public name;</span><br><span class="line">    string public symbol;</span><br><span class="line">    uint8 public immutable decimals;</span><br><span class="line"></span><br><span class="line">    address public immutable owner;</span><br><span class="line"></span><br><span class="line">    // uint256 public immutable totalSupply; // 不增加总量</span><br><span class="line">    uint256 public totalSupply; // 总价总量</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">    // 函数修改器</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;not owner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 构造函数</span><br><span class="line">    constructor(</span><br><span class="line">        string memory _name,</span><br><span class="line">        string memory _symbol,</span><br><span class="line">        uint8 _decimals,</span><br><span class="line">        uint256 _totalSupply</span><br><span class="line">    ) &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        name = _name;</span><br><span class="line">        symbol = _symbol;</span><br><span class="line">        decimals = _decimals;</span><br><span class="line">        totalSupply = _totalSupply;</span><br><span class="line">        balanceOf[msg.sender] = _totalSupply;</span><br><span class="line">        emit Transfer(address(0), msg.sender, _totalSupply);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1个授权</span><br><span class="line">    function approve(address spender, uint256 amount) external returns (bool) &#123;</span><br><span class="line">        allowance[msg.sender][spender] = amount;</span><br><span class="line">        emit Approval(msg.sender, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2个交易</span><br><span class="line">    function transfer(address recipient, uint256 amount)</span><br><span class="line">        external</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">        balanceOf[recipient] += amount;</span><br><span class="line">        emit Transfer(msg.sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(</span><br><span class="line">        address sender,</span><br><span class="line">        address recipient,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) external returns (bool) &#123;</span><br><span class="line">        // msg.sender 也就是当前调用者，是被批准者</span><br><span class="line">        allowance[sender][msg.sender] -= amount;</span><br><span class="line">        balanceOf[sender] -= amount;</span><br><span class="line">        balanceOf[recipient] += amount;</span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1个铸币 - 非必须</span><br><span class="line">    function mint(uint256 amount) external onlyOwner returns (bool) &#123;</span><br><span class="line">        totalSupply += amount;</span><br><span class="line">        balanceOf[msg.sender] += amount;</span><br><span class="line">        emit Transfer(address(0), msg.sender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1个销毁 - 非必须</span><br><span class="line">    function burn(uint256 amount) external returns (bool) &#123;</span><br><span class="line">        totalSupply -= amount;</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">        emit Transfer(msg.sender, address(0), amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 转移 owner 权限等其他一些操作均是看各自业务，非必需的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ERC721-标准"><a href="#ERC721-标准" class="headerlink" title="ERC721 标准"></a>ERC721 标准</h1><p>参考资料:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-721">https://eips.ethereum.org/EIPS/eip-721</a></li>
<li><a target="_blank" rel="noopener" href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-721/">https://ethereum.org/zh/developers/docs/standards/tokens/erc-721/</a></li>
</ul>
<h3 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h3><p>非同质化代币（NFT）用于以唯一的方式标识某人或者某物。 此类型的代币可以被完美地用于出售下列物品的平台：收藏品、密钥、彩票、音乐会座位编号、体育比赛等。 这种类型的代币有着惊人的潜力，因此它需要一个适当的标准。ERC-721 就是为解决这个问题而来！</p>
<p>所有 NFTs 都有一个 <code>uint256</code> 变量，名为 <code>tokenId</code>，所以对于任何 ERC-721 合约，这对值 <code>contract address, tokenId</code> 必须是全局唯一的。 也就是说，去中心化应用程序可以有一个“转换器”， 使用 tokenId 作为输入并输出一些很酷的事物图像，例如僵尸、武器、技能或神奇的小猫咪！</p>
<h3 id="合约代码"><a href="#合约代码" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @dev ERC165 标准的接口 https://eips.ethereum.org/EIPS/eip-165</span><br><span class="line"> * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified</span><br><span class="line"> */</span><br><span class="line">interface IERC165 &#123;</span><br><span class="line">    /// @notice 查询合约是否实现接口</span><br><span class="line">    /// @param interfaceID ERC-165 中指定的接口标识符</span><br><span class="line">    /// @dev 接口标识在 ERC-165 中指定。此功能需要低于 30,000 gas。</span><br><span class="line">    /// @return 如果合约实现了 interfaceID 且 interfaceID 不是 0xffffffff，则为 true，否则为 false</span><br><span class="line">    function supportsInterface(bytes4 interfaceID) external view returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// @title ERC-721 Non-Fungible Token Standard</span><br><span class="line">/// @dev See https://eips.ethereum.org/EIPS/eip-721</span><br><span class="line">///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.</span><br><span class="line">interface IERC721 is IERC165 &#123;</span><br><span class="line">    /**</span><br><span class="line">     @dev 当任何 NFT 的所有权通过任何形式发生变化时，需要触发该事件。</span><br><span class="line">     当 NFT 创建（`from` == 0）和销毁（`to` == 0）时会触发此事件。</span><br><span class="line">     例外情况：在合约创建期间，可以创建和分配任意数量的 NFT，而不会发出 Transfer。</span><br><span class="line">     在任何形式的资产转移时，该 NFT如果有批准地址将重置为无。</span><br><span class="line">    */</span><br><span class="line">    event Transfer(</span><br><span class="line">        address indexed _from,</span><br><span class="line">        address indexed _to,</span><br><span class="line">        uint256 indexed _tokenId</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当 NFT 的批准地址被更改或重新确认时，它会发出。</span><br><span class="line">     * 零地址表示没有批准的地址。</span><br><span class="line">     * 当 Transfer 事件发出时，这也表明该 NFT 如果有批准地址被重置为无。</span><br><span class="line">     */</span><br><span class="line">    event Approval(</span><br><span class="line">        address indexed _owner,</span><br><span class="line">        address indexed _approved,</span><br><span class="line">        uint256 indexed _tokenId</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /// @dev 当为所有者启用或禁用操作员时，它会发出。 运营者可以管理所有者的所有 NFT。</span><br><span class="line">    event ApprovalForAll(</span><br><span class="line">        address indexed _owner,</span><br><span class="line">        address indexed _operator,</span><br><span class="line">        bool _approved</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /// @notice 所有者的 NFT 数量</span><br><span class="line">    /// @dev 分配给零地址的 NFT 被认为是无效的，并且该函数抛出有关零地址的查询。</span><br><span class="line">    /// @param _owner 查询余额的地址</span><br><span class="line">    /// @return `_owner` 拥有的 NFT 数量，可能为零</span><br><span class="line">    function balanceOf(address _owner) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    /// @notice 找到 NFT 的所有者</span><br><span class="line">    /// @dev 分配给零地址的 NFT 被认为是无效的，并且对它们的查询确实会抛出异常。</span><br><span class="line">    /// @param _tokenId NFT 的标识符</span><br><span class="line">    /// @return NFT所有者的地址</span><br><span class="line">    function ownerOf(uint256 _tokenId) external view returns (address);</span><br><span class="line"></span><br><span class="line">    /// @notice 将 NFT 的所有权从一个地址转移到另一个地址</span><br><span class="line">    /// @dev Throws unless `msg.sender` is the current owner, an authorized</span><br><span class="line">    ///  operator, or the approved address for this NFT. Throws if `_from` is</span><br><span class="line">    ///  not the current owner. Throws if `_to` is the zero address. Throws if</span><br><span class="line">    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function</span><br><span class="line">    ///  checks if `_to` is a smart contract (code size &gt; 0). If so, it calls</span><br><span class="line">    ///  `onERC721Received` on `_to` and throws if the return value is not</span><br><span class="line">    ///  `bytes4(keccak256(&quot;onERC721Received(address,address,uint256,bytes)&quot;))`.</span><br><span class="line">    /// @param _from NFT的当前所有者</span><br><span class="line">    /// @param _to 新 owner</span><br><span class="line">    /// @param _tokenId 转移的 NFT</span><br><span class="line">    /// @param data 没有指定格式的附加数据，在调用 _to 时发送</span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address _from,</span><br><span class="line">        address _to,</span><br><span class="line">        uint256 _tokenId,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external payable;</span><br><span class="line"></span><br><span class="line">    /// @notice 将 NFT 的所有权从一个地址转移到另一个地址</span><br><span class="line">    /// @dev 这与具有额外数据参数的其他函数的工作方式相同，只是此函数只是将数据设置为“”。</span><br><span class="line">    /// @param _from NFT的当前所有者</span><br><span class="line">    /// @param _to 新 owner</span><br><span class="line">    /// @param _tokenId 转移的 NFT</span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address _from,</span><br><span class="line">        address _to,</span><br><span class="line">        uint256 _tokenId</span><br><span class="line">    ) external payable;</span><br><span class="line"></span><br><span class="line">    /// @notice 转移 NFT 的所有权——调用者有责任确认 `_to` 能够接收 NFT，否则它们可能会永久丢失</span><br><span class="line">    /// @dev Throws unless `msg.sender` is the current owner, an authorized</span><br><span class="line">    ///  operator, or the approved address for this NFT. Throws if `_from` is</span><br><span class="line">    ///  not the current owner. Throws if `_to` is the zero address. Throws if</span><br><span class="line">    ///  `_tokenId` is not a valid NFT.</span><br><span class="line">    /// @param _from NFT的当前所有者</span><br><span class="line">    /// @param _to 新 owner</span><br><span class="line">    /// @param _tokenId 转移的 NFT</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address _from,</span><br><span class="line">        address _to,</span><br><span class="line">        uint256 _tokenId</span><br><span class="line">    ) external payable;</span><br><span class="line"></span><br><span class="line">    /// @notice 更改或重申 NFT 的批准地址</span><br><span class="line">    /// @dev The zero address indicates there is no approved address.</span><br><span class="line">    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized</span><br><span class="line">    ///  operator of the current owner.</span><br><span class="line">    /// @param _approved 新批准的 NFT 控制器</span><br><span class="line">    /// @param _tokenId NFT 批准</span><br><span class="line">    function approve(address _approved, uint256 _tokenId) external payable;</span><br><span class="line"></span><br><span class="line">    /// @notice 启用或禁用对第三方（“操作员”）的批准以管理所有 `msg.sender` 的资产</span><br><span class="line">    /// @dev 发出 ApprovalForAll 事件。 合同必须允许每个所有者有多个操作员。</span><br><span class="line">    /// @param _operator 添加到授权运营商集中的地址</span><br><span class="line">    /// @param _approved 如果运营商获得批准，则为 True，如果撤消批准，则为 false</span><br><span class="line">    function setApprovalForAll(address _operator, bool _approved) external;</span><br><span class="line"></span><br><span class="line">    /// @notice 获取单个 NFT 的认可地址</span><br><span class="line">    /// @dev 如果 _tokenId 不是有效的 NFT，则抛出。</span><br><span class="line">    /// @param _tokenId NFT寻找批准的地址</span><br><span class="line">    /// @return 此 NFT 的批准地址，如果没有则为零地址</span><br><span class="line">    function getApproved(uint256 _tokenId) external view returns (address);</span><br><span class="line"></span><br><span class="line">    /// @notice 查询一个地址是否是另一个地址的授权操作员</span><br><span class="line">    /// @param _owner 拥有 NFT 的地址</span><br><span class="line">    /// @param _operator 代表所有者的地址</span><br><span class="line">    /// @return 如果 _operator 是 _owner 的批准运算符，则为真，否则为假</span><br><span class="line">    function isApprovedForAll(address _owner, address _operator)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (bool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ERC1155-标准"><a href="#ERC1155-标准" class="headerlink" title="ERC1155 标准"></a>ERC1155 标准</h1><p>参考资料:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-1155">https://eips.ethereum.org/EIPS/eip-1155</a></li>
<li><a target="_blank" rel="noopener" href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-1155/">https://ethereum.org/zh/developers/docs/standards/tokens/erc-1155/</a></li>
</ul>
<h3 id="场景说明-1"><a href="#场景说明-1" class="headerlink" title="场景说明"></a>场景说明</h3><p>用于多种代币管理的合约标准接口。单个部署的合约可以包括同质化代币、非同质化代币或其他配置（如半同质化代币）的任何组合。</p>
<p>它的目的很单纯，就是创建一个智能合约接口，可以代表和控制任何数量的同质化和非同质化代币类型。 这样一来，ERC-1155 代币就具有与 ERC-20 和 ERC-721 代币相同的功能，甚至可以同时使用这两者的功能。 而最重要的是，它能改善这两种标准的功能，使其更有效率，并纠正 ERC-20 和 ERC-721 标准上明显的实施错误。</p>
<h3 id="合约代码-1"><a href="#合约代码-1" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @dev ERC165 标准的接口 https://eips.ethereum.org/EIPS/eip-165</span><br><span class="line"> * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified</span><br><span class="line"> */</span><br><span class="line">interface IERC165 &#123;</span><br><span class="line">    /// @notice 查询合约是否实现接口</span><br><span class="line">    /// @param interfaceID ERC-165 中指定的接口标识符</span><br><span class="line">    /// @dev 接口标识在 ERC-165 中指定。此功能需要低于 30,000 gas。</span><br><span class="line">    /// @return 如果合约实现了 interfaceID 且 interfaceID 不是 0xffffffff，则为 true，否则为 false</span><br><span class="line">    function supportsInterface(bytes4 interfaceID) external view returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">    @title ERC-1155 Multi Token Standard</span><br><span class="line">    @dev See https://eips.ethereum.org/EIPS/eip-1155</span><br><span class="line">    Note: The ERC-165 identifier for this interface is 0xd9b67a26.</span><br><span class="line"> */</span><br><span class="line">interface IERC1155 is IERC165 &#123;</span><br><span class="line">    /**</span><br><span class="line">        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred,</span><br><span class="line">        including zero value transfers as well as minting or burning (see &quot;Safe Transfer Rules&quot; section of the standard).</span><br><span class="line">        The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).</span><br><span class="line">        The `_from` argument MUST be the address of the holder whose balance is decreased.</span><br><span class="line">        The `_to` argument MUST be the address of the recipient whose balance is increased.</span><br><span class="line">        The `_id` argument MUST be the token type being transferred.</span><br><span class="line">        The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.</span><br><span class="line">        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).</span><br><span class="line">        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).</span><br><span class="line">    */</span><br><span class="line">    event TransferSingle(</span><br><span class="line">        address indexed _operator,</span><br><span class="line">        address indexed _from,</span><br><span class="line">        address indexed _to,</span><br><span class="line">        uint256 _id,</span><br><span class="line">        uint256 _value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred,</span><br><span class="line">        including zero value transfers as well as minting or burning (see &quot;Safe Transfer Rules&quot; section of the standard).</span><br><span class="line">        The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).</span><br><span class="line">        The `_from` argument MUST be the address of the holder whose balance is decreased.</span><br><span class="line">        The `_to` argument MUST be the address of the recipient whose balance is increased.</span><br><span class="line">        The `_ids` argument MUST be the list of tokens being transferred.</span><br><span class="line">        The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids)</span><br><span class="line">        the holder balance is decreased by and match what the recipient balance is increased by.</span><br><span class="line">        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).</span><br><span class="line">        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).</span><br><span class="line">    */</span><br><span class="line">    event TransferBatch(</span><br><span class="line">        address indexed _operator,</span><br><span class="line">        address indexed _from,</span><br><span class="line">        address indexed _to,</span><br><span class="line">        uint256[] _ids,</span><br><span class="line">        uint256[] _values</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        @dev 必须在批准第二方/运营商地址管理所有者地址的所有令牌时启用或禁用（没有事件假定禁用）</span><br><span class="line">    */</span><br><span class="line">    event ApprovalForAll(</span><br><span class="line">        address indexed _owner,</span><br><span class="line">        address indexed _operator,</span><br><span class="line">        bool _approved</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        @dev 必须在为令牌 ID 更新 URI 时发出。</span><br><span class="line">        URI 在 RFC 3986 中定义。</span><br><span class="line">        URI 必须指向符合“ERC-1155 元数据 URI JSON 模式”的 JSON 文件。</span><br><span class="line">    */</span><br><span class="line">    event URI(string _value, uint256 indexed _id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        @notice Transfers `_value` amount of an `_id` from the `_from` address</span><br><span class="line">                to the `_to` address specified (with safety call).</span><br><span class="line">        @dev Caller must be approved to manage the tokens being transferred</span><br><span class="line">        out of the `_from` account (see &quot;Approval&quot; section of the standard).</span><br><span class="line">        MUST revert if `_to` is the zero address.</span><br><span class="line">        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.</span><br><span class="line">        MUST revert on any other error.</span><br><span class="line">        MUST emit the `TransferSingle` event to reflect the balance change (see &quot;Safe Transfer Rules&quot; section of the standard).</span><br><span class="line">        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size &gt; 0). If so,</span><br><span class="line">        it MUST call `onERC1155Received` on `_to` and act appropriately (see &quot;Safe Transfer Rules&quot; section of the standard).</span><br><span class="line">        @param _from    Source address</span><br><span class="line">        @param _to      Target address</span><br><span class="line">        @param _id      ID of the token type</span><br><span class="line">        @param _value   Transfer amount</span><br><span class="line">        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`</span><br><span class="line">    */</span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address _from,</span><br><span class="line">        address _to,</span><br><span class="line">        uint256 _id,</span><br><span class="line">        uint256 _value,</span><br><span class="line">        bytes calldata _data</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        @notice 将 `_ids` 的 `_values` 数量从 `_from` 地址转移到指定的 `_to` 地址（使用安全调用）。</span><br><span class="line">        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see &quot;Approval&quot; section of the standard).</span><br><span class="line">        MUST revert if `_to` is the zero address.</span><br><span class="line">        MUST revert if length of `_ids` is not the same as length of `_values`.</span><br><span class="line">        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.</span><br><span class="line">        MUST revert on any other error.</span><br><span class="line">        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see &quot;Safe Transfer Rules&quot; section of the standard).</span><br><span class="line">        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).</span><br><span class="line">        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size &gt; 0). If so,</span><br><span class="line">        it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see &quot;Safe Transfer Rules&quot; section of the standard).</span><br><span class="line">        @param _from    Source address</span><br><span class="line">        @param _to      Target address</span><br><span class="line">        @param _ids     每个令牌类型的 ID（顺序和长度必须匹配 _values 数组）</span><br><span class="line">        @param _values  每种代币类型的转账金额（顺序和长度必须匹配 _ids 数组）</span><br><span class="line">        @param _data    没有指定格式的额外数据，必须在调用 _to 上的 `ERC1155TokenReceiver` 钩子时原封不动地发送</span><br><span class="line">    */</span><br><span class="line">    function safeBatchTransferFrom(</span><br><span class="line">        address _from,</span><br><span class="line">        address _to,</span><br><span class="line">        uint256[] calldata _ids,</span><br><span class="line">        uint256[] calldata _values,</span><br><span class="line">        bytes calldata _data</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        @notice 获取帐户令牌的余额。</span><br><span class="line">        @param _owner  令牌持有者的地址</span><br><span class="line">        @param _id     ID of the token</span><br><span class="line">        @return        请求的代币类型的所有者余额</span><br><span class="line">     */</span><br><span class="line">    function balanceOf(address _owner, uint256 _id)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (uint256);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        @notice 获取多个账户/代币对的余额</span><br><span class="line">        @param _owners 代币持有者的地址</span><br><span class="line">        @param _ids    ID of the tokens</span><br><span class="line">        @return        请求的令牌类型的 _owner 余额（即每个 (owner, id) 对的余额）</span><br><span class="line">     */</span><br><span class="line">    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (uint256[] memory);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        @notice 启用或禁用对第三方（“操作员”）的批准以管理所有调用者的令牌。</span><br><span class="line">        @dev 必须在成功时发出 ApprovalForAll 事件。</span><br><span class="line">        @param _operator  添加到授权运营商集中的地址</span><br><span class="line">        @param _approved  如果运营商获得批准，则为 True，如果撤消批准，则为 false</span><br><span class="line">    */</span><br><span class="line">    function setApprovalForAll(address _operator, bool _approved) external;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        @notice 查询给定所有者的操作员的批准状态。</span><br><span class="line">        @param _owner     The owner of the tokens</span><br><span class="line">        @param _operator  授权操作员的地址</span><br><span class="line">        @return           如果操作员被批准则为真，否则为假</span><br><span class="line">    */</span><br><span class="line">    function isApprovedForAll(address _owner, address _operator)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (bool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ERC3525-标准"><a href="#ERC3525-标准" class="headerlink" title="ERC3525 标准"></a>ERC3525 标准</h1><p>每个符合 EIP-3525 的合约都必须实现 EIP-3525、EIP-721 和 EIP-165 接口</p>
<p>参考资料:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-3525">https://eips.ethereum.org/EIPS/eip-3525</a></li>
</ul>
<h3 id="场景说明-2"><a href="#场景说明-2" class="headerlink" title="场景说明"></a>场景说明</h3><p>描述一组具有相同类型，但是有轻微不同的东西。比如相同的 100 元人民币，一共 100 张，每一张都是价值 100 的纸币，大部分的防伪等等都不同，但是每一张都编号都不同。</p>
<h3 id="合约代码-2"><a href="#合约代码-2" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title EIP-3525 Semi-Fungible Token Standard</span><br><span class="line"> * Note: the EIP-165 identifier for this interface is 0xd5358140.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">interface IERC3525  /* is IERC165, IERC721 */ &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @dev MUST emit when value of a token is transferred to another token with the same slot,</span><br><span class="line">     *  including zero value transfers (_value == 0) as well as transfers when tokens are created</span><br><span class="line">     *  (`_fromTokenId` == 0) or destroyed (`_toTokenId` == 0).</span><br><span class="line">     * @param _fromTokenId The token id to transfer value from</span><br><span class="line">     * @param _toTokenId The token id to transfer value to</span><br><span class="line">     * @param _value The transferred value</span><br><span class="line">     */</span><br><span class="line">    event TransferValue(</span><br><span class="line">        uint256 indexed _fromTokenId,</span><br><span class="line">        uint256 indexed _toTokenId,</span><br><span class="line">        uint256 _value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev MUST emit when the approval value of a token is set or changed.</span><br><span class="line">     * @param _tokenId The token to approve</span><br><span class="line">     * @param _operator The operator to approve for</span><br><span class="line">     * @param _value The maximum value that `_operator` is allowed to manage</span><br><span class="line">     */</span><br><span class="line">    event ApprovalValue(</span><br><span class="line">        uint256 indexed _tokenId,</span><br><span class="line">        address indexed _operator,</span><br><span class="line">        uint256 _value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev MUST emit when the slot of a token is set or changed.</span><br><span class="line">     * @param _tokenId The token of which slot is set or changed</span><br><span class="line">     * @param _oldSlot The previous slot of the token</span><br><span class="line">     * @param _newSlot The updated slot of the token</span><br><span class="line">     */</span><br><span class="line">    event SlotChanged(</span><br><span class="line">        uint256 indexed _tokenId,</span><br><span class="line">        uint256 indexed _oldSlot,</span><br><span class="line">        uint256 indexed _newSlot</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice Get the number of decimals the token uses for value - e.g. 6, means the user</span><br><span class="line">     *  representation of the value of a token can be calculated by dividing it by 1,000,000.</span><br><span class="line">     *  Considering the compatibility with third-party wallets, this function is defined as</span><br><span class="line">     *  `valueDecimals()` instead of `decimals()` to avoid conflict with EIP-20 tokens.</span><br><span class="line">     * @return The number of decimals for value</span><br><span class="line">     */</span><br><span class="line">    function valueDecimals() external view returns (uint8);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice Get the value of a token.</span><br><span class="line">     * @param _tokenId The token for which to query the balance</span><br><span class="line">     * @return The value of `_tokenId`</span><br><span class="line">     */</span><br><span class="line">    function balanceOf(uint256 _tokenId) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice Get the slot of a token.</span><br><span class="line">     * @param _tokenId The identifier for a token</span><br><span class="line">     * @return The slot of the token</span><br><span class="line">     */</span><br><span class="line">    function slotOf(uint256 _tokenId) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice Allow an operator to manage the value of a token, up to the `_value`.</span><br><span class="line">     * @dev MUST revert unless caller is the current owner, an authorized operator, or the approved</span><br><span class="line">     *  address for `_tokenId`.</span><br><span class="line">     *  MUST emit the ApprovalValue event.</span><br><span class="line">     * @param _tokenId The token to approve</span><br><span class="line">     * @param _operator The operator to be approved</span><br><span class="line">     * @param _value The maximum value of `_toTokenId` that `_operator` is allowed to manage</span><br><span class="line">     */</span><br><span class="line">    function approve(</span><br><span class="line">        uint256 _tokenId,</span><br><span class="line">        address _operator,</span><br><span class="line">        uint256 _value</span><br><span class="line">    ) external payable;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice Get the maximum value of a token that an operator is allowed to manage.</span><br><span class="line">     * @param _tokenId The token for which to query the allowance</span><br><span class="line">     * @param _operator The address of an operator</span><br><span class="line">     * @return The current approval value of `_tokenId` that `_operator` is allowed to manage</span><br><span class="line">     */</span><br><span class="line">    function allowance(uint256 _tokenId, address _operator)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (uint256);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice Transfer value from a specified token to another specified token with the same slot.</span><br><span class="line">     * @dev Caller MUST be the current owner, an authorized operator or an operator who has been</span><br><span class="line">     *  approved the whole `_fromTokenId` or part of it.</span><br><span class="line">     *  MUST revert if `_fromTokenId` or `_toTokenId` is zero token id or does not exist.</span><br><span class="line">     *  MUST revert if slots of `_fromTokenId` and `_toTokenId` do not match.</span><br><span class="line">     *  MUST revert if `_value` exceeds the balance of `_fromTokenId` or its allowance to the</span><br><span class="line">     *  operator.</span><br><span class="line">     *  MUST emit `TransferValue` event.</span><br><span class="line">     * @param _fromTokenId The token to transfer value from</span><br><span class="line">     * @param _toTokenId The token to transfer value to</span><br><span class="line">     * @param _value The transferred value</span><br><span class="line">     */</span><br><span class="line">    function transferFrom(</span><br><span class="line">        uint256 _fromTokenId,</span><br><span class="line">        uint256 _toTokenId,</span><br><span class="line">        uint256 _value</span><br><span class="line">    ) external payable;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice 转移将指定数量的代币到新地址。调用者应确认 _to 能够接收 EIP-3525 资产。</span><br><span class="line">     * @dev This function MUST create a new EIP-3525 token with the same slot for `_to`,</span><br><span class="line">     *  or find an existing token with the same slot owned by `_to`, to receive the transferred value.</span><br><span class="line">     *  MUST revert if `_fromTokenId` is zero token id or does not exist.</span><br><span class="line">     *  MUST revert if `_to` is zero address.</span><br><span class="line">     *  MUST revert if `_value` exceeds the balance of `_fromTokenId` or its allowance to the</span><br><span class="line">     *  operator.</span><br><span class="line">     *  MUST emit `Transfer` and `TransferValue` events.</span><br><span class="line">     * @param _fromTokenId The token to transfer value from</span><br><span class="line">     * @param _to The address to transfer value to</span><br><span class="line">     * @param _value The transferred value</span><br><span class="line">     * @return ID of the token which receives the transferred value</span><br><span class="line">     */</span><br><span class="line">    function transferFrom(</span><br><span class="line">        uint256 _fromTokenId,</span><br><span class="line">        address _to,</span><br><span class="line">        uint256 _value</span><br><span class="line">    ) external payable returns (uint256);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>更多关于 3525 协议的内容，参考 <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2155201">https://cloud.tencent.com/developer/article/2155201</a></p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/07/15/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/12-%E5%90%88%E7%BA%A6%E9%83%A8%E7%BD%B2%E5%90%88%E7%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/15/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/12-%E5%90%88%E7%BA%A6%E9%83%A8%E7%BD%B2%E5%90%88%E7%BA%A6/" class="post-title-link" itemprop="url">12-合约部署合约</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-15 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-15T00:00:00+08:00">2022-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="通过-new-创建合约-create"><a href="#通过-new-创建合约-create" class="headerlink" title="通过 new 创建合约 &#x2F; create"></a>通过 <code>new</code> 创建合约 &#x2F; <code>create</code></h1><p>使用关键字 <code>new</code> 可以创建一个新合约。待创建合约的完整代码必须事先知道，因此递归的创建依赖是不可能的。<code>create</code>主要有以下三种表现形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract D &#123;</span><br><span class="line">    uint x;</span><br><span class="line">     constructor(uint256 a) payable&#123;</span><br><span class="line">        x = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    // 1.将作为合约的一部分执行</span><br><span class="line">    D d = new D(4);</span><br><span class="line"></span><br><span class="line">    // 2.方法内创建</span><br><span class="line">    function createD1(uint arg) public &#123;</span><br><span class="line">        D newD = new D(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.方法内创建，并转账</span><br><span class="line">    function createD2(uint arg, uint amount) public payable &#123;</span><br><span class="line">        //随合约的创建发送 ether</span><br><span class="line">        D newD = (new D)&#123;value:amount&#125;(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如示例中所示，通过使用 <code>value</code> 选项创建 <code>D</code> 的实例时可以附带发送 Ether，但是不能限制 gas 的数量。 如果创建失败（可能因为栈溢出，或没有足够的余额或其他问题），会引发异常。</p>
<p>这种方式也被称为 Factory 创建。工厂合约部署，也被称为 <code>create</code>，批量创建的时候使用，比如批量创建交易池，DeFi 类产品中批量创建借贷池等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Account &#123;</span><br><span class="line">    address public deployer;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor(address _owner) payable &#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">        deployer = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() external view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract AccountFactory &#123;</span><br><span class="line">    Account[] public accounts;</span><br><span class="line"></span><br><span class="line">    function deploy(address _owner) external payable &#123;</span><br><span class="line">        Account account = new Account&#123;value: msg.value&#125;(_owner);</span><br><span class="line">        accounts.push(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="通过-salt-创建合约-create2"><a href="#通过-salt-创建合约-create2" class="headerlink" title="通过 salt 创建合约 &#x2F; create2"></a>通过 <code>salt</code> 创建合约 &#x2F; <code>create2</code></h1><p>在创建合约时，将根据创建合约的地址和每次创建合约交易时的 <code>nonce</code> 来计算合约的地址。如果你指定了一个可选的 <code>salt</code> （一个 bytes32 值），那么合约创建将使用另一种机制(<code>create2</code>)来生成新合约的地址：它将根据给定的 <code>salt</code> ，创建合约的字节码和构造函数参数来计算创建合约的地址。特别注意，这里不再使用 <code>nonce</code>。</p>
<p>create2 的意义：可以在创建合约时提供更大的灵活性：你可以在创建新合约之前就推导出将要创建的合约地址。 甚至是还可以依赖此地址（即便它还不存在）来创建其他合约。一个主要用例场景是<strong>充当链下交互仲裁合约，仅在有争议时才需要创建。</strong></p>
<h3 id="案例演示-1"><a href="#案例演示-1" class="headerlink" title="案例演示 1"></a>案例演示 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract D &#123;</span><br><span class="line">    uint256 public x;</span><br><span class="line"></span><br><span class="line">    constructor(uint256 a) &#123;</span><br><span class="line">        x = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function createDSalted(bytes32 salt, uint256 arg) public &#123;</span><br><span class="line">        // 最新的语法</span><br><span class="line">        D d = new D&#123;salt: salt&#125;(arg);</span><br><span class="line"></span><br><span class="line">        // 之前的写法</span><br><span class="line">        // 这个复杂的表达式只是告诉我们，如何预先计算地址。</span><br><span class="line">        // 这里仅仅用来说明。 实际上，现在仅需要使用 `new D&#123;salt: salt&#125;(arg)` 即可.</span><br><span class="line">        address predictedAddress = address(</span><br><span class="line">            uint160(</span><br><span class="line">                uint256(</span><br><span class="line">                    keccak256(</span><br><span class="line">                        abi.encodePacked(</span><br><span class="line">                            bytes1(0xff),</span><br><span class="line">                            address(this),</span><br><span class="line">                            salt,</span><br><span class="line">                            keccak256(</span><br><span class="line">                                abi.encodePacked(type(D).creationCode, arg)</span><br><span class="line">                            )</span><br><span class="line">                        )</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        require(address(d) == predictedAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>create2</code> 创建合约还有一些特别之处。 合约销毁后可以在同一地址重新创建。不过，即使创建字节码（creation bytecode）相同（这是要求，因为否则地址会发生变化），该新创建的合约也可能有不同的部署字节码（deployed bytecode）。 这是因为构造函数可以使用两次创建合约之间可能已更改的外部状态，并在存储合约时将其合并到部署字节码中。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这种也被称为操作码部署，<code>create</code> 可以通过加入 salt，来预测即将生成的地址。这种创建就能预测生成地址的方式也被称为 <code>create2</code> 创建。</p>
<ul>
<li>加 salt ,salt 决定了合约地址，不能重复使用<ul>
<li>除非之前 salt 生成的合约被销毁了。</li>
</ul>
</li>
<li>即将部署的合约地址计算<ul>
<li><code>uint160</code> 格式就是地址格式了</li>
</ul>
</li>
</ul>
<p>下面是两者的简短总结：</p>
<ul>
<li><strong>普通合约</strong>的地址生成方式: 部署者的<code>地址</code> + <code>地址 nonce</code></li>
<li><strong>预测合约地址的方式</strong>:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bytes32 hash = keccak256(</span><br><span class="line">    abi.encodePacked(</span><br><span class="line">        bytes1(0xff), // 固定字符串</span><br><span class="line">        address(this), // 当前工厂合约地址，固定写法</span><br><span class="line">        _salt, // salt</span><br><span class="line">        keccak256(bytecode) //部署合约的 bytecode</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line">return address(uint160(uint256(hash)));</span><br></pre></td></tr></table></figure>

<h3 id="案例代码-2"><a href="#案例代码-2" class="headerlink" title="案例代码 2"></a>案例代码 2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract DeployWithCreate2 &#123;</span><br><span class="line">    address public deployer;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor(address _owner) payable &#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">        deployer = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() external view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract AccountFactory &#123;</span><br><span class="line">    DeployWithCreate2[] public accounts;</span><br><span class="line"></span><br><span class="line">    function deploy(uint256 _salt) external payable &#123;</span><br><span class="line">        DeployWithCreate2 account = new DeployWithCreate2&#123;</span><br><span class="line">            salt: bytes32(_salt), // uint256 需要转为 bytes32</span><br><span class="line">            value: msg.value</span><br><span class="line">        &#125;(msg.sender);</span><br><span class="line">        accounts.push(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取即将部署的地址</span><br><span class="line">    function getAddress(bytes memory bytecode, uint256 _salt)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (address)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes32 hash = keccak256(</span><br><span class="line">            abi.encodePacked(</span><br><span class="line">                bytes1(0xff), // 固定字符串</span><br><span class="line">                address(this), // 当前工厂合约地址</span><br><span class="line">                _salt, // salt</span><br><span class="line">                keccak256(bytecode) //部署合约的 bytecode</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        return address(uint160(uint256(hash)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取合约的 bytecode</span><br><span class="line">    function getBytecode(address _owner) external pure returns (bytes memory) &#123;</span><br><span class="line">        bytes memory bytecode = type(DeployWithCreate2).creationCode;</span><br><span class="line">        // 连接的参数使用 abi.encode</span><br><span class="line">        return abi.encodePacked(bytecode, abi.encode(_owner));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合约测试"><a href="#合约测试" class="headerlink" title="合约测试"></a>合约测试</h3><ul>
<li><p>address1部署合约</p>
<ul>
<li>address1: <code>0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</code></li>
</ul>
</li>
<li><p>使用 <code>address1</code> 作为参数，获取 <code>getBytecode</code> 返回值。</p>
</li>
<li><p>调用 getAddress</p>
<ul>
<li>bytecode 参数是 <code>getBytecode</code> 返回值</li>
<li>salt 参数是 1</li>
<li>计算结果是: <code>0x0022172A008CEdf60B1770dDD987888e5663D1Cc</code></li>
</ul>
</li>
<li><p>调用 deploy，salt 参数是 1</p>
</li>
<li><p>调用 accounts[0]</p>
<ul>
<li>返回的合约地址是 <code>0x0022172A008CEdf60B1770dDD987888e5663D1Cc</code>，和计算的完全一样。</li>
</ul>
</li>
<li><p>再次调用 deploy，salt 参数是 1</p>
<ul>
<li>返回失败 <code>transact to AccountFactory.deploy errored: VM error: revert.</code></li>
</ul>
</li>
</ul>
<h1 id="用-assembly-做-create"><a href="#用-assembly-做-create" class="headerlink" title="用 assembly 做 create"></a>用 assembly 做 create</h1><h3 id="create-部署"><a href="#create-部署" class="headerlink" title="create 部署"></a>create 部署</h3><ul>
<li>Proxy: 部署合约的方法，和修改 owner</li>
<li>Helper: 生成部署用的 bytecode 和修改 owner 的 data</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test1 &#123;</span><br><span class="line">    address public owner = msg.sender;</span><br><span class="line"></span><br><span class="line">    function setOwner(address _owner) public &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;now owner&quot;);</span><br><span class="line">        owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test2 &#123;</span><br><span class="line">    address public owner = msg.sender;</span><br><span class="line">    uint256 public value = msg.value;</span><br><span class="line">    uint256 public x;</span><br><span class="line">    uint256 public y;</span><br><span class="line"></span><br><span class="line">    constructor(uint256 _x, uint256 _y) &#123;</span><br><span class="line">        x = _x;</span><br><span class="line">        y = _y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// contract Proxy &#123;</span><br><span class="line">//     function depolyTest1() external &#123;</span><br><span class="line">//         new Test1();</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     function depolyTest2() external payable &#123;</span><br><span class="line">//         new Test2(1, 2);</span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// assembly 部署</span><br><span class="line">contract Proxy &#123;</span><br><span class="line">    event Depoly(address);</span><br><span class="line"></span><br><span class="line">    // fallback() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function depoly(bytes memory _code)</span><br><span class="line">        external</span><br><span class="line">        payable</span><br><span class="line">        returns (address adds)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // create(v,p,n);</span><br><span class="line">            // v 是 发送的ETH值</span><br><span class="line">            // p 是 内存中机器码开始的位置</span><br><span class="line">            // n 是 内存中机器码的大小</span><br><span class="line">            // msg.value 不能使用，需要用 callvalue()</span><br><span class="line">            adds := create(callvalue(), add(_code, 0x20), mload(_code))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        require(adds != address(0), &quot;Depoly Failed&quot;);</span><br><span class="line">        emit Depoly(adds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 跳用</span><br><span class="line">    function execute(address _target, bytes memory _data) external payable &#123;</span><br><span class="line">        (bool success, ) = _target.call&#123;value: msg.value&#125;(_data);</span><br><span class="line">        require(success, &quot;Failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Helper &#123;</span><br><span class="line">    // 生成 type(contract).creationCode</span><br><span class="line">    function getBytescode1() external pure returns (bytes memory bytecode) &#123;</span><br><span class="line">        bytecode = type(Test1).creationCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 生成构造函数带有参数的 bytecode，参数连接后面就可以了</span><br><span class="line">    function getBytescode2(uint256 _x, uint256 _y)</span><br><span class="line">        external</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes memory)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes memory bytecode = type(Test2).creationCode;</span><br><span class="line">        // abi 全局变量</span><br><span class="line">        return abi.encodePacked(bytecode, abi.encode(_x, _y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用合约方法的calldata，使用 abi.encodeWithSignature</span><br><span class="line">    function getCalldata(address _owner) external pure returns (bytes memory) &#123;</span><br><span class="line">        return abi.encodeWithSignature(&quot;setOwner(address)&quot;, _owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试部署"><a href="#测试部署" class="headerlink" title="测试部署"></a>测试部署</h3><p>前提条件：部署 Helper 和 Proxy 合约。</p>
<ol>
<li>通过 getBytescode1 ，获取 Test1 需要的 bytecode</li>
<li>部署 Test1</li>
<li>获取 Test1 合约地址</li>
<li>At Test1 Address</li>
<li>获取 Test1 owner 地址</li>
<li>通过 getCalldata ，获取 Test1 setOwner 需要的 bytecode。参数是想要设置的 Owner 地址。</li>
<li>执行 execute(),参数是 Test1 合约地址 和 getCalldata 返回值。</li>
</ol>
<p>合约 2</p>
<ol>
<li>通过 getBytescode2 ，获取 Test2 需要的 bytecode</li>
<li>部署 Test2，需要设置 x, y 的值，可以选择支付 ETH。</li>
<li>获取 Test2 合约地址</li>
<li>At Test2 Address</li>
<li>查看 Test2 的值</li>
</ol>
<h1 id="用-assembly-做-create2"><a href="#用-assembly-做-create2" class="headerlink" title="用 assembly 做 create2"></a>用 assembly 做 create2</h1><p>UniswapV2Factory 的创建 pair 代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function createPair(address tokenA, address tokenB) external returns (address pair) &#123;</span><br><span class="line">    require(tokenA != tokenB, &#x27;UniswapV2: IDENTICAL_ADDRESSES&#x27;);</span><br><span class="line">    (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span><br><span class="line">    require(token0 != address(0), &#x27;UniswapV2: ZERO_ADDRESS&#x27;);</span><br><span class="line"></span><br><span class="line">    // single check is sufficient</span><br><span class="line">    require(getPair[token0][token1] == address(0), &#x27;UniswapV2: PAIR_EXISTS&#x27;);</span><br><span class="line">    bytes memory bytecode = type(UniswapV2Pair).creationCode;</span><br><span class="line">    bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">    assembly &#123;</span><br><span class="line">        pair := create2(0, add(bytecode, 32), mload(bytecode), salt)</span><br><span class="line">    &#125;</span><br><span class="line">    IUniswapV2Pair(pair).initialize(token0, token1);</span><br><span class="line">    getPair[token0][token1] = pair;</span><br><span class="line">    getPair[token1][token0] = pair; // populate mapping in the reverse direction</span><br><span class="line">    allPairs.push(pair);</span><br><span class="line">    emit PairCreated(token0, token1, pair, allPairs.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/07/10/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/11-%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8%E5%90%88%E7%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/10/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/11-%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8%E5%90%88%E7%BA%A6/" class="post-title-link" itemprop="url">11-合约调用合约</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-10 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-10T00:00:00+08:00">2022-07-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>Solidity 支持一个合约调用另一个合约。两个合约既可以位于同一文件内，也可以位于不同的两个文件中。还能调用已经上链的其它合约。</p>
</li>
<li><p>调用内部合约</p>
<ul>
<li>内部合约指：位于同一 sol 文件中的合约，它们不需要额外的声明就可以直接调用。</li>
</ul>
</li>
<li><p>调用外部合约</p>
<ul>
<li>外部合约指：位于不同文件的外部合约，以及上链的合约。</li>
<li>方法一: 通过接口方式调用</li>
<li>方法二: 通过签名方式调用</li>
</ul>
</li>
</ul>
<p>了解上面的调用后，可以扩展了解<strong>多次调用</strong></p>
<h1 id="调用内部合约"><a href="#调用内部合约" class="headerlink" title="调用内部合约"></a>调用内部合约</h1><p>地址转换为合约对象的防范：</p>
<ul>
<li><p>方法 1: 通过ContractName(_ads)将传入的地址，转为合约对象</p>
<ul>
<li><p><code>Test(_ads).setX(_x);</code></p>
</li>
<li><p>如果为了代码逻辑，也可以分开写，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test temp = Test(_ads);</span><br><span class="line">temp.setX(_x);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>方法 2: 可以通过参数中指定合约名字进行转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function setX2(Test _ads, uint256 _x) public &#123;</span><br><span class="line">    _ads.setX(_x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用并发送 ETH: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fnName&#123;value: msg.value&#125;();</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Test(_ads).setYBySendEth&#123;value: msg.value&#125;();</code></li>
</ul>
</li>
</ul>
<p>例子演示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    uint256 public x = 1;</span><br><span class="line">    uint256 public y = 2;</span><br><span class="line"></span><br><span class="line">    function setX(uint256 _x) public &#123;</span><br><span class="line">        x = _x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getX() public view returns (uint256) &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setYBySendEth() public payable &#123;</span><br><span class="line">        y = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getXandY() public view returns (uint256, uint256) &#123;</span><br><span class="line">        return (x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CallTest &#123;</span><br><span class="line">    // 第1种方法: 229647 / 27858 gas</span><br><span class="line">    function setX1(address _ads, uint256 _x) public &#123;</span><br><span class="line">        Test(_ads).setX(_x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 第2种方法:   27923 gas</span><br><span class="line">    function setX2(Test _ads, uint256 _x) public &#123;</span><br><span class="line">        _ads.setX(_x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getX(address _ads) public view returns (uint256) &#123;</span><br><span class="line">        return Test(_ads).getX();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setYBySendEth(address _ads) public payable &#123;</span><br><span class="line">        Test(_ads).setYBySendEth&#123;value: msg.value&#125;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getXandY(address _ads)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 __x, uint256 __y)</span><br><span class="line">    &#123;</span><br><span class="line">        (__x, __y) = Test(_ads).getXandY();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="调用外部合约"><a href="#调用外部合约" class="headerlink" title="调用外部合约"></a>调用外部合约</h1><h2 id="2-1-通过接口方式调用"><a href="#2-1-通过接口方式调用" class="headerlink" title="2.1 通过接口方式调用"></a>2.1 通过接口方式调用</h2><p>核心代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface AnimalEat &#123;</span><br><span class="line">    function eat() external returns (string memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Animal &#123;</span><br><span class="line">    function test(address _addr) external returns (string memory) &#123;</span><br><span class="line">        AnimalEat general = AnimalEat(_addr);</span><br><span class="line">        return general.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-通过签名方式调用"><a href="#2-2-通过签名方式调用" class="headerlink" title="2.2 通过签名方式调用"></a>2.2 通过签名方式调用</h2><p>通过签名方式调用合约，只需要传入被调用者的地址和调用方法声明。</p>
<p><strong>call 核心代码如下</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bytes memory data = abi.encodeWithSignature(</span><br><span class="line">    &quot;setNameAndAge(string,uint256)&quot;,</span><br><span class="line">    _name,</span><br><span class="line">    _age</span><br><span class="line">);</span><br><span class="line">(bool success, bytes memory _bys) = _ads.call&#123;value: msg.value&#125;(data);</span><br><span class="line">require(success, &quot;Call Failed&quot;);</span><br><span class="line">bys = _bys;</span><br></pre></td></tr></table></figure>

<p>用给定的有效载荷（payload）发出低级 <code>CALL</code> 调用，并<strong>返回交易成功状态和返回数据</strong>（调用合约的方法并转账）, 格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.call(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure>

<p><strong>DelegateCall 核心代码如下</strong></p>
<ul>
<li>委托调用后，所有变量修改都是发生在委托合约内部，并不会保存在被委托合约中。<ul>
<li>利用这个特性，可以通过更换被委托合约，来升级委托合约。</li>
</ul>
</li>
<li>委托调用合约内部，需要和被委托合约的内部参数完全一样，否则容易导致数据混乱<ul>
<li>可以通过顺序来避免这个问题，但是推荐完全一样</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function set(address _ads, uint256 _num) external payable &#123;</span><br><span class="line">    sender = msg.sender;</span><br><span class="line">    value = msg.value;</span><br><span class="line">    num = _num;</span><br><span class="line">    // 第1种 encode</span><br><span class="line">    // 不需知道合约名字，函数完全自定义</span><br><span class="line">    bytes memory data1 = abi.encodeWithSignature(&quot;set(uint256)&quot;, _num);</span><br><span class="line">    // 第2种 encode</span><br><span class="line">    // 需要合约名字，可以避免函数和参数写错</span><br><span class="line">    // bytes memory data2 = abi.encodeWithSelector(Test1.set.selector, _num);</span><br><span class="line"></span><br><span class="line">    (bool success, bytes memory _data) = _ads.delegatecall(data1);</span><br><span class="line"></span><br><span class="line">    require(success, &quot;DelegateCall set failed&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>staticcall 核心代码如下</strong>: 它与 call 基本相同，<strong>但如果被调用的函数以任何方式修改状态变量，都将回退</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 被调用的合约</span><br><span class="line">contract Hello &#123;</span><br><span class="line">    function echo() external pure returns (string memory) &#123;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用者合约</span><br><span class="line">contract SoldityTest &#123;</span><br><span class="line">    function callHello(address _ads) external view returns (string memory) &#123;</span><br><span class="line">        // 编码被调用者的方法签名</span><br><span class="line">        bytes4 methodId = bytes4(keccak256(&quot;echo()&quot;));</span><br><span class="line"></span><br><span class="line">        // 调用合约</span><br><span class="line">        (bool success, bytes memory data) = _ads.staticcall(</span><br><span class="line">            abi.encodeWithSelector(methodId)</span><br><span class="line">        );</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            return abi.decode(data, (string));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;error&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="MultiCall-多次调用"><a href="#MultiCall-多次调用" class="headerlink" title="MultiCall&#x2F;多次调用"></a>MultiCall&#x2F;多次调用</h1><ul>
<li>把多个合约的多次函数的调用，打包在一个里面对合约进行调用。RPC 对调用有限制，这样可以绕开限制。</li>
<li>多次调用里面，对方的内部, <code>msg.sender</code> 是 MultiCall 合约，而不是用户地址。</li>
</ul>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>调用的地址</li>
<li>调用的 data</li>
</ul>
<h3 id="合约代码"><a href="#合约代码" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function fn1()</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (</span><br><span class="line">            uint256,</span><br><span class="line">            address,</span><br><span class="line">            uint256</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        return (1, msg.sender, block.timestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fn2()</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (</span><br><span class="line">            uint256,</span><br><span class="line">            address,</span><br><span class="line">            uint256</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        return (2, msg.sender, block.timestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getFn1Data() external pure returns (bytes memory) &#123;</span><br><span class="line">        // 两种签名方法都可以</span><br><span class="line">        // abi.encodeWithSignature(&quot;fn1()&quot;);</span><br><span class="line">        return abi.encodeWithSelector(this.fn1.selector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getFn2Data() external pure returns (bytes memory) &#123;</span><br><span class="line">        return abi.encodeWithSelector(this.fn2.selector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MultiCall &#123;</span><br><span class="line">    function multiCall(address[] calldata targets, bytes[] calldata data)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (bytes[] memory)</span><br><span class="line">    &#123;</span><br><span class="line">        require(targets.length == data.length, &quot;targets.length != data.length&quot;);</span><br><span class="line">        bytes[] memory results = new bytes[](data.length);</span><br><span class="line">        for (uint256 index = 0; index &lt; targets.length; index++) &#123;</span><br><span class="line">            (bool success, bytes memory result) = targets[index].staticcall(</span><br><span class="line">                data[index]</span><br><span class="line">            );</span><br><span class="line">            require(success, &quot;call faild&quot;);</span><br><span class="line">            results[index] = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<ul>
<li><p>部署 <code>Test</code>: <code>0x1c91347f2A44538ce62453BEBd9Aa907C662b4bD</code></p>
<ul>
<li>使用 <code>getFn1Data</code> 获取 fn1 data</li>
<li>使用 <code>getFn2Data</code> 获取 fn2 data</li>
</ul>
</li>
<li><p>部署 <code>MultiCall</code>: <code>0x93f8dddd876c7dBE3323723500e83E202A7C96CC</code></p>
</li>
<li><p>调用 multiCall 方法</p>
<ul>
<li>参数 1: <code>[&quot;Test 地址&quot;,&quot;Test 地址&quot;]</code></li>
<li>参数 2: <code>[&quot;fn1 data&quot;,&quot;fn2 data&quot;]</code></li>
</ul>
</li>
<li><p>返回值如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000001</span><br><span class="line">00000000000000000000000093f8dddd876c7dbe3323723500e83e202a7c96cc</span><br><span class="line">00000000000000000000000000000000000000000000000000000000630c7834,</span><br><span class="line">0x</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">00000000000000000000000093f8dddd876c7dbe3323723500e83e202a7c96cc</span><br><span class="line">00000000000000000000000000000000000000000000000000000000630c7834</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="MultiDelegatecall-多次委托调用"><a href="#MultiDelegatecall-多次委托调用" class="headerlink" title="MultiDelegatecall &#x2F; 多次委托调用"></a>MultiDelegatecall &#x2F; 多次委托调用</h1><p>为什么使用 MultiDelegatecall ，不使用 MultiCall?是为了让被调用的合约内，<code>msg.sender</code> 是用户合约，而不是中转合约的地址。</p>
<p>但是委托调用的缺点是，合约必须是自己编写的，不能是别人编写的。</p>
<p>多次委托调用，存在漏洞，不要在里面多次累加余额。或者多重委托禁止接受资金。</p>
<h3 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract MultiDelegatecall &#123;</span><br><span class="line">    function multiDelegatecall(bytes[] calldata data)</span><br><span class="line">        external</span><br><span class="line">        returns (bytes[] memory)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes[] memory results = new bytes[](data.length);</span><br><span class="line">        for (uint256 index = 0; index &lt; data.length; index++) &#123;</span><br><span class="line">            (bool success, bytes memory result) = address(this).delegatecall(</span><br><span class="line">                data[index]</span><br><span class="line">            );</span><br><span class="line">            require(success, &quot;call faild&quot;);</span><br><span class="line">            results[index] = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test is MultiDelegatecall &#123;</span><br><span class="line">    function fn1()</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (</span><br><span class="line">            uint256,</span><br><span class="line">            address,</span><br><span class="line">            uint256</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        return (1, msg.sender, block.timestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fn2()</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (</span><br><span class="line">            uint256,</span><br><span class="line">            address,</span><br><span class="line">            uint256</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        return (2, msg.sender, block.timestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getFn1Data() external pure returns (bytes memory) &#123;</span><br><span class="line">        // 两种签名方法都可以</span><br><span class="line">        // abi.encodeWithSignature(&quot;fn1()&quot;);</span><br><span class="line">        return abi.encodeWithSelector(this.fn1.selector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getFn2Data() external pure returns (bytes memory) &#123;</span><br><span class="line">        return abi.encodeWithSelector(this.fn2.selector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>合约测试</strong></p>
<ul>
<li><p>部署 Test 合约</p>
</li>
<li><p>获取 getFn1Data: <code>0x648fc804</code></p>
</li>
<li><p>获取 getFn2Data: <code>0x98d26a11</code></p>
</li>
<li><p>调用 <code>multiDelegatecall</code></p>
<ul>
<li>[“0x648fc804”,“0x98d26a11”]</li>
</ul>
</li>
<li><p>得到 decoded output，发现地址是用户的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000001</span><br><span class="line">0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4</span><br><span class="line">00000000000000000000000000000000000000000000000000000000630c8ebc,</span><br><span class="line">0x</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4</span><br><span class="line">00000000000000000000000000000000000000000000000000000000630c8ebc</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/07/06/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/10-%E5%90%88%E7%BA%A6%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/06/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/10-%E5%90%88%E7%BA%A6%E7%BB%A7%E6%89%BF/" class="post-title-link" itemprop="url">10-合约继承</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-06 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-06T00:00:00+08:00">2022-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>实现继承的方式是通过复制包括多态的代码到子类来实现的。合约继承通过关键字 <code>is</code> 来实现。</p>
<p>由于 Solidity 继承的实现方案是代码拷贝，所以合约继承后，部署到网络时，将变成一个合约，代码将从父类拷贝到子类中。</p>
<ul>
<li>修饰符可以继承</li>
<li>事件不可以继承，但是可以重载</li>
<li><code>fallback</code> 可以继承，但是需要保持原有的 <code>payable/nonpayable</code></li>
<li><code>receive</code> 可以继承，但是需要保持原有的 <code>payable/nonpayable</code></li>
</ul>
<h1 id="使用-is-实现继承"><a href="#使用-is-实现继承" class="headerlink" title="使用 is 实现继承"></a>使用 <code>is</code> 实现继承</h1><p>当一个合约从多个合约继承时，在区块链上只有一个合约被创建，所有基类合约（或称为父合约）的代码被编译到创建的合约中。这意味着对基类合约函数的所有内部调用也只是使用内部函数调用（super.f（..）将使用 JUMP 跳转而不是消息调用）。</p>
<ul>
<li>继承: <strong>派生合约</strong>继承<strong>基础合约</strong>的属性和方法</li>
<li>基础合约通常也被称为<strong>父合约</strong>，派生合约通常也称作<strong>子合约</strong>。</li>
<li>下面是: “男人”继承”人”的演示。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Person &#123;</span><br><span class="line">    string internal name;</span><br><span class="line">    uint256 age; // 状态变量默认是internal权限</span><br><span class="line"></span><br><span class="line">    event Log(string funName);</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() virtual &#123;</span><br><span class="line">        age = 1;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable virtual &#123;</span><br><span class="line">        emit Log(&quot;fallback by Person&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable virtual &#123;</span><br><span class="line">        emit Log(&quot;receive by Person&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Man is Person &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        name = &quot;Anbang&quot;;</span><br><span class="line">        age = 18;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Log(string funName, address _ads);</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() override &#123;</span><br><span class="line">        age = 99;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getName() external view returns (string memory) &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getAge() external view returns (uint256) &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getAge2() external onlyOwner returns (uint256) &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable override &#123;</span><br><span class="line">        emit Log(&quot;fallback by man&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable override &#123;</span><br><span class="line">        emit Log(&quot;receive by Man&quot;, msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>父合约必须写在子合约的前面，否则会报错: <code>TypeError: Definition of base has to precede definition of derived contract</code></li>
</ul>
<h1 id="子类可以继承父类哪些数据？"><a href="#子类可以继承父类哪些数据？" class="headerlink" title="子类可以继承父类哪些数据？"></a>子类可以继承父类哪些数据？</h1><p>子类可以访问父类的权限修饰符只有：<code>public/internal</code>，不能是 <code>external/private</code>。</p>
<ul>
<li><p>如果父类的状态变量和函数是private和external，则子类不可以继承和访问。</p>
<p>如果子类调用父类 <code>external</code> 修饰的函数，会报错:<code>Cannot call function via contract type name.</code></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Person &#123;</span><br><span class="line">    string internal name;</span><br><span class="line">    uint256 age; // 状态变量默认是internal权限</span><br><span class="line">    uint256 public hand = 2;</span><br><span class="line">    uint256 private privateState = 99;</span><br><span class="line"></span><br><span class="line">    function publicFn() public pure returns (uint256) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function internalFn() internal pure returns (uint256) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function privateFn() private pure returns (uint256) &#123;</span><br><span class="line">        return 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Man is Person &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        name = &quot;Anbang&quot;;</span><br><span class="line">        age = 18;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getInfo()</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (</span><br><span class="line">            string memory,</span><br><span class="line">            uint256,</span><br><span class="line">            uint256</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        return (name, age, hand);</span><br><span class="line">        // privateState 不可以访问</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getPublicFn() external pure returns (uint256) &#123;</span><br><span class="line">        return publicFn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getInternalFn() external pure returns (uint256) &#123;</span><br><span class="line">        return internalFn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 不可以访问 privateFn 的方法</span><br><span class="line">    // function getPrivateFn() external pure returns (uint256) &#123;</span><br><span class="line">    //     return privateFn(); // Undeclared identifier.</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="多重继承中的重名"><a href="#多重继承中的重名" class="headerlink" title="多重继承中的重名"></a>多重继承中的重名</h1><ul>
<li>一个合约同时继承 2 个合约时，这种情况叫多重继承</li>
<li>多重继承中不允许出现相同的<strong>函数名</strong>、<strong>事件名</strong>、<strong>修改器名</strong>以及<strong>状态变量名</strong>等。</li>
</ul>
<p>如下继承会报错，不允许编译:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    string internal name;</span><br><span class="line">    event log();</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test() internal &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    string internal name;</span><br><span class="line">    event log();</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test() internal &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C is A, B &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>多重继承函数中 getter 函数重名也不可以，如下是<strong>比较隐蔽的冲突情况</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    uint256 public data = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    // data函数之所以出错</span><br><span class="line">    // 是因为和 A 中状态变量 data 的 getter 函数重名。</span><br><span class="line">    function data() public returns (uint256) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C is A, B &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>当继承时合约出现了一下相同名字会被认为是一个错误：</p>
<ul>
<li>函数 和 修改器&#x2F;modifier 同名</li>
<li>函数 和 事件同名</li>
<li>事件和 修改器&#x2F;modifier 同名</li>
<li>有一种例外情况，状态变量的 <code>getter</code> 函数可以覆盖 <code>external</code> 函数。</li>
</ul>
<h1 id="重写函数"><a href="#重写函数" class="headerlink" title="重写函数"></a>重写函数</h1><p>solidity 引入了 <code>abstract</code>, <code>virtual</code>, <code>override</code> 几个关键字，用于重写函数。父合约标记为 <code>virtual</code>函数可以在继承合约里重写(overridden)以更改他们的行为。重写的函数需要使用关键字 <code>override</code> 修饰。</p>
<p>继承的方法重写需要注意的点:</p>
<ul>
<li><p>父合约方法需要标示为<strong>可修改</strong>，使用关键字 <code>virtual</code>，</p>
</li>
<li><p>子合约方法需要标示为覆盖，使用关键词override</p>
<ul>
<li>对于多重继承，如果有多个父合约有相同定义的函数， override 关键字后必须指定所有父合约名。</li>
</ul>
</li>
<li><p>基础合约中可以包含没有实现代码的函数，也就是纯虚函数，那么基础合约必须声明为 <code>abstract</code>。</p>
</li>
<li><p>继承多个合约时，所有同名的可修改函数都需要重写</p>
</li>
<li><p>继承后重写合约方法，各个合约内的函数可见性需要一致</p>
</li>
<li><p>可变性可以按照以下顺序更改为更严格的一种： <code>nonpayable</code> 可以被 <code>view</code> 和<code>pure</code> 覆盖。 <code>view</code> 可以被 <code>pure</code> 覆盖。 <code>payable</code>是一个例外，不能更改为任何其他可变性。</p>
</li>
</ul>
<h2 id="4-1-virtual-和-override"><a href="#4-1-virtual-和-override" class="headerlink" title="4.1 virtual 和 override"></a>4.1 virtual 和 override</h2><p>以下例子，B 继承 A，C 继承 B</p>
<ul>
<li>A 是爷爷</li>
<li>B 是爸爸</li>
<li>C 是孙子</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function test1() public pure virtual returns (string memory) &#123;</span><br><span class="line">        return &quot;test1 from A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用 public 和 external 都可以</span><br><span class="line">    function test2() external pure virtual returns (string memory) &#123;</span><br><span class="line">        return &quot;test2 from A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test3() public pure virtual returns (string memory) &#123;</span><br><span class="line">        return &quot;test3 from A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B is A &#123;</span><br><span class="line">    function test1() public pure virtual override returns (string memory) &#123;</span><br><span class="line">        return &quot;test1 from B&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test2() external pure override returns (string memory) &#123;</span><br><span class="line">        return &quot;test2 from B&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C is B &#123;</span><br><span class="line">    function test1() public pure override returns (string memory) &#123;</span><br><span class="line">        return &quot;test1 from C&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于多重继承，如果有多个父合约有相同定义的函数， <code>override</code> 关键字后必须指定所有父合约名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Base1</span><br><span class="line">&#123;</span><br><span class="line">    function foo() virtual public &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base2</span><br><span class="line">&#123;</span><br><span class="line">    function foo() virtual public &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Inherited is Base1, Base2</span><br><span class="line">&#123;</span><br><span class="line">    // 继承自两个基类合约定义的foo(), 必须显示的指定 override</span><br><span class="line">    function foo() public override(Base1, Base2) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过如果（重写的）函数继承自一个公共的父合约， <code>override</code> 是可以不用显示指定的。 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract A &#123; function f() public pure&#123;&#125; &#125;</span><br><span class="line">contract B is A &#123;&#125;</span><br><span class="line">contract C is A &#123;&#125;</span><br><span class="line">// 不用显示  override</span><br><span class="line">contract D is B, C &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>更正式地说，如果存在父合约是签名函数的所有重写路径的一部分，则不需要重写（直接或间接）从多个基础继承的函数，并且（1）父合约实现了该函数，从当前合约到父合约的路径都没有提到具有该签名的函数，或者（2）父合约没有实现该函数，并且存在从当前合约到该父合约的所有路径中，最多只能提及该函数。</p>
<p>从这个意义上说，签名函数的重写路径是通过继承图的路径，该路径始于所考虑的合约，并终止于提及具有该签名的函数的合约。</p>
<p>如果函数没有标记为 <code>virtual</code> ，那么派生合约将不能更改函数的行为（即不能重写）。</p>
<blockquote>
<p><code>private</code> 的函数是不可以标记为 <code>virtual</code> 的。</p>
</blockquote>
<blockquote>
<p>除接口之外（因为接口会自动作为 <code>virtual</code> ），没有实现的函数必须标记为<code>virtual</code></p>
</blockquote>
<p>如果 getter 函数的参数和返回值都和外部函数一致时，外部（external）函数是可以被 public 的状态变量被重写的，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract A</span><br><span class="line">&#123;</span><br><span class="line">    function f() external view virtual returns(uint) &#123; return 5; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B is A</span><br><span class="line">&#123;</span><br><span class="line">    uint public override f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️ : 尽管 public 的状态变量可以重写外部函数，但是 public 的状态变量不能被重写。</p>
<h2 id="4-2-abstract（抽象合约）"><a href="#4-2-abstract（抽象合约）" class="headerlink" title="4.2 abstract（抽象合约）"></a>4.2 abstract（抽象合约）</h2><p>基础合约中可以包含没有实现代码的函数，也就是纯虚函数，那么基础合约必须声明为 <code>abstract</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">abstract contract IERC20 &#123;</span><br><span class="line">    function transfer() external virtual returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ERC20 is IERC20 &#123;</span><br><span class="line">    function transfer() external pure override returns (bool) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展: 这里的 <code>abstract</code>，也可以使用 <code>interface</code> 来解决。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line">    function transfer() external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ERC20 is IERC20 &#123;</span><br><span class="line">    function transfer() external pure returns (bool) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="继承中两种构造函数传参方式"><a href="#继承中两种构造函数传参方式" class="headerlink" title="继承中两种构造函数传参方式"></a>继承中两种构造函数传参方式</h1><p>继承的父合约，如果有构造函数并且需要传入参数，我们有以下几种方法进行参数传入</p>
<ul>
<li><p>方法 1: 固定值传参。（该方式不能在部署时动态输入）。</p>
<ul>
<li>如果我们已经知道基类初始化参数，那么就可以在派生类的继承声明中，直接传递参数给基类的构造函数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract C is A(&quot;n&quot;),B(&quot;v&quot;) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法 2: 动态传参</p>
<ul>
<li>如果我们需要在部署时或者运行时，由调用方传递基类初始化参数。在这种情况下，我们需要编写一个新的构造函数，传递参数给基类。</li>
<li>部署子合约的时候，传入参数到构造函数，该种方法是动态的值，可以部署的时候动态输入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract D is A &#123;</span><br><span class="line">  constructor(string memory _name) A(_name) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>混写: 方法 1 和方法 2 可以混合使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract E is A, B(&quot;EEEEEEEEEEEEE&quot;) &#123;</span><br><span class="line">  constructor(string memory _name) A(_name) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>例子如下:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    string public nameA;</span><br><span class="line"></span><br><span class="line">    constructor(string memory _name) &#123;</span><br><span class="line">        nameA = _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    string public nameB;</span><br><span class="line"></span><br><span class="line">    constructor(string memory _name) &#123;</span><br><span class="line">        nameB = _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法1: 继承时候直接传入参数，该种方法是固定值，不能动态输入</span><br><span class="line">contract C is A(&quot;Name From C&quot;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法2: 部署子合约的时候，传入参数到构造函数，该种方法是动态的值，可以部署的时候动态输入</span><br><span class="line">contract D is A &#123;</span><br><span class="line">    constructor(string memory _name) A(_name) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  混合使用</span><br><span class="line">contract E is A, B(&quot;EEEEEEEEEEEEE&quot;) &#123;</span><br><span class="line">    constructor(string memory _name) A(_name) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="两种子合约调用父合约的方法"><a href="#两种子合约调用父合约的方法" class="headerlink" title="两种子合约调用父合约的方法"></a>两种子合约调用父合约的方法</h1><p>有两种方法可以调用</p>
<ol>
<li><p>直接使用合约名调用 <code>ParentContractName.functionName()</code>;</p>
</li>
<li><p>使用 super 关键字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super.functionName()</span><br></pre></td></tr></table></figure>

<ul>
<li>super 会自动寻找父合约，并执行对应的方法；</li>
<li><strong>如果是多个父级，那么父级都会执行。但有时候又不会，执行顺序的原理，这些需要详细的了解</strong></li>
<li>如果 super 导致 2 个父级同时触发同一个爷爷合约的相同方法；则爷爷的方法只执行一次。一个合约的同一个方法只会执行一次，不会执行多次。</li>
</ul>
</li>
</ol>
<h2 id="6-1-直接使用合约名调用"><a href="#6-1-直接使用合约名调用" class="headerlink" title="6.1 直接使用合约名调用"></a>6.1 直接使用合约名调用</h2><p>执行顺序:像水中的冒泡一样，由下向上进行执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    event Log(string msg);</span><br><span class="line"></span><br><span class="line">    function test1() public virtual &#123;</span><br><span class="line">        emit Log(&quot;A.test1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B is A &#123;</span><br><span class="line">    function test1() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;B.test1&quot;);</span><br><span class="line">        A.test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子执行顺序是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. B.test1</span><br><span class="line">2. A.test1</span><br></pre></td></tr></table></figure>

<h2 id="6-2-使用-super-关键字调用"><a href="#6-2-使用-super-关键字调用" class="headerlink" title="6.2 使用 super 关键字调用"></a>6.2 使用 super 关键字调用</h2><h3 id="6-2-1-基础继承"><a href="#6-2-1-基础继承" class="headerlink" title="6.2.1 基础继承"></a>6.2.1 基础继承</h3><p>执行顺序：像水中的冒泡一样，由下向上进行执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    event Log(string msg);</span><br><span class="line"></span><br><span class="line">    function test1() public virtual &#123;</span><br><span class="line">        emit Log(&quot;A.test1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C is A &#123;</span><br><span class="line">    function test1() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;C.test1&quot;);</span><br><span class="line">        super.test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子执行顺序是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. C.test1</span><br><span class="line">2. A.test1</span><br></pre></td></tr></table></figure>

<h3 id="6-2-2-多重继承"><a href="#6-2-2-多重继承" class="headerlink" title="6.2.2 多重继承"></a>6.2.2 多重继承</h3><p>写一个如下逻辑的继承</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   A</span><br><span class="line"> /   \</span><br><span class="line">B     C</span><br><span class="line"> \   /</span><br><span class="line">   D</span><br><span class="line"> */</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    event Log(string msg);</span><br><span class="line"></span><br><span class="line">    function test1() public virtual &#123;</span><br><span class="line">        emit Log(&quot;A.test1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B is A &#123;</span><br><span class="line">    function test1() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;B.test1&quot;);</span><br><span class="line">        A.test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C is A &#123;</span><br><span class="line">    function test1() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;C.test1&quot;);</span><br><span class="line">        super.test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract D is B, C &#123;</span><br><span class="line">    function test1() public override(B, C) &#123;</span><br><span class="line">        emit Log(&quot;D.test1&quot;);</span><br><span class="line">        // 因为 B 和 C 都是 D 的父级，所以B和C都会执行</span><br><span class="line">        super.test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行顺序：像水中的冒泡一样，由下向上进行执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. D.test1</span><br><span class="line">1. C.test1</span><br><span class="line">1. B.test1</span><br><span class="line">1. A.test1 (这里 A 只执行一次)</span><br></pre></td></tr></table></figure>

<p><strong>警告</strong> : 为什么先输出 C，后输出 B ?</p>
<p>上面的例子，如果代码中 B 和 C 换顺序，还是执行的 <code>DCBA</code>。开始怀疑和函数名字的 hash 结果顺序有关系，看完下面的继续研究代码，可以得出结论，复杂继承的时候，supper 方式就像一个疯子一样没有规律可言。我们能做的就是避开使用它。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/07/02/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/09-%E4%BA%8B%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/02/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/09-%E4%BA%8B%E4%BB%B6/" class="post-title-link" itemprop="url">09-事件</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-02 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-02T00:00:00+08:00">2022-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Solidity0-8-17/" itemprop="url" rel="index">
                    <span itemprop="name">Solidity0.8.17</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>事件是能方便地调用以太坊虚拟机日志功能的接口。应用程序可以通过以太坊客户端的 RPC 接口订阅和监听这些事件。</p>
<p><strong>重点:记录区块链的日志，可以使用状态变量，也可以使用事件 Event，但 Event 使用的 gas 费比状态变量低。</strong></p>
<p>原则：改变状态变量时，一定要触发事件。</p>
<p>Soliddity Event 事件是以太坊虚拟机(EVM)日志基础设施提供的一个便利接口。当被发送事件（调用）时，会触发参数存储到交易的日志中。这些日志与合约的地址关联，并记录到区块链中。每个交易收据包含 0 到多个 log 记录，log 表明着智能合约所触发的事件。</p>
<h1 id="Event-语法"><a href="#Event-语法" class="headerlink" title="Event 语法"></a>Event 语法</h1><p><strong>事件的定义</strong>:使用 <code>event</code> 关键字来定义一个事件 Event，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event EventName(&lt;parameter list&gt;);</span><br></pre></td></tr></table></figure>

<p><strong>事件的触发</strong>:只能使用 <code>emit</code> 关键字来触发事件 Event，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emit EventName(&lt;parameter list&gt;);</span><br></pre></td></tr></table></figure>

<h1 id="四种事件定义方式"><a href="#四种事件定义方式" class="headerlink" title="四种事件定义方式"></a>四种事件定义方式</h1><ol>
<li>不带参数的 event</li>
<li>带参数的 event</li>
<li>带参数名的 event</li>
<li>带 indexed 参数名的 event<ol>
<li>这种事件也被称为<strong>索引事件</strong></li>
<li>语法:<code>event EventName(TypeName indexed varibleName....);</code></li>
<li>事件中 indexed 标记过的参数，可以在链外进行搜索查询。</li>
<li>一个事件中 indexed 标记过的参数最多有 3 个。</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Event &#123;</span><br><span class="line">    // 普通 event</span><br><span class="line">    event Log1(address, string);</span><br><span class="line"></span><br><span class="line">    // 带名字的 event</span><br><span class="line">    event Log2(address ads, string msg);</span><br><span class="line"></span><br><span class="line">    // 带 indexed 的event</span><br><span class="line">    event Log3(address indexed ads, string msg);</span><br><span class="line"></span><br><span class="line">    // indexed 在一个事件内使用次数不能超过3次</span><br><span class="line">    event Transfer(</span><br><span class="line">        address indexed from,</span><br><span class="line">        address indexed to,</span><br><span class="line">        uint256 indexed amount</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    function log1() external &#123;</span><br><span class="line">        emit Log1(msg.sender, &quot;Log111&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function log2() external &#123;</span><br><span class="line">        emit Log2(msg.sender, &quot;Log222&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function log3() external &#123;</span><br><span class="line">        emit Log3(msg.sender, &quot;Log333&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address _to, uint256 amount) external &#123;</span><br><span class="line">        emit Transfer(msg.sender, _to, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-不带参数的-event"><a href="#2-1-不带参数的-event" class="headerlink" title="2.1 不带参数的 event"></a>2.1 不带参数的 event</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">	<span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x7874d94b8f9E2a28FCceCE404666C984f33a82b8&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x1732d0c17008d342618e7f03069177d8d39391d79811bb4e706d7c6c84108c0f&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Log1&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-带参数的-event"><a href="#2-2-带参数的-event" class="headerlink" title="2.2 带参数的 event"></a>2.2 带参数的 event</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">	<span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x7874d94b8f9E2a28FCceCE404666C984f33a82b8&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x54010eb0426bdddd13273086604fca7ba750a84093c6839732d954056646e81b&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Log2&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Log222&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-带参数名的-event"><a href="#2-3-带参数名的-event" class="headerlink" title="2.3 带参数名的 event"></a>2.3 带参数名的 event</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">	<span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x7874d94b8f9E2a28FCceCE404666C984f33a82b8&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x940879bf2d29cdfe8084f2f033d2168f5859a6e10530b61fb84dc1c5ddc9ca40&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Log3&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Log333&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;ads&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Log333&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-带-indexed-参数名的-event"><a href="#2-4-带-indexed-参数名的-event" class="headerlink" title="2.4 带 indexed 参数名的 event"></a>2.4 带 indexed 参数名的 event</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">	<span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xfB72aAdB17a855D27A68B565ee0a84CB30A387e4&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xf485c071883274befba21423da7f60203f9df753bf614bca26c4763ed4b240fb&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Log4&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Log444&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;ads&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Log444&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">	<span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xfB72aAdB17a855D27A68B565ee0a84CB30A387e4&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Transfer&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;amount&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h1 id="indexed-的作用"><a href="#indexed-的作用" class="headerlink" title="indexed 的作用"></a>indexed 的作用</h1><p>indexed 数据会被记录到 <code>topics</code> 中，可以用于检索。已索引的部分，最多有 3 个（对于非匿名事件）或 4 个（对于匿名事件）</p>
<p>对于非匿名事件，最多三个参数可以接收 <code>indexed</code>属性（它是一个特殊的名为: “主题” 的数据结构，而不作为日志的数据部分）。主题仅有 32 字节， 因此如果:引用类型 标记为索引项，则它们的 keccak-256 哈希值会被作为 主题（topic） 保存。</p>
<p>主题（topic）让我们可以可以搜索事件，比如在为某些事件过滤一些区块，还可以按发起事件的合同地址来过滤事件。</p>
<p>例如, 使用如下的 web3.js <code>subscribe(&quot;logs&quot;)方法</code> 去过滤符合特定地址的 主题（topic） ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">	<span class="attr">fromBlock</span>: <span class="number">0</span>,</span><br><span class="line">	<span class="attr">address</span>: web3.<span class="property">eth</span>.<span class="property">defaultAccount</span>,</span><br><span class="line">	<span class="attr">topics</span>: [<span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>],</span><br><span class="line">&#125;;</span><br><span class="line">web3.<span class="property">eth</span></span><br><span class="line">	.<span class="title function_">subscribe</span>(<span class="string">&quot;logs&quot;</span>, options, <span class="keyword">function</span> (<span class="params">error, result</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!error) <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">	&#125;)</span><br><span class="line">	.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="keyword">function</span> (<span class="params">log</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(log);</span><br><span class="line">	&#125;)</span><br><span class="line">	.<span class="title function_">on</span>(<span class="string">&quot;changed&quot;</span>, <span class="keyword">function</span> (<span class="params">log</span>) &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>主要用在链下服务，可以通过 RPC 获取，比如 web3 的以下方法:</p>
<ul>
<li><pre><code>myContract.once
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - https://web3js.readthedocs.io/en/v1.7.5/web3-eth-contract.html</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  myContract.events.MyEvent</span><br></pre></td></tr></table></figure>

- https://web3js.readthedocs.io/en/v1.7.5/web3-eth-contract.html#contract-events
</code></pre>
</li>
<li><pre><code>myContract.getPastEvents
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - https://web3js.readthedocs.io/en/v1.7.5/web3-eth-contract.html#getpastevents</span><br><span class="line"></span><br><span class="line"># log 的使用</span><br><span class="line"></span><br><span class="line">除非你用 `anonymous` 声明事件，否则事件签名的哈希值是一个 主题（topic）。同时也意味着对于匿名事件无法通过名字来过滤，仅能按合约地址过滤。匿名事件的优势是他们部署和调用的成本更低。它也允许你声明 4 个索引参与而不是 3 个。</span><br><span class="line"></span><br><span class="line">⚠️：由于交易日志只存储事件数据而不存储类型。你必须知道事件的类型，包括哪个参数被索引，以及该事件是否是匿名的，以便正确解释数据。尤其是，有可能使用一个匿名事件来&quot;伪造&quot;另一个事件的签名。</span><br><span class="line"></span><br><span class="line">```solidity</span><br><span class="line">pragma solidity  &gt;=0.4.21 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract ClientReceipt &#123;</span><br><span class="line">    event Deposit(</span><br><span class="line">        address indexed from,</span><br><span class="line">        bytes32 indexed id,</span><br><span class="line">        uint value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    function deposit(bytes32 id) public payable &#123;</span><br><span class="line">        // 事件使用 emit 触发事件。</span><br><span class="line">        // 我们可以过滤对 `Deposit` 的调用，从而用 Javascript API 来查明对这个函数的任何调用（甚至是深度嵌套调用）。</span><br><span class="line">        emit Deposit(msg.sender, id, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>使用 JavaScript API 调用事件的用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abi = <span class="comment">/* abi 由编译器产生 */</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ClientReceipt</span> = web3.<span class="property">eth</span>.<span class="title function_">contract</span>(abi);</span><br><span class="line"><span class="keyword">var</span> clientReceipt = <span class="title class_">ClientReceipt</span>.<span class="title function_">at</span>(<span class="string">&quot;0x1234...xlb67&quot;</span> <span class="comment">/* 地址 */</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> depositEvent = clientReceipt.<span class="title class_">Deposit</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听变化</span></span><br><span class="line">depositEvent.<span class="title function_">watch</span>(<span class="keyword">function</span>(<span class="params">error, result</span>) &#123;</span><br><span class="line">    <span class="comment">// 结果包含 非索引参数 以及 主题 topic</span></span><br><span class="line">    <span class="keyword">if</span> (!error)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者通过传入回调函数，立即开始听监</span></span><br><span class="line"><span class="keyword">var</span> depositEvent = clientReceipt.<span class="title class_">Deposit</span>(<span class="keyword">function</span>(<span class="params">error, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的输出如下所示（有删减）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;returnValues&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x1111…FFFFCCCC&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x50…sd5adb20&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x420042&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;raw&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x7f…91385&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;topics&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;0xfd4…b4ead7&quot;</span><span class="punctuation">,</span> <span class="string">&quot;0x7f…1a91385&quot;</span><span class="punctuation">]</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="Log-重载"><a href="#Log-重载" class="headerlink" title="Log 重载"></a>Log 重载</h1><p>Log 可以像函数一样重载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Event &#123;</span><br><span class="line">    event Log(address ads);</span><br><span class="line">    event Log(address indexed ads, string msg); // 重载</span><br><span class="line"></span><br><span class="line">    function log1() external &#123;</span><br><span class="line">        emit Log(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function log2() external &#123;</span><br><span class="line">        emit Log(msg.sender, &quot;Log111&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/17/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="幺柒YQ"
      src="/images/avater.png">
  <p class="site-author-name" itemprop="name">幺柒YQ</p>
  <div class="site-description" itemprop="description">努力坚持就会有希望</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">232</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kpyaoqi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kpyaoqi" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:18312386077@163.com" title="E-Mail → mailto:18312386077@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat.jpg" title="WeChat → images&#x2F;wechat.jpg"><i class="fa fa-fw fa-wechat"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/qq.jpg" title="QQ → images&#x2F;qq.jpg"><i class="fa fa-fw fa-qq"></i>QQ</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://stackoverflow.com/" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;" rel="noopener" target="_blank">Stackoverflow</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2021-11 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">幺柒YQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">899k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:37</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共379.4k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  


</body>
</html>
