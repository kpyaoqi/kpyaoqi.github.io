<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://kongpengyq.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="努力坚持就会有希望">
<meta property="og:type" content="website">
<meta property="og:title" content="YQ &amp; 博客">
<meta property="og:url" content="https://kongpengyq.com/page/21/index.html">
<meta property="og:site_name" content="YQ &amp; 博客">
<meta property="og:description" content="努力坚持就会有希望">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="幺柒YQ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://kongpengyq.com/page/21/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>YQ & 博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="YQ & 博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YQ & 博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/02/14/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/01%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/14/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/01%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">01程序结构</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-14 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-14T00:00:00+08:00">2022-02-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-09 10:01:34" itemprop="dateModified" datetime="2023-11-09T10:01:34+08:00">2023-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">Go笔记</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><p>关键字不能用于自定义名字，只能在特定语法结构中使用。</p>
<p>break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var</p>
<p>此外，还有大约30多个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。</p>
<p>内建常量: true false iota nil</p>
<p>内建类型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune 				 string error</p>
<p>内建函数: make len cap new append copy close delete complex real imag panic recover</p>
<p>这些内部预先定义的名字并不是关键字，你可以在定义中重新使用它们。在一些特殊的场景</p>
<p>中重新定义它们也是有意义的，但是也要注意避免过度而引起语义混乱。</p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>var 变量名字 类型 &#x3D; 表达式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> i, j, k <span class="type">int</span> 	<span class="comment">// int, int, int</span></span><br><span class="line"><span class="keyword">var</span> b, f, s = <span class="literal">true</span>, <span class="number">2.3</span>, <span class="string">&quot;four&quot;</span>	 <span class="comment">// bool, float64, string</span></span><br></pre></td></tr></table></figure>

<p>名字</p>
<p><strong>:&#x3D; 表达式”形式声明变量，变量的类型根据表达式来自动推导。</strong></p>
<h4 id="new函数：表达式new-T-将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为-T"><a href="#new函数：表达式new-T-将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为-T" class="headerlink" title="new函数：表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为 *T"></a>new函数：表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为 *T</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="type">int</span>) <span class="comment">// p, *int 类型, 指向匿名的 int 变量</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// &quot;0&quot;</span></span><br><span class="line">*p = <span class="number">2</span> <span class="comment">// 设置 int 匿名变量的值为 2</span></span><br><span class="line">fmt.Println(*p) <span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>type 类型名字 底层类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Celsius <span class="type">float64</span> <span class="comment">// 摄氏温度</span></span><br><span class="line"><span class="keyword">type</span> Fahrenheit <span class="type">float64</span> <span class="comment">// 华氏温度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	AbsoluteZeroC Celsius = <span class="number">-273.15</span> <span class="comment">// 绝对零度</span></span><br><span class="line">	FreezingC Celsius = <span class="number">0</span> <span class="comment">// 结冰点温度</span></span><br><span class="line">	BoilingC Celsius = <span class="number">100</span> <span class="comment">// 沸水温度</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="包和文件"><a href="#包和文件" class="headerlink" title="包和文件"></a>包和文件</h1><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/img/image-20221121211730320.png" alt="image-20221121211730320"></p>
<p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/img/image-20221121212110139.png" alt="image-20221121212110139"></p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/02/13/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E4%B8%8Ego-redis%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/13/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E4%B8%8Ego-redis%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">命令模式与go-redis设计</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-13 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-13T00:00:00+08:00">2022-02-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">Go其他知识点</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="命令模式与go-redis-command设计"><a href="#命令模式与go-redis-command设计" class="headerlink" title="命令模式与go-redis command设计"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangxinwen/p/14311991.html">命令模式与go-redis command设计</a></h1><p>目录</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangxinwen/p/14311991.html#%E4%B8%80%E4%BB%80%E4%B9%88%E6%98%AF%E5%91%BD%E4%BB%A4command%E6%A8%A1%E5%BC%8F">一、什么是命令（Command）模式</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangxinwen/p/14311991.html#%E4%BA%8Cgo-redis-command%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81">二、go-redis command相关代码</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangxinwen/p/14311991.html#%E4%B8%89%E6%80%BB%E7%BB%93">三、总结</a></li>
</ul>
<h4 id="一、什么是命令（Command）模式"><a href="#一、什么是命令（Command）模式" class="headerlink" title="一、什么是命令（Command）模式#"></a>一、什么是命令（Command）模式<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangxinwen/p/14311991.html#%E4%B8%80%E4%BB%80%E4%B9%88%E6%98%AF%E5%91%BD%E4%BB%A4command%E6%A8%A1%E5%BC%8F">#</a></h4><p>命令模式是行为型设计模式的一种，其目的是将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化。与另一种将每种命令与调用命令的对象结合形成一个专有类的方式相比，命令模式的优点有将调用操作的对象与知道如何实现该操作的对象解耦，增加新的命令不需要修改现有的类。<br>命令模式的结构如下：<br><a target="_blank" rel="noopener" href="https://img2020.cnblogs.com/blog/1447810/202101/1447810-20210122095641252-470394572.png"><img src="https://img2020.cnblogs.com/blog/1447810/202101/1447810-20210122095641252-470394572.png" alt="command"></a><br>参与者有：<br>1.Invoker请求者<br>要求该命令执行这个请求，即命令的调用者<br>2.Command接口<br>3.ConcreteCommand具体接口<br>4.Receiver接收者<br>命令的相关操作的实际实施者<br>5.Client<br>协作过程：<br>1.Client创建一个ConcreteCommand对象并指定它的Receiver对象<br>2.某Invoker对象存储该ConcreteCommand对象<br>3.该Invoker通过调用Command对象的Excute操作来提交一个请求。若该命令是可撤消的，ConcreteCommand就在执行Excute操作之前存储当前状态以用于取消该命令<br>4.ConcreteCommand对象对调用它的Receiver的一些操作以执行该请求</p>
<h4 id="二、go-redis-command相关代码"><a href="#二、go-redis-command相关代码" class="headerlink" title="二、go-redis command相关代码#"></a>二、go-redis command相关代码<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangxinwen/p/14311991.html#%E4%BA%8Cgo-redis-command%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81">#</a></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// commands.go</span><br><span class="line"></span><br><span class="line">// <span class="type">Invoker</span>请求者接口</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Cmdable</span> interface &#123;</span></span><br><span class="line"><span class="class">      <span class="type">Pipeline</span>() <span class="type">Pipeliner</span></span></span><br><span class="line"><span class="class">      <span class="type">Pipelined</span>(<span class="title">ctx</span> <span class="title">context</span>.<span class="type">Context</span>, <span class="title">fn</span> <span class="title">func</span>(<span class="type">Pipeliner</span>) <span class="title">error</span>) ([]<span class="type">Cmder</span>, <span class="title">error</span>)</span></span><br><span class="line"><span class="class">      <span class="type">TxPipelined</span>(<span class="title">ctx</span> <span class="title">context</span>.<span class="type">Context</span>, <span class="title">fn</span> <span class="title">func</span>(<span class="type">Pipeliner</span>) <span class="title">error</span>) ([]<span class="type">Cmder</span>, <span class="title">error</span>)</span></span><br><span class="line"><span class="class">      <span class="type">TxPipeline</span>() <span class="type">Pipeliner</span></span></span><br><span class="line"><span class="class">      <span class="type">Command</span>(<span class="title">ctx</span> <span class="title">context</span>.<span class="type">Context</span>) *<span class="type">CommandsInfoCmd</span></span></span><br><span class="line"><span class="class">      <span class="type">ClientGetName</span>(<span class="title">ctx</span> <span class="title">context</span>.<span class="type">Context</span>) *<span class="type">StringCmd</span></span></span><br><span class="line"><span class="class">      // ...</span></span><br><span class="line"><span class="class">      // 和所有<span class="type">Redis</span>命令的相关方法</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"></span><br><span class="line">// cmdable实现了<span class="type">Cmdable</span>接口</span><br><span class="line"><span class="class"><span class="keyword">type</span> cmdable func(<span class="title">ctx</span> <span class="title">context</span>.<span class="type">Context</span>, <span class="title">cmd</span> <span class="type">Cmder</span>) error  </span></span><br><span class="line"><span class="title">func</span> (c cmdable) <span class="type">Echo</span>(ctx context.<span class="type">Context</span>, message interface&#123;&#125;) *<span class="type">StringCmd</span> &#123;</span><br><span class="line">	cmd := <span class="type">NewStringCmd</span>(ctx, <span class="string">&quot;echo&quot;</span>, message)</span><br><span class="line">	_ = c(ctx, cmd)</span><br><span class="line">	return cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里值得一提的是cmdable是一个函数类型，func(ctx context.Context, cmd Cmder) error<br>并且每个cmdable方法里都会有_ &#x3D; c(ctx, cmd)，也就是如何去调用cmd在这里还没有明确写出<br>再回头看redis.go，会发现这样一段代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">      *baseClient</span><br><span class="line">      cmdable</span><br><span class="line">      hooks</span><br><span class="line">      ctx context.Context</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(opt *Options)</span></span> *Client &#123;</span><br><span class="line">      opt.init()</span><br><span class="line"></span><br><span class="line">      c := Client&#123;</span><br><span class="line">            baseClient: newBaseClient(opt, newConnPool(opt)),</span><br><span class="line">            ctx:        context.Background(),</span><br><span class="line">      &#125;</span><br><span class="line">      c.cmdable = c.Process <span class="comment">//划线</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &amp;c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c.cmdable &#x3D; c.Process这行指定了请求如何调用Command的<br>在ctrl+左键追踪几层后，会在redis.go里找到调用的具体过程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis.go </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *baseClient)</span></span> process(ctx context.Context, cmd Cmder) <span class="type">error</span> &#123;</span><br><span class="line">      ......</span><br><span class="line">      err := cn.WithWriter(ctx, c.opt.WriteTimeout, <span class="function"><span class="keyword">func</span><span class="params">(wr *proto.Writer)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">            eturn writeCmd(wr, cmd)</span><br><span class="line">      &#125;)</span><br><span class="line">				</span><br><span class="line">      err = cn.WithReader(ctx, c.cmdTimeout(cmd), cmd.readReply)</span><br><span class="line">      ......			</span><br></pre></td></tr></table></figure>

<p>然后再去找Command，这边就比较清晰了，都在command.go中</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// command.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Command接口</span></span><br><span class="line">type Cmder interface &#123;</span><br><span class="line">      <span class="built_in">Name</span>() string</span><br><span class="line">      <span class="built_in">FullName</span>() string</span><br><span class="line">      <span class="built_in">Args</span>() <span class="selector-attr">[]</span>interface&#123;&#125;</span><br><span class="line">      <span class="built_in">String</span>() string</span><br><span class="line">      <span class="built_in">stringArg</span>(int) string</span><br><span class="line">      <span class="built_in">firstKeyPos</span>() int8</span><br><span class="line">      <span class="built_in">setFirstKeyPos</span>(int8)</span><br><span class="line"></span><br><span class="line">      <span class="built_in">readTimeout</span>() *<span class="selector-tag">time</span><span class="selector-class">.Duration</span></span><br><span class="line">      <span class="built_in">readReply</span>(rd *proto.Reader) error</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">SetErr</span>(error)</span><br><span class="line">      <span class="built_in">Err</span>() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有许多Cmder的具体实现，其中一个实现的部分代码如下</span></span><br><span class="line">type XPendingExtCmd struct &#123;</span><br><span class="line">      baseCmd</span><br><span class="line">      val <span class="selector-attr">[]</span>XPendingExt</span><br><span class="line">&#125;</span><br><span class="line">func (cmd *XPendingExtCmd) <span class="built_in">Val</span>() <span class="selector-attr">[]</span>XPendingExt &#123;</span><br><span class="line">      return cmd<span class="selector-class">.val</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里没有看到Receiver，是因为每个Cmder实现都自己实现了所有功能，根本不需要额外的接收者对象。</p>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结#"></a>三、总结<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangxinwen/p/14311991.html#%E4%B8%89%E6%80%BB%E7%BB%93">#</a></h4><p>有时必须向某对象提交请求，但并不知道关于被请求的操作或请求的接受者的任何信息。这个时候可以用到命令模式，通过将请求本身变成一个对象来使工具箱对象可向未指定的应用对象提出请求。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/02/08/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/go-redis%E5%92%8Credisgo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/08/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/go-redis%E5%92%8Credisgo/" class="post-title-link" itemprop="url">go-redis和redisgo</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-08 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-08T00:00:00+08:00">2022-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">Go其他知识点</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/go-redis/redis">go-redis</a>和<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/gomodule/redigo">redigo</a>底层是通过调用的万能 Do 方法实现, 但是</p>
<p><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/gomodule/redigo">redigo</a>:</p>
<ul>
<li>由于输入是万能类型所以必须记住每个命令的参数和返回值情况, 使用起来非常的不友好，</li>
<li>参数类型是万能类型导致在编译阶段无法检查参数类型,</li>
<li>每个命令都需要花时间记录使用方法，参数个数等，使用成本高；</li>
</ul>
<p><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/go-redis/redis">go-redis</a>:</p>
<ul>
<li>细化了每个redis每个命令的功能, 我们只需记住命令，具体的用法直接查看接口的申请就可以了，使用成本低；</li>
<li>其次它对数据类型按照redis底层的类型进行统一，编译时就可以帮助检查参数类型</li>
<li>并且它的响应统一采用 Result 的接口返回，确保了返回参数类型的正确性，对用户更加友好；</li>
</ul>
<h1 id="Redigo库"><a href="#Redigo库" class="headerlink" title="Redigo库"></a>Redigo库</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/gomodule/redigo">redigo</a> 是<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://redis.io/">Redis</a><a target="_blank" rel="noopener" href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>的<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://golang.org/">Go</a>客户端, 操作Redis基本和commands一样. Redigo命令基本都是通过Do方法来实现的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Do</span>(ctx context.<span class="property">Context</span>, cmd string, args ...interface&#123;&#125;) (interface&#123;&#125;, error)</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>虽然调用<code>Do</code>函数万能参数可以实现所有的功能，但是使用起来非常的不友好，参数类型是万能类型，所以在编译阶段无法检查参数类型, 其次每个命令都需要花时间记录使用方法，参数个数等，使用成本高；</p>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>演示基本的<strong>连接池建立, ping, string操作, hash操作, list操作, expire</strong>等操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/gomodule/redigo/redis&quot;</span></span><br><span class="line">)</span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="comment">// 新建一个连接池</span></span><br><span class="line">   <span class="keyword">var</span> pool *redis.<span class="property">Pool</span></span><br><span class="line">   pool = &amp;amp;redis.<span class="property">Pool</span>&#123;</span><br><span class="line">      <span class="title class_">MaxIdle</span>:     <span class="number">10</span>,  <span class="comment">//最初的连接数量</span></span><br><span class="line">      <span class="title class_">MaxActive</span>:   <span class="number">0</span>,   <span class="comment">//连接池最大连接数量,（0表示自动定义），按需分配</span></span><br><span class="line">      <span class="title class_">IdleTimeout</span>: <span class="number">300</span>, <span class="comment">//连接关闭时间 300秒 （300秒不使用自动关闭）</span></span><br><span class="line">      <span class="title class_">Dial</span>: <span class="title function_">func</span>() (redis.<span class="property">Conn</span>, error) &#123; <span class="comment">//要连接的redis数据库</span></span><br><span class="line">         <span class="keyword">return</span> redis.<span class="title class_">Dial</span>(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:6379&quot;</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;</span><br><span class="line">   conn := pool.<span class="title class_">Get</span>() <span class="comment">//从连接池，取一个链接</span></span><br><span class="line">   defer conn.<span class="title class_">Close</span>()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 0. ping正常返回pong， 异常res is nil, err not nil</span></span><br><span class="line">   res, err := conn.<span class="title class_">Do</span>(<span class="string">&quot;ping&quot;</span>)</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;ping res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;ping err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// string操作</span></span><br><span class="line">   <span class="comment">// set</span></span><br><span class="line">   res, err = conn.<span class="title class_">Do</span>(<span class="string">&quot;set&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;测试001&quot;</span>)</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;set res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;set err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// get</span></span><br><span class="line">   res, err = redis.<span class="title class_">String</span>(conn.<span class="title class_">Do</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;name&quot;</span>))</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;get res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;get err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// MSet   MGet</span></span><br><span class="line">   res, err = conn.<span class="title class_">Do</span>(<span class="string">&quot;MSet&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;测试001&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;MSet res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;MSet err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   r, err := redis.<span class="title class_">Strings</span>(conn.<span class="title class_">Do</span>(<span class="string">&quot;MGet&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>))</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;MGet res=%v\n&quot;</span>, r)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;MGet err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// expire</span></span><br><span class="line">   res, err = conn.<span class="title class_">Do</span>(<span class="string">&quot;expire&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="number">5</span>)</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;expire res=%v\n&quot;</span>, r)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;expire err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// list操作</span></span><br><span class="line">   <span class="comment">// lpush lpop</span></span><br><span class="line">   res, err = conn.<span class="title class_">Do</span>(<span class="string">&quot;lpush&quot;</span>, <span class="string">&quot;hobby&quot;</span>, <span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;足球&quot;</span>, <span class="string">&quot;乒乓球&quot;</span>)</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;lpush res=%v\n&quot;</span>, r)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;lpush err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// lpop</span></span><br><span class="line">   rs, er := conn.<span class="title class_">Do</span>(<span class="string">&quot;lpop&quot;</span>, <span class="string">&quot;hobby&quot;</span>)</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;lpop res=%v\n&quot;</span>, rs)</span><br><span class="line">   <span class="keyword">if</span> er != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;lpop err=%v\n&quot;</span>, er.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// hash 操作</span></span><br><span class="line">   <span class="comment">// hset</span></span><br><span class="line">   res, err = conn.<span class="title class_">Do</span>(<span class="string">&quot;HSet&quot;</span>, <span class="string">&quot;userinfo&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;lqz&quot;</span>)</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;HSet res=%v\n&quot;</span>, r)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;HSet err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// hget</span></span><br><span class="line">   r4, er4 := conn.<span class="title class_">Do</span>(<span class="string">&quot;HGet&quot;</span>, <span class="string">&quot;userinfo&quot;</span>, <span class="string">&quot;name&quot;</span>)</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;HGet res=%v\n&quot;</span>, r4)</span><br><span class="line">   <span class="keyword">if</span> er4 != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;HGet err=%v\n&quot;</span>, er4.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="go-redis组件介绍和使用"><a href="#go-redis组件介绍和使用" class="headerlink" title="go-redis组件介绍和使用"></a>go-redis组件介绍和使用</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/go-redis/redis">go-redis</a>提供了三种对应服务端的客户端模式，集群，哨兵，和单机模式，三种模式在连接池这一块都是公用的, 同时还提供了灵活的Hook机制, 其底层实际也是调用的万能 Do 方法.</p>
<p><img src="https://ask.qcloudimg.com/developer-images/article/7380026/ooeifbs9by.png" alt="img"></p>
<p>但go-redis细化了每个redis每个命令的功能, 我们只需记住命令，具体的用法直接查看接口的申请就可以了，使用成本低；其次它对数据类型按照redis底层的类型进行统一，编译时就可以帮助检查参数类型, 并且它的响应统一采用 Result 的接口返回，确保了返回参数类型的正确性，对用户更加友好；</p>
<h2 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h2><p>演示基本的<strong>连接池建立, ping, string操作, hash操作, list操作, expire</strong>等操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> rdb = redis2.<span class="title class_">NewClient</span>(</span><br><span class="line">      &amp;amp;redis2.<span class="property">Options</span>&#123;</span><br><span class="line">         <span class="title class_">Addr</span>:     <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">         <span class="title class_">Password</span>: <span class="string">&quot;&quot;</span>, <span class="attr">DB</span>: <span class="number">1</span>,</span><br><span class="line">         <span class="title class_">MinIdleConns</span>: <span class="number">1</span>,</span><br><span class="line">         <span class="title class_">PoolSize</span>:     <span class="number">1000</span>,</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">   ctx := context.<span class="title class_">Background</span>()</span><br><span class="line">   res, err = rdb.<span class="title class_">Ping</span>(ctx).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;ping res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;ping err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// string操作</span></span><br><span class="line">   <span class="comment">// set</span></span><br><span class="line">   res, err = rdb.<span class="title class_">Set</span>(ctx, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;测试001&quot;</span>, <span class="number">0</span>).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;set res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;set err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// get</span></span><br><span class="line">   res, err = rdb.<span class="title class_">Get</span>(ctx, <span class="string">&quot;name&quot;</span>).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;get res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;get err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// MSet   MGet</span></span><br><span class="line">   res, err = rdb.<span class="title class_">MSet</span>(ctx, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;测试001&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;18&quot;</span>).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;MSet res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;MSet err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> ret []interface&#123;&#125;</span><br><span class="line">   ret, err = rdb.<span class="title class_">MGet</span>(ctx, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;MGet res=%v\n&quot;</span>, ret)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;MGet err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// expire</span></span><br><span class="line">   res, err = rdb.<span class="title class_">Expire</span>(ctx, <span class="string">&quot;name&quot;</span>, time.<span class="property">Second</span>).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;expire res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;expire err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// list操作</span></span><br><span class="line">   <span class="comment">// lpush lpop</span></span><br><span class="line">   res, err = rdb.<span class="title class_">LPush</span>(ctx, <span class="string">&quot;hobby&quot;</span>, <span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;足球&quot;</span>, <span class="string">&quot;乒乓球&quot;</span>).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;lpush res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;lpush err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// lpop</span></span><br><span class="line">   rs, err = rdb.<span class="title class_">LPop</span>(ctx, <span class="string">&quot;hobby&quot;</span>).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;lpop res=%v\n&quot;</span>, rs)</span><br><span class="line">   <span class="keyword">if</span> er != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;lpop err=%v\n&quot;</span>, er.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// hash 操作</span></span><br><span class="line">   <span class="comment">// hset</span></span><br><span class="line">   res, err = rdb.<span class="title class_">HSet</span>(ctx, <span class="string">&quot;userinfo&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;lqz&quot;</span>).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;HSet res=%v\n&quot;</span>, r)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;HSet err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// hget</span></span><br><span class="line">   r4, er4 = rdb.<span class="title class_">HGet</span>(ctx, <span class="string">&quot;userinfo&quot;</span>, <span class="string">&quot;name&quot;</span>).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;HGet res=%v\n&quot;</span>, r4)</span><br><span class="line">   <span class="keyword">if</span> er4 != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;HGet err=%v\n&quot;</span>, er4.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/02/03/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GRPC/2-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/03/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GRPC/2-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">2-基础教程</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-03 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-03T00:00:00+08:00">2022-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GRPC/" itemprop="url" rel="index">
                    <span itemprop="name">GRPC</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="定义服务"><a href="#定义服务" class="headerlink" title="定义服务"></a>定义服务</h1><p>要定义服务，您可以<code>service</code>在 .proto 文件中指定一个名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service RouteGuide &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rpc</code>然后，您在服务定义中定义方法，指定它们的请求和响应类型。gRPC允许您定义四种服务方法，所有这些方法都在<code>RouteGuide</code>服务中使用：</p>
<ul>
<li><p>一个<em>简单的 RPC</em>，客户端使用存根向服务器发送请求并等待响应返回，就像正常的函数调用一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Obtains the feature at a given position.</span><br><span class="line">rpc GetFeature(Point) returns (Feature) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器<em>端流式 RPC</em>，客户端向服务器发送请求并获取流以读回一系列消息。客户端从返回的流中读取，直到没有更多消息为止。<em>正如您在我们的示例中看到的，您可以通过将关键字放在响应</em><code>stream</code>类型 之前来指定服务器端流方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Obtains the Features available within the given Rectangle.  Results are</span><br><span class="line">// streamed rather than returned at once (e.g. in a response message with a</span><br><span class="line">// repeated field), as the rectangle may cover a large area and contain a</span><br><span class="line">// huge number of features.</span><br><span class="line">rpc ListFeatures(Rectangle) returns (stream Feature) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户<em>端流式 RPC</em>，客户端写入一系列消息并将它们发送到服务器，同样使用提供的流。一旦客户端完成消息写入，它就会等待服务器读取所有消息并返回响应。<em>您可以通过将关键字放在请求</em><code>stream</code>类型之前来指定客户端流方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Accepts a stream of Points on a route being traversed, returning a</span><br><span class="line">// RouteSummary when traversal is completed.</span><br><span class="line">rpc RecordRoute(stream Point) returns (RouteSummary) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双向<em>流式 RPC</em>，双方使用读写流发送一系列消息。这两个流独立运行，因此客户端和服务器可以按照它们喜欢的任何顺序读取和写入：例如，服务器可以在写入响应之前等待接收所有客户端消息，或者可以交替读取消息然后写入消息，或其他一些读和写的组合。每个流中消息的顺序都会被保留。<code>stream</code> 您可以通过在请求和响应之前放置关键字来指定这种类型的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Accepts a stream of RouteNotes sent while a route is being traversed,</span><br><span class="line">// while receiving other RouteNotes (e.g. from other users).</span><br><span class="line">rpc RouteChat(stream RouteNote) returns (stream RouteNote) &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>我们的 .proto 文件还包含服务方法中使用的所有请求和响应类型的协议缓冲区消息类型定义 - 例如，以下是消息<code>Point</code>类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Points are represented as latitude-longitude pairs in the E7 representation</span><br><span class="line">// (degrees multiplied by 10**7 and rounded to the nearest integer).</span><br><span class="line">// Latitudes should be in the range +/- 90 degrees and longitude should be in</span><br><span class="line">// the range +/- 180 degrees (inclusive).</span><br><span class="line">message Point &#123;</span><br><span class="line">  int32 latitude = 1;</span><br><span class="line">  int32 longitude = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/02/01/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GRPC/1-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/01/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GRPC/1-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/" class="post-title-link" itemprop="url">1-快速开始</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-01 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-01T00:00:00+08:00">2022-02-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GRPC/" itemprop="url" rel="index">
                    <span itemprop="name">GRPC</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h1><h3 id="gRPC简介"><a href="#gRPC简介" class="headerlink" title="gRPC简介"></a>gRPC简介</h3><ul>
<li>gRPC由google开发，是一款语言中立、平台中立、开源的远程过程调用系统</li>
<li>gRPC客户端和服务端可以在多种环境中运行和交互，例如用java写一个服务端，可以用go语言写客户端调用</li>
</ul>
<h3 id="gRPC与Protobuf介绍"><a href="#gRPC与Protobuf介绍" class="headerlink" title="gRPC与Protobuf介绍"></a>gRPC与Protobuf介绍</h3><ul>
<li>微服务架构中，由于每个服务对应的代码库是独立运行的，无法直接调用，彼此间的通信就是个大问题</li>
<li>gRPC可以实现微服务，将大的项目拆分为多个小且独立的业务模块，也就是服务，各服务间使用高效的protobuf协议进行RPC调用，gRPC默认使用protocol buffers，这是google开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如JSON）</li>
<li>可以用proto files创建gRPC服务，用message类型来定义方法参数和返回类型</li>
</ul>
<h3 id="安装gRPC和Protobuf"><a href="#安装gRPC和Protobuf" class="headerlink" title="安装gRPC和Protobuf"></a>安装gRPC和Protobuf</h3><ul>
<li>go get github.com&#x2F;golang&#x2F;protobuf&#x2F;proto</li>
<li>go get google.golang.org&#x2F;grpc（无法使用，用如下命令代替）<ul>
<li>git clone <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc-go.git">https://github.com/grpc/grpc-go.git</a> $GOPATH&#x2F;src&#x2F;google.golang.org&#x2F;grpc</li>
<li>git clone <a target="_blank" rel="noopener" href="https://github.com/golang/net.git">https://github.com/golang/net.git</a> $GOPATH&#x2F;src&#x2F;golang.org&#x2F;x&#x2F;net</li>
<li>git clone <a target="_blank" rel="noopener" href="https://github.com/golang/text.git">https://github.com/golang/text.git</a> $GOPATH&#x2F;src&#x2F;golang.org&#x2F;x&#x2F;text</li>
<li>go get -u github.com&#x2F;golang&#x2F;protobuf&#x2F;{proto,protoc-gen-go}</li>
<li>git clone <a target="_blank" rel="noopener" href="https://github.com/google/go-genproto.git">https://github.com/google/go-genproto.git</a> $GOPATH&#x2F;src&#x2F;google.golang.org&#x2F;genproto</li>
<li>cd $GOPATH&#x2F;src&#x2F;</li>
<li>go install google.golang.org&#x2F;grpc</li>
</ul>
</li>
<li>go get github.com&#x2F;golang&#x2F;protobuf&#x2F;protoc-gen-go</li>
<li>上面安装好后，会在GOPATH&#x2F;bin下生成protoc-gen-go.exe</li>
<li>但还需要一个protoc.exe，windows平台编译受限，很难自己手动编译，直接去网站下载一个，地址：<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf/releases/tag/v3.9.0">https://github.com/protocolbuffers/protobuf/releases/tag/v3.9.0</a> ，同样放在GOPATH&#x2F;bin下</li>
</ul>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/01/31/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/31/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">面试题</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-31 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-31T00:00:00+08:00">2022-01-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-09 10:01:34" itemprop="dateModified" datetime="2023-11-09T10:01:34+08:00">2023-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index">
                    <span itemprop="name">GO基础知识</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="init函数和main函数的异同"><a href="#init函数和main函数的异同" class="headerlink" title="init函数和main函数的异同"></a>init函数和main函数的异同</h1><p><strong>init函数不能被其他函数调用，而是在main函数执行之前，自动被调用</strong></p>
<p>​    相同点：<br>​        两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。<br>​    不同点：<br>​        init可以应用于任意包中，且可以重复定义多个。<br>​        main函数只能用于main包中，且只能定义一个。</p>
<h1 id="new与make的区别"><a href="#new与make的区别" class="headerlink" title="new与make的区别"></a>new与make的区别</h1><p>​    1.二者都是用来做内存分配的。<br>​    2.<strong>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</strong><br>​    3.而<strong>new用于类型的内存分配，并且内存对应的值为类型默认值，返回的是指向类型的指针</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a *<span class="type">int</span></span><br><span class="line">    a = <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">    *a = <span class="number">10</span></span><br><span class="line">    fmt.Println(*a)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">    b = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    b[<span class="string">&quot;测试&quot;</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>匿名函数是指<strong>不需要定义函数名的一种函数</strong>实现方式，匿名函数的优越性在于可以<strong>直接使用函数内的变量，不必申明</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> getSqrt := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Sqrt(a)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(getSqrt(<span class="number">4</span>))</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>Golang匿名函数可赋值给变量，做为结构字段，或者在 channel 里传送。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fn := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">&quot;Hello, World!&quot;</span>) &#125;</span><br><span class="line">    fn()</span><br><span class="line"></span><br><span class="line">    fns := [](<span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x + <span class="number">1</span> &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x + <span class="number">2</span> &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(fns[<span class="number">0</span>](<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    d := <span class="keyword">struct</span> &#123;</span><br><span class="line">        fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        fn: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span> &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(d.fn())</span><br><span class="line"></span><br><span class="line">    fc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    fc &lt;- <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span> &#125;</span><br><span class="line">    <span class="built_in">println</span>((&lt;-fc)())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>Go语言中的闭包（Closure）是一种<strong>引用了自由变量的函数</strong>，<strong>自由变量是指在函数中使用的变量</strong>，但<strong>既不是函数参数也不是函数本地变量</strong>。闭包允许在一个函数内部包含一个自由变量的引用，这样就可以让这个自由变量的值在函数调用之间得以保留。</p>
<p>当<strong>函数返回时，函数所引用的自由变量可以被继续访问，不被释放</strong>。这是因为<strong>在编译时，编译器将函数与其自由变量打包为一个封闭函数对象</strong>，<strong>该对象包含函数的代码以及其访问的自由变量的引用</strong>。<strong>当函数对象被返回或直接使用时，自由变量的引用会被保留，因此可以继续访问闭包引用的自由变量</strong>。</p>
<h1 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h1><p>defer语句本质上是<strong>将语句推迟到函数返回之前</strong>执行，在函数退出时，defer推迟执行的语句会被按照<strong>后进先出</strong>的顺序执行，<strong>不管函数是否出错都会执行</strong>。因此，在使用defer时，<strong>需要考虑变量的作用域和生命周期，确保变量可以正确地传递到defer语句中</strong>。</p>
<p>defer<strong>后面的语句在执行的时候，函数调用的参数会被保存起来，但是不执行。也就是复制了一份。</strong>但是并没有说struct这里的this指针如何处理，通过这个例子可以看出go语言并没有把这个明确写出来的this指针当作参数来看待。</p>
<h4 id="用途：关闭文件句柄、锁资源释放、数据库连接释放"><a href="#用途：关闭文件句柄、锁资源释放、数据库连接释放" class="headerlink" title="用途：关闭文件句柄、锁资源释放、数据库连接释放"></a>用途：关闭文件句柄、锁资源释放、数据库连接释放</h4><h4 id="陷阱："><a href="#陷阱：" class="headerlink" title="陷阱："></a>陷阱：</h4><p>defer 与 return：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> (i <span class="type">int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure>

<p>defer nil 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> run <span class="function"><span class="keyword">func</span><span class="params">()</span></span> = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">defer</span> run()</span><br><span class="line"><span class="comment">//  defer 函数会被执行且会因为值为 nil 而产生 panic 异常。然而值得注意的是，run() 的声明是没有问题，因为在test函数运行完成后它才会被调用</span></span><br></pre></td></tr></table></figure>

<p>在错误的位置使用 defer：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">res, err := http.Get(<span class="string">&quot;http://www.google.com&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line"><span class="comment">// 因为在这里我们并没有检查我们的请求是否成功执行，当它失败的时候，我们访问了 Body 中的空变量 res ，因此会抛出异常</span></span><br><span class="line"><span class="comment">// 解决：</span></span><br><span class="line"><span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>Golang 没有结构化异常，使用 panic 抛出错误，recover 捕获错误</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>1.利用recover处理panic指令，<strong>defer 必须放在 panic 之前定义</strong>，另外 recover <strong>只有在 defer 调用的函数中才有效</strong>。否则当panic时，  recover无法捕获到panic，无法防止panic扩散。<br>2.recover 处理异常后，逻辑并不会恢复到 panic 那个点去，函数跑到 defer 之后的那个点。<br>3.多个 defer 会形成 defer 栈，后定义的 defer 语句会被最先调用。</p>
<blockquote>
<p>延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后一个错误可被捕获。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="built_in">recover</span>())</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;defer panic&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line"><span class="comment">// 输出defer panic</span></span><br></pre></td></tr></table></figure>

<h1 id="保护代码段"><a href="#保护代码段" class="headerlink" title="保护代码段"></a>保护代码段</h1><p>将代码块重构成匿名函数，如此可确保后续代码被执 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> z <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">                z = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="comment">// 出错</span></span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">        z = x / y</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;()</span><br><span class="line">	<span class="comment">// 继续执行</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;x / y = %d\n&quot;</span>, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Go实现类似-try-catch-的异常处理"><a href="#Go实现类似-try-catch-的异常处理" class="headerlink" title="Go实现类似 try catch 的异常处理"></a>Go实现类似 try catch 的异常处理</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Try</span><span class="params">(fun <span class="keyword">func</span>()</span></span>, handler <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            handler(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fun()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Try(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">func</span><span class="params">(err <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="普通函数与方法的区别"><a href="#普通函数与方法的区别" class="headerlink" title="普通函数与方法的区别"></a>普通函数与方法的区别</h1><p>1.对于普通函数，<strong>接收者为值类型时，不能将指针类型的数据直接传递，反之亦然。</strong></p>
<p>2.对于方法（如struct的方法），<strong>接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以</strong>。</p>
<h1 id="Golang方法集-："><a href="#Golang方法集-：" class="headerlink" title="Golang方法集 ："></a>Golang方法集 ：</h1><p>每个类型都有与之关联的方法集，这会影响到接口实现规则</p>
<p>​    • 类型 T 方法集包含全部 receiver T 方法。<br>​    • 类型 *T 方法集包含全部 receiver T + *T 方法。<br>​    • 如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。<br>​    • 如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T + *T 方法。<br>​    • 不管嵌入 T 或 <em>T，</em>S 方法集总是包含 T + *T 方法。</p>
<h1 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h1><p>为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型</p>
<h1 id="进程线程协程"><a href="#进程线程协程" class="headerlink" title="进程线程协程"></a>进程线程协程</h1><p>进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。<br>线程是进程的一个执行实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。<br>一个进程可以创建和撤销多个线程;同一个进程中的多个线程之间可以并发执行。</p>
<p>协程：协程是一种用户态的轻量级线程，由程序自身控制调度，不需要操作系统的支持，协程之间可以通过协程间通信机制进行通信，协程的执行效率高，可以减少线程切换的开销。<br>线程：一个线程上可以跑多个协程，协程是轻量级的线程。</p>
<h1 id="GPM"><a href="#GPM" class="headerlink" title="GPM"></a>GPM</h1><p>是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p>
<ul>
<li>1.G很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li>
<li>2.P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li>
<li>3.M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</li>
</ul>
<p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p>
<p>P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p>
<p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用&#x2F;调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的，  不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池，  不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。  另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上，  再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p>
<h1 id="runtime包"><a href="#runtime包" class="headerlink" title="runtime包"></a>runtime包</h1><p>runtime.Gosched():让出CPU时间片，重新等待安排任务</p>
<p>runtime.Goexit():退出当前协程</p>
<p>runtime.GOMAXPROCS(n):需要使用多少个OS线程来同时执行Go代码</p>
<p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/image-20230409150132645.png" alt="image-20230409150132645"></p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/01/26/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/26/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/" class="post-title-link" itemprop="url">随便写写</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-26 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-26T00:00:00+08:00">2022-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index">
                    <span itemprop="name">GO基础知识</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>477</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="init函数和main函数的异同"><a href="#init函数和main函数的异同" class="headerlink" title="init函数和main函数的异同"></a>init函数和main函数的异同</h2><p>​    相同点：<br>​        两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。<br>​    不同点：<br>​        init可以应用于任意包中，且可以重复定义多个。<br>​        main函数只能用于main包中，且只能定义一个。</p>
<h2 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h2><p>使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值</p>
<p><code>var a *int</code>只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值</p>
<p>make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型</p>
<p><code>var b map[string]int</code>只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值</p>
<p>区别：二者都是用来做内存分配的；make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/01/20/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/20/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Go面试题</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-20 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-20T00:00:00+08:00">2022-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-09 10:01:34" itemprop="dateModified" datetime="2023-11-09T10:01:34+08:00">2023-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index">
                    <span itemprop="name">GO基础知识</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a><strong>基础部分</strong></h2><h3 id="golang-中-make-和-new-的区别？（基本必问）"><a href="#golang-中-make-和-new-的区别？（基本必问）" class="headerlink" title="golang 中 make 和 new 的区别？（基本必问）"></a><strong>golang 中 make 和 new 的区别？（基本必问）</strong></h3><p><strong>共同点：</strong>给变量分配内存</p>
<p><strong>不同点：</strong></p>
<p>1）作用变量类型不同，new给string,int和数组分配内存，make给切片，map，channel分配内存；</p>
<p>2）返回类型不一样，new返回指向变量的指针，make返回变量本身；</p>
<p>3）new 分配的空间被清零。make 分配空间后，会进行初始化；</p>
<p>\4) 字节的面试官还说了另外一个区别，就是分配的位置，在堆上还是在栈上？这块我比较模糊，大家可以自己探究下，我搜索出来的答案是golang会弱化分配的位置的概念，因为编译的时候会自动内存逃逸处理，懂的大佬帮忙补充下：make、new内存分配是在堆上还是在栈上？</p>
<h3 id="数组和切片的区别-（基本必问）"><a href="#数组和切片的区别-（基本必问）" class="headerlink" title="数组和切片的区别 （基本必问）"></a><strong>数组和切片的区别 （基本必问）</strong></h3><p><strong>相同点：</strong></p>
<p>1)只能存储一组相同类型的数据结构</p>
<p>2)都是通过下标来访问，并且有容量长度，长度通过 len 获取，容量通过 cap 获取</p>
<p><strong>区别：</strong></p>
<p>1）数组是定长，访问和复制不能超过数组定义的长度，否则就会下标越界，切片长度和容量可以自动扩容</p>
<p>2）数组是值类型，切片是引用类型，每个切片都引用了一个底层数组，切片本身不能存储任何数据，都是这底层数组存储数据，所以修改切片的时候修改的是底层数组中的数据。切片一旦扩容，指向一个新的底层数组，内存地址也就随之改变</p>
<p><strong>简洁的回答：</strong></p>
<p>1）定义方式不一样 2）初始化方式不一样，数组需要指定大小，大小不改变 3）在函数传递中，数组切片都是值传递。</p>
<p><strong>数组的定义</strong></p>
<p>var a1 [3]int</p>
<p>var a2 […]int{1,2,3}</p>
<p><strong>切片的定义</strong></p>
<p>var a1 []int</p>
<p>var a2 :&#x3D;make([]int,3,5)</p>
<p><strong>数组的初始化</strong></p>
<p>a1 :&#x3D; […]int{1,2,3}</p>
<p>a2 :&#x3D; [5]int{1,2,3}</p>
<p><strong>切片的初始化</strong></p>
<p>b:&#x3D; make([]int,3,5)</p>
<h3 id="for-range-的时候它的地址会发生变化么？"><a href="#for-range-的时候它的地址会发生变化么？" class="headerlink" title="for range 的时候它的地址会发生变化么？"></a><strong>for range 的时候它的地址会发生变化么？</strong></h3><p>答：在 for a,b :&#x3D; range c 遍历中， a 和 b 在内存中只会存在一份，即之后每次循环时遍历到的数据都是以值覆盖的方式赋给 a 和 b，a，b 的内存地址始终不变。由于有这个特性，for 循环里面如果开协程，不要直接把 a 或者 b 的地址传给协程。解决办法：在每次循环时，创建一个临时变量。</p>
<h3 id="go-defer，多个-defer-的顺序，defer-在什么时机会修改返回值？"><a href="#go-defer，多个-defer-的顺序，defer-在什么时机会修改返回值？" class="headerlink" title="go defer，多个 defer 的顺序，defer 在什么时机会修改返回值？"></a><strong>go defer，多个 defer 的顺序，defer 在什么时机会修改返回值？</strong></h3><p>作用：defer延迟函数，释放资源，收尾工作；如释放锁，关闭文件，关闭链接；捕获panic;</p>
<p>避坑指南：defer函数紧跟在资源打开后面，否则defer可能得不到执行，导致内存泄露。</p>
<p>多个 defer 调用顺序是 LIFO（后入先出），defer后的操作可以理解为压入栈中</p>
<p>defer，return，return value（函数返回值） 执行顺序：首先return，其次return value，最后defer。defer可以修改函数最终返回值，修改时机：<strong>有名返回值或者函数返回指针</strong> 参考：</p>
<p><strong>有名返回值</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> (i <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(<span class="string">&quot;defer2:&quot;</span>, i)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(<span class="string">&quot;defer1:&quot;</span>, i)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> i <span class="comment">//或者直接写成return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;return:&quot;</span>, b())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p>
<p><strong>函数返回指针</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func c() *int &#123;</span><br><span class="line">	var i int</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(&quot;defer2:&quot;, i)</span><br><span class="line">	&#125;()</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(&quot;defer1:&quot;, i)</span><br><span class="line">	&#125;()</span><br><span class="line">	return &amp;i</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(&quot;return:&quot;, *(c()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uint-类型溢出问题"><a href="#uint-类型溢出问题" class="headerlink" title="uint 类型溢出问题"></a><strong>uint 类型溢出问题</strong></h3><p>超过最大存储值如uint8最大是255</p>
<p>var a uint8 &#x3D;255</p>
<p>var b uint8 &#x3D;1</p>
<p>a+b &#x3D; 0总之类型溢出会出现难以意料的事</p>
<p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-5bf5e213ce315a16d0b7e65ef41cc685_720w.webp" alt="img"></p>
<h3 id="能介绍下-rune-类型吗？"><a href="#能介绍下-rune-类型吗？" class="headerlink" title="能介绍下 rune 类型吗？"></a><strong>能介绍下 rune 类型吗？</strong></h3><p>相当int32</p>
<p>golang中的字符串底层实现是通过byte数组的，中文字符在unicode下占2个字节，在utf-8编码下占3个字节，而golang默认编码正好是utf-8</p>
<p>byte 等同于int8，常用来处理ascii字符</p>
<p>rune 等同于int32,常用来处理unicode或utf-8字符</p>
<p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-15a9656d176cfcc16d4116bbc9d2a24d_720w.webp" alt="img"></p>
<h3 id="调用函数传入结构体时，应该传值还是指针？-（Golang-都是传值）"><a href="#调用函数传入结构体时，应该传值还是指针？-（Golang-都是传值）" class="headerlink" title="调用函数传入结构体时，应该传值还是指针？ （Golang 都是传值）"></a><strong>调用函数传入结构体时，应该传值还是指针？ （Golang 都是传值）</strong></h3><p>Go 的函数参数传递都是值传递。所谓值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。参数传递还有引用传递，所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数</p>
<p>因为 Go 里面的 map，slice，chan 是引用类型。变量区分值类型和引用类型。所谓值类型：变量和变量的值存在同一个位置。所谓引用类型：变量和变量的值是不同的位置，变量的值存储的是对值的引用。但并不是 map，slice，chan 的所有的变量在函数内都能被修改，不同数据类型的底层存储结构和实现可能不太一样，情况也就不一样。</p>
<h3 id="讲讲-Go-的-slice-底层数据结构和一些特性？"><a href="#讲讲-Go-的-slice-底层数据结构和一些特性？" class="headerlink" title="讲讲 Go 的 slice 底层数据结构和一些特性？"></a><strong>讲讲 Go 的 slice 底层数据结构和一些特性？</strong></h3><p>答：Go 的 slice 底层数据结构是由一个 array 指针指向底层数组，len 表示切片长度，cap 表示切片容量。slice 的主要实现是扩容。对于 append 向 slice 添加元素时，假如 slice 容量够用，则追加新元素进去，slice.len++，返回原来的 slice。当原容量不够，则 slice 先扩容，扩容之后 slice 得到新的 slice，将元素追加进新的 slice，slice.len++，返回新的 slice。对于切片的扩容规则：当切片比较小时（容量小于 1024），则采用较大的扩容倍速进行扩容（新的扩容会是原来的 2 倍），避免频繁扩容，从而减少内存分配的次数和数据拷贝的代价。当切片较大的时（原来的 slice 的容量大于或者等于 1024），采用较小的扩容倍速（新的扩容将扩大大于或者等于原来 1.25 倍），主要避免空间浪费，网上其实很多总结的是 1.25 倍，那是在不考虑内存对齐的情况下，实际上还要考虑内存对齐，扩容是大于或者等于 1.25 倍。</p>
<p>（关于刚才问的 slice 为什么传到函数内可能被修改，如果 slice 在函数内没有出现扩容，函数外和函数内 slice 变量指向是同一个数组，则函数内复制的 slice 变量值出现更改，函数外这个 slice 变量值也会被修改。如果 slice 在函数内出现扩容，则函数内变量的值会新生成一个数组（也就是新的 slice，而函数外的 slice 指向的还是原来的 slice，则函数内的修改不会影响函数外的 slice。）</p>
<h3 id="讲讲-Go-的-select-底层数据结构和一些特性？（难点，没有项目经常可能说不清，面试一般会问你项目中怎么使用select）"><a href="#讲讲-Go-的-select-底层数据结构和一些特性？（难点，没有项目经常可能说不清，面试一般会问你项目中怎么使用select）" class="headerlink" title="讲讲 Go 的 select 底层数据结构和一些特性？（难点，没有项目经常可能说不清，面试一般会问你项目中怎么使用select）"></a><strong>讲讲 Go 的 select 底层数据结构和一些特性？（难点，没有项目经常可能说不清，面试一般会问你项目中怎么使用select）</strong></h3><p>答：go 的 select 为 golang 提供了多路 IO 复用机制，和其他 IO 复用一样，用于检测是否有读写事件是否 ready。linux 的系统 IO 模型有 select，poll，epoll，go 的 select 和 linux 系统 select 非常相似。</p>
<p>select 结构组成主要是由 case 语句和执行的函数组成 select 实现的多路复用是：每个线程或者进程都先到注册和接受的 channel（装置）注册，然后阻塞，然后只有一个线程在运输，当注册的线程和进程准备好数据后，装置会根据注册的信息得到相应的数据。</p>
<p><strong>select 的特性</strong></p>
<p>1）select 操作至少要有一个 case 语句，出现读写 nil 的 channel 该分支会忽略，在 nil 的 channel 上操作则会报错。</p>
<p>2）select 仅支持管道，而且是单协程操作。</p>
<p>3）每个 case 语句仅能处理一个管道，要么读要么写。</p>
<p>4）多个 case 语句的执行顺序是随机的。</p>
<p>5）存在 default 语句，select 将不会阻塞，但是存在 default 会影响性能。</p>
<h3 id="讲讲-Go-的-defer-底层数据结构和一些特性？"><a href="#讲讲-Go-的-defer-底层数据结构和一些特性？" class="headerlink" title="讲讲 Go 的 defer 底层数据结构和一些特性？"></a><strong>讲讲 Go 的 defer 底层数据结构和一些特性？</strong></h3><p>答：每个 defer 语句都对应一个_defer 实例，多个实例使用指针连接起来形成一个单连表，保存在 gotoutine 数据结构中，每次插入_defer 实例，均插入到链表的头部，函数结束再一次从头部取出，从而形成后进先出的效果。</p>
<p><strong>defer 的规则总结</strong>：</p>
<p>延迟函数的参数是 defer 语句出现的时候就已经确定了的。</p>
<p>延迟函数执行按照后进先出的顺序执行，即先出现的 defer 最后执行。</p>
<p>延迟函数可能操作主函数的返回值。</p>
<p>申请资源后立即使用 defer 关闭资源是个好习惯。</p>
<h3 id="单引号，双引号，反引号的区别？"><a href="#单引号，双引号，反引号的区别？" class="headerlink" title="单引号，双引号，反引号的区别？"></a><strong>单引号，双引号，反引号的区别？</strong></h3><p>单引号，表示byte类型或rune类型，对应 uint8和int32类型，默认是 rune 类型。byte用来强调数据是raw data，而不是数字；而rune用来表示Unicode的code point。</p>
<p>双引号，才是字符串，实际上是字符数组。可以用索引号访问某字节，也可以用len()函数来获取字符串所占的字节长度。</p>
<p>反引号，表示字符串字面量，但不支持任何转义序列。字面量 raw literal string 的意思是，你定义时写的啥样，它就啥样，你有换行，它就换行。你写转义字符，它也就展示转义字符。</p>
<h2 id="map相关"><a href="#map相关" class="headerlink" title="map相关"></a><strong>map相关</strong></h2><h3 id="map-使用注意的点，是否并发安全？"><a href="#map-使用注意的点，是否并发安全？" class="headerlink" title="map 使用注意的点，是否并发安全？"></a>map 使用注意的点，是否并发安全？</h3><p>map的类型是map[key]，key类型的ke必须是可比较的，通常情况，会选择内建的基本类型，比如整数、字符串做key的类型。如果要使用struct作为key，要保证struct对象在逻辑上是不可变的。在Go语言中，map[key]函数返回结果可以是一个值，也可以是两个值。map是无序的，如果我们想要保证遍历map时元素有序，可以使用辅助的数据结构，例如orderedmap。</p>
<p><strong>第一，</strong>一定要先初始化，否则panic</p>
<p><strong>第二，</strong>map类型是容易发生并发访问问题的。不注意就容易发生程序运行时并发读写导致的panic。 Go语言内建的map对象不是线程安全的，并发读写的时候运行时会有检查，遇到并发问题就会导致panic。</p>
<h3 id="map-循环是有序的还是无序的？"><a href="#map-循环是有序的还是无序的？" class="headerlink" title="map 循环是有序的还是无序的？"></a>map 循环是有序的还是无序的？</h3><p>无序的, map 因扩张⽽重新哈希时，各键值项存储位置都可能会发生改变，顺序自然也没法保证了，所以官方避免大家依赖顺序，直接打乱处理。就是 for range map 在开始处理循环逻辑的时候，就做了随机播种</p>
<h3 id="map-中删除一个-key，它的内存会释放么？（常问）"><a href="#map-中删除一个-key，它的内存会释放么？（常问）" class="headerlink" title="map 中删除一个 key，它的内存会释放么？（常问）"></a>map 中删除一个 key，它的内存会释放么？（常问）</h3><p>如果删除的元素是值类型，如int，float，bool，string以及数组和struct，map的内存不会自动释放</p>
<p>如果删除的元素是引用类型，如指针，slice，map，chan等，map的内存会自动释放，但释放的内存是子元素应用类型的内存占用</p>
<p>将map设置为nil后，内存被回收。</p>
<p><strong>这个问题还需要大家去搜索下答案，我记得有不一样的说法，谨慎采用本题答案。</strong></p>
<h3 id="怎么处理对-map-进行并发访问？有没有其他方案？-区别是什么？"><a href="#怎么处理对-map-进行并发访问？有没有其他方案？-区别是什么？" class="headerlink" title="怎么处理对 map 进行并发访问？有没有其他方案？ 区别是什么？"></a>怎么处理对 map 进行并发访问？有没有其他方案？ 区别是什么？</h3><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-1107961e741b834eb5fc071ff68da831_720w.webp" alt="img"></p>
<p><strong>方式一、使用内置sync.Map，详细参考</strong></p>
<p><a href="https://link.zhihu.com/?target=https://mbd.baidu.com/ma/s/7Hwd9yMc">https://mbd.baidu.com/ma/s/7Hwd9yMcmbd.baidu.com/ma/s/7Hwd9yMc</a></p>
<p><strong>方式二、使用读写锁实现并发安全map</strong></p>
<p><a href="https://link.zhihu.com/?target=https://mbd.baidu.com/ma/s/qO7b0VQU">https://mbd.baidu.com/ma/s/qO7b0VQUmbd.baidu.com/ma/s/qO7b0VQU</a></p>
<h3 id="nil-map-和空-map-有何不同？"><a href="#nil-map-和空-map-有何不同？" class="headerlink" title="nil map 和空 map 有何不同？"></a>nil map 和空 map 有何不同？</h3><p>1）可以对未初始化的map进行取值，但取出来的东西是空：</p>
<p>var m1 map[string]string</p>
<p>fmt.Println(m1[“1”])</p>
<p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p>
<p>2）不能对未初始化的map进行赋值，这样将会抛出一个异常：</p>
<p>var m1 map[string]string</p>
<p>m1[“1”] &#x3D; “1”</p>
<p>panic: assignment to entry in nil map</p>
<p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p>
<p>\3) 通过fmt打印map时，空map和nil map结果是一样的，都为map[]。所以，这个时候别断定map是空还是nil，而应该通过map &#x3D;&#x3D; nil来判断。</p>
<p><strong>nil map 未初始化，空map是长度为空</strong></p>
<h3 id="map-的数据结构是什么？是怎么实现扩容？"><a href="#map-的数据结构是什么？是怎么实现扩容？" class="headerlink" title="map 的数据结构是什么？是怎么实现扩容？"></a>map 的数据结构是什么？是怎么实现扩容？</h3><p>答：golang 中 map 是一个 kv 对集合。底层使用 hash table，用链表来解决冲突 ，出现冲突时，不是每一个 key 都申请一个结构通过链表串起来，而是以 bmap 为最小粒度挂载，一个 bmap 可以放 8 个 kv。在哈希函数的选择上，会在程序启动时，检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。每个 map 的底层结构是 hmap，是有若干个结构为 bmap 的 bucket 组成的数组。每个 bucket 底层都采用链表结构。</p>
<p><strong>hmap 的结构如下：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type hmap struct &#123;</span><br><span class="line">    count     int                  // 元素个数</span><br><span class="line">    flags     uint8</span><br><span class="line">    B         uint8                // 扩容常量相关字段B是buckets数组的长度的对数 2^B</span><br><span class="line">    noverflow uint16               // 溢出的bucket个数</span><br><span class="line">    hash0     uint32               // hash seed</span><br><span class="line">    buckets    unsafe.Pointer      // buckets 数组指针</span><br><span class="line">    oldbuckets unsafe.Pointer      // 结构扩容的时候用于赋值的buckets数组</span><br><span class="line">    nevacuate  uintptr             // 搬迁进度</span><br><span class="line">    extra *mapextra                // 用于扩容的指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>map 的容量大小</strong></p>
<p>底层调用 makemap 函数，计算得到合适的 B，map 容量最多可容纳 6.52^B 个元素，6.5 为装载因子阈值常量。装载因子的计算公式是：装载因子&#x3D;填入表中的元素个数&#x2F;散列表的长度，装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。底层调用 makemap 函数，计算得到合适的 B，map 容量最多可容纳 6.52^B 个元素，6.5 为装载因子阈值常量。装载因子的计算公式是：装载因子&#x3D;填入表中的元素个数&#x2F;散列表的长度，装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p>
<p><strong>触发 map 扩容的条件</strong></p>
<p>1）装载因子超过阈值，源码里定义的阈值是 6.5。</p>
<p>2）overflow 的 bucket 数量过多 map 的 bucket 定位和 key 的定位高八位用于定位 bucket，低八位用于定位 key，快速试错后再进行完整对比</p>
<p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-f99ed061ef6ea995743cda6d332861e3_720w.webp" alt="img"></p>
<h3 id="slices能作为map类型的key吗？"><a href="#slices能作为map类型的key吗？" class="headerlink" title="slices能作为map类型的key吗？"></a>slices能作为map类型的key吗？</h3><p>当时被问的一脸懵逼，其实是这个问题的变种：golang 哪些类型可以作为map key？</p>
<p>答案是：<strong>在golang规范中，可比较的类型都可以作为map key；</strong>这个问题又延伸到在：golang规范中，哪些数据类型可以比较？</p>
<p><strong>不能作为map key 的类型包括：</strong></p>
<ul>
<li>slices</li>
<li>maps</li>
<li>functions</li>
</ul>
<h2 id="context相关"><a href="#context相关" class="headerlink" title="context相关**"></a>context相关**</h2><h3 id="context-结构是什么样的？context-使用场景和用途？"><a href="#context-结构是什么样的？context-使用场景和用途？" class="headerlink" title="context 结构是什么样的？context 使用场景和用途？"></a><strong>context 结构是什么样的？context 使用场景和用途？</strong></h3><p><strong>（难，也常常问你项目中怎么用，光靠记答案很难让面试官满意，反正有各种结合实际的问题）</strong></p>
<p><strong>参考链接：</strong></p>
<p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/juanmaofeifei/p/14439957.html">go context详解 - 卷毛狒狒 - 博客园www.cnblogs.com/juanmaofeifei/p/14439957.html</a></p>
<p>答：Go 的 Context 的数据结构包含 Deadline，Done，Err，Value，Deadline 方法返回一个 time.Time，表示当前 Context 应该结束的时间，ok 则表示有结束时间，Done 方法当 Context 被取消或者超时时候返回的一个 close 的 channel，告诉给 context 相关的函数要停止当前工作然后返回了，Err 表示 context 被取消的原因，Value 方法表示 context 实现共享数据存储的地方，是协程安全的。context 在业务中是经常被使用的，</p>
<p><strong>其主要的应用 ：</strong></p>
<p>1：上下文控制，2：多个 goroutine 之间的数据交互等，3：超时控制：到某个时间点超时，过多久超时。</p>
<h2 id="channel相关"><a href="#channel相关" class="headerlink" title="channel相关"></a><strong>channel相关</strong></h2><h3 id="channel-是否线程安全？锁用在什么地方？"><a href="#channel-是否线程安全？锁用在什么地方？" class="headerlink" title="channel 是否线程安全？锁用在什么地方？"></a><strong>channel 是否线程安全？锁用在什么地方？</strong></h3><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-e287f5861392d5de73d8956974acdbbd_720w.webp" alt="img"></p>
<p>就着图片里面的答案看看吧。</p>
<h3 id="go-channel-的底层实现原理-（数据结构）"><a href="#go-channel-的底层实现原理-（数据结构）" class="headerlink" title="go channel 的底层实现原理 （数据结构）"></a><strong>go channel 的底层实现原理 （数据结构）</strong></h3><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-9452c08ff058590cea1b40a39fd8c70f_720w.webp" alt="img"></p>
<p>底层结构需要描述出来，这个简单，buf，发送队列，接收队列，lock。</p>
<h3 id="nil、关闭的-channel、有数据的-channel，再进行读、写、关闭会怎么样？（各类变种题型，重要）"><a href="#nil、关闭的-channel、有数据的-channel，再进行读、写、关闭会怎么样？（各类变种题型，重要）" class="headerlink" title="nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？（各类变种题型，重要）"></a><strong>nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？（各类变种题型，重要）</strong></h3><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-8e12b7eb664280346ec96bcc4fe1db2c_720w.webp" alt="img"></p>
<p>还要去了解一下单向channel,如只读或者只写通道常见的异常问题，这块还需要大家自己总结总结，有懂得大佬也可以评论发送答案。</p>
<h3 id="向-channel-发送数据和从-channel-读数据的流程是什么样的？"><a href="#向-channel-发送数据和从-channel-读数据的流程是什么样的？" class="headerlink" title="向 channel 发送数据和从 channel 读数据的流程是什么样的？"></a><strong>向 channel 发送数据和从 channel 读数据的流程是什么样的？</strong></h3><p><strong>发送流程：</strong></p>
<p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-d2a3f2aa5c85b94df49430c21a53a2d9_720w.webp" alt="img"></p>
<p><strong>接收流程：</strong></p>
<p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-69e0e2f1409a17ec2987e4b63e6210da_720w.webp" alt="img"></p>
<p>这个没啥好说的，底层原理，1、2、3描述出来，保证面试官满意。具体的文字描述下面一题有，channel的概念多且复杂，脑海中有个总分的概念，否则你说的再多，面试官也抓不住你说的重点，等于白说。问题5已经为大家总结好了。</p>
<h3 id="讲讲-Go-的-chan-底层数据结构和主要使用场景"><a href="#讲讲-Go-的-chan-底层数据结构和主要使用场景" class="headerlink" title="讲讲 Go 的 chan 底层数据结构和主要使用场景"></a><strong>讲讲 Go 的 chan 底层数据结构和主要使用场景</strong></h3><p>答：channel 的数据结构包含 qccount 当前队列中剩余元素个数，dataqsiz 环形队列长度，即可以存放的元素个数，buf 环形队列指针，elemsize 每个元素的大小，closed 标识关闭状态，elemtype 元素类型，sendx 队列下表，指示元素写入时存放到队列中的位置，recv 队列下表，指示元素从队列的该位置读出。recvq 等待读消息的 goroutine 队列，sendq 等待写消息的 goroutine 队列，lock 互斥锁，chan 不允许并发读写。</p>
<p><strong>无缓冲和有缓冲区别：</strong> 管道没有缓冲区，从管道读数据会阻塞，直到有协程向管道中写入数据。同样，向管道写入数据也会阻塞，直到有协程从管道读取数据。管道有缓冲区但缓冲区没有数据，从管道读取数据也会阻塞，直到协程写入数据，如果管道满了，写数据也会阻塞，直到协程从缓冲区读取数据。</p>
<p><strong>channel 的一些特点</strong> 1）、读写值 nil 管道会永久阻塞 2）、关闭的管道读数据仍然可以读数据 3）、往关闭的管道写数据会 panic 4）、关闭为 nil 的管道 panic 5）、关闭已经关闭的管道 panic</p>
<p><strong>向 channel 写数据的流程：</strong> 如果等待接收队列 recvq 不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从 recvq 取出 G,并把数据写入，最后把该 G 唤醒，结束发送过程； 如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程； 如果缓冲区中没有空余位置，将待发送数据写入 G，将当前 G 加入 sendq，进入睡眠，等待被读 goroutine 唤醒；</p>
<p><strong>向 channel 读数据的流程：</strong> 如果等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G，把 G 中数据读出，最后把 G 唤醒，结束读取过程； 如果等待发送队列 sendq 不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程； 如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；将当前 goroutine 加入 recvq，进入睡眠，等待被写 goroutine 唤醒；</p>
<p><strong>使用场景：</strong> 消息传递、消息过滤，信号广播，事件订阅与广播，请求、响应转发，任务分发，结果汇总，并发控制，限流，同步与异步</p>
<h2 id="GMP相关"><a href="#GMP相关" class="headerlink" title="GMP相关"></a><strong>GMP相关</strong></h2><h3 id="什么是-GMP？（必问）"><a href="#什么是-GMP？（必问）" class="headerlink" title="什么是 GMP？（必问）"></a>什么是 GMP？（必问）</h3><p>答：G 代表着 goroutine，P 代表着上下文处理器，M 代表 thread 线程，在 GPM 模型，有一个全局队列（Global Queue）：存放等待运行的 G，还有一个 P 的本地队列：也是存放等待运行的 G，但数量有限，不超过 256 个。GPM 的调度流程从 go func()开始创建一个 goroutine，新建的 goroutine 优先保存在 P 的本地队列中，如果 P 的本地队列已经满了，则会保存到全局队列中。M 会从 P 的队列中取一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会从其他的 MP 组合偷取一个可执行的 G 来执行，当 M 执行某一个 G 时候发生系统调用或者阻塞，M 阻塞，如果这个时候 G 在执行，runtime 会把这个线程 M 从 P 中摘除，然后创建一个新的操作系统线程来服务于这个 P，当 M 系统调用结束时，这个 G 会尝试获取一个空闲的 P 来执行，并放入到这个 P 的本地队列，如果这个线程 M 变成休眠状态，加入到空闲线程中，然后整个 G 就会被放入到全局队列中。</p>
<p>关于 G,P,M 的个数问题，G 的个数理论上是无限制的，但是受内存限制，P 的数量一般建议是逻辑 CPU 数量的 2 倍，M 的数据默认启动的时候是 10000，内核很难支持这么多线程数，所以整个限制客户忽略，M 一般不做设置，设置好 P，M 一般都是要大于 P。</p>
<h3 id="进程、线程、协程有什么区别？（必问）"><a href="#进程、线程、协程有什么区别？（必问）" class="headerlink" title="进程、线程、协程有什么区别？（必问）"></a>进程、线程、协程有什么区别？（必问）</h3><p>进程：是应用程序的启动实例，每个进程都有独立的内存空间，不同的进程通过进程间的通信方式来通信。</p>
<p>线程：从属于进程，每个进程至少包含一个线程，线程是 CPU 调度的基本单位，多个线程之间可以共享进程的资源并通过共享内存等线程间的通信方式来通信。</p>
<p>协程：为轻量级线程，与线程相比，协程不受操作系统的调度，协程的调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行</p>
<h3 id="抢占式调度是如何抢占的？"><a href="#抢占式调度是如何抢占的？" class="headerlink" title="抢占式调度是如何抢占的？"></a><strong>抢占式调度是如何抢占的？</strong></h3><p><strong>基于协作式抢占</strong></p>
<p><strong>基于信号量抢占</strong></p>
<p>就像操作系统要负责线程的调度一样，Go的runtime要负责goroutine的调度。现代操作系统调度线程都是抢占式的，我们不能依赖用户代码主动让出CPU，或者因为IO、锁等待而让出，这样会造成调度的不公平。基于经典的时间片算法，当线程的时间片用完之后，会被时钟中断给打断，调度器会将当前线程的执行上下文进行保存，然后恢复下一个线程的上下文，分配新的时间片令其开始执行。这种抢占对于线程本身是无感知的，系统底层支持，不需要开发人员特殊处理。</p>
<p>基于时间片的抢占式调度有个明显的优点，能够避免CPU资源持续被少数线程占用，从而使其他线程长时间处于饥饿状态。goroutine的调度器也用到了时间片算法，但是和操作系统的线程调度还是有些区别的，因为整个Go程序都是运行在用户态的，所以不能像操作系统那样利用时钟中断来打断运行中的goroutine。也得益于完全在用户态实现，goroutine的调度切换更加轻量。</p>
<p><strong>上面这两段文字只是对调度的一个概括，具体的协作式调度、信号量调度大家还需要去详细了解，这偏底层了，大厂或者中高级开发会问。（字节就问了）</strong></p>
<h3 id="M-和-P-的数量问题？"><a href="#M-和-P-的数量问题？" class="headerlink" title="M 和 P 的数量问题？"></a>M 和 P 的数量问题？</h3><p>p默认cpu内核数</p>
<p>M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来</p>
<p>【Go语言调度模型G、M、P的数量多少合适？】</p>
<p>详细参考这篇文章</p>
<p><a href="https://link.zhihu.com/?target=https://mbd.baidu.com/ma/s/ZMOKQATr">https://mbd.baidu.com/ma/s/ZMOKQATrmbd.baidu.com/ma/s/ZMOKQATr</a></p>
<p>GMP数量这一块，结论很好记，没用项目经验的话，问了项目中怎么用可能容易卡壳。</p>
<h2 id="锁相关"><a href="#锁相关" class="headerlink" title="锁相关"></a>锁相关</h2><h3 id="除了-mutex-以外还有那些方式安全读写共享变量？"><a href="#除了-mutex-以外还有那些方式安全读写共享变量？" class="headerlink" title="除了 mutex 以外还有那些方式安全读写共享变量？"></a>除了 mutex 以外还有那些方式安全读写共享变量？</h3><p>* 将共享变量的读写放到一个 goroutine 中，其它 goroutine 通过 channel 进行读写操作。</p>
<p>* 可以用个数为 1 的信号量（semaphore）实现互斥</p>
<p>* 通过 Mutex 锁实现</p>
<h3 id="Go-如何实现原子操作？"><a href="#Go-如何实现原子操作？" class="headerlink" title="Go 如何实现原子操作？"></a>Go 如何实现原子操作？</h3><p>答：原子操作就是不可中断的操作，外界是看不到原子操作的中间状态，要么看到原子操作已经完成，要么看到原子操作已经结束。在某个值的原子操作执行的过程中，CPU 绝对不会再去执行其他针对该值的操作，那么其他操作也是原子操作。</p>
<p>Go 语言的标准库代码包 sync&#x2F;atomic 提供了原子的读取（Load 为前缀的函数）或写入（Store 为前缀的函数）某个值（这里细节还要多去查查资料）。</p>
<p><strong>原子操作与互斥锁的区别</strong></p>
<p>1）、互斥锁是一种数据结构，用来让一个线程执行程序的关键部分，完成互斥的多个操作。</p>
<p>2）、原子操作是针对某个值的单个互斥操作。</p>
<h3 id="Mutex-是悲观锁还是乐观锁？悲观锁、乐观锁是什么？"><a href="#Mutex-是悲观锁还是乐观锁？悲观锁、乐观锁是什么？" class="headerlink" title="Mutex 是悲观锁还是乐观锁？悲观锁、乐观锁是什么？"></a>Mutex 是悲观锁还是乐观锁？悲观锁、乐观锁是什么？</h3><p><strong>悲观锁</strong></p>
<p>悲观锁：当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。</p>
<p><strong>乐观锁</strong></p>
<p>乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量</p>
<h3 id="Mutex-有几种模式？"><a href="#Mutex-有几种模式？" class="headerlink" title="Mutex 有几种模式？"></a>Mutex 有几种模式？</h3><p><strong>1）正常模式</strong></p>
<ol>
<li>当前的mutex只有一个goruntine来获取，那么没有竞争，直接返回。</li>
<li>新的goruntine进来，如果当前mutex已经被获取了，则该goruntine进入一个先入先出的waiter队列，在mutex被释放后，waiter按照先进先出的方式获取锁。该goruntine会处于自旋状态(不挂起，继续占有cpu)。</li>
<li>新的goruntine进来，mutex处于空闲状态，将参与竞争。新来的 goroutine 有先天的优势，它们正在 CPU 中运行，可能它们的数量还不少，所以，在高并发情况下，被唤醒的 waiter 可能比较悲剧地获取不到锁，这时，它会被插入到队列的前面。如果 waiter 获取不到锁的时间超过阈值 1 毫秒，那么，这个 Mutex 就进入到了饥饿模式。</li>
</ol>
<p><strong>2）饥饿模式</strong></p>
<p>在饥饿模式下，Mutex 的拥有者将直接把锁交给队列最前面的 waiter。新来的 goroutine 不会尝试获取锁，即使看起来锁没有被持有，它也不会去抢，也不会 spin（自旋），它会乖乖地加入到等待队列的尾部。 如果拥有 Mutex 的 waiter 发现下面两种情况的其中之一，它就会把这个 Mutex 转换成正常模式:</p>
<ol>
<li>此 waiter 已经是队列中的最后一个 waiter 了，没有其它的等待锁的 goroutine 了；</li>
<li>此 waiter 的等待时间小于 1 毫秒。</li>
</ol>
<h3 id="goroutine-的自旋占用资源如何解决"><a href="#goroutine-的自旋占用资源如何解决" class="headerlink" title="goroutine 的自旋占用资源如何解决"></a>goroutine 的自旋占用资源如何解决</h3><p>自旋锁是指当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断地判断是否能够被成功获取，直到获取到锁才会退出循环。</p>
<p><strong>自旋的条件如下：</strong></p>
<p>1）还没自旋超过 4 次,</p>
<p>2）多核处理器，</p>
<p>3）GOMAXPROCS &gt; 1，</p>
<p>4）p 上本地 goroutine 队列为空。</p>
<p>mutex 会让当前的 goroutine 去空转 CPU，在空转完后再次调用 CAS 方法去尝试性的占有锁资源，直到不满足自旋条件，则最终会加入到等待队列里。</p>
<h2 id="并发相关"><a href="#并发相关" class="headerlink" title="并发相关"></a><strong>并发相关</strong></h2><h3 id="怎么控制并发数？"><a href="#怎么控制并发数？" class="headerlink" title="怎么控制并发数？"></a>怎么控制并发数？</h3><p><strong>第一，有缓冲通道</strong></p>
<p>根据通道中没有数据时读取操作陷入阻塞和通道已满时继续写入操作陷入阻塞的特性，正好实现控制并发数量。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	count := 10 // 最大支持并发</span><br><span class="line">	sum := 100 // 任务总数</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125; //控制主协程等待所有子协程执行完之后再退出。</span><br><span class="line"></span><br><span class="line">	c := make(chan struct&#123;&#125;, count) // 控制任务并发的chan</span><br><span class="line">	defer close(c)</span><br><span class="line"></span><br><span class="line">	for i:=0; i&lt;sum;i++&#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		c &lt;- struct&#123;&#125;&#123;&#125; // 作用类似于waitgroup.Add(1)</span><br><span class="line">		go func(j int) &#123;</span><br><span class="line">			defer wg.Done()</span><br><span class="line">			fmt.Println(j)</span><br><span class="line">			&lt;- c // 执行完毕，释放资源</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二，三方库实现的协程池</strong></p>
<p>panjf2000&#x2F;ants（比较火）</p>
<p>Jeffail&#x2F;tunny</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line"></span><br><span class="line">	&quot;github.com/Jeffail/tunny&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">	pool := tunny.NewFunc(10, func(i interface&#123;&#125;) interface&#123;&#125; &#123;</span><br><span class="line">		log.Println(i)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		return nil</span><br><span class="line">	&#125;)</span><br><span class="line">	defer pool.Close()</span><br><span class="line"></span><br><span class="line">	for i := 0; i &lt; 500; i++ &#123;</span><br><span class="line">		go pool.Process(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second * 4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多个-goroutine-对同一个-map-写会-panic，异常是否可以用-defer-捕获？"><a href="#多个-goroutine-对同一个-map-写会-panic，异常是否可以用-defer-捕获？" class="headerlink" title="多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 捕获？"></a>多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 捕获？</h3><p>可以捕获异常，但是只能捕获一次，Go语言，可以使用多值返回来返回错误。不要用异常代替错误，更不要用来控制流程。在极个别的情况下，才使用Go中引入的Exception处理：defer, panic, recover Go中，对异常处理的原则是：多用error包，少用panic</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">defer func() &#123;</span><br><span class="line">		if err := recover(); err != nil &#123;</span><br><span class="line">			// 打印异常，关闭资源，退出此函数</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br></pre></td></tr></table></figure>

<h3 id="如何优雅的实现一个-goroutine-池"><a href="#如何优雅的实现一个-goroutine-池" class="headerlink" title="如何优雅的实现一个 goroutine 池"></a>如何优雅的实现一个 goroutine 池</h3><p>（百度、手写代码，本人面传音控股被问道：请求数大于消费能力怎么设计协程池）</p>
<p>这一块能啃下来，offer满天飞，这应该是保证高并发系统稳定性、高可用的核心部分之一。</p>
<p><strong>建议参考：</strong></p>
<p><strong>这篇文章的目录是：</strong></p>
<p>\1. 为什么需要协程池？</p>
<p>\2. 简单的协程池</p>
<p>\3. go-playground&#x2F;pool</p>
<p>\4. ants（推荐）</p>
<p><strong>所以直接研究ants底层吧，省的造轮子。</strong></p>
<h2 id="GC相关"><a href="#GC相关" class="headerlink" title="GC相关"></a><strong>GC相关</strong></h2><h3 id="go-gc-是怎么实现的？（必问）"><a href="#go-gc-是怎么实现的？（必问）" class="headerlink" title="go gc 是怎么实现的？（必问）"></a>go gc 是怎么实现的？（必问）</h3><p>答：</p>
<p><strong>细分常见的三个问题：1、GC机制随着golang版本变化如何变化的？2、三色标记法的流程？3、插入屏障、删除屏障，混合写屏障（具体的实现比较难描述，但你要知道屏障的作用：避免程序运行过程中，变量被误回收；减少STW的时间）4、虾皮还问了个开放性的题目：你觉得以后GC机制会怎么优化？</strong></p>
<p>Go 的 GC 回收有三次演进过程，Go V1.3 之前普通标记清除（mark and sweep）方法，整体过程需要启动 STW，效率极低。GoV1.5 三色标记法，堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要 STW)，效率普通。GoV1.8 三色标记法，混合写屏障机制：栈空间不启动（全部标记成黑色），堆空间启用写屏障，整个过程不要 STW，效率高。</p>
<p>Go1.3 之前的版本所谓标记清除是先启动 STW 暂停，然后执行标记，再执行数据回收，最后停止 STW。Go1.3 版本标记清除做了点优化，流程是：先启动 STW 暂停，然后执行标记，停止 STW，最后再执行数据回收。</p>
<p>Go1.5 三色标记主要是插入屏障和删除屏障，写入屏障的流程：程序开始，全部标记为白色，1）所有的对象放到白色集合，2）遍历一次根节点，得到灰色节点，3）遍历灰色节点，将可达的对象，从白色标记灰色，遍历之后的灰色标记成黑色，4）由于并发特性，此刻外界向在堆中的对象发生添加对象，以及在栈中的对象添加对象，在堆中的对象会触发插入屏障机制，栈中的对象不触发，5）由于堆中对象插入屏障，则会把堆中黑色对象添加的白色对象改成灰色，栈中的黑色对象添加的白色对象依然是白色，6）循环第 5 步，直到没有灰色节点，7）在准备回收白色前，重新遍历扫描一次栈空间，加上 STW 暂停保护栈，防止外界干扰（有新的白色会被添加成黑色）在 STW 中，将栈中的对象一次三色标记，直到没有灰色，8）停止 STW，清除白色。至于删除写屏障，则是遍历灰色节点的时候出现可达的节点被删除，这个时候触发删除写屏障，这个可达的被删除的节点也是灰色，等循环三色标记之后，直到没有灰色节点，然后清理白色，删除写屏障会造成一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮 GC 中被清理掉。</p>
<p>GoV1.8 混合写屏障规则是：</p>
<p>1）GC 开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需 STW)，2）GC 期间，任何在栈上创建的新对象，均为黑色。3）被删除的对象标记为灰色。4）被添加的对象标记为灰色。</p>
<h3 id="go-是-gc-算法是怎么实现的？-（得物，出现频率低）"><a href="#go-是-gc-算法是怎么实现的？-（得物，出现频率低）" class="headerlink" title="go 是 gc 算法是怎么实现的？ （得物，出现频率低）"></a>go 是 gc 算法是怎么实现的？ （得物，出现频率低）</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func GC() &#123;</span><br><span class="line">	n := atomic.Load(&amp;amp;work.cycles)</span><br><span class="line">	gcWaitOnMark(n)</span><br><span class="line"></span><br><span class="line">	gcStart(gcTrigger&#123;kind: gcTriggerCycle, n: n + 1&#125;)</span><br><span class="line">	gcWaitOnMark(n + 1)</span><br><span class="line"></span><br><span class="line">	for atomic.Load(&amp;amp;work.cycles) == n+1 &amp;amp;&amp;amp; sweepone() != ^uintptr(0) &#123;</span><br><span class="line">		sweep.nbgsweep++</span><br><span class="line">		Gosched()</span><br><span class="line">	&#125;</span><br><span class="line">	for atomic.Load(&amp;amp;work.cycles) == n+1 &amp;amp;&amp;amp; atomic.Load(&amp;amp;mheap_.sweepers) != 0 &#123;</span><br><span class="line">		Gosched()</span><br><span class="line">	&#125;</span><br><span class="line">	mp := acquirem()</span><br><span class="line">	cycle := atomic.Load(&amp;amp;work.cycles)</span><br><span class="line">	if cycle == n+1 || (gcphase == _GCmark &amp;amp;&amp;amp; cycle == n+2) &#123;</span><br><span class="line">		mProf_PostSweep()</span><br><span class="line">	&#125;</span><br><span class="line">	releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层原理了，可能大厂，中高级才会问，参考：</p>
<h3 id="GC-中-stw-时机，各个阶段是如何解决的？-（百度）"><a href="#GC-中-stw-时机，各个阶段是如何解决的？-（百度）" class="headerlink" title="GC 中 stw 时机，各个阶段是如何解决的？ （百度）"></a>GC 中 stw 时机，各个阶段是如何解决的？ （百度）</h3><p><strong>底层原理，自行百度一下，我等渣渣简历都过不了BAT，字节，虾皮，特使拉以及一些国Q还能收到面试邀约</strong>。</p>
<p>1）在开始新的一轮 GC 周期前，需要调用 gcWaitOnMark 方法上一轮 GC 的标记结束（含扫描终止、标记、或标记终止等）。</p>
<p>2）开始新的一轮 GC 周期，调用 gcStart 方法触发 GC 行为，开始扫描标记阶段。</p>
<p>3）需要调用 gcWaitOnMark 方法等待，直到当前 GC 周期的扫描、标记、标记终止完成。</p>
<p>4）需要调用 sweepone 方法，扫描未扫除的堆跨度，并持续扫除，保证清理完成。在等待扫除完毕前的阻塞时间，会调用 Gosched 让出。</p>
<p>5）在本轮 GC 已经基本完成后，会调用 mProf_PostSweep 方法。以此记录最后一次标记终止时的堆配置文件快照。</p>
<p>6）结束，释放 M。</p>
<h3 id="GC-的触发时机？"><a href="#GC-的触发时机？" class="headerlink" title="GC 的触发时机？"></a>GC 的触发时机？</h3><p>初级必问，分为系统触发和主动触发。</p>
<p>1）gcTriggerHeap：当所分配的堆大小达到阈值（由控制器计算的触发堆的大小）时，将会触发。</p>
<p>2）gcTriggerTime：当距离上一个 GC 周期的时间超过一定时间时，将会触发。时间周期以runtime.forcegcperiod 变量为准，默认 2 分钟。</p>
<p>3）gcTriggerCycle：如果没有开启 GC，则启动 GC。</p>
<p>4）手动触发的 runtime.GC 方法。</p>
<h2 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a><strong>内存相关</strong></h2><h3 id="谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？"><a href="#谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？" class="headerlink" title="谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？"></a>谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？</h3><p>答：go 中的内存泄漏一般都是 goroutine 泄漏，就是 goroutine 没有被关闭，或者没有添加超时控制，让 goroutine 一只处于阻塞状态，不能被 GC。</p>
<p><strong>内存泄露有下面一些情况</strong></p>
<p>1）如果 goroutine 在执行时被阻塞而无法退出，就会导致 goroutine 的内存泄漏，一个 goroutine 的最低栈大小为 2KB，在高并发的场景下，对内存的消耗也是非常恐怖的。</p>
<p>2）互斥锁未释放或者造成死锁会造成内存泄漏</p>
<p>3）time.Ticker 是每隔指定的时间就会向通道内写数据。作为循环触发器，必须调用 stop 方法才会停止，从而被 GC 掉，否则会一直占用内存空间。</p>
<p>4）字符串的截取引发临时性的内存泄漏</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	var str0 = &quot;12345678901234567890&quot;</span><br><span class="line">	str1 := str0[:10]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5）切片截取引起子切片内存泄漏</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	var s0 = []int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br><span class="line">	s1 := s0[:3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6）函数数组传参引发内存泄漏【如果我们在函数传参的时候用到了数组传参，且这个数组够大（我们假设数组大小为 100 万，64 位机上消耗的内存约为 800w 字节，即 8MB 内存），或者该函数短时间内被调用 N 次，那么可想而知，会消耗大量内存，对性能产生极大的影响，如果短时间内分配大量内存，而又来不及 GC，那么就会产生临时性的内存泄漏，对于高并发场景相当可怕。】</p>
<p><strong>排查方式：</strong></p>
<p>一般通过 pprof 是 Go 的性能分析工具，在程序运行过程中，可以记录程序的运行信息，可以是 CPU 使用情况、内存使用情况、goroutine 运行情况等，当需要性能调优或者定位 Bug 时候，这些记录的信息是相当重要。</p>
<p><strong>当然你能说说具体的分析指标更加分咯，有的面试官就喜欢他问什么，你简洁的回答什么，不喜欢巴拉巴拉详细解释一通，比如虾P面试官，不过他考察的内容特别多，可能是为了节约时间。</strong></p>
<h3 id="知道-golang-的内存逃逸吗？什么情况下会发生内存逃逸？（必问）"><a href="#知道-golang-的内存逃逸吗？什么情况下会发生内存逃逸？（必问）" class="headerlink" title="知道 golang 的内存逃逸吗？什么情况下会发生内存逃逸？（必问）"></a>知道 golang 的内存逃逸吗？什么情况下会发生内存逃逸？（必问）</h3><p>答：1)本该分配到栈上的变量，跑到了堆上，这就导致了内存逃逸。2)栈是高地址到低地址，栈上的变量，函数结束后变量会跟着回收掉，不会有额外性能的开销。3)变量从栈逃逸到堆上，如果要回收掉，需要进行 gc，那么 gc 一定会带来额外的性能开销。编程语言不断优化 gc 算法，主要目的都是为了减少 gc 带来的额外性能开销，变量一旦逃逸会导致性能开销变大。</p>
<p><strong>内存逃逸的情况如下：</strong></p>
<p>1）方法内返回局部变量指针。</p>
<p>2）向 channel 发送指针数据。</p>
<p>3）在闭包中引用包外的值。</p>
<p>4）在 slice 或 map 中存储指针。</p>
<p>5）切片（扩容后）长度太大。</p>
<p>6）在 interface 类型上调用方法。</p>
<h3 id="请简述-Go-是如何分配内存的？"><a href="#请简述-Go-是如何分配内存的？" class="headerlink" title="请简述 Go 是如何分配内存的？"></a>请简述 Go 是如何分配内存的？</h3><p>mcache mcentral mheap mspan</p>
<p>Go 程序启动的时候申请一大块内存，并且划分 spans，bitmap，areana 区域；arena 区域按照页划分成一个个小块，span 管理一个或者多个页，mcentral 管理多个 span 供现场申请使用；mcache 作为线程私有资源，来源于 mcentral。</p>
<p><strong>这里描述的比较简单，你可以自己再去搜索下更简洁完整的答案。</strong></p>
<h3 id="Channel-分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？"><a href="#Channel-分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？" class="headerlink" title="Channel 分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？"></a>Channel 分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？</h3><p>Channel 被设计用来实现协程间通信的组件，其作用域和生命周期不可能仅限于某个函数内部，所以 golang 直接将其分配在堆上</p>
<p>准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。</p>
<p>知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。然而，如果编译器不能确保变量在函数 return 之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。</p>
<p>当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上,然而，还要对这些变量做逃逸分析，如果函数 return 之后，变量不再被引用，则将其分配到栈上。</p>
<h3 id="介绍一下大对象小对象，为什么小对象多了会造成-gc-压力？"><a href="#介绍一下大对象小对象，为什么小对象多了会造成-gc-压力？" class="headerlink" title="介绍一下大对象小对象，为什么小对象多了会造成 gc 压力？"></a>介绍一下大对象小对象，为什么小对象多了会造成 gc 压力？</h3><p>小于等于 32k 的对象就是小对象，其它都是大对象。一般小对象通过 mspan 分配内存；大对象则直接由 mheap 分配内存。通常小对象过多会导致 GC 三色法消耗过多的 CPU。优化思路是，减少对象分配。</p>
<p>小对象：如果申请小对象时，发现当前内存空间不存在空闲跨度时，将会需要调用 nextFree 方法获取新的可用的对象，可能会触发 GC 行为。</p>
<p>大对象：如果申请大于 32k 以上的大对象时，可能会触发 GC 行为。</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="Go-多返回值怎么实现的？"><a href="#Go-多返回值怎么实现的？" class="headerlink" title="Go 多返回值怎么实现的？"></a>Go 多返回值怎么实现的？</h3><p>答：Go 传参和返回值是通过 FP+offset 实现，并且存储在调用函数的栈帧中。FP 栈底寄存器，指向一个函数栈的顶部;PC 程序计数器，指向下一条执行指令;SB 指向静态数据的基指针，全局符号;SP 栈顶寄存器。</p>
<h3 id="讲讲-Go-中主协程如何等待其余协程退出"><a href="#讲讲-Go-中主协程如何等待其余协程退出" class="headerlink" title="讲讲 Go 中主协程如何等待其余协程退出?"></a>讲讲 Go 中主协程如何等待其余协程退出?</h3><p>答：Go 的 sync.WaitGroup 是等待一组协程结束，sync.WaitGroup 只有 3 个方法，Add()是添加计数，Done()减去一个计数，Wait()阻塞直到所有的任务完成。Go 里面还能通过有缓冲的 channel 实现其阻塞等待一组协程结束，这个不能保证一组 goroutine 按照顺序执行，可以并发执行协程。Go 里面能通过无缓冲的 channel 实现其阻塞等待一组协程结束，这个能保证一组 goroutine 按照顺序执行，但是不能并发执行。</p>
<p><strong>啰嗦一句：</strong>循环智能二面，手写代码部分时，三个协程按交替顺序打印数字，最后题目做出来了，问我代码中Add()是什么意思，我回答的不是很清晰，这家公司就没有然后了。Add()表示协程计数，可以一次Add多个，如Add(3),可以多次Add(1);然后每个子协程必须调用done（）,这样才能保证所有子协程结束，主协程才能结束。</p>
<h3 id="Go-语言中不同的类型如何比较是否相等？"><a href="#Go-语言中不同的类型如何比较是否相等？" class="headerlink" title="Go 语言中不同的类型如何比较是否相等？"></a>Go 语言中不同的类型如何比较是否相等？</h3><p>答：像 string，int，float interface 等可以通过 reflect.DeepEqual 和等于号进行比较，像 slice，struct，map 则一般使用 reflect.DeepEqual 来检测是否相等。</p>
<h3 id="Go-中-init-函数的特征"><a href="#Go-中-init-函数的特征" class="headerlink" title="Go 中 init 函数的特征?"></a>Go 中 init 函数的特征?</h3><p>答：一个包下可以有多个 init 函数，每个文件也可以有多个 init 函数。多个 init 函数按照它们的文件名顺序逐个初始化。应用初始化时初始化工作的顺序是，从被导入的最深层包开始进行初始化，层层递出最后到 main 包。不管包被导入多少次，包内的 init 函数只会执行一次。应用初始化时初始化工作的顺序是，从被导入的最深层包开始进行初始化，层层递出最后到 main 包。但包级别变量的初始化先于包内 init 函数的执行。</p>
<h3 id="Go-中-uintptr-和-unsafe-Pointer-的区别？"><a href="#Go-中-uintptr-和-unsafe-Pointer-的区别？" class="headerlink" title="Go 中 uintptr 和 unsafe.Pointer 的区别？"></a>Go 中 uintptr 和 unsafe.Pointer 的区别？</h3><p>答：unsafe.Pointer 是通用指针类型，它不能参与计算，任何类型的指针都可以转化成 unsafe.Pointer，unsafe.Pointer 可以转化成任何类型的指针，uintptr 可以转换为 unsafe.Pointer，unsafe.Pointer 可以转换为 uintptr。uintptr 是指针运算的工具，但是它不能持有指针对象（意思就是它跟指针对象不能互相转换），unsafe.Pointer 是指针对象进行运算（也就是 uintptr）的桥梁。</p>
<h3 id="golang共享内存（互斥锁）方法实现发送多个get请求"><a href="#golang共享内存（互斥锁）方法实现发送多个get请求" class="headerlink" title="golang共享内存（互斥锁）方法实现发送多个get请求"></a>golang共享内存（互斥锁）方法实现发送多个get请求</h3><p>待补充</p>
<h3 id="从数组中取一个相同大小的slice有成本吗？"><a href="#从数组中取一个相同大小的slice有成本吗？" class="headerlink" title="从数组中取一个相同大小的slice有成本吗？"></a>从数组中取一个相同大小的slice有成本吗？</h3><p>或者这么问：从切片中取一个相同大小的数组有成本吗？</p>
<p>这是爱立信的二面题目，这个问题我至今还没搞懂，不知道从什么切入点去分析，欢迎指教。</p>
<p>PS：爱立信面试都要英文自我介绍，以及问答，如果英文回答不上来，会直接切换成中文。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/01/14/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E8%AF%AD%E8%A8%80%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/14/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E8%AF%AD%E8%A8%80%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">Go语言面经</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-14 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-14T00:00:00+08:00">2022-01-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-09 10:01:34" itemprop="dateModified" datetime="2023-11-09T10:01:34+08:00">2023-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index">
                    <span itemprop="name">GO基础知识</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="进程、线程、协程的区别"><a href="#进程、线程、协程的区别" class="headerlink" title="进程、线程、协程的区别"></a>进程、线程、协程的区别</h1><p><strong>进程：</strong>就是二进制可执行文件在计算机内存中的运行实例，<strong>进程是操作系统最小的资源分配单位</strong>，拥有独立的内存空间和系统资源，为了方便管理，每个进程都有自己的描述符，我们称之为<strong>进程控制块</strong>，即PCB，进程分类：</p>
<ul>
<li><strong>用户进程：位于用户空间中，是程序执行的实例</strong></li>
<li><strong>内核进程：位于内核空间中，可以访问硬件</strong></li>
</ul>
<p>进程在创建后，在执行过程中，其状态一直在变化。分别是：<strong>初始态、就绪态、运行态、挂起态（阻塞）、终止态</strong></p>
<p><strong>线程：线程是操作系统最小的调度执行单位</strong>，线程不能独立于进程而存在，其生命周期不可能逾越其所属的进程生命周期，<strong>线程与进程一样拥有独立的PCB，但是没有独立的地址空间，即线程之间共享了地址空间，直接就能通信！！</strong>进程的<strong>大多数资源会被其内部的线程所共享。</strong></p>
<p><strong>协程：</strong>程与进程、线程相比并不是一个维度的概念，协程不是被操作系统内核所管理的，而是<strong>完全由程序所控制，也就是在用户态执行</strong>。由程序员显式地定义和控制，可以在执行过程中暂停和恢复。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。   </p>
<p>优点：</p>
<ul>
<li>占用小：<strong>协程更加轻量，创建成本更小，降低了内存消耗</strong>，协程一般只占据极小的内存（2~5KB），而线程是1MB左右。虽然线程和协程都是独有栈，但是线程栈是固定的，比如在Java中，基本是2M，假如一个栈只有一个打印方法，还要为此开辟一个2M的栈，就太浪费了。而<strong>Go的的协程具备动态收缩功能</strong>，初始化为2KB，最大可达1GB</li>
<li><strong>运行效率高：</strong>线程切换需要从用户态-&gt;内核态-&gt;用户态，而协程切换是在用户态上，即用户态-&gt;用户态-&gt;用户态，其切换过程由语言层面的调度器（coroutine）或者语言引擎（goroutine）实现。</li>
<li>减少了同步锁：协程最终还是运行在线程上，本质上还是单线程运行，没有临界区域的话自然不需要锁的机制。<strong>多协程自然没有竞争关系</strong>。但是，如果存在临界区域，依然需要使用锁，<strong>协程可以减少以往必须使用锁的场景</strong></li>
</ul>
<p>缺点：</p>
<ul>
<li>无法利用多核资源：协程运行在线程上，单线程应用无法很好的利用多核，只能以多进程方式启动。</li>
<li><strong>协程不能有阻塞操作</strong>：线程是抢占式，线程在遇见IO操作时候，线程从运行态→阻塞态，释放cpu使用权。这是由操作系统调度。<strong>协程是非抢占式，如果遇见IO操作时候，协程是主动释放执行权限的，如果无法主动释放，程序将阻塞，无法往下执行，随之而来是整个线程被阻塞。</strong></li>
<li>CPU密集型不是长处：假设这个线程中有一个协程是 CPU 密集型的他没有 IO 操作，也就是自己不会主动触发调度器调度的过程，那么就会出现其他协程得不到执行的情况，所以这种情况下需要程序员自己避免。</li>
</ul>
<h1 id="Golang协程间如何通信"><a href="#Golang协程间如何通信" class="headerlink" title="Golang协程间如何通信"></a>Golang协程间如何通信</h1><p>Go推荐使用通道（channel）的方式解决数据传递问题，在多个goroutine之间，channel负责传递数据，还能保证整个过程的并发安全性。  </p>
<h1 id="GMP模型-Go协程调度模型"><a href="#GMP模型-Go协程调度模型" class="headerlink" title="GMP模型(Go协程调度模型)"></a>GMP模型(Go协程调度模型)</h1><p>每个G的执行需要P和M的支持，M与P关联后才会形成一个有效的G运行环境，即 <code>工作线程+上下文环境</code>。  </p>
<p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/image-20230530155013217.png" alt="image-20230530155013217"> </p>
<ul>
<li>G：goroutine，一个G代表一个Go协程</li>
<li>M：machine，一个M代表一个工作线程，runtime&#x2F;debug 中的 <strong>SetMaxThreads</strong> 函数，设置 M 的最大数量</li>
<li>P：processor，一个P代表执行一个Go代码段需要的上下文环境，由<strong>启动时环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS()</strong> 决定</li>
</ul>
<blockquote>
<p>M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。</p>
</blockquote>
<p><strong>go func () 调度流程</strong>：</p>
<p> 1、我们通过 go func () 来创建一个 goroutine；</p>
<p> 2、有两个存储 G 的队列，一个是局部调度器 P 的本地队列、一个是全局 G 队列。新创建的 G 会先保存在 P 的本地队列中，如果 P 的本地队列已经满了就会保存在全局的队列中；（所有的 M 都可以从全局队列中拉取 G 来执行）</p>
<p> 3、G 只能运行在 M 中，一个 M 必须持有一个 P，M 和 P 存在一一绑定的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，则  M 从全局队列中拉取；如果全局队列也为空，则从其他的 P 中拉取 G</p>
<p> 4、一个 M 调度 G 执行的过程是一个循环机制；</p>
<p> 5、当 M 执行某一个 G 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime  会把这个线程 M 从 P 中摘除 (detach)，然后再创建一个新的操作系统的线程 (如果有空闲的线程可用就复用空闲线程) 来服务于这个 P；</p>
<p> 6、当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中。</p>
<h1 id="Golang-Map底层"><a href="#Golang-Map底层" class="headerlink" title="Golang Map底层"></a>Golang Map底层</h1><p>Map的底层实现是由哈希表（Hash Table）实现的。</p>
<p>哈希表是一种基于哈希函数的数据结构，它将键映射到存储位置，从而实现快速的查找。在Go语言中，Map的底层结构是一个哈希表数组，每个元素称为桶（Bucket）。每个桶存储着一个或多个键值对。</p>
<p>下面是Map底层的几个关键点：</p>
<ol>
<li>哈希函数：Map使用哈希函数将键转换为一个索引，用于确定键值对在哈希表数组中的存储位置。哈希函数应该具有良好的散列性，以减少冲突的发生。</li>
<li>桶（Bucket）：Map底层的哈希表数组由多个桶组成，每个桶存储着一个或多个键值对。当多个键映射到同一个索引位置时，它们会被存储在同一个桶中，形成一个链表或其他数据结构。</li>
<li>冲突解决：由于哈希函数的有限性，可能会发生不同的键映射到相同的索引位置，这就是哈希冲突。Map使用链表或其他冲突解决方法来处理冲突，确保所有键值对都能正确存储和访问。</li>
<li>动态调整大小：Map具有自动扩容和收缩的能力，以适应键值对的增加或减少。当Map中的键值对数量达到一定阈值时，Map会自动进行扩容，重新分配更大的哈希表数组。反之，如果键值对数量减少到一定程度，Map会自动进行收缩，释放不必要的内存。</li>
</ol>
<p>总结来说，Go语言中的Map底层使用哈希表实现，通过哈希函数将键映射到存储位置，解决键值对的查找、插入和删除操作。哈希冲突通过链表等冲突解决方法来处理。同时，Map具有动态调整大小的能力，以适应键值对的变化。这种底层实现使得Map在大多数情况下能够提供高效的性能和常数时间复杂度的操作。</p>
<h1 id="如何实现Map的有序查找"><a href="#如何实现Map的有序查找" class="headerlink" title="如何实现Map的有序查找"></a>如何实现Map的有序查找</h1><p>一种常见的方法是使用有序的数据结构，如切片（Slice）或平衡二叉树（Balanced Binary Tree）来维护键值对的有序性。</p>
<p>使用切片（Slice）：可以将Map的键值对复制到一个切片中，并按照键的顺序排序切片。然后，可以使用二分查找算法在有序的切片中进行查找操作</p>
<p>使用平衡二叉树（如红黑树）：将Map的键作为树节点的关键字，值作为节点的值，构建一颗平衡二叉树。可以使用平衡二叉树的查找操作来实现有序查找。</p>
<h1 id="sync包-sync包提供了基本的同步基元"><a href="#sync包-sync包提供了基本的同步基元" class="headerlink" title="sync包(sync包提供了基本的同步基元)"></a>sync包(sync包提供了基本的同步基元)</h1><h4 id="互斥锁-sync-Mutex"><a href="#互斥锁-sync-Mutex" class="headerlink" title="互斥锁 sync.Mutex"></a>互斥锁 sync.Mutex</h4><p><strong>互斥锁</strong>是传统并发程序进行共享资源访问控制的主要方法。Go中由结构体<code>sync.Mutex</code>表示互斥锁，<strong>保证同时只有一个 goroutine 可以访问共享资源</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock()</span><br></pre></td></tr></table></figure>

<h4 id="读写锁-sync-RWMutex"><a href="#读写锁-sync-RWMutex" class="headerlink" title="读写锁 sync.RWMutex"></a>读写锁 sync.RWMutex</h4><p>在开发场景中，经常遇到多处并发读取，一次并发写入的情况，Go为了方便这些操作，<strong>在互斥锁基础上，提供了读写锁操作</strong>。  读写锁即针对读写操作的互斥锁，简单来说，就是将数据设定为 写模式（只写）或者读模式（只读）。使用读写锁可以分别针对读操作和写操作进行锁定和解锁操作。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rwm sync.RWMutex</span><br><span class="line"><span class="comment">// 设定为写模式：与互斥锁使用方式一致，一路只写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span></span> Lock()				<span class="comment">// 锁定写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span></span> Unlock()			<span class="comment">// 解锁写</span></span><br><span class="line"><span class="comment">// 设定为读模式：对读执行加锁解锁，即多路只读</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span></span> RLock()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span></span> RUnlock()</span><br><span class="line"><span class="comment">//返回值Locker是实现了接口`sync.Lokcer`的值，该接口同样被 `*sync.Mutex`和`*sync.RWMutex`实现，包含方法：`Lock`和`Unlock`。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLocker() Locker</span><br></pre></td></tr></table></figure>

<h4 id="等待组-sync-WaitGroup"><a href="#等待组-sync-WaitGroup" class="headerlink" title="等待组 sync.WaitGroup"></a>等待组 sync.WaitGroup</h4><p><code>sync.WaitGroup</code>类型的值也是并发安全的，该类型结构体中<strong>内部拥有一个计数器</strong>，计数器的值可以通过方法调用实现计数器的增加和减少 。  </p>
<p>当我们<strong>添加了 N 个并发任务进行工作时，就将等待组的计数器值增加 N。每个任务完成时，这个值减1</strong>。 同时，在另外一个 goroutine 中等待这个等待组的计数器值为 0 时， 表示所有任务己经完成。  </p>
<p>等待组常用方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Add方法向内部计数加上delta，delta可以是负数；如果内部计数器变为0，切记不能减少为负数，会引发崩溃</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Add(delta <span class="type">int</span>)</span><br><span class="line"><span class="comment">//Done方法减少WaitGroup计数器的值，应在线程的最后执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Done()</span><br><span class="line"><span class="comment">//Wait方法阻塞直到WaitGroup计数器减为0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait()</span><br></pre></td></tr></table></figure>

<h4 id="条件变量-sync-Cond"><a href="#条件变量-sync-Cond" class="headerlink" title="条件变量 sync.Cond"></a>条件变量 sync.Cond</h4><p>条件变量通常与锁配合使用： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l locker)</span></span> *Cond        <span class="comment">// 条件变量必须传入一个锁，二者需要配合使用</span></span><br></pre></td></tr></table></figure>

<p><code>*sync.Cond</code>类型有三个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Broadcast唤醒所有等待c的线程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast()</span><br><span class="line"><span class="comment">//Signal唤醒等待c的一个线程（如果存在）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal()</span><br><span class="line"><span class="comment">//该方法会阻塞等待条件变量满足条件。也会对锁进行解锁，一旦收到通知则唤醒，并立即锁定该锁</span></span><br><span class="line"><span class="comment">//Wait自行解锁c.L并阻塞当前线程，在之后线程恢复执行时，Wait方法会在返回前锁定c.L。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait()</span><br></pre></td></tr></table></figure>

<h4 id="Once-只执行一次"><a href="#Once-只执行一次" class="headerlink" title="Once 只执行一次"></a>Once 只执行一次</h4><p><code>sync.Once</code>，负责只执行一次，也即全局唯一操作。  使用方式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;&#125;)           <span class="comment">// Do方法的有效调用次数永远是1</span></span><br></pre></td></tr></table></figure>

<p><code>sync.Once</code>的典型应用场景是只执行一次的任务，如果这样的任务不适合在init函数中执行，该结构体类就会派上用场。  </p>
<p>sync.Once内部使用了“卫述语句、双重检查锁定、共享标记的原子操作”来实现<code>Once</code>功能。</p>
<h4 id="对象池-sync-Pool"><a href="#对象池-sync-Pool" class="headerlink" title="对象池 sync.Pool"></a>对象池 sync.Pool</h4><p><code>sync.Pool</code>可以作为临时值的容器，该容器具备自动伸缩、高效特性，同时也是并发安全的，其方法有：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Get() <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Put(x <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果池子从未Put过，其New字段也没有被赋值一个非nil值，那么Get方法返回结果一定是nil。  </li>
<li>Get获取的值不一定存在于池中，如果Get到的值存在于池中，则该值Get后会被删除</li>
</ul>
<h4 id="原子操作-sync-atomic"><a href="#原子操作-sync-atomic" class="headerlink" title="原子操作 sync&#x2F;atomic"></a>原子操作 sync&#x2F;atomic</h4><p>这些函数可以对一些数据类型进行原子操作这些函数提供的原子操作有5种：增、减、比较并交换、载入、存储、交换。  </p>
<h5 id="原子运算：增-减"><a href="#原子运算：增-减" class="headerlink" title="原子运算：增&#x2F;减"></a>原子运算：增&#x2F;减</h5><p>增加函数的函数名前缀都是Add开头</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子性的把一个int32类型变量 i32 增大3 ，下列函数返回值必定是已经被修改的值</span></span><br><span class="line">newi32 := atomic.AddInt32(&amp;i32, <span class="number">3</span>)      <span class="comment">// 传入指针类型因为该函数需要获得数据的内存位置，以施加特殊的CPU指令</span></span><br></pre></td></tr></table></figure>

<p>常见的增&#x2F;减原子操作函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt32</span><span class="params">(addr *<span class="type">int32</span>, delta <span class="type">int32</span>)</span></span> (<span class="built_in">new</span> <span class="type">int32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt64</span><span class="params">(addr *<span class="type">int64</span>, delta <span class="type">int64</span>)</span></span> (<span class="built_in">new</span> <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint32</span><span class="params">(addr *<span class="type">uint32</span>, delta <span class="type">uint32</span>)</span></span> (<span class="built_in">new</span> <span class="type">uint32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint64</span><span class="params">(addr *<span class="type">uint64</span>, delta <span class="type">uint64</span>)</span></span> (<span class="built_in">new</span> <span class="type">uint64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, delta <span class="type">uintptr</span>)</span></span> (<span class="built_in">new</span> <span class="type">uintptr</span>)</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<ul>
<li>如果需要执行减少操作，可以这样书写 atomic.AddInt32(&amp;i32, -3)</li>
<li>对uint32执行增加NN（代表负整数，增加NN也可以理解为减少-NN）：atomic.AddUint32(&amp;ui32, ^uint32(-NN-1)) </li>
<li>不存在atomic.AddPointer的函数，因为unsafe.Poniter类型的值无法被增减</li>
</ul>
<h5 id="原子运算：比较与替换"><a href="#原子运算：比较与替换" class="headerlink" title="原子运算：比较与替换"></a>原子运算：比较与替换</h5><p>比较并替换即“Compare And Swap”，简称CAS。该类原子操作名称都以<code>CompareAndSwap</code>为前缀。   </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数一：被操作数 参数二和参数三代表被操作数的旧值和新值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt32</span><span class="params">(addr *<span class="type">int32</span>, old, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt64</span><span class="params">(addr *<span class="type">int64</span>, old, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint32</span><span class="params">(addr *<span class="type">uint32</span>, old, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint64</span><span class="params">(addr *<span class="type">uint64</span>, old, <span class="built_in">new</span> <span class="type">uint64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, old, <span class="built_in">new</span> <span class="type">uintptr</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapPointer</span><span class="params">(addr *unsafe.Pointer, old, <span class="built_in">new</span> unsafe.Pointer)</span></span> (swapped <span class="type">bool</span>)</span><br></pre></td></tr></table></figure>

<p>CAS的一些特点：</p>
<ul>
<li>CAS与锁相比，明显不同是它总是假设操作值未被改变，一旦确认这个假设为真，立即进行替换。所以锁的做法趋于悲观，CAS的做法趋于乐观。  </li>
<li>CAS的优势：可以在不创建互斥量和不形成临界区的情况下，完成并发安全的值替换操作，可以大大减少性能损耗。  </li>
<li>CAS的劣势：在被操作之被频繁变更的情况下，CAS操作容易失败，有时候需要for循环判断返回结构的bool来进行多次尝试 </li>
<li>CAS操作不会阻塞协程，但是仍可能使流程执行暂时停滞（这种停滞极短）</li>
</ul>
<p>应用场景：并发安全的更新一些类型的值，可以优先选择CAS操作。  </p>
<h5 id="原子读取：载入"><a href="#原子读取：载入" class="headerlink" title="原子读取：载入"></a>原子读取：载入</h5><p>为了原子的读取数值，Go提供了一系列载入函数，名称以<code>Load</code>为前缀。   </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt32</span><span class="params">(addr *<span class="type">int32</span>)</span></span> (val <span class="type">int32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt64</span><span class="params">(addr *<span class="type">int64</span>)</span></span> (val <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint32</span><span class="params">(addr *<span class="type">uint32</span>)</span></span> (val <span class="type">uint32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint64</span><span class="params">(addr *<span class="type">uint64</span>)</span></span> (val <span class="type">uint64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUintptr</span><span class="params">(addr *<span class="type">uintptr</span>)</span></span> (val <span class="type">uintptr</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadPointer</span><span class="params">(addr *unsafe.Pointer)</span></span> (val unsafe.Pointer)</span><br></pre></td></tr></table></figure>

<p>CAS与载入的配合示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value 增加 num</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addValue</span><span class="params">(value,num <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        v := atomic.LoadInt32(&amp;value)</span><br><span class="line">        <span class="keyword">if</span> atomic.ComapreAndSwapInt32(&amp;value, v, (v + num)) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="原子写入：存储"><a href="#原子写入：存储" class="headerlink" title="原子写入：存储"></a>原子写入：存储</h5><p>在原子存储时，任何CPU都不会进行针对同一个值的读写操作，此时不会出现并发时候，别人读取到了修改了一半的值。</p>
<p>Go的<code>sync/atomic</code>包提供的存储函数都是以<code>Store</code>为前缀。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt32</span><span class="params">(addr *<span class="type">int32</span>, val <span class="type">int32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt64</span><span class="params">(addr *<span class="type">int64</span>, val <span class="type">int64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint32</span><span class="params">(addr *<span class="type">uint32</span>, val <span class="type">uint32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint64</span><span class="params">(addr *<span class="type">uint64</span>, val <span class="type">uint64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, val <span class="type">uintptr</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StorePointer</span><span class="params">(addr *unsafe.Pointer, val unsafe.Pointer)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数一为被操作数据的指针 参数二是要存储的新值</span></span><br><span class="line">atomic.StoreInt32(i *int3, v <span class="type">int32</span>)     </span><br></pre></td></tr></table></figure>

<p>Go原子存储的特点：存储操作总会成功，因为不关心被操作值的旧值是什么，这与CAS有明显区别。  </p>
<h5 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h5><p>交换与CAS操作相似，但是交换不关心被操作数据的旧值，而是直接设置新值，不过会返回被操作值的旧值。交换操作比CAS操作的约束更少，且比载入操作功能更强。 在Go中，交换操作都以<code>Swap</code>为前缀，示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt32</span><span class="params">(addr *<span class="type">int32</span>, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> (old <span class="type">int32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt64</span><span class="params">(addr *<span class="type">int64</span>, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (old <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUint32</span><span class="params">(addr *<span class="type">uint32</span>, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> (old <span class="type">uint32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUint64</span><span class="params">(addr *<span class="type">uint64</span>, <span class="built_in">new</span> <span class="type">uint64</span>)</span></span> (old <span class="type">uint64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, <span class="built_in">new</span> <span class="type">uintptr</span>)</span></span> (old <span class="type">uintptr</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapPointer</span><span class="params">(addr *unsafe.Pointer, <span class="built_in">new</span> unsafe.Pointer)</span></span> (old unsafe.Pointer)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数一是被操作值指针  参数二是新值  返回值为旧值</span></span><br><span class="line">atomic.SwapInt32(i *<span class="type">int32</span>, v <span class="type">int32</span>)         </span><br></pre></td></tr></table></figure>

<h1 id="怎么实现Map的并发安全-sync-Map，底层实际上用了一个Map缓存"><a href="#怎么实现Map的并发安全-sync-Map，底层实际上用了一个Map缓存" class="headerlink" title="怎么实现Map的并发安全(sync.Map，底层实际上用了一个Map缓存)"></a>怎么实现Map的并发安全(sync.Map，底层实际上用了一个Map缓存)</h1><p><code>sync.Map</code>类型提供了一种并发安全的键值对映射，它可以在多个goroutine之间安全地读取和写入数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个并发安全的Map</span></span><br><span class="line"><span class="keyword">var</span> m sync.Map</span><br><span class="line"><span class="comment">// 添加键值对</span></span><br><span class="line">m.Store(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>)</span><br><span class="line">m.Store(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>)</span><br><span class="line"><span class="comment">// 从Map中获取值</span></span><br><span class="line">value1, ok1 := m.Load(<span class="string">&quot;key1&quot;</span>)</span><br><span class="line">value2, ok2 := m.Load(<span class="string">&quot;key2&quot;</span>)</span><br><span class="line"><span class="comment">// 删除键值对</span></span><br><span class="line">m.Delete(<span class="string">&quot;key2&quot;</span>)</span><br><span class="line"><span class="comment">// 遍历Map</span></span><br><span class="line">m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Key:&quot;</span>, key, <span class="string">&quot;Value:&quot;</span>, value)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>sync.Map</code>内部被<strong>分成了多个分片（shard）</strong>，每个分片都包含了一个独立的映射，<strong>以及一个互斥锁用于保护该分片的读写操作</strong>。默认情况下，分<strong>片的数量是32，可以通过调整<code>runtime.GOMAXPROCS()</code>来改变分片的数量。</strong>当<strong>需要读取或写入映射时，<code>sync.Map</code>会根据键的哈希值选择一个特定的分片</strong>。对于读操作，只需要获取对应分片的互斥锁，并直接进行读取操作，不会对其他分片产生影响。<strong>对于写操作，需要先获取对应分片的互斥锁，然后执行写入操作，并最后释放互斥锁。</strong>这样就实现了对分片的并发访问控制，从而保证了并发安全性。</p>
<p>此外，<code>sync.Map</code>还使用了一种特殊的技术，即<strong>当读操作遇到正在进行的写操作时，读操作会等待写操作完成，并重新加载最新的数据。</strong>这种技术可以避免读操作读取到过期的数据，并确保读取的数据是最新的。</p>
<p>需要注意的是，<strong>由于<code>sync.Map</code>采用了分片锁的机制，因此在高并发的情况下，对于频繁的写操作可能会导致锁的争用，进而影响性能</strong>。因此，如果需要高性能的并发映射，可以<strong>考虑使用其他第三方的并发安全映射库</strong>，如<code>concurrent-map</code>、<code>go-cache</code>等，它们可能会采用更高效的底层实现方式。</p>
<h1 id="defer函数的使用场景（延迟Close、recover-panic）"><a href="#defer函数的使用场景（延迟Close、recover-panic）" class="headerlink" title="defer函数的使用场景（延迟Close、recover panic）"></a>defer函数的使用场景（延迟Close、recover panic）</h1><ol>
<li><strong>解锁互斥锁</strong>：在使用互斥锁进行临界区保护时，为了避免忘记解锁而导致死锁，可以<strong>使用defer函数来确保在函数执行完毕后解锁互斥锁</strong>。</li>
<li>延迟<strong>执行资源清理</strong>：在函数执行过程中，如果需要进行一些<strong>资源清理操作</strong>，可以使用defer函数来延迟执行清理操作，确保无论函数执行的逻辑分支如何，都能够进行资源清理.(文件、数据库连接、网络连接)</li>
<li><strong>恢复错误</strong>：在处理可能发生错误的代码段时，可以<strong>使用defer函数来捕获和处理错误</strong>，<strong>避免错误传播到调用栈的更高层。</strong></li>
<li><strong>确保函数调用顺序：</strong>当在函数中有多个函数调用的顺序很重要时，可以使用<strong>defer函数来确保它们按照正确的顺序执行</strong>。</li>
</ol>
<h1 id="Map可以用数组作为Key吗（数组可以，切片不可以）"><a href="#Map可以用数组作为Key吗（数组可以，切片不可以）" class="headerlink" title="Map可以用数组作为Key吗（数组可以，切片不可以）"></a>Map可以用数组作为Key吗（数组可以，切片不可以）</h1><p>Go 语言中只要是可比较的类型都可以作为 key。除开 <strong>slice，map，functions</strong> 这几种类型，其他类型都是 OK 的。具体包括：布尔值、数字、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组。</p>
<h1 id="Channel的阻塞和非阻塞（顺带问了select用法）"><a href="#Channel的阻塞和非阻塞（顺带问了select用法）" class="headerlink" title="Channel的阻塞和非阻塞（顺带问了select用法）"></a>Channel的阻塞和非阻塞（顺带问了select用法）</h1><ol>
<li>阻塞通道：<strong>默认情况下，通道是阻塞</strong>的。<strong>当发送方尝试将数据发送到通道时，如果通道已满（接收方没有准备好接收），发送方将被阻塞，直到有空间可用。类似地，当接收方尝试从通道中接收数据时，如果通道为空（发送方没有准备好发送），接收方将被阻塞，直到有数据可用</strong>。这种阻塞行为使得通道成为一种有效的同步机制。</li>
<li>非阻塞通道： 非阻塞通道的特点是在数据传输期间不会发生暂停，发送方和接收方可以继续执行其他操作。在 Go 中，<strong>可以使用<code>select</code>语句结合<code>default</code>分支来实现非阻塞的通道操作</strong>。<code>select</code>语句用于同时监视多个通道的状态，并执行相应的操作。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// 创建一个整数类型的通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送方（非阻塞）</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ch &lt;- <span class="number">42</span>: <span class="comment">// 尝试发送数据到通道</span></span><br><span class="line">    <span class="comment">// 发送成功时执行的代码</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 通道已满时执行的代码或其他操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收方（非阻塞）</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch: <span class="comment">// 尝试从通道接收数据</span></span><br><span class="line">    <span class="comment">// 接收到数据时执行的代码</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 通道为空时执行的代码或其他操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="实现一个接口C在指定时间内最大次数并发调用接口A与接口B"><a href="#实现一个接口C在指定时间内最大次数并发调用接口A与接口B" class="headerlink" title="实现一个接口C在指定时间内最大次数并发调用接口A与接口B"></a>实现一个接口C在指定时间内最大次数并发调用接口A与接口B</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">duration := <span class="number">5</span> * time.Second  <span class="comment">// 指定时间段</span></span><br><span class="line">startTime := time.Now()</span><br><span class="line"><span class="comment">// 循环调用接口A和接口B，直到达到指定时间或最大调用次数</span></span><br><span class="line"><span class="keyword">for</span> time.Since(startTime) &lt; duration&#123;</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="comment">// 并发调用接口A和接口B</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			a := InterfaceA&#123;&#125;</span><br><span class="line">			b := InterfaceB&#123;&#125;</span><br><span class="line">			a.CallA()</span><br><span class="line">			b.CallB()</span><br><span class="line">		&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待所有调用完成</span></span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>

<h1 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h1><p>在<code>Ethereum.StartMining()</code>函数中，出现了<code>if c, ok := s.engine.(*clique.Clique); ok</code> 的写法。这中写法是 Golang 中的语法糖，称为<strong>类型断言</strong>。具体的语法是 <code>value, ok := element.(T)</code>，它的含义是如果 <code>element</code> 是 <code>T</code> 类型的话，那么ok等于<code>True</code>, <code>value</code> 等于 <code>element</code> 的值。在 <code>if c, ok := s.engine.(*clique.Clique); ok</code> 语句中，就是在判断 <code>s.engine</code> 的是否为 <code>*clique.Clique</code> 类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cli *clique.Clique</span><br><span class="line"><span class="keyword">if</span> c, ok := s.engine.(*clique.Clique); ok &#123;</span><br><span class="line"> cli = c</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> cl, ok := s.engine.(*beacon.Beacon); ok &#123;</span><br><span class="line"> <span class="keyword">if</span> c, ok := cl.InnerEngine().(*clique.Clique); ok &#123;</span><br><span class="line">  cli = c</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/01/13/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/13/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" class="post-title-link" itemprop="url">8-垃圾回收器</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-13 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-13T00:00:00+08:00">2022-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-09 10:01:34" itemprop="dateModified" datetime="2023-11-09T10:01:34+08:00">2023-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index">
                    <span itemprop="name">GO基础知识</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h1><p><strong>我们在程序中定义一个变量，会在内存中开辟相应内存空间进行存储，当不需要此变量后，需要手动销毁此对象，并释放内存。而这种对不再使用的内存资源进行自动回收的功能即为垃圾回收（Garbage Collection，缩写为GC），是一种自动内存管理机制</strong></p>
<h1 id="如何识别垃圾"><a href="#如何识别垃圾" class="headerlink" title="如何识别垃圾"></a>如何识别垃圾</h1><h2 id="引用计数算法-reference-counting"><a href="#引用计数算法-reference-counting" class="headerlink" title="引用计数算法(reference counting)"></a>引用计数算法(reference counting)</h2><p>引<strong>用计数通过在对象上增加自己被引用的次数，被其他对象引用时加1，引用自己的对象被回收时减1，引用数为0的对象即为可以被回收的对象，</strong>这种算法在内存比较紧张和实时性比较高的系统中使用比较广泛，如php，Python等。</p>
<img src="/noteimg/Go知识点/GO基础知识/img/3a41e75733c54c75b053ac26b3b526e8tplv-k3u1fbpfcp-zoom-in-crop-mark4536000-168662237133012.awebp" alt="img" style="zoom:80%;" /> 

<p>优点：方式简单，回收速度快。</p>
<p>缺点：</p>
<ol>
<li>需要额外的空间存放计数。</li>
<li>无法处理循环引用(如a.b&#x3D;b; b.a&#x3D;a)。</li>
<li>频繁更新引用计数降低了性能。</li>
</ol>
<h2 id="追踪式回收算法-Tracing"><a href="#追踪式回收算法-Tracing" class="headerlink" title="追踪式回收算法(Tracing)"></a>追踪式回收算法(Tracing)</h2><p>追踪式算法(可达性分析)的核心思想是<strong>判断一个对象是否可达，如果这个对象一旦不可达就可以立刻被GC回收了</strong>，那么我们怎么判断一个对象是否可达呢？第一步从<strong>根节点开始找出所有的全局变量和当前函数栈里的变量，标记为可达</strong>。第二步，<strong>从已经标记的数据开始，进一步标记它们可访问的变量，</strong>以此类推，专业术语叫传递闭包。当追踪结束时，没有被打上标记的对象就被判定是不可触达。</p>
<p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/d42f9e9925ae473eb52ed795f8da5e35tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p>
<p>优点：</p>
<ol>
<li>解决了循环引用的问题</li>
<li>占用的空间少了</li>
</ol>
<p>和引用计数法相比，有以下缺点：</p>
<ol>
<li>无法立刻识别出垃圾对象，需要依赖GC线程</li>
<li>算法在标记时必须暂停整个程序，即STW(stop the world)，否则其他线程有可能会修改对象的状态从而回收不该回收的对象</li>
</ol>
<h2 id="STW-是什么意思？"><a href="#STW-是什么意思？" class="headerlink" title="STW 是什么意思？"></a>STW 是什么意思？</h2><p><code>STW</code> 可以是 <code>Stop the World</code> 的缩写，也可以是 <code>Start the World</code> 的缩写。通常意义上指指代从 <code>Stop the World</code> 这一动作发生时到 <code>Start the World</code> 这一动作发生时这一段时间间隔，即万物静止。STW 在垃圾回收过程中为了保证实现的正确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图的一段过程。</p>
<p>在这个过程中整个用户代码被停止或者放缓执行， <code>STW</code> 越长，对用户代码造成的影响（例如延迟）就越大，早期 Go 对垃圾回收器的实现中 <code>STW</code> 长达几百毫秒，对时间敏感的实时通信等应用程序会造成巨大的影响。</p>
<h1 id="如何清理垃圾"><a href="#如何清理垃圾" class="headerlink" title="如何清理垃圾"></a>如何清理垃圾</h1><h2 id="标记清除算法-Mark-Sweep"><a href="#标记清除算法-Mark-Sweep" class="headerlink" title="标记清除算法(Mark Sweep)"></a>标记清除算法(Mark Sweep)</h2><p>标记清除算法是最常见的垃圾收集算法，标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记(Mark)和清除(Sweep)两个阶段：</p>
<ol>
<li>标记阶段：<strong>暂停应用程序的执行，从根对象触发查找并标记堆中所有存活的对象；</strong></li>
<li>清除阶段：<strong>遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表，恢复应用程序的执行；</strong></li>
</ol>
<img src="/noteimg/Go知识点/GO基础知识/img/26a3f4946dfe438893654a9dad0d0a53tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img" style="zoom: 50%;" /> 

<p>优点：实现简单。</p>
<p>缺点：</p>
<ol>
<li><strong>执行期间需要把整个程序完全暂停，不能异步的进行垃圾回收。</strong></li>
<li>容易产生大量不连续的内存碎片，碎片太多可能会导致后续没有足够的连续内存分配给较大的对象，从而提前触发新的一次垃圾收集动作。</li>
</ol>
<h2 id="标记复制算法"><a href="#标记复制算法" class="headerlink" title="标记复制算法"></a>标记复制算法</h2><p>它把内存空间划分为两个相等的区域，每次只使用其中一个区域。在垃圾收集时，遍历当前使用的区域，<strong>把存活对象复制到另一个区域中，最后将当前使用的区域的可回收对象进行回收。</strong></p>
<p>实现：</p>
<p>首先这个算法会把对分成两块，一块是From、一块是To</p>
<p>对象只会在From上生成，发生GC之后会找到所有的存活对象，然后将其复制到To区，然后整体回收From区。</p>
<img src="/noteimg/Go知识点/GO基础知识/img/432b58a1a30f4d91a5d810fcfddf9478tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img" style="zoom: 67%;" /> 

<p>优点：</p>
<ol>
<li>不用进行大量垃圾对象的扫描：标记复制算法需要从<code>GC-root</code>对象出发，将可达的对象复制到另外一块内存后直接清理当前这块内存即可。</li>
<li>解决了内存碎片问题，防止分配大空间对象是提前gc的问题。</li>
</ol>
<p>缺点：</p>
<ol>
<li>复制成本问题：在可达对象占用内存高的时候，复制成本会很高。</li>
<li>内存利用率低：相当于可利用的内存仅有一半。</li>
</ol>
<h2 id="标记压缩算法"><a href="#标记压缩算法" class="headerlink" title="标记压缩算法"></a>标记压缩算法</h2><p>在标记可回收的对象后<strong>将所有存活的对象压缩到内存的一端</strong>，使他们紧凑地排列在一起，对边界以外的内存进行回收，回收后，已用和未用的内存都各自一边。</p>
<img src="/noteimg/Go知识点/GO基础知识/img/9fc05db886244859a02fa3ac92d1e57atplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img" style="zoom:67%;" /> 

<p>优点：</p>
<ol>
<li>避免了内存碎片化的问题。</li>
<li>适合老年代算法，老年代对象存活率高的情况下，标记整理算法由于不需要复制对象，效率更高。</li>
</ol>
<p>缺点：整理过程复杂：需要多次遍历内存，导致STW时间比标记清除算法高。</p>
<h1 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h1><h2 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h2><p>为了解决原始标记清除算法带来的长时间STW, Go从v1.5版本实现了<strong>基于三色标记清除的并发垃圾收集器</strong>，在<strong>不暂停程序的情况下即可完成对象的可达性分析</strong>，三色标记算法将程序中的对象分成白色、黑色和灰色三类：</p>
<ul>
<li><strong>白色对象 - 潜在的垃圾，其内存可能会被垃圾收集器回收；</strong></li>
<li><strong>灰色对象 - 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；</strong></li>
<li><strong>黑色对象 - 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象</strong></li>
</ul>
<p>三色标记法属于增量式GC算法，回收器<strong>首先将所有对象标记成白色</strong>，然后从gc root出发，<strong>逐步把所有可达的对象变成灰色再到黑色</strong>，最终所有的白色对象都是不可达对象。</p>
<p>具体实现：</p>
<ul>
<li><strong>初始时所有对象都是白色的</strong></li>
<li>从<code>gc root</code>对象出发，<strong>扫描所有可达对象标记为灰色，放入待处理队列</strong></li>
<li><strong>从队列取出一个灰色对象并标记为黑色，将其引用对象标记为灰色</strong>，放入队列</li>
<li><strong>重复上一步骤，直到灰色对象队列为空</strong></li>
<li><strong>此时剩下的所有白色对象都是垃圾对象</strong></li>
</ul>
<img src="/noteimg/Go知识点/GO基础知识/img/45d06eb5f99d49f385ac21e4027b4973tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img" style="zoom:50%;" /> 

<p>优点：</p>
<ul>
<li>不需要STW</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果产生垃圾速度大于回收速度时，可能会导致程序中垃圾对象越来越多而无法及时收集</li>
<li>线程切换和上下文转换的消耗会使得垃圾回收的总体成本上升，从而降低系统吞吐量</li>
</ul>
<p>三色标记法存在并发性问题，</p>
<ul>
<li><strong>可能会出现野指针(指向没有合法地址的指针)，从而造成严重的程序错误</strong></li>
<li><strong>漏标，错误的回收非垃圾对象</strong></li>
</ul>
<h2 id="三色不变性"><a href="#三色不变性" class="headerlink" title="三色不变性"></a>三色不变性</h2><p>想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性中的任意一种。</p>
<ul>
<li><p>强三色不变性——<strong>黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象。</strong></p>
<img src="/noteimg/Go知识点/GO基础知识/img/8bf86801841744ab97923af572b763f2tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img" style="zoom: 50%;" /> 
</li>
<li><p>弱三色不变性——<strong>黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径</strong>。</p>
</li>
</ul>
<img src="/noteimg/Go知识点/GO基础知识/img/4fc07e2bf7a743d0902fac72ed174f80tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img" style="zoom:67%;" /> 

<h2 id="屏障技术"><a href="#屏障技术" class="headerlink" title="屏障技术"></a>屏障技术</h2><p>垃圾收集中的屏障技术更像是一个钩子方法，<strong>它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码</strong>，根据操作类型的不同，我们可以将它们分成读屏障和写屏障两种，<strong>因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以往往都会采用写屏障保证三色不变性。</strong></p>
<h3 id="插入写屏障"><a href="#插入写屏障" class="headerlink" title="插入写屏障"></a><strong>插入写屏障</strong></h3><p><strong>当一个对象引用另外一个对象时，将另外一个对象标记为灰色，以此满足强三色不变性，不会存在黑色对象引用白色对象。</strong></p>
<h3 id="删除写屏障"><a href="#删除写屏障" class="headerlink" title="删除写屏障"></a>删除写屏障</h3><p><strong>在灰色对象删除对白色对象的引用时，将白色对象置为灰色，其实就是快照保存旧的引用关系，这叫STAB,以此满足弱三色不变性。</strong></p>
<h3 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h3><p>v1.8版本之前，运行时会使用插入写屏障保证强三色不变性；</p>
<p>在v1.8中，<strong>组合插入写屏障和删除写屏障构成了混合写屏障，保证弱三色不变性；</strong>该写屏障会<strong>将覆盖的对象标记成灰色(删除写屏障)并在当前栈没有扫描时将新对象也标记成灰色(插入写屏障)：</strong></p>
<p><strong>写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新建的对象都会被直接标记成黑色。</strong></p>
<h1 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h1><p>Go语言的垃圾收集可以分成清除终止、标记、标记终止和清除四个不同阶段：</p>
<img src="/noteimg/Go知识点/GO基础知识/img/0a5a6c1f177d41f393de2a6a8f860c13tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img" style="zoom:50%;" /> 

<p><strong>清理终止阶段</strong></p>
<ol>
<li>清扫终止阶段，为下一个阶段的并发标记做准备工作，启动写屏障</li>
</ol>
<p><strong>标记阶段</strong></p>
<ol>
<li>将状态切换至<code>_GCmark</code>、<strong>与赋值器并发执行，开启写屏障</strong>、用户程序协助(<code>Mutator Assists</code>)并将根对象入队；</li>
<li>恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，<strong>写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；</strong></li>
<li><strong>开始扫描根对象，包括所有<code>Goroutine</code>的栈、全局对象以及不在堆中的运行时数据结构，扫描<code>Goroutine</code>栈期间会暂停当前处理器；</strong></li>
<li><strong>依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；</strong></li>
<li>使用分布式的终止算法检查剩余的工作，<strong>发现标记阶段完成后进入标记终止阶段；</strong></li>
</ol>
<p><strong>标记终止阶段</strong></p>
<ol>
<li><strong>保证一个周期内标记任务完成，停止写屏障</strong></li>
<li>暂停程序、将状态切换至<code>_GCmarktermination </code>并关闭辅助标记的用户程序；</li>
<li>清理处理器上的线程缓存；</li>
</ol>
<p><strong>清理阶段</strong></p>
<ol>
<li>将状态切换至<code>_GCoff</code> <strong>开始清理阶段、初始化清理状态并关闭写屏障；</strong></li>
<li><strong>恢复用户程序，所有新创建的对象会标记成白色；</strong></li>
<li><strong>后台并发清理所有的内存管理单元，当<code>Goroutine</code>申请新的内存管理单元时就会触发清理；</strong></li>
</ol>
<h1 id="GC触发时机"><a href="#GC触发时机" class="headerlink" title="GC触发时机"></a>GC触发时机</h1><p>当满足触发垃圾收集的基本条件：允许垃圾收集、程序没有崩溃并且没有处于垃圾循环；</p>
<p>注：运行时会通过如下所示的<code>runtime.gcTrigger.test</code>方法决定是否需要触发垃圾收集，该方法会根据三种不同方式触发进行不同的检查。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t gcTrigger)</span></span> test() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !memstats.enablegc || panicking != <span class="number">0</span> || gcphase != _GCoff &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> t.kind &#123;</span><br><span class="line">	<span class="keyword">case</span> gcTriggerHeap:</span><br><span class="line">		<span class="keyword">return</span> memstats.heap_live &gt;= memstats.gc_trigger</span><br><span class="line">	<span class="keyword">case</span> gcTriggerTime:</span><br><span class="line">		<span class="keyword">if</span> gcpercent &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		lastgc := <span class="type">int64</span>(atomic.Load64(&amp;memstats.last_gc_nanotime))</span><br><span class="line">		<span class="keyword">return</span> lastgc != <span class="number">0</span> &amp;&amp; t.now-lastgc &gt; forcegcperiod</span><br><span class="line">	<span class="keyword">case</span> gcTriggerCycle:</span><br><span class="line">		<span class="keyword">return</span> <span class="type">int32</span>(t.n-work.cycles) &gt; <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>超过内存大小阙值，分配内存时</strong>，当前已分配内存与上一次<code>GC</code>结束时存活对象的内存达到某个比例时就触发<code>GC</code>。(默认配置会在堆内存达到上一次垃圾收集的2倍时，触发新一轮的垃圾收集，可以通过环境变量<code>GOGC</code>调整，在默认情况下他的值为100，即增长100%的堆内存才会触发<code>GC</code>)；比如一次回收完毕后，内存的使用量为5M，那么下次回收的机制则是内存分配达到10M的时候，也就是说，并不是内存分配越多，垃圾回收频率越高。</li>
<li>如果一直达不到内存大小的阙值，<code>sysmon</code>检测出一段时间内（由<code>runtime.forcegcperiod</code>变量控制，<strong>默认为2分钟）没有触发过<code>GC</code>，就会触发新的GC。</strong></li>
<li><strong>手动调用<code>runtime.GC()</code>强制触发<code>GC</code></strong></li>
</ul>
<h1 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h1><p>减少堆内存的分配是最好的优化方式。比如合理重复利用对象；避免<code>string</code>和<code>byte[]</code>之间的转化等，两者发生转换的时候，底层数据结构会进行复制，因此导致gc效率会变低，少量使用<code>+</code>连接<code>string</code>，Go里面<code>string</code>是最基础的类型，是一个只读类型，针对他的每一个操作都会创建一个新的<code>string</code>，如果是少量小文本拼接，用<code>“+”</code>就好，如果是大量小文本拼接，用<code>strings.Join</code>;如果是大量大文本拼接，用<code>bytes.Buffer</code>。</p>
<p>优化努力的方向：</p>
<ul>
<li>控制内存分配的速度，限制 goroutine 的数量，从而提高赋值器对 CPU 的利用率。</li>
<li>减少并复用内存，例如使用 sync.Pool 来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的拷贝。</li>
<li>需要时，增大 GOGC 的值，降低 GC 的运行频率。</li>
</ul>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/20/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/22/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="幺柒YQ"
      src="/images/avater.png">
  <p class="site-author-name" itemprop="name">幺柒YQ</p>
  <div class="site-description" itemprop="description">努力坚持就会有希望</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">232</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kpyaoqi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kpyaoqi" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:18312386077@163.com" title="E-Mail → mailto:18312386077@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat.jpg" title="WeChat → images&#x2F;wechat.jpg"><i class="fa fa-fw fa-wechat"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/qq.jpg" title="QQ → images&#x2F;qq.jpg"><i class="fa fa-fw fa-qq"></i>QQ</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://stackoverflow.com/" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;" rel="noopener" target="_blank">Stackoverflow</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2021-11 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">幺柒YQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">899k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:37</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共379.4k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  


</body>
</html>
