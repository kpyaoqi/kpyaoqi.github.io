<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://kongpengyq.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="努力坚持就会有希望">
<meta property="og:type" content="website">
<meta property="og:title" content="YQ &amp; 博客">
<meta property="og:url" content="https://kongpengyq.com/page/12/index.html">
<meta property="og:site_name" content="YQ &amp; 博客">
<meta property="og:description" content="努力坚持就会有希望">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="幺柒YQ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://kongpengyq.com/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>YQ & 博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="YQ & 博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YQ & 博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/11/19/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/IPFS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/IPFS/" class="post-title-link" itemprop="url">IPFS</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-19 00:00:00" itemprop="dateCreated datePublished" datetime="2022-11-19T00:00:00+08:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/" itemprop="url" rel="index">
                    <span itemprop="name">区块链其他</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是IPFS"><a href="#什么是IPFS" class="headerlink" title="什么是IPFS"></a>什么是IPFS</h2><p>IPFS，是点到点的超媒体协议，它让网络更快、更安全、更开放。说简单一点，它就是一个去中心化互联网。说技术一点，它是一个基于分布式哈希表DHT进行内容寻址的，基于git模型版本管理的，基于默克尔对象关联的，基于点对点技术的，基于全球化命名空间IPNS的，基于各种技术的，一种分布式文件系统。</p>
<h2 id="为什么需要IPFS"><a href="#为什么需要IPFS" class="headerlink" title="为什么需要IPFS"></a>为什么需要IPFS</h2><p>现代社会中互联网对我们非常重要，它是我们生活、工作、学习、消费、娱乐和社交不可获取的媒介，但当下中心化的互联网有很多问题。</p>
<p><img src="/./img/v2-9322a329ae16fdafd91325a655a085e9_720w.webp" alt="img"></p>
<ul>
<li><em>中心化互联网效率低，成本高，HTTP是一个请求响应式协议，大家从一个中心服务商索取数据，服务器商构建大规模的服务器集群，服务全世界的用户。这，在高峰期，服务阻塞延迟，低峰期，大量资源闲置浪费。IPFS是通过激励，发动大量用户共享存储和带宽，资源分享和获取都在一个闭环的生态。因为网络带宽都被大文件消耗了，比如视频文件，很多都是重复数据，IPFS能有效的去重文件，消除冗余。所以IPFS能更高效的利用带宽，降低成本。</em></li>
<li><em>目前互联网特别容易丢失数据，IPFS能永远保存有价值的数据。</em></li>
<li><em>今天的互联网严重依赖主干网，一旦主干网发生故障，就会出现大规模服务中段或延迟，IPFS不依赖主干网，即便是网络不发达的地区，或者发生了灾害的地区，IPFS也能有很好的表现。</em></li>
<li><em>中心化的网络非常容易引入审查机制，每个government都很容易干掉某个网站或者app。</em></li>
</ul>
<p>现在，用户对互联网服务性能要求越来越高，响应快、低延迟、4K无码高清视频，大的中心化公司，能快速集中资金，做出用户体验更好的产品，但这些成本是通过广告费、会员费和竞价搜索排名转嫁到消费者头上。用户是没有选择权的。</p>
<p><img src="/./img/v2-e7ef02c8dff5da578f69cb78c032f63d_720w.webp" alt="img"></p>
<p>IPFS希望超越HTTP协议，并构建一个更好的互联网生态。</p>
<p>从技术角度看，IPFS是一个协议，它借鉴了许多技术，（P2P+BitTorrent+Git+Hash+kademlia DHT+SFS+Merkel  DAG等等）。通过这些技术，IPFS能将网站、应用、文件和各种数据，建立在点对点分布式网络上，并且高效的索引，这种高效的核心在于它是基于内容寻址的。</p>
<p>互联网上任何一个资源，都需要地址来找到它们，可能是IP地址、域名、文件的系统路径或者Nginx反向代理的路径。</p>
<p><img src="/./img/v2-5ebc25db00f09fe77c3b44c4edda28d0_720w.webp" alt="img"></p>
<p>总之得有一个地址，这个地址指向哪个资源，就返回什么资源，如果资源的地址变了，或者给的地址失效了，就无法获取资源。但我们如果真的很需要这个资源，恰好之前有人下载过这个资源，并存在他的电脑上，我们很想找到这个人，因为我们并不在乎资源在什么位置，我们只在乎这个资源的内容是不是我们想要的，那这种基于位置，也就是location的寻址就没用了，我们需要一种新的寻址模式，基于内容content的寻址，IPFS就是基于内容的寻址，它的地址长这样↓</p>
<p><img src="/./img/v2-507b54458be1a9478ea84a2023fb4664_720w.webp" alt="img"></p>
<h2 id="IPFS实现内容寻址的工作原理"><a href="#IPFS实现内容寻址的工作原理" class="headerlink" title="IPFS实现内容寻址的工作原理"></a>IPFS实现内容寻址的工作原理</h2><p><strong>第一步：将文件分割成一些小块blocks，并且分别打上hash指纹，hash指纹是一串字符，能够跟它的数据块一一对应，相当于我们每个人和自己指纹的关系。通过这个hash可以找到这个文件数据。</strong></p>
<p><img src="/./img/v2-d642fd2ac7420487fdbeaa75b36e81e7_720w.webp" alt="img"></p>
<p><strong>第二步：IPFS去除重复文件，因为每个文件有了对应的哈希值，可以非常方便的找到重复的文件，最终只保留一个对象，当然每个节点都可以保留，这个文件对象的备份。</strong></p>
<p><img src="/./img/v2-32df01b765b4d68e4fb66a9fcf1a2a82_720w.webp" alt="img"></p>
<p><strong>第三步：每个IPFS网络节点都去存储它需要的数据，用一个叫DHT的表，来记录每个节点存储了哪些数据。</strong></p>
<p><img src="/./img/v2-1772e85304355f0f60886ced5d3b2982_720w.webp" alt="img"></p>
<p>下图左边Key代表文件内容的Hash（CID），右边的Value代表内容所在的节点（PeerID），这一条DHT数据表示，CID是QmCheese的数据块，存在QmRichard这个用户的设备上。</p>
<p><img src="/./img/v2-e8f8780fcfb6ff7d926d3fb817dc0379_720w.webp" alt="img"></p>
<p><strong>第四步：当我们寻找或下载一个文件时，我们先计算这个文件的Hash指纹，通过指纹向其他节点寻找文件，当然获取他人的资源是需要成本的，别人给我分享资源也将得到回报，这种激励模式叫BitSwap。</strong></p>
<p><img src="/./img/v2-d8028e2251f3a021644335b3b9e8b1d1_720w.webp" alt="img"></p>
<h2 id="IPFS文件时如何存储和共享的"><a href="#IPFS文件时如何存储和共享的" class="headerlink" title="IPFS文件时如何存储和共享的"></a>IPFS文件时如何存储和共享的</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IPFS  object</span><br><span class="line">DATA  &quot;Hello World&quot;</span><br><span class="line">Links []</span><br></pre></td></tr></table></figure>

<p>IPFS的文件都是通过对象的结构来存储的，每个对象包含数据Data项和连接Links数组，Data不超过256K，Data是一串文本“Hello  World”，如果数据大于256K，比如图片或者视频，我们将拆分多个对象，都不超过256K，然后再建立一个更上层的对象，将他们归纳起来，就像一个文件夹，所以IPFS的文件结构，很想UNIX文件系统。</p>
<p><img src="/./img/v2-3aab9b542c2fc5f4ea5fce896dee957f_720w.webp" alt="img"></p>
<p>还有一个问题，这些寻址链接都是通过内容查找的，如果一个文件更新了内容，那么Hash就变了，之前的索引就失效了，所以类似区块链一样，IPFS数据是不可变的，为了追踪文件的更新，IPFS引入了版本控制模型，IPFS版本控制模型和Git基本一致，Git是常用的版本控制系统，用来记录、追踪和同步文件的版本更新，每次更新的版本快照我们叫commit。</p>
<p><img src="/./img/v2-540fdb1954e1addb14669b116a184f08_720w.webp" alt="img"></p>
<p>IPFS最大大问题是不能保证文件始终有资源，比如一个文件在4个节点有备份，如果这4个节点离线或断开，我们就无法获取这个文件数据，类似BT下载就没有种子了。</p>
<p>我们有2种方案解决这个问题：</p>
<ul>
<li><em>增加激励机制，鼓励节点多多存储文件，并在长期在线分享。</em></li>
<li><em>主动分发文件，保证一直有足够量的在线备份，这是Filecoin要做的事。</em></li>
</ul>
<p>Filecoin和IPFS是同一个团队开发的，他是搭建在IPFS上的一个区块链应用。Filecoin构建了去中心化的存储市场，如果你有空闲的存储空间，可以通过Filecoin分享给别人，赚取收益，Filecoin也用奖励，来激励用户尽可能多的保持节点在线，并且保证文件有足够多的备份。</p>
<p>IPFS已经建立了相对成熟的技术架构，他是去中心化产品开发者的首选存储技术方案，</p>
<p><img src="/./img/v2-1a8b0331c622c0434d6a863bf8efffa1_720w.webp" alt="img"></p>
<p>这些应用都在用IPFS技术，这里大多数是去中心化应用。IPFS还有一个经典案例，2017年土耳其政府block了维基百科，开发者在IPFS上搭建了一个去中心化的维基百科镜像，因为IPFS没有中心服务器，节点就像星星之火分布在世界各地，土耳其政府就无法再墙掉这个网站了。</p>
<p><img src="/./img/v2-f91617bd0b2bfd687d9ad4b6cb92419b_720w.webp" alt="img"></p>
<p>IPFS星际文件系统，一个如此带有科幻感和未来感的名字！</p>
<p>他是一个适合跨越“星际”间使用的文件系统，在星球之间传输信号，延迟是比较大的，比如火星和地球之间，传输信号的时间在4~24分钟，那么我们要是在火星上访问地球上的网页，最快8分钟，最慢48分钟。</p>
<p>如果有了IPFS系统，火星上查看了地球上的网页后，把网页数据存储下来，可以作为一个节点分享给其他火星人，这样，火星人的上网体验就快多了，所以我们给IPFS起名星际文件系统，一个去中心化的互联网文件分发协议，他会让互联网更快、更安全、更开放！</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/Dao%E6%B2%BB%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/Dao%E6%B2%BB%E7%90%86/" class="post-title-link" itemprop="url">Dao治理</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-17 00:00:00" itemprop="dateCreated datePublished" datetime="2022-11-17T00:00:00+08:00">2022-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/" itemprop="url" rel="index">
                    <span itemprop="name">区块链其他</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>777</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Dao治理"><a href="#Dao治理" class="headerlink" title="Dao治理"></a>Dao治理</h1><p>DAO治理是基于去中心化自治组织（DAO）的决策过程。DAO是一种由智能合约和区块链技术支持的组织形式，它可以在无需信任中介的情况下实现透明、开放和民主的决策过程。</p>
<p>在DAO治理中，持有Token的用户可以通过投票来决定组织的事务和方向。这些事务可以包括跨链治理、协议改进、新增功能、经济模型、财务预算等。持有Token的用户可以提出提案并进行投票。除此之外，DAO还可能吸引外部代表、专家、投资者等参与到组织治理中来。</p>
<p>DAO治理的最大优势是去中心化，使得决策过程更加透明、团队更富有民主性，从而提高了决策的质量。同样，由于DAO无法被单一实体控制，其操作和治理决策也非常自由和民主。</p>
<p>一些常见的DAO治理项目包括Compound、MakerDAO和Uniswap等。这些DAO项目通过去中心化的组织结构，吸引了更多人来参与其中，推动了Defi市场的快速成长。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ol>
<li>投票治理：投票治理是DAO中最常见的一种治理方法，持有Token的用户可以投票决定在治理计划中的提案。这种治理方法对于少数股东具有很大的控制力，也会出现“多数派专政”的问题。</li>
<li>贡献度治理：贡献度治理是一种根据用户对项目的贡献来赋予其治理权的方法，持有Token的用户可以回答提出的问题或完成一些任务来提高其贡献度，并最终获得投票权。这种治理方法纠正了少数股东掌握大权的情况，但也会出现恶意行为，如伪造贡献度。</li>
<li>代表治理：代表治理是将治理权委托给一些信任的代表来投票决定，这些代表是由DAO社区自己选出的。虽然代表治理可以让个人更容易参与决策过程，但无法彻底消除上述“多数派专政”的问题。</li>
<li>资产管理治理：资产管理治理是一种将资产管理和投票权挂钩的治理方法，基于投票权与锁定资产的数量进行挂钩，锁定资产数量更多的用户将具有更大的投票权。这种方法纠正了少数股东掌握大权的情况，同时也鼓励长期参与。</li>
</ol>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/11/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/09-solidity_Instructions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/09-solidity_Instructions/" class="post-title-link" itemprop="url">09-solidity_Instructions</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-12 00:00:00" itemprop="dateCreated datePublished" datetime="2022-11-12T00:00:00+08:00">2022-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">以太坊源码</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Solidity"><a href="#Solidity" class="headerlink" title="Solidity"></a>Solidity</h1><h2 id="Instructions"><a href="#Instructions" class="headerlink" title="Instructions"></a>Instructions</h2><p><strong>EVM类似汇编器，负责把合约汇编成更底层的指令(instruction)<strong>。每条指令表示了一些基础或者原子行逻辑操作，例如opCreate用于在State Database上创建一个新的Contract，opBalance用于从State Database中获取某个State Object的balance。这些</strong>指令的的具体的代码实现位于core&#x2F;vm&#x2F;instructions.go 文件中。</strong></p>
<p>值得注意的是，<strong>这些指令仍然会调用go-ethereum中其他package所提供的API，而不是直接对更底层的数据进行操作</strong>。比如，opSstore与opSload指令用于从Storage层存储和读取数据。这两个指令直接调用了StateDB(core&#x2F;state&#x2F;statedb.go)与StateObject(core&#x2F;state&#x2F;state_object.go)提供的API。</p>
<h3 id="opSload"><a href="#opSload" class="headerlink" title="opSload"></a>opSload</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/vm/instructions.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">opSload</span><span class="params">(pc *<span class="type">uint64</span>, interpreter *EVMInterpreter, scope *ScopeContext)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	loc := scope.Stack.peek()</span><br><span class="line">	hash := common.Hash(loc.Bytes32())</span><br><span class="line">	val := interpreter.evm.StateDB.GetState(scope.Contract.Address(), hash)</span><br><span class="line">	loc.SetBytes(val.Bytes())</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="opSstore"><a href="#opSstore" class="headerlink" title="opSstore"></a>opSstore</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">opSstore</span><span class="params">(pc *<span class="type">uint64</span>, interpreter *EVMInterpreter, scope *ScopeContext)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> interpreter.readOnly &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ErrWriteProtection</span><br><span class="line">	&#125;</span><br><span class="line">	loc := scope.Stack.pop()</span><br><span class="line">	val := scope.Stack.pop()</span><br><span class="line">	interpreter.evm.StateDB.SetState(scope.Contract.Address(), loc.Bytes32(), val.Bytes32())</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到，opSstore指令中向合约中的写入逻辑是调用了StateDB中的SetState函数。<strong>SetState函数有三个参数作为input，分别是目标合约的地址，目标storage object的has，以及其更新后的value</strong>。其代码如下所示。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/state/statedb.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> SetState(addr common.Address, key, value common.Hash) &#123;</span><br><span class="line">	stateObject := s.GetOrNewStateObject(addr)</span><br><span class="line">	<span class="keyword">if</span> stateObject != <span class="literal">nil</span> &#123;</span><br><span class="line">		stateObject.SetState(s.db, key, value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SetState 函数通过调用StateObject的SetState函数来修改Storage的值。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stateObject)</span></span> SetState(db Database, key, value common.Hash) &#123;</span><br><span class="line">	<span class="comment">// 如果新值与旧值相同，则不设置</span></span><br><span class="line">	prev := s.GetState(db, key)</span><br><span class="line">	<span class="keyword">if</span> prev == value &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 新值不同，更新并记录更改</span></span><br><span class="line">	s.db.journal.<span class="built_in">append</span>(storageChange&#123;</span><br><span class="line">		account:  &amp;s.address,</span><br><span class="line">		key:      key,</span><br><span class="line">		prevalue: prev,</span><br><span class="line">	&#125;)</span><br><span class="line">	s.setState(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stateObject)</span></span> setState(key, value common.Hash) &#123;</span><br><span class="line">	s.dirtyStorage[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里的dirtStorage起到了一个cache的作用</strong>。之后<strong>在updated storage root的时候会基于当前dirtyStorage中的信息，在commit函数中统一更新root的值。</strong></p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/11/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/08-Bloom%20Filter%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/08-Bloom%20Filter%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" class="post-title-link" itemprop="url">08-Bloom Filter布隆过滤器</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-12 00:00:00" itemprop="dateCreated datePublished" datetime="2022-11-12T00:00:00+08:00">2022-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">以太坊源码</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>687</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h1><p><strong>Bloom Filter 是一种可以快速检索的工具</strong>。Bloom Filter 本身由<strong>是一个长度为m的bit array，k个不相同的hash函数和源dataset组成</strong>。具体的说，Bloom Filter是由k个不同的hash function将源dataset hash到m位的bit array构成。<strong>通过Bloom Filter，我们可以快速检测出一个data是不是在源dataset中</strong>（O(k) time）。</p>
<p><strong>Bloom Filter不保证完全的正确性</strong>：如果被检索的data得到了false的反馈那他一定不在源data之中，true不一定在</p>
<p>在文件的起始位置，定义了两个常量BloomByteLength 和 BloomBitLength</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/types/bloom9.go”</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	BloomByteLength = <span class="number">256</span></span><br><span class="line">	BloomBitLength = <span class="number">8</span> * BloomByteLength</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在Ethereum中的Bloom Filter是一个长度为256的byte数组组成的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bloom represents a 2048 bit bloom filter</span></span><br><span class="line"><span class="keyword">type</span> Bloom [BloomByteLength]<span class="type">byte</span></span><br></pre></td></tr></table></figure>

<p>Ethereum 中Bloom Filter使用的SHA Hash Function.</p>
<p>基本的思想是，使用三个value的值来判断log是否存在。<br>首先对data使用SHA function进行求值。选择hash后的<br>这三个value的选择[0,1],[2,3],[4,5]的值对2048取模得到目标位置的下标，并把这几个位置设为1.</p>
<p>对待判断的log进行相同的操作。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/07-Txpool%E4%BA%A4%E6%98%93%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/07-Txpool%E4%BA%A4%E6%98%93%E6%B1%A0/" class="post-title-link" itemprop="url">07-Txpool交易池</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-09 00:00:00" itemprop="dateCreated datePublished" datetime="2022-11-09T00:00:00+08:00">2022-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">以太坊源码</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>txpool主要用来存放当前提交的等待写入区块的交易</p>
<p>Transaction Pool 里主要是Subpool结构，里面的 Pending 为当前可处理的交易</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/txpool/txpool.go</span></span><br><span class="line"><span class="keyword">type</span> TxPool <span class="keyword">struct</span> &#123;</span><br><span class="line">	subpools []SubPool               <span class="comment">// 用于专门交易处理的子池列表</span></span><br><span class="line">	subs     event.SubscriptionScope <span class="comment">// 关闭时取消所有订阅的订阅范围</span></span><br><span class="line">	quit     <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="type">error</span>         <span class="comment">// 退出频道以拆除head更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SubPool 代表一个独立存在的专用事务池（例如 blob 池），由于与我们拥有多少个专用池无关，它们确实需要同步更新并组装成一个连贯的视图以进行块生产，因此该接口定义了允许主交易池管理子池的通用方法。</span></span><br><span class="line"><span class="keyword">type</span> SubPool <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Filter 是一个选择器，用于决定是否将交易添加到该特定子池中</span></span><br><span class="line">	Filter(tx *types.Transaction) <span class="type">bool</span></span><br><span class="line">	<span class="comment">// Init 设置子池的基本参数</span></span><br><span class="line">	Init(gasTip *big.Int, head *types.Header) <span class="type">error</span></span><br><span class="line">	Close() <span class="type">error</span></span><br><span class="line">	<span class="comment">// 重置检索区块链的当前状态，并确保交易池的内容对于链状态而言是有效的。</span></span><br><span class="line">	Reset(oldHead, newHead *types.Header)</span><br><span class="line">	<span class="comment">// 更新子池对新交易所需的最低价格，并将所有交易降低到低于此阈值。</span></span><br><span class="line">	SetGasTip(tip *big.Int)</span><br><span class="line">	<span class="comment">// 返回子池是否具有使用给定哈希缓存的事务的指示符。</span></span><br><span class="line">	Has(hash common.Hash) <span class="type">bool</span></span><br><span class="line">	Get(hash common.Hash) *Transaction</span><br><span class="line">	<span class="comment">// 如果一批交易有效，则 Add 将其放入池中。 由于交易波动较大，add 可能会推迟将交易完全集成到稍后的时间点，以便将多个交易批量	   处理在一起。</span></span><br><span class="line">	Add(txs []*Transaction, local <span class="type">bool</span>, sync <span class="type">bool</span>) []<span class="type">error</span></span><br><span class="line">	<span class="comment">// Pending 检索所有当前可处理的交易，按原始帐户分组并按随机数排序。</span></span><br><span class="line">	Pending(enforceTips <span class="type">bool</span>) <span class="keyword">map</span>[common.Address][]*types.Transaction</span><br><span class="line">	SubscribeTransactions(ch <span class="keyword">chan</span>&lt;- core.NewTxsEvent) event.Subscription</span><br><span class="line">	<span class="comment">// Nonce 返回帐户的下一个随机数，池中可执行的所有交易都已应用于顶部。</span></span><br><span class="line">	Nonce(addr common.Address) <span class="type">uint64</span></span><br><span class="line">	Stats() (<span class="type">int</span>, <span class="type">int</span>)</span><br><span class="line">	<span class="comment">// Content 检索交易池的数据内容，返回所有待处理和排队的交易，按帐户分组并按随机数排序。</span></span><br><span class="line">	Content() (<span class="keyword">map</span>[common.Address][]*types.Transaction, <span class="keyword">map</span>[common.Address][]*types.Transaction)</span><br><span class="line">	<span class="comment">// ContentFrom 检索交易池的数据内容，返回该地址的待处理交易以及排队交易，并按随机数分组。</span></span><br><span class="line">	ContentFrom(addr common.Address) ([]*types.Transaction, []*types.Transaction)</span><br><span class="line">	<span class="comment">// Locals 检索当前被池视为本地的帐户.</span></span><br><span class="line">	Locals() []common.Address</span><br><span class="line">	<span class="comment">// Status 返回由哈希值标识的事务的已知状态（未知/待处理/排队）</span></span><br><span class="line">	Status(hash common.Hash) TxStatus</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/11/07/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/06-Sync%E5%90%8C%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/07/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/06-Sync%E5%90%8C%E6%AD%A5/" class="post-title-link" itemprop="url">06-Sync同步</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-07 00:00:00" itemprop="dateCreated datePublished" datetime="2022-11-07T00:00:00+08:00">2022-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">以太坊源码</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>301</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p> 在前面的章节中，我们已经讨论了在以太坊中 Transactions 是从 Transaction Pool 中，被 Validator&#x2F;Miner 们验证打包，最终被保存在区块链中。那么，接下来的问题是，<strong>Transaction 是怎么被进入到 Transaction Pool 中的呢？</strong>基于同样的思考方式，那么一个刚刚在某个节点被打包好的 Block，它又将<strong>怎么传输到区块链网络中的其他节点</strong>那里，并<strong>最终实现 Blockchain 长度是一致</strong>的呢？在本章中，我们就来探索一下，节点是如何发送和接收 Transaction 和 Block 的。</p>
<h2 id="syncs-Transactions：同步交易状态"><a href="#syncs-Transactions：同步交易状态" class="headerlink" title="syncs Transactions：同步交易状态"></a>syncs Transactions：同步交易状态</h2><h2 id="syncs-Blocks：同步区块状态"><a href="#syncs-Blocks：同步区块状态" class="headerlink" title="syncs Blocks：同步区块状态"></a>syncs Blocks：同步区块状态</h2>
      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/11/03/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/05-Worker%E5%B7%A5%E4%BD%9C%E8%80%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/03/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/05-Worker%E5%B7%A5%E4%BD%9C%E8%80%85/" class="post-title-link" itemprop="url">05-Worker工作者</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-03 00:00:00" itemprop="dateCreated datePublished" datetime="2022-11-03T00:00:00+08:00">2022-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">以太坊源码</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Mining：挖矿"><a href="#Mining：挖矿" class="headerlink" title="Mining：挖矿"></a>Mining：挖矿</h1><h2 id="Block-Reward：区块奖励"><a href="#Block-Reward：区块奖励" class="headerlink" title="Block Reward：区块奖励"></a>Block Reward：区块奖励</h2><h2 id="How-to-Seal-Block：组装区块"><a href="#How-to-Seal-Block：组装区块" class="headerlink" title="How to Seal Block：组装区块"></a>How to Seal Block：组装区块</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miner/worker.go</span></span><br><span class="line"><span class="comment">// Worker是负责向共识引擎提交新工作的主要对象和收集密封结果。</span></span><br><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> &#123;</span><br><span class="line">	config      *Config</span><br><span class="line">	chainConfig *params.ChainConfig</span><br><span class="line">	engine      consensus.Engine</span><br><span class="line">	eth         Backend				<span class="comment">// eth的协议</span></span><br><span class="line">	chain       *core.BlockChain	<span class="comment">// 区块链</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Feeds</span></span><br><span class="line">	pendingLogsFeed event.Feed</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Subscriptions</span></span><br><span class="line">	mux          *event.TypeMux</span><br><span class="line">	txsCh        <span class="keyword">chan</span> core.NewTxsEvent</span><br><span class="line">	txsSub       event.Subscription</span><br><span class="line">	chainHeadCh  <span class="keyword">chan</span> core.ChainHeadEvent</span><br><span class="line">	chainHeadSub event.Subscription</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Channels</span></span><br><span class="line">	newWorkCh          <span class="keyword">chan</span> *newWorkReq</span><br><span class="line">	getWorkCh          <span class="keyword">chan</span> *getWorkReq</span><br><span class="line">	taskCh             <span class="keyword">chan</span> *task</span><br><span class="line">	resultCh           <span class="keyword">chan</span> *types.Block</span><br><span class="line">	startCh            <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	exitCh             <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	resubmitIntervalCh <span class="keyword">chan</span> time.Duration</span><br><span class="line">	resubmitAdjustCh   <span class="keyword">chan</span> *intervalAdjust</span><br><span class="line"></span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	current *environment 	<span class="comment">// 当前运行循环的环境。</span></span><br><span class="line"></span><br><span class="line">	mu       sync.RWMutex 	<span class="comment">// 用于保护coinbase和额外字段的锁</span></span><br><span class="line">	coinbase common.Address	<span class="comment">// coinbase的地址</span></span><br><span class="line">	extra    []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">	pendingMu    sync.RWMutex</span><br><span class="line">	pendingTasks <span class="keyword">map</span>[common.Hash]*task</span><br><span class="line"></span><br><span class="line">	snapshotMu       sync.RWMutex 	<span class="comment">// 快照 RWMutex（快照读写锁）</span></span><br><span class="line">	snapshotBlock    *types.Block</span><br><span class="line">	snapshotReceipts types.Receipts</span><br><span class="line">	snapshotState    *state.StateDB <span class="comment">// 快照StateDB</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//原子状态计数器</span></span><br><span class="line">	running atomic.Bool  <span class="comment">// The indicator whether the consensus engine is running or not.</span></span><br><span class="line">	newTxs  atomic.Int32 <span class="comment">// New arrival transaction count since last sealing work submitting.</span></span><br><span class="line">	syncing atomic.Bool  <span class="comment">// The indicator whether the node is still syncing.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// newpayloadTimeout是创建有效负载的最大超时。</span></span><br><span class="line">	<span class="comment">//默认值为2秒，但节点操作符可以将其设置为任意大的值。过大的超时允许可能导致Geth无法在指定的时间内创建非空负载，并且在txpool	  中存在一些计算开销较大的事务的情况下最终错过插槽。</span></span><br><span class="line">	newpayloadTimeout time.Duration</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重新提交是在权益证明阶段重新创建密封工作或重新构建有效载荷的时间间隔。</span></span><br><span class="line">	recommit time.Duration</span><br><span class="line"></span><br><span class="line">	<span class="comment">// External functions</span></span><br><span class="line">    <span class="comment">//用于确定指定块是否被本地矿工挖掘的函数。</span></span><br><span class="line">	isLocalBlock <span class="function"><span class="keyword">func</span><span class="params">(header *types.Header)</span></span> <span class="type">bool</span> </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Test hooks</span></span><br><span class="line">	newTaskHook  <span class="function"><span class="keyword">func</span><span class="params">(*task)</span></span>                        <span class="comment">//接收到新的封装任务时调用的方法</span></span><br><span class="line">	skipSealHook <span class="function"><span class="keyword">func</span><span class="params">(*task)</span></span> <span class="type">bool</span>                   <span class="comment">//决定是否跳过密封的方法。</span></span><br><span class="line">	fullTaskHook <span class="function"><span class="keyword">func</span><span class="params">()</span></span>                             <span class="comment">//在推送完全密封任务之前调用的方法。</span></span><br><span class="line">	resubmitHook <span class="function"><span class="keyword">func</span><span class="params">(time.Duration, time.Duration)</span></span> <span class="comment">//更新重新提交间隔时调用的方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中一个关键的函数是<code>miner/worker.go</code>中的<code>fillTransactions()</code>函数。</p>
<p>也就说如果我们希望修改Block中Transaction的打包顺序和从Transaction Pool选择Transactions的策略的话，我们可以通修改<code>fillTransactions()</code>函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miner/worker.go</span></span><br><span class="line"><span class="comment">// 从txpool中检索待处理的交易，并将它们填充到给定的密封块中，交易选择和排序策略可以在将来使用插件进行定制。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> fillTransactions(interrupt *atomic.Int32, env *environment) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 用所有可用的待定交易填充块。</span></span><br><span class="line">	<span class="comment">// 将待处理交易拆分为本地和远程交易</span></span><br><span class="line">	pending := w.eth.TxPool().Pending(<span class="literal">true</span>)</span><br><span class="line">	localTxs, remoteTxs := <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address][]*types.Transaction), pending</span><br><span class="line">	<span class="keyword">for</span> _, account := <span class="keyword">range</span> w.eth.TxPool().Locals() &#123;</span><br><span class="line">		<span class="keyword">if</span> txs := remoteTxs[account]; <span class="built_in">len</span>(txs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">delete</span>(remoteTxs, account)</span><br><span class="line">			localTxs[account] = txs</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//首先处理Local Pool中的交易</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(localTxs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//按照GasPrice和Nonce的顺序进行排序形成新的txs并传递给commitTransactions()函数</span></span><br><span class="line">		txs := types.NewTransactionsByPriceAndNonce(env.signer, localTxs, env.header.BaseFee)</span><br><span class="line">		<span class="keyword">if</span> err := w.commitTransactions(env, txs, interrupt); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//然后再处理从网络中接受到的远程交易。</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(remoteTxs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		txs := types.NewTransactionsByPriceAndNonce(env.signer, remoteTxs, env.header.BaseFee)</span><br><span class="line">		<span class="keyword">if</span> err := w.commitTransactions(env, txs, interrupt); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>commitTransactions()</code>函数的主体是一个for循环体。在这个for循环中，函数会从txs中不断拿出头部的tx进行调用<code>commitTransaction()</code>函数进行处理。在Transaction那一个Section我们提到的<code>commitTransaction()</code>函数会将成功执行的Transaction保存在<code>env.txs</code>中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> commitTransactions(env *environment, txs *types.TransactionsByPriceAndNonce, interrupt *atomic.Int32) <span class="type">error</span> &#123;</span><br><span class="line">	.....</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		.....</span><br><span class="line">		logs, err := w.commitTransaction(env, tx)</span><br><span class="line">		.....</span><br><span class="line">	&#125;</span><br><span class="line">	.....</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> commitTransaction(env *environment, tx *types.Transaction) ([]*types.Log, <span class="type">error</span>) &#123;</span><br><span class="line">	.....</span><br><span class="line">    <span class="comment">//ApplyTransaction尝试将交易应用到给定的状态数据库，并使用其环境的输入参数。</span></span><br><span class="line">    <span class="comment">//它返回交易的收据、使用的gas，如果交易失败则返回一个错误，表明该区块无效。</span></span><br><span class="line">	receipt, err := core.ApplyTransaction(w.chainConfig, w.chain, &amp;env.coinbase, env.gasPool, env.state, env.header, tx, &amp;env.header.GasUsed, *w.chain.GetVMConfig())</span><br><span class="line">	.....</span><br><span class="line">	<span class="keyword">return</span> receipt.Logs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/10/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/04-Blockchain%E5%8C%BA%E5%9D%97%E9%93%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/04-Blockchain%E5%8C%BA%E5%9D%97%E9%93%BE/" class="post-title-link" itemprop="url">04-Blockchain区块链</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-30 00:00:00" itemprop="dateCreated datePublished" datetime="2022-10-30T00:00:00+08:00">2022-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">以太坊源码</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Blockchain"><a href="#Blockchain" class="headerlink" title="Blockchain"></a>Blockchain</h1><h2 id="Block区块数据结构"><a href="#Block区块数据结构" class="headerlink" title="Block区块数据结构"></a>Block区块数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/types/block.go</span></span><br><span class="line"><span class="comment">// Block代表以太坊区块链中的整个区块</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">	header       *Header</span><br><span class="line">	uncles       []*Header</span><br><span class="line">	transactions Transactions</span><br><span class="line">	<span class="comment">// 缓存</span></span><br><span class="line">	hash atomic.Value</span><br><span class="line">	size atomic.Value</span><br><span class="line">	<span class="comment">//这些字段被包eth用来跟踪</span></span><br><span class="line">	<span class="comment">//点间块中继</span></span><br><span class="line">	ReceivedAt   time.Time</span><br><span class="line">	ReceivedFrom <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Header表示以太坊区块链中的区块头</span></span><br><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">	ParentHash  common.Hash    <span class="string">`json:&quot;parentHash&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">	UncleHash   common.Hash    <span class="string">`json:&quot;sha3Uncles&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">	Coinbase    common.Address <span class="string">`json:&quot;miner&quot;`</span></span><br><span class="line">	Root        common.Hash    <span class="string">`json:&quot;stateRoot&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">	TxHash      common.Hash    <span class="string">`json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">	ReceiptHash common.Hash    <span class="string">`json:&quot;receiptsRoot&quot;     gencodec:&quot;required&quot;`</span></span><br><span class="line">	Bloom       Bloom          <span class="string">`json:&quot;logsBloom&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">	Difficulty  *big.Int       <span class="string">`json:&quot;difficulty&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">	Number      *big.Int       <span class="string">`json:&quot;number&quot;           gencodec:&quot;required&quot;`</span></span><br><span class="line">	GasLimit    <span class="type">uint64</span>         <span class="string">`json:&quot;gasLimit&quot;         gencodec:&quot;required&quot;`</span></span><br><span class="line">	GasUsed     <span class="type">uint64</span>         <span class="string">`json:&quot;gasUsed&quot;          gencodec:&quot;required&quot;`</span></span><br><span class="line">	Time        <span class="type">uint64</span>         <span class="string">`json:&quot;timestamp&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">	Extra       []<span class="type">byte</span>         <span class="string">`json:&quot;extraData&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">	MixDigest   common.Hash    <span class="string">`json:&quot;mixHash&quot;`</span></span><br><span class="line">	Nonce       BlockNonce     <span class="string">`json:&quot;nonce&quot;`</span></span><br><span class="line">	<span class="comment">// BaseFee由EIP-1559添加，在遗留的报头中被忽略</span></span><br><span class="line">	BaseFee *big.Int <span class="string">`json:&quot;baseFeePerGas&quot; rlp:&quot;optional&quot;`</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Blockchain区块链数据结构"><a href="#Blockchain区块链数据结构" class="headerlink" title="Blockchain区块链数据结构"></a>Blockchain区块链数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/blockchain.go</span></span><br><span class="line"><span class="comment">// 区块链还有助于从数据库中包含的任何链中返回块，以及代表规范链的块。值得注意的是，GetBlock可以返回任何块，而不需要包含在规范块	中，因为GetBlockByNumber总是代表规范链。</span></span><br><span class="line"><span class="keyword">type</span> BlockChain <span class="keyword">struct</span> &#123;</span><br><span class="line">	chainConfig *params.ChainConfig <span class="comment">// 链和网络配置</span></span><br><span class="line">	cacheConfig *CacheConfig        <span class="comment">// 缓存配置修剪</span></span><br><span class="line">	db            ethdb.Database                   <span class="comment">// 用于存储最终内容的底层持久数据库</span></span><br><span class="line">	snaps         *snapshot.Tree                   <span class="comment">// 快照树快速单词查找树的叶子的访问</span></span><br><span class="line">	triegc        *prque.Prque[<span class="type">int64</span>, common.Hash] <span class="comment">// 优先级队列映射块编号到尝试gc</span></span><br><span class="line">	gcproc        time.Duration                    <span class="comment">// Trie转储的累积规范块处理</span></span><br><span class="line">	lastWrite     <span class="type">uint64</span>                           <span class="comment">// 刷新状态时的最后一个块</span></span><br><span class="line">	flushInterval atomic.Int64                     <span class="comment">// 刷新状态的时间间隔(处理时间)</span></span><br><span class="line">	triedb        *trie.Database                   <span class="comment">// 用于维护trie节点的数据库处理程序。</span></span><br><span class="line">	stateCache    state.Database                   <span class="comment">// 要在导入之间重用的状态数据库（包含状态缓存）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// txlookupllimit是从head中保留tx索引的最大块数:</span></span><br><span class="line">    <span class="comment">// * 0:表示没有限制，并重新生成任何缺失的索引</span></span><br><span class="line">    <span class="comment">// * N:表示N块限制[HEAD-N+1, HEAD]，并删除多余的索引</span></span><br><span class="line">    <span class="comment">// * nil:禁用tx索引器/删除器，但仍然索引新的块</span></span><br><span class="line">	txLookupLimit <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">	hc            *HeaderChain				<span class="comment">// 只包含了区块头的区块链</span></span><br><span class="line">	rmLogsFeed    event.Feed  				<span class="comment">// 下面是很多消息通知的组件</span></span><br><span class="line">	chainFeed     event.Feed</span><br><span class="line">	chainSideFeed event.Feed</span><br><span class="line">	chainHeadFeed event.Feed</span><br><span class="line">	logsFeed      event.Feed</span><br><span class="line">	blockProcFeed event.Feed</span><br><span class="line">	scope         event.SubscriptionScope</span><br><span class="line">	genesisBlock  *types.Block				<span class="comment">// 创世区块</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//同步互斥锁链的写操作。</span></span><br><span class="line">	<span class="comment">//读者不需要拿，他们可以直接读取数据库。</span></span><br><span class="line">	chainmu *syncx.ClosableMutex</span><br><span class="line"></span><br><span class="line">	currentBlock      atomic.Pointer[types.Header] <span class="comment">// 当前链头</span></span><br><span class="line">	currentSnapBlock  atomic.Pointer[types.Header] <span class="comment">// 当前快照同步头</span></span><br><span class="line">	currentFinalBlock atomic.Pointer[types.Header] <span class="comment">// 最新(共识)完成的区块</span></span><br><span class="line">	currentSafeBlock  atomic.Pointer[types.Header] <span class="comment">// 最新的(共识)安全的块</span></span><br><span class="line"></span><br><span class="line">	bodyCache     *lru.Cache[common.Hash, *types.Body]</span><br><span class="line">	bodyRLPCache  *lru.Cache[common.Hash, rlp.RawValue]</span><br><span class="line">	receiptsCache *lru.Cache[common.Hash, []*types.Receipt]</span><br><span class="line">	blockCache    *lru.Cache[common.Hash, *types.Block]</span><br><span class="line">	txLookupCache *lru.Cache[common.Hash, *rawdb.LegacyTxLookupEntry]</span><br><span class="line"></span><br><span class="line">	<span class="comment">//未来块是为以后的处理添加的块</span></span><br><span class="line">	futureBlocks *lru.Cache[common.Hash, *types.Block]</span><br><span class="line"></span><br><span class="line">	wg            sync.WaitGroup </span><br><span class="line">	quit          <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;  <span class="comment">//关闭信号，在停止中关闭。</span></span><br><span class="line">	stopping      atomic.Bool    <span class="comment">//如果链正在运行则为false，停止时为true</span></span><br><span class="line">	procInterrupt atomic.Bool    <span class="comment">//块处理的中断信号</span></span><br><span class="line"></span><br><span class="line">	engine     consensus.Engine <span class="comment">// 一致性引擎</span></span><br><span class="line">	validator  Validator 		<span class="comment">// 块和状态验证者接口</span></span><br><span class="line">	prefetcher Prefetcher</span><br><span class="line">	processor  Processor 		<span class="comment">// 块交易处理程序接口</span></span><br><span class="line">	forker     *ForkChoice</span><br><span class="line">	vmConfig   vm.Config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><p>NewBlockChain：返回一个使用数据库中可用信息的完全初始化的区块链。它初始化了默认的以太坊验证器和处理器。</p>
<p>loadLastState：从数据库中加载最后一个已知的链状态。此方法假定持有链管理器互斥锁。</p>
<p>Reset：清除整个区块链，将其恢复到初始状态。</p>
<p>SetHead：将本地链倒回到一个新的头。根据节点是快速同步还是完全同步以及处于哪种状态，该方法将尝试从磁盘中删除最小的数据，同时保持链的一致性。</p>
<p>InsertChain：尝试将给定批次的块插入到规范链中，否则，创建一个分叉。如果返回一个错误，它将返回失败块的索引号以及描述错误的错误。插入完成后，将触发所有累积的事件。</p>
<p>insertChain：是InsertChain的内部实现，它假设链是连续的，且 链互斥锁被持有。这个方法被分离出来，这样需要重新注入历史块的导入批可以在不释放锁的情况下完成，否则会导致不稳定的行为。如果侧链导入正在进行中，并且导入了历史状态，但是在实际侧链完成之前添加了新的canon-head，则可以再次修剪历史状态</p>
<p>writeblockandsehead将给定块和所有相关状态写入数据库，并应用该块作为新的链头。</p>
<p>reorg：获取两个区块，一个旧链和一个新链，并将重建区块并将它们插入到新的规范链中，并积累潜在的缺失交易并发布关于它们的事件。注意，这里不会处理新的头部块，调用者需要在外部处理它。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/10/27/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/03-Transaction%E4%BA%A4%E6%98%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/27/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/03-Transaction%E4%BA%A4%E6%98%93/" class="post-title-link" itemprop="url">03-Transaction交易</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-27 00:00:00" itemprop="dateCreated datePublished" datetime="2022-10-27T00:00:00+08:00">2022-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-09 10:01:34" itemprop="dateModified" datetime="2023-11-09T10:01:34+08:00">2023-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">以太坊源码</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Transaction-一个交易的生老病死"><a href="#Transaction-一个交易的生老病死" class="headerlink" title="Transaction: 一个交易的生老病死"></a>Transaction: 一个交易的生老病死</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们知道，<strong>Ethereum的基本模型是基于交易的状态机模型</strong>(Transaction-based State Machine)，Transaction是Ethereum执行数据操作的媒介，它主要起到下面的几个作用:</p>
<ol>
<li>在Layer-1网络上的Account之间进行Native Token的转账。</li>
<li>创建新的Contract。</li>
<li>调用Contract中会修改目标Contract中持久化数据或者间接修改其他Account&#x2F;Contract数据的函数。</li>
</ol>
<p>这里我们对Transaction的功能性的细节再进行一些额外的补充。首先，<strong>Transaction只能创建Contract账户，而不能用于创建外部账户</strong>(EOA)。第二，<strong>如果调用Contract中的只读函数，是不需要构造Transaction</strong>的。相对的，所有参与Account&#x2F;Contract数据修改的操作都需要通过Transaction来进行。第三，广义上的Transaction只能由外部账户(EOA)构建。Contract是没有办法显式构造Layer-1层面的交易的。在某些合约函数的执行过程中，Contract在可以通过构造internal transaction来与其他的合约进行交互，但是这种Internal transaction与我们提到的Layer-1层面的交易有所不同，我们会在之后的章节介绍。</p>
<h2 id="LegacyTx-AccessListTX-DynamicFeeTx"><a href="#LegacyTx-AccessListTX-DynamicFeeTx" class="headerlink" title="LegacyTx &amp; AccessListTX &amp; DynamicFeeTx"></a>LegacyTx &amp; AccessListTX &amp; DynamicFeeTx</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/types/transaction.go</span></span><br><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line"> inner TxData    <span class="comment">// 交易的共识内容</span></span><br><span class="line"> time  time.Time <span class="comment">// 首次在本地看到的时间(避免垃圾邮件)</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 缓存</span></span><br><span class="line"> hash atomic.Value</span><br><span class="line"> size atomic.Value</span><br><span class="line"> from atomic.Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们需要重点关注一下<code>inner</code>这个变量。目前与Transaction直接相关的数据都由这个变量来维护。</p>
<p>目前，<code>TxData</code>类型是一个接口，它的定义如下面的代码所示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TxData <span class="keyword">interface</span> &#123;</span><br><span class="line">	txType() <span class="type">byte</span> <span class="comment">// returns the type ID</span></span><br><span class="line">	<span class="built_in">copy</span>() TxData <span class="comment">// 创建一个深拷贝和初始化所有字段</span></span><br><span class="line"></span><br><span class="line">	chainID() *big.Int</span><br><span class="line">	accessList() AccessList</span><br><span class="line">	data() []<span class="type">byte</span></span><br><span class="line">	gas() <span class="type">uint64</span></span><br><span class="line">	gasPrice() *big.Int</span><br><span class="line">	gasTipCap() *big.Int</span><br><span class="line">	gasFeeCap() *big.Int</span><br><span class="line">	value() *big.Int</span><br><span class="line">	nonce() <span class="type">uint64</span></span><br><span class="line">	to() *common.Address</span><br><span class="line">	blobGas() <span class="type">uint64</span></span><br><span class="line">	blobGasFeeCap() *big.Int</span><br><span class="line">	blobHashes() []common.Hash</span><br><span class="line"></span><br><span class="line">	rawSignatureValues() (v, r, s *big.Int)</span><br><span class="line">	setSignatureValues(chainID, v, r, s *big.Int)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在给定包含区块baseFee的情况下，计算交易支付的gas价格。</span></span><br><span class="line">    <span class="comment">//不像其他TxData方法，返回*大。Int应该是计算值的独立副本，即允许调用者改变结果。</span></span><br><span class="line">    <span class="comment">//方法实现可以使用&#x27;dst&#x27;来存储结果。</span></span><br><span class="line">	effectiveGasPrice(dst *big.Int, baseFee *big.Int) *big.Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来的TxData现在被声明成了一个interface，是为了后续版本的更新中可以对Transaction类型进行更加灵活的修改。目前，在Ethereum中定义了三种类型的Transaction来实现TxData这个接口。按照时间上的定义顺序来说，这三种类型的Transaction分别是，LegacyT，AccessListTx，TxDynamicFeeTx。</p>
<p>LegacyTx：是原始的Ethereum的Transaction设计</p>
<p>AccessListTX：是基于EIP-2930(Berlin分叉)的Transaction。</p>
<p>DynamicFeeTx：是<a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559</a>(伦敦分叉)生效之后的默认的Transaction。</p>
<h3 id="LegacyTx"><a href="#LegacyTx" class="headerlink" title="LegacyTx"></a>LegacyTx</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LegacyTx <span class="keyword">struct</span> &#123;</span><br><span class="line"> Nonce    <span class="type">uint64</span>          <span class="comment">// nonce of sender account</span></span><br><span class="line"> GasPrice *big.Int        <span class="comment">// wei per gas</span></span><br><span class="line"> Gas      <span class="type">uint64</span>          <span class="comment">// gas limit</span></span><br><span class="line"> To       *common.Address <span class="string">`rlp:&quot;nil&quot;`</span> <span class="comment">// nil means contract creation</span></span><br><span class="line"> Value    *big.Int        <span class="comment">// wei amount</span></span><br><span class="line"> Data     []<span class="type">byte</span>          <span class="comment">// contract invocation input data</span></span><br><span class="line"> V, R, S  *big.Int        <span class="comment">// signature values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AccessListTX"><a href="#AccessListTX" class="headerlink" title="AccessListTX"></a>AccessListTX</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AccessListTx <span class="keyword">struct</span> &#123;</span><br><span class="line"> ChainID    *big.Int        <span class="comment">// destination chain ID</span></span><br><span class="line"> Nonce      <span class="type">uint64</span>          <span class="comment">// nonce of sender account</span></span><br><span class="line"> GasPrice   *big.Int        <span class="comment">// wei per gas</span></span><br><span class="line"> Gas        <span class="type">uint64</span>          <span class="comment">// gas limit</span></span><br><span class="line"> To         *common.Address <span class="string">`rlp:&quot;nil&quot;`</span> <span class="comment">// nil means contract creation</span></span><br><span class="line"> Value      *big.Int        <span class="comment">// wei amount</span></span><br><span class="line"> Data       []<span class="type">byte</span>          <span class="comment">// contract invocation input data</span></span><br><span class="line"> AccessList AccessList      <span class="comment">// EIP-2930 access list</span></span><br><span class="line"> V, R, S    *big.Int        <span class="comment">// signature values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DynamicFeeTx"><a href="#DynamicFeeTx" class="headerlink" title="DynamicFeeTx"></a>DynamicFeeTx</h3><p>如果我们观察DynamicFeeTx就会发现，DynamicFeeTx的定义其实就是在LegacyTx&#x2F;AccessListTX的定义的基础上额外的增加了GasTipCap与GasFeeCap这两个字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DynamicFeeTx <span class="keyword">struct</span> &#123;</span><br><span class="line"> ChainID    *big.Int</span><br><span class="line"> Nonce      <span class="type">uint64</span></span><br><span class="line"> GasTipCap  *big.Int <span class="comment">// a.k.a. maxPriorityFeePerGas</span></span><br><span class="line"> GasFeeCap  *big.Int <span class="comment">// a.k.a. maxFeePerGas</span></span><br><span class="line"> Gas        <span class="type">uint64</span></span><br><span class="line"> To         *common.Address <span class="string">`rlp:&quot;nil&quot;`</span> <span class="comment">// nil means contract creation</span></span><br><span class="line"> Value      *big.Int</span><br><span class="line"> Data       []<span class="type">byte</span></span><br><span class="line"> AccessList AccessList</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Signature values</span></span><br><span class="line"> V *big.Int <span class="string">`json:&quot;v&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line"> R *big.Int <span class="string">`json:&quot;r&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line"> S *big.Int <span class="string">`json:&quot;s&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Transaction的执行流程"><a href="#Transaction的执行流程" class="headerlink" title="Transaction的执行流程"></a>Transaction的执行流程</h2><p>Transaction的执行主要在发生在两个Workflow中:</p>
<ol>
<li><strong>Miner在打包新的Block时。此时Miner会按Block中Transaction的打包顺序来执行其中的Transaction。</strong></li>
<li><strong>其他节点添加Block到Blockchain时</strong>。当<strong>节点从网络中监听并获取到新的Block时，它们会执行Block中的Transaction</strong>，来更新本地的State Trie的 Root，并与Block Header中的State Trie Root进行比较，来验证Block的合法性。</li>
</ol>
<p>一条Transaction执行，可能会涉及到多个Account&#x2F;Contract的值的变化，最终造成一个或多个Account的State的发生转移。在<strong>Byzantium分叉之前的Geth版本中，在每个Transaction执行之后，都会计算一个当前的State Trie Root，并写入到对应的Transaction Receipt中。</strong>这符合以太坊黄皮书中的原始设计。即交易是使得Ethereum状态机发生状态状态转移的最细粒度单位。读者们可能已经来开产生疑惑了，“每个Transaction都会重算一个State Trie Root”的方式岂不是会带来大量的计算(重算一次一个MPT Path上的所有Node)和读写开销(新生成的MPT Node是很有可能最终被持久化到LevelDB中的)？结论是显然的。因此<strong>在Byzantium分叉之后，在一个Block的验证周期中只会计算一次的State Root。</strong>我们仍然可以在<code>state_processor.go</code>找寻到早年代码的痕迹。最终，一个Block中所有Transaction执行的结果使得World State发生状态转移。下面我们就来根据geth代码库中的调用关系，从Miner的视角来探索一个Transaction的生命周期。</p>
<h3 id="Native-Token-Transferring-Transaction"><a href="#Native-Token-Transferring-Transaction" class="headerlink" title="Native Token Transferring Transaction"></a>Native Token Transferring Transaction</h3><h3 id="Transaction修改Contract的持久化存储的"><a href="#Transaction修改Contract的持久化存储的" class="headerlink" title="Transaction修改Contract的持久化存储的"></a>Transaction修改Contract的持久化存储的</h3><p>在Ethereum中，当Miner开始构造新的区块的时候，首先会启动 <code>mainLoop()</code>函数。具体的函数如下所示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miner/worker.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> mainLoop() &#123;</span><br><span class="line">    ....</span><br><span class="line">    txs := <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]types.Transactions)</span><br><span class="line">    <span class="keyword">for</span> _, tx := <span class="keyword">range</span> ev.Txs &#123;</span><br><span class="line">        acc, _ := types.Sender(w.current.signer, tx)</span><br><span class="line">        txs[acc] = <span class="built_in">append</span>(txs[acc], tx)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里看到，通过NewTransactionsByPriceAndNonce获取一部分的Tx并打包</span></span><br><span class="line">    txset := types.NewTransactionsByPriceAndNonce(w.current.signer, txs, w.current.header.BaseFee)</span><br><span class="line">    tcount := w.current.tcount</span><br><span class="line">    <span class="comment">//提交打包任务</span></span><br><span class="line">    w.commitTransactions(w.current, txset, <span class="literal">nil</span>)        </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Mining新区块前，<strong>Worker首先需要决定，哪些Transaction会被打包到新的Block中</strong>。这里选取Transaction其实经历了两个步骤。首先，**<code>txs</code>变量保存了从Transaction Pool中拿到的合法的交易，以及准备好被打包的交易。**这里举一个例子，来说明什么是准备好被打包的交易，比如Alice先后发了新三个交易到网络中，对应的Nonce分别是100和101，102。假如Miner只收到了100和102号交易。那么对于此刻的Transaction Pool来说Nonce 100的交易就是准备好被打包的交易，交易Nonce 是102需要等待Nonce 101的交易被确认之后才能提交。</p>
<p>在<strong>Worker会从Transaction Pool中拿出若干的transaction, 赋值给<em>txs</em></strong>之后, 然后<strong>调用<code>NewTransactionsByPriceAndNonce</code>函数按照Gas Price和Nonce对<em>txs</em>进行排序，并将结果赋值给<em>txset</em></strong>。此外在Worker的实例中，还存在<code>fillTransactions</code>函数，为了未来定制化的给Transaction的执行顺序进行排序。</p>
<p>在<strong>拿到<em>txset</em>之后，mainLoop函数会调用<code>commitTransactions</code>函数，正式进入Mining新区块的流程</strong>。<code>commitTransactions</code>函数如下所示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> commitTransactions(env *environment,txs *types.TransactionsByPriceAndNonce,interrupt *atomic.Int32) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 首先给Block设置最大可以使用的Gas的上限</span></span><br><span class="line">    gasLimit := env.header.GasLimit</span><br><span class="line">    <span class="keyword">if</span> env.gasPool == <span class="literal">nil</span> &#123;</span><br><span class="line">		env.gasPool = <span class="built_in">new</span>(core.GasPool).AddGas(gasLimit)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 函数的主体是一个For循环</span></span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">    	.....</span><br><span class="line">        <span class="comment">// 如果我们没有足够的gas进行任何进一步的交易，循环结束</span></span><br><span class="line">		<span class="keyword">if</span> env.gasPool.Gas() &lt; params.TxGas &#123;</span><br><span class="line">			log.Trace(<span class="string">&quot;Not enough gas for further transactions&quot;</span>, <span class="string">&quot;have&quot;</span>, env.gasPool, <span class="string">&quot;want&quot;</span>, params.TxGas)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">        tx := txs.Peek()</span><br><span class="line">        <span class="keyword">if</span> tx == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">// 开始执行交易</span></span><br><span class="line">        env.state.SetTxContext(tx.Hash(), env.tcount)</span><br><span class="line">        logs, err := w.commitTransaction(env, tx)</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>commitTransactions</code>函数的主体是一个for循环，<strong>每次获取结构体切片头部的txs.Peek()的transaction</strong>，并作为参数调用函数miner&#x2F;worker.go的<code>commitTransaction()</code>。<code>commitTransaction()</code>函数如下所示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> commitTransaction(env *environment, tx *types.Transaction) ([]*types.Log, <span class="type">error</span>)&#123;</span><br><span class="line">    <span class="comment">// 在每次commitTransaction执行前都要记录当前StateDB的Snapshot,一旦交易执行失败则基于这个Snapshot进行回滚。</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">		snap = env.state.Snapshot()</span><br><span class="line">		gp   = env.gasPool.Gas()</span><br><span class="line">	)</span><br><span class="line">    <span class="comment">// 调用执行Transaction的函数</span></span><br><span class="line">    receipt, err := core.ApplyTransaction(w.chainConfig, w.chain, &amp;env.coinbase, env.gasPool, env.state, env.header, tx, &amp;env.header.GasUsed, *w.chain.GetVMConfig())</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Blockchain系统中的<strong>Transaction</strong>和DBMS中的Transaction一样，<strong>要么完成要么失败</strong>。所以在调用执行Transaction的函数前，<strong>首先记录了一下当前world state的Snapshot，用于交易失败时回滚操作</strong>。之后调用ApplyTransaction()函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/state_processor.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ApplyTransaction</span><span class="params">(config *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.StateDB, header *types.Header, tx *types.Transaction, usedGas *<span class="type">uint64</span>, cfg vm.Config)</span></span> (*types.Receipt, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 将Transaction 转化为Message的形式</span></span><br><span class="line">    msg, err := TransactionToMessage(tx, types.MakeSigner(config, header.Number, header.Time), header.BaseFee)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建要在EVM环境中使用的新上下文</span></span><br><span class="line">    blockContext := NewEVMBlockContext(header, bc, author)</span><br><span class="line">    vmenv := vm.NewEVM(blockContext, vm.TxContext&#123;&#125;, statedb, config, cfg)</span><br><span class="line">    <span class="comment">// 调用执行Contract的函数</span></span><br><span class="line">    <span class="keyword">return</span> applyTransaction(msg, config, gp, statedb, header.Number, header.Hash(), tx, usedGas, vmenv)</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p><strong>在 ApplyTransaction()函数中首先Transaction会被转换成Message的形式。</strong>在执行每一个Transaction的时候，<strong>都会生成一个新的EVM来执行</strong>。之后调用applyTransaction()函数来执行Message。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/state_processor.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applyTransaction</span><span class="params">(msg *Message, config *params.ChainConfig, gp *GasPool, statedb *state.StateDB, blockNumber *big.Int, blockHash common.Hash, tx *types.Transaction, usedGas *<span class="type">uint64</span>, evm *vm.EVM)</span></span> (*types.Receipt, <span class="type">error</span>) &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 将交易应用到当前状态(包含在环境中)。</span></span><br><span class="line">    result, err := ApplyMessage(evm, msg, gp)</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>之后调用ApplyMessage()函数。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/state_transition.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ApplyMessage</span><span class="params">(evm *vm.EVM, msg Message, gp *GasPool)</span></span> (*ExecutionResult, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> NewStateTransition(evm, msg, gp).TransitionDb()</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p><strong>之后调用TransitionDb()函数。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/state_transition.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *StateTransition)</span></span> TransitionDb() (*ExecutionResult, <span class="type">error</span>) &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">var</span> contractCreation = msg.To == <span class="literal">nil</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">if</span> contractCreation &#123;</span><br><span class="line">        <span class="comment">//创建合约</span></span><br><span class="line">		ret, _, st.gasRemaining, vmerr = st.evm.Create(sender, msg.Data, st.gasRemaining, msg.Value)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 增加下一个交易的nonce</span></span><br><span class="line">		st.state.SetNonce(msg.From, st.state.GetNonce(sender.Address())+<span class="number">1</span>)</span><br><span class="line">		ret, st.gasRemaining, vmerr = st.evm.Call(sender, st.to(), msg.Data, st.gasRemaining, msg.Value)</span><br><span class="line">	&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>之后调用Call()函数</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/vm/evm.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(evm *EVM)</span></span> Call(caller ContractRef, addr common.Address, input []<span class="type">byte</span>, gas <span class="type">uint64</span>, value *big.Int) (ret []<span class="type">byte</span>, leftOverGas <span class="type">uint64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 执行合约</span></span><br><span class="line">    ret, err = evm.interpreter.Run(contract, input, <span class="literal">false</span>)</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>之后调用Run()函数。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/vm/interpreter.go</span></span><br><span class="line"><span class="comment">// Run循环并使用给定的输入数据计算合约代码，并返回返回的字节片，如果发生错误则返回一个错误。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(in *EVMInterpreter)</span></span> Run(contract *Contract, input []<span class="type">byte</span>, readOnly <span class="type">bool</span>) (ret []<span class="type">byte</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    ....</span><br><span class="line">    op = contract.GetOp(pc)</span><br><span class="line">    operation := in.cfg.JumpTable[op]</span><br><span class="line">    cost = operation.constantGas <span class="comment">// For tracing</span></span><br><span class="line">    <span class="comment">// UseGas 函数：当前剩余的gas减去操作所需gas</span></span><br><span class="line">    <span class="comment">// 剩余的gas小于input直接返回false</span></span><br><span class="line">    <span class="comment">// 否则当前的gas减去操作所需gas并返回true</span></span><br><span class="line">    <span class="keyword">if</span> !contract.UseGas(cost) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrOutOfGas</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">    res, err = operation.execute(&amp;pc, in, callContext)</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在更细粒度的层面<strong>，每个opcode循环调用core&#x2F;vm&#x2F;jump_table.go中的execute函数</strong>。这里值得一提的是，获取Contract中每条Operate的方式，是从Contact中的code数组中按照第n个拿取。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/vm/contract.go</span></span><br><span class="line"><span class="comment">// GetOp返回合约字节数组中的第n个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Contract)</span></span> GetOp(n <span class="type">uint64</span>) OpCode &#123;</span><br><span class="line"> <span class="keyword">return</span> OpCode(c.GetByte(n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>OPCODE的具体实现代码位于core&#x2F;vm&#x2F;instructor.go文件中</strong>。比如，<strong>对Contract中持久化数据修改的OPSSTORE指令的实现位于opStore()函数中</strong>。而<strong>opStore的函数的具体操作又是调用了StateDB中的SetState函数</strong>，将Go-ethereum中的几个主要的模块串联了起来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">opSstore</span><span class="params">(pc *<span class="type">uint64</span>, interpreter *EVMInterpreter, scope *ScopeContext)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    loc := scope.Stack.pop()</span><br><span class="line">    val := scope.Stack.pop()</span><br><span class="line">    <span class="comment">//根据指令跟地址来修改StateDB中某一存储位置的值。</span></span><br><span class="line">    interpreter.evm.StateDB.SetState(scope.Contract.Address(),loc.Bytes32(), val.Bytes32())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//core/state/stateDB</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> SetState(addr common.Address, key, value common.Hash) &#123;</span><br><span class="line">    stateObject := s.GetOrNewStateObject(addr)</span><br><span class="line">    <span class="keyword">if</span> stateObject != <span class="literal">nil</span> &#123;</span><br><span class="line">    	stateObject.SetState(s.db, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于一条调用合约函数的交易，其中必然会存在修改StateDB的操作。通过上述的函数调用关系，我们就完成了在一个新区块的形成过程中，Transaction如何修改StateDB的Workflow。</p>
</blockquote>
<p>commitTransactions –&gt; commitTransaction –&gt; ApplyTransaction –&gt; applyTransaction –&gt;  ApplyMessage –&gt; TransactionDB –&gt; Call –&gt; Run –&gt; opSstore –&gt; StateDB –&gt; StateObject –&gt; Key-Value-Trie</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">commitTransactions --&gt; commitTransaction --&gt; ApplyTransaction --&gt; applyTransaction --&gt;  ApplyMessage --&gt; TransactionDB --&gt; Call --&gt; Run --&gt; opSstore --&gt; StateDB --&gt; StateObject --&gt; Key-Value-Trie</span><br></pre></td></tr></table></figure>

<p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/img/tx_exec_calls.png" alt="Transaction Execution stack Flow"></p>
<h2 id="Validator-验证节点如何执行Transaction并更新World-State"><a href="#Validator-验证节点如何执行Transaction并更新World-State" class="headerlink" title="[Validator] 验证节点如何执行Transaction并更新World State"></a>[Validator] 验证节点如何执行Transaction并更新World State</h2><p>而<strong>对于不参与Mining的节点，他们执行Block中Transaction的入口是在core&#x2F;blockchain.go中的InsertChain()函数</strong>。InsertChain函数通过<strong>调用内部函数insertChain</strong>，其中<strong>调用中的core&#x2F;state_processor.go中的Process()函数</strong>。<strong>Process函数的核心在于循环遍历Block中的Transaction</strong>，调<strong>用上述的applyTransaction函数。从这里开始更底层的调用关系就与Mining Workflow中的调用关系相同。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *StateProcessor)</span></span> Process(block *types.Block, statedb *state.StateDB, cfg vm.Config) (types.Receipts, []*types.Log, <span class="type">uint64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	....</span><br><span class="line">	<span class="keyword">for</span> i, tx := <span class="keyword">range</span> block.Transactions() &#123;</span><br><span class="line">		msg, err := TransactionToMessage(tx, signer, header.BaseFee)</span><br><span class="line">		statedb.SetTxContext(tx.Hash(), i)</span><br><span class="line">		receipt, err := applyTransaction(msg, p.config, gp, statedb, blockNumber, blockHash, tx, usedGas, vmenv)</span><br><span class="line">		....</span><br><span class="line">	&#125;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="State-based-Blockchain：基于状态的区块链"><a href="#State-based-Blockchain：基于状态的区块链" class="headerlink" title="State-based Blockchain：基于状态的区块链"></a>State-based Blockchain：基于状态的区块链</h2><ul>
<li>State-based Blockchain 的数据主要由两部分的数据管理模块组成：World State 和 Blockchain。</li>
<li>State Object是系统中基于K-V结构的基础数据元素。在Ethereum中，State Object是Account。</li>
<li>World State表示了System中所有State Object的最新值的一个Snapshot，。</li>
<li>Blockchain是以块为单位的数据结构，每个块中包含了若干Transaction。Blockchain 可以被视为历史交易数据的组合。</li>
<li>Transaction是Blockchain System中与承载数据更新的载体。通过Transaction，State Object从当前状态切换到另一个状态。</li>
<li>World State的更新是以Block为单位的。</li>
</ul>
<h2 id="Read-Transaction-from-Database：从数据库读取交易"><a href="#Read-Transaction-from-Database：从数据库读取交易" class="headerlink" title="Read Transaction from Database：从数据库读取交易"></a>Read Transaction from Database：从数据库读取交易</h2><p>当我们想要通过Transaction的Hash查询一个Transaction具体的数据的时候，上层的API会调用<code>eth/api_backend.go</code>中的<code>GetTransaction()</code>函数，并最终调用了<code>core/rawdb/accessors_indexes.go</code>中的<code>ReadTransaction()</code>函数来查询。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eth/api_backend.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *EthAPIBackend)</span></span> GetTransaction(ctx context.Context, txHash common.Hash) (*types.Transaction, common.Hash, <span class="type">uint64</span>, <span class="type">uint64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	tx, blockHash, blockNumber, index := rawdb.ReadTransaction(b.eth.ChainDb(), txHash)</span><br><span class="line">	<span class="keyword">return</span> tx, blockHash, blockNumber, index, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里值得注意的是，在读取Transaction的时候，<code>ReadTransaction()</code>函数<strong>首先获取了保存该Transaction的函数block body</strong>，并<strong>循环遍历该Block Body中获取到对应的Transaction</strong>。这是因为，虽然<strong>Transaction是作为一个基本的数据结构</strong>(Transaction Hash可以保证Transaction的唯一性)，但是<strong>在写入数据库的时候就是被按照Block Body的形式被整个的打包写入到Database中</strong>的。具体的可以查看<code>core/rawdb/accesssor_chain.go</code>中的<code>WriteBlock()</code>和<code>WriteBody()</code>函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadTransaction</span><span class="params">(db ethdb.Reader, hash common.Hash)</span></span> (*types.Transaction, common.Hash, <span class="type">uint64</span>, <span class="type">uint64</span>) &#123;</span><br><span class="line">	blockNumber := ReadTxLookupEntry(db, hash)</span><br><span class="line">	<span class="keyword">if</span> blockNumber == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, common.Hash&#123;&#125;, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	blockHash := ReadCanonicalHash(db, *blockNumber)</span><br><span class="line">	<span class="keyword">if</span> blockHash == (common.Hash&#123;&#125;) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, common.Hash&#123;&#125;, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 保存该Transaction的函数block body</span></span><br><span class="line">	body := ReadBody(db, blockHash, *blockNumber)</span><br><span class="line">	<span class="keyword">if</span> body == <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(<span class="string">&quot;Transaction referenced missing&quot;</span>, <span class="string">&quot;number&quot;</span>, *blockNumber, <span class="string">&quot;hash&quot;</span>, blockHash)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, common.Hash&#123;&#125;, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> txIndex, tx := <span class="keyword">range</span> body.Transactions &#123;</span><br><span class="line">		<span class="keyword">if</span> tx.Hash() == hash &#123;</span><br><span class="line">			<span class="keyword">return</span> tx, blockHash, *blockNumber, <span class="type">uint64</span>(txIndex)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	log.Error(<span class="string">&quot;Transaction not found&quot;</span>, <span class="string">&quot;number&quot;</span>, *blockNumber, <span class="string">&quot;hash&quot;</span>, blockHash, <span class="string">&quot;txhash&quot;</span>, hash)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, common.Hash&#123;&#125;, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/10/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/02-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/02-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">02-状态管理</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-21 00:00:00" itemprop="dateCreated datePublished" datetime="2022-10-21T00:00:00+08:00">2022-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">以太坊源码</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="状态管理一-StateDB"><a href="#状态管理一-StateDB" class="headerlink" title="状态管理一: StateDB"></a>状态管理一: StateDB</h1><p> Ethereum State 管理模块中最重要的几个数据结构：<strong>StateDB, Trie，StateTrie，以及 StackTrie</strong>。我们将通过分析Ethereum中的主workflow的方式来深入理解这三个数据结构的使用场景，以及设计上的不同。</p>
<p>首先，<strong>StateDB是这三个数据结构中最高层的封装</strong>，它是<strong>直接提供了与StateObject (Account，Contract)相关的 CURD 的接口</strong>给其他的模块，比如：</p>
<ul>
<li>Mining 模块，执行新 Blockchain 中的交易形成新的 world state。</li>
<li>Block 同步模块，执行新 Blockchain 中的交易形成新的 world state，与header中的 state root 进行比较验证。</li>
<li>EVM 中的两个与 Contract 中的持久化存储相关的两个 opcode, sStore, sSload.</li>
</ul>
<h2 id="StateDB：状态数据库"><a href="#StateDB：状态数据库" class="headerlink" title="StateDB：状态数据库"></a>StateDB：状态数据库</h2><p>我们可以在 genesis block 创建的相关代码中，找到直接相关的例子。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">statedb.Commit(<span class="literal">false</span>)</span><br><span class="line">statedb.Database().TrieDB().Commit(root,<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>具体 World State 的更新顺序是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">StateDB --&gt; Memory_Trie_Database --&gt; LevelDB</span><br></pre></td></tr></table></figure>

<p>StateDB 调用 <code>Commit</code> 的时候并没有同时触发 <code>TrieDB</code> 的 Commit 。</p>
<p>在Block被插入到 Blockchain 的这个Workflow中，<strong>stateDB的commit首先在<code>writeBlockWithState</code>函数中被调用了</strong>。之后<code>writeBlockWithState</code>函数会判断 <code>GC</code> 的状态来决定在本次调用中，<strong>是否需要向 <code>Disk Database</code> 写入数据</strong>。</p>
<h3 id="From-Memory-to-Disk：存储到硬盘"><a href="#From-Memory-to-Disk：存储到硬盘" class="headerlink" title="From Memory to Disk：存储到硬盘"></a>From Memory to Disk：存储到硬盘</h3><p>当新的Block被添加到Blockchain时，State 的数据并不一会立即被写入到 Disk Database 中。在<code>writeBlockWithState</code>函数中，函数会判断 <code>gc</code> 条件，<strong>只有满足一定的条件</strong>，才<strong>会在此刻调用 TrieDB 中的 <code>Cap</code> 或者 <code>Commit</code> 函数将数据写入Disk Database中</strong>。</p>
<h1 id="状态管理二-World-State-Trie-and-Storage-Trie"><a href="#状态管理二-World-State-Trie-and-Storage-Trie" class="headerlink" title="状态管理二: World State Trie and Storage Trie"></a>状态管理二: World State Trie and Storage Trie</h1><h2 id="Trie-概述"><a href="#Trie-概述" class="headerlink" title="Trie 概述"></a>Trie 概述</h2><p><strong>Trie 结构是 Ethereum 中用于管理数据的基本数据结构</strong>，它被广泛的运用在Ethereum 里的多个模块中，包括管理全局的 <strong>World State Trie</strong>，管理 <strong>Contract中持久化存储的Storage Trie</strong>，以及每个 Block 中的<strong>与交易相关的 Transaction Trie 和 Receipt Trie。</strong></p>
<p>在以太坊的体系中，广义上的 <strong>Trie 的指的是 Merkel Patricia Trie(MPT)<strong>这种数据结构。在实际的实现中，根据业务功能的不同，在 go-ethereum 中</strong>一共实现了三种不同的MPT的instance</strong>，分别是，<code>Trie</code>，<code>State Trie</code>(<code>Secure Trie</code>) 以及<code>Stack Trie</code>.</p>
<p>这些Trie在具体实现上的不同点在于，<strong>Transaction Trie本质上并没有使用Trie来管理Transaction的数据</strong>，而是<strong>依赖于MPT的根来快速验证</strong>，具体可以参考<strong>core&#x2F;types&#x2F;hashing.go&#x2F;DeriveSha()函数</strong>来了解Transaction Trie 的<strong>root是如何产生的</strong>，这里的Trie使用的是Stack Trie。</p>
<p>从调用关系上看 <code>Trie</code> 是最底层的核心结构，它<strong>用于之间负责 StateObject 数据的保存</strong>，以及提<strong>供相应的 CURD 函数</strong>。它的定义在trie&#x2F;trie.go文件中。</p>
<p><strong>State Trie 结构本质上是对 Trie 的一层封装</strong>。它具体的CURD操作的实现都是通过<code>Trie</code>中定义的函数来执行的。它的定义在<code>trie/secure_trie.go</code>文件中。这个 Trie 也就是我们常说的World State Trie，它是<strong>唯一的一个全局 Trie 结构</strong>。与 Trie 不同的是，<strong>Secure Trie要求新加入的Key-Value pair中的Key 的数据都是Sha过的。</strong>这是为了防止恶意的构造Key来增加MPT的高度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StateTrie <span class="keyword">struct</span> &#123;</span><br><span class="line"> trie             Trie</span><br><span class="line"> preimages        *preimageStore</span><br><span class="line"> hashKeyBuf       [common.HashLength]<span class="type">byte</span></span><br><span class="line"> secKeyCache      <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">byte</span></span><br><span class="line"> secKeyCacheOwner *StateTrie <span class="comment">// 指向self的指针，在不匹配时替换键缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不管是Secure Trie还是Trie，他们的创建的前提是: 更下层的db的实例已经创建成功了，否则就会报错</strong>。</p>
<p>值得注意的是一个<strong>关键函数Prove(证明构造merkle关键证据。结果包含所有编码节点的路径在关键的值。价值本身也包含在最后一个节点,可以通过验证证明检索)的实现</strong>，并不在这两个Trie的定义文件中，而是位于<code>trie/proof.go</code>文件中。</p>
<h2 id="Trie-运用"><a href="#Trie-运用" class="headerlink" title="Trie 运用"></a>Trie 运用</h2><h3 id="Read-Operation：读写行动"><a href="#Read-Operation：读写行动" class="headerlink" title="Read Operation：读写行动"></a>Read Operation：读写行动</h3><h3 id="Insert：插入"><a href="#Insert：插入" class="headerlink" title="Insert：插入"></a>Insert：插入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> insert(n node, prefix, key []<span class="type">byte</span>, value node) (<span class="type">bool</span>, node, <span class="type">error</span>) &#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Update：更新"><a href="#Update：更新" class="headerlink" title="Update：更新"></a>Update：更新</h3><h3 id="Delete：删除"><a href="#Delete：删除" class="headerlink" title="Delete：删除"></a>Delete：删除</h3><h3 id="Finalize-And-Commit-to-Disk：存储到硬盘"><a href="#Finalize-And-Commit-to-Disk：存储到硬盘" class="headerlink" title="Finalize And Commit to Disk：存储到硬盘"></a>Finalize And Commit to Disk：存储到硬盘</h3><ul>
<li>在leveldb中保存的是Trie中的节点。</li>
<li>&lt;hash, node.rlprawdata&gt;</li>
</ul>
<p>在Geth中，Trie并不是实时更新的，而是依赖于Committer和Database两个额外的辅助单位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">Trie.Commit --&gt; Committer.Commit --&gt; trie/Database.insert</span><br></pre></td></tr></table></figure>

<p>我们可以看到Trie的Commit并不会真的对Disk Database的值进行修改。</p>
<p>Trie真正更新到Disk Database的，是依赖于<code>trie/Database.Commit</code>函数的调用。我们可以在诸多函数中找到这个函数的调用比如。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateChain</span><span class="params">(config *params.ChainConfig, parent *types.Block, engine consensus.Engine, db ethdb.Database, n <span class="type">int</span>, gen <span class="keyword">func</span>(<span class="type">int</span>, *BlockGen)</span></span>) ([]*types.Block, []types.Receipts) &#123;</span><br><span class="line">  ...</span><br><span class="line">   <span class="comment">// Write state changes to db</span></span><br><span class="line">   root, err := statedb.Commit(config.IsEIP158(b.header.Number))</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;state write error: %v&quot;</span>, err))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := statedb.Database().TrieDB().Commit(root, <span class="literal">false</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;trie write error: %v&quot;</span>, err))</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="StackTrie"><a href="#StackTrie" class="headerlink" title="StackTrie"></a>StackTrie</h2><p>StackTrie虽然也是MPT结构，但是它与另外的两个Trie最大的不同在于，其<strong>主要作用不是用于存储数据</strong>，而是<strong>用于给一组数据生成证明。</strong>比如，在Block中的Transaction Hash以及Receipt Hash都是基于StackTrie生成的。这里我们使用一个更直观的例子。这个部分的代码位于<em>core&#x2F;block_validator.go</em>中。在block_validator中定义了一系列验证用的函数, 比如<code>ValidateBody</code>和 <code>ValidateState</code>函数。我们选取了这两个函数的其中一部分，如下所示。为了验证Block的合法性，ValidateBody和ValidateState函数分别在本地基于Block中提供的数据来构造Transaction和Receipt的哈希来与Header中的TxHash与ReceiptHash。我们可以发现，<strong>函数<code>types.DeriveSha</code>需要一个<code>TrieHasher</code>类型的参数</strong>。但是在具体调用的时候，<strong>却传入了了一个<code>trie.NewStackTrie</code>类型的变量</strong>。这是因为StackTrie实现了TrieHasher接口所需要的三个函数，所以这种调用是合法的。我们可以在<em>core&#x2F;types&#x2F;hashing.go</em>中找到TrieHasher的定义。这里**<code>DeriveSha</code>不断的向StackTrie中添加数据，并最终返回StackTrie的Root哈希值**。</p>
<p>同时，我们可以发现，在<strong>调用DeriveSha函数</strong>的时候，我们<strong>每次都会new一个新的StackTrie</strong>作为参数。这也反映出了，<strong>StackTrie的主要作用就是生成验证用的Proof，而不是存储数据。</strong></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *BlockValidator)</span></span> ValidateBody(block *types.Block) <span class="type">error</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">if</span> hash := types.DeriveSha(block.Transactions(), trie.NewStackTrie(<span class="literal">nil</span>)); hash != header.TxHash &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;transaction root hash mismatch: have %x, want %x&quot;</span>, hash, header.TxHash)</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *BlockValidator)</span></span> ValidateState(block *types.Block, statedb *state.StateDB, receipts types.Receipts, usedGas <span class="type">uint64</span>) <span class="type">error</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">// Tre receipt Trie&#x27;s root (R = (Tr [[H1, R1], ... [Hn, Rn]]))</span></span><br><span class="line"> receiptSha := types.DeriveSha(receipts, trie.NewStackTrie(<span class="literal">nil</span>))</span><br><span class="line"> <span class="keyword">if</span> receiptSha != header.ReceiptHash &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid receipt root hash (remote: %x local: %x)&quot;</span>, header.ReceiptHash, receiptSha)</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="State-Trie的更新是什么时候发生的？"><a href="#State-Trie的更新是什么时候发生的？" class="headerlink" title="State Trie的更新是什么时候发生的？"></a>State Trie的更新是什么时候发生的？</h2><p><strong>State Trie的更新</strong>，通常是<strong>指的是基于State Trie中节点值的变化从而重新计算State Trie的Root的Hash值的过程</strong>。目前这一过程是<strong>通过调用StateDB中的<code>IntermediateRoot</code>函数来完成的。</strong></p>
<p>  我们从三个粒度层面来看待State Trie更新的问题。</p>
<ul>
<li>Block 层：<br><strong>在一个新的Block Insert到Blockchain的过程中，State Trie可能会发生多次的更新</strong>。比如，在每次Transaction被执行之后，**<code>IntermediateRoot</code>函数都会被调用<strong>。同时，</strong>更新后的 State Trie的Root值，会被写入到Transaction对应的Receipt中<strong>。请注意，</strong>在调用<code>IntermediateRoot</code>函数时，更新后的值在此时并没有被立刻写入到Disk Database中<strong>。此时的State Trie Root只是基于内存中的数据计算出来的。</strong>真正的Trie数据写盘，需要等到<code>trieDB.Commit</code>函数的执行。**</li>
<li>Transaction 层：<br>如上面提到的，在每次Transaction执行完成后，系统都会调用一次StateDB的<code>IntermediateRoot</code>函数，来更新State Trie。并且会将更新后的Trie的Root Hash写入到该Transaction对应的Receipt中。这里提一下关于<code>IntermediateRoot</code>函数细节。在<code>IntermediateRoot</code>函数调用时，会<strong>首先更新被修改的Contract的Storage Trie的Root。</strong></li>
<li>Instruction 层：<br>执行Contract的Instruction，并不会直接的引发State Trie的更新。比如，我们知道，<strong>EVM指令<code>OpSstore</code>会修改Contract中的持久化存储</strong>。这个<strong>指令调用了StateDB中的<code>SetState</code>函数</strong>，并最终<strong>调用了对应的StateObject中的<code>setState</code>函数</strong>。StateObject中的<code>setState</code> 函数并没有直接对Contract的Storage Trie进行更新，而是<strong>将修改的存储对象保存在了StateObject中的<em>dirtyStorage</em> 中</strong>(<em>dirtyStorage</em>是用于缓存Storage Slot数据的Key-Value Map). <strong>Storage Trie的更新是由更上层的函数调用所触发的，比如<code>IntermediateRoot</code>函数，以及<code>StateDB.Commit</code>函数。</strong></li>
</ul>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="幺柒YQ"
      src="/images/avater.png">
  <p class="site-author-name" itemprop="name">幺柒YQ</p>
  <div class="site-description" itemprop="description">努力坚持就会有希望</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">232</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kpyaoqi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kpyaoqi" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:18312386077@163.com" title="E-Mail → mailto:18312386077@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat.jpg" title="WeChat → images&#x2F;wechat.jpg"><i class="fa fa-fw fa-wechat"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/qq.jpg" title="QQ → images&#x2F;qq.jpg"><i class="fa fa-fw fa-qq"></i>QQ</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://stackoverflow.com/" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;" rel="noopener" target="_blank">Stackoverflow</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2021-11 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">幺柒YQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">899k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:37</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共379.4k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  


</body>
</html>
