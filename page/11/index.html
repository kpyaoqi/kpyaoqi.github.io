<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://kongpengyq.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="努力坚持就会有希望">
<meta property="og:type" content="website">
<meta property="og:title" content="YQ &amp; 博客">
<meta property="og:url" content="https://kongpengyq.com/page/11/index.html">
<meta property="og:site_name" content="YQ &amp; 博客">
<meta property="og:description" content="努力坚持就会有希望">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="幺柒YQ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://kongpengyq.com/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>YQ & 博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="YQ & 博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YQ & 博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/12/18/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/%E5%8C%BA%E5%9D%97%E9%93%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/18/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/%E5%8C%BA%E5%9D%97%E9%93%BE/" class="post-title-link" itemprop="url">区块链</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-18 00:00:00" itemprop="dateCreated datePublished" datetime="2022-12-18T00:00:00+08:00">2022-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-09 10:01:35" itemprop="dateModified" datetime="2023-11-09T10:01:35+08:00">2023-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index">
                    <span itemprop="name">区块链知识</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="智能合约中如何解决随机数的问题"><a href="#智能合约中如何解决随机数的问题" class="headerlink" title="智能合约中如何解决随机数的问题"></a>智能合约中如何解决随机数的问题</h1><p>使用区块变量，常见方法是使用<code>block.timestamp</code> 和 <code>block.difficulty</code></p>
<p>使用API：通过数字签名的方式来证明随机数是取自于某个随机数服务提供并且未被篡改过</p>
<p>Chainlink VRF：提供了一个链上去中心化的解决方案</p>
<h1 id="oracle预言机-oraclize-chainlink-TEE-SGX"><a href="#oracle预言机-oraclize-chainlink-TEE-SGX" class="headerlink" title="oracle预言机(oraclize,chainlink,TEE(SGX))"></a>oracle预言机(oraclize,chainlink,TEE(SGX))</h1><p>在区块链中，智能合约通常只能读取和修改区块链上的数据，而无法访问外部的数据源，Oracle预言机被引入到区块链中。Oracle预言机是一种中心化的服务，它可以从外部数据源获取数据，并将数据传递给智能合约。智能合约可以使用这些数据来执行相应的操作。</p>
<p>分类：</p>
<ol>
<li>中心化Oracle预言机：中心化的Oracle预言机是最简单的实现方式。它通常由一个中心化的服务提供商提供，可以从外部数据源获取数据并将数据传递给智能合约。这种实现方式具有简单、易用和高可用的特点，但也存在单点故障和安全性问题。</li>
<li>分布式Oracle预言机：分布式的Oracle预言机采用多个服务提供商来提供数据。它的实现方式可以基于共识算法（如PoS、PoW等），或者基于多方计算（MPC）协议。这种实现方式可以提高可靠性和安全性，但也增加了复杂度和成本。</li>
<li>去中心化Oracle预言机：去中心化的Oracle预言机是最安全的实现方式。它通常基于区块链技术实现，使用智能合约来管理Oracle预言机。数据由多个服务提供商提供，并经过验证后提交到智能合约中。这种实现方式具有高可靠性和高安全性的特点，但也存在复杂度高和成本高的问题。</li>
</ol>
<h1 id="event-modifier的作用和用法"><a href="#event-modifier的作用和用法" class="headerlink" title="event,modifier的作用和用法"></a>event,modifier的作用和用法</h1><p>event：</p>
<p>​	作用：应用程序通过以太坊客户端的 RPC 接口订阅和监听这些事件，外部应用程序可以根据这些通知做出相应的响应或者记录区块链的日志，日志与合约的地址关联，并记录到区块链中</p>
<p>​	用法：event ，emit，indexed关键字表示该参数可以在Event日志中被索引</p>
<p>modifier：</p>
<p>​	作用: 将一些通用的操作提取出来，包装为函数修改器，来提高代码的复用性，改善编码效率。是函数高内聚，低耦合的延伸。</p>
<p>​	用法：常用于在函数执行前检查某种前置条件。</p>
<h1 id="solidity-各大版本的新特性"><a href="#solidity-各大版本的新特性" class="headerlink" title="solidity 各大版本的新特性"></a>solidity 各大版本的新特性</h1><p>Solidity 0.7.0:</p>
<ul>
<li>支持了 try&#x2F;catch 异常处理</li>
<li>引入了 receive() 和 fallback() 函数，用于接收 Ether</li>
<li>引入了 contract 关键字，用于定义新的合约类型</li>
</ul>
<p>Solidity 0.8.0:</p>
<ul>
<li>引入了 calldata 关键字，用于指示函数参数应该在 calldata 中传递</li>
<li>支持了 struct 和 enum 的本地定义</li>
<li>支持了抽象合约（abstract contract）</li>
<li>函数参数可以标记为 immutable</li>
<li>引入了 error 关键字，用于定义错误类型</li>
</ul>
<p>Solidity 0.9.0:</p>
<ul>
<li>引入了 revert 可接受一个 string 参数</li>
<li>引入了内部可变映射（Internal Mutable Mapping）</li>
<li>引入了枚举元素间的数学操作符</li>
<li>引入了事件上的 gas 注释</li>
</ul>
<h1 id="形式化证明"><a href="#形式化证明" class="headerlink" title="形式化证明"></a>形式化证明</h1><p>形式化验证是指根据形式化规范评估系统正确性的过程。 简言之，形式化验证让我们可以检查系统的行为是否满足某些要求（即，系统按照我们的想法运作）</p>
<h1 id="contractfuzzer-模糊测试-有什么缺点"><a href="#contractfuzzer-模糊测试-有什么缺点" class="headerlink" title="contractfuzzer(模糊测试)有什么缺点"></a>contractfuzzer(模糊测试)有什么缺点</h1><ol>
<li>覆盖率限制：模糊测试<strong>通常只能测试少数路径，而不能测试所有路径</strong>，因此存在漏洞被忽略的可能性。这可能导致合约中潜在的漏洞未被发现，从而导致安全风险。</li>
<li>资源限制：使用模糊测试<strong>需要耗费大量的计算资源和时间</strong>，这可能会使得测试成本变得很高。特别是对于非常大的合约，测试过程可能需要数天或数周才能完成。</li>
<li>精度问题：尽管模糊测试可以检测出许多常见的漏洞类型，但它可能<strong>无法检测出复杂的漏洞</strong>。例如，对于需要多步操作的漏洞，模糊测试可能无法完全模拟所有必要的操作序列。</li>
<li>误报率高：模糊测试<strong>可能会产生大量误报</strong>，即将无害的代码标记为漏洞。这可能会导致开发人员在排查问题时浪费时间和精力。</li>
<li>无法解决语义问题：模糊测试通常只能检查合约的语法正确性，而不能检查合约的<strong>语义正确性</strong>。这意味着即使合约代码通过了模糊测试，仍然可能存在潜在的逻辑问题</li>
</ol>
<h1 id="以太坊中nonce的作用-防止重放攻击-，如何获得nonce"><a href="#以太坊中nonce的作用-防止重放攻击-，如何获得nonce" class="headerlink" title="以太坊中nonce的作用(防止重放攻击)，如何获得nonce"></a>以太坊中nonce的作用(防止重放攻击)，如何获得nonce</h1><p>nonce是一个递增的随机数，用于确保每笔交易是唯一的，并防止重放攻击。每个账户都有一个对应的nonce值，用于记录该账户已经发送了多少笔交易。当一个账户发送一笔交易时，交易的nonce值必须是该账户的当前nonce值加1，这样就确保了每笔交易的唯一性。</p>
<p>nonce值是公开可见的，可以通过区块浏览器等工具查询，或者web3.js、ethers.js</p>
<h1 id="如何调用他人的合约："><a href="#如何调用他人的合约：" class="headerlink" title="如何调用他人的合约："></a>如何调用他人的合约：</h1><p>通过接口方式调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface AnimalEat &#123;</span><br><span class="line">    function eat() external returns (string memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Animal &#123;</span><br><span class="line">    function test(address _addr) external returns (string memory) &#123;</span><br><span class="line">        AnimalEat general = AnimalEat(_addr);</span><br><span class="line">        return general.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过签名方式调用：三个call</p>
<h1 id="除开EVM，还知道什么虚拟机"><a href="#除开EVM，还知道什么虚拟机" class="headerlink" title="除开EVM，还知道什么虚拟机"></a>除开EVM，还知道什么虚拟机</h1><ol>
<li>Java虚拟机（JVM）：JVM是用于执行Java字节码的虚拟机，它是Java平台的核心组成部分之一。</li>
<li>NEO虚拟机（NeoVM）：NEO是一个开源的智能合约平台，它的虚拟机是NeoVM。</li>
<li>EOS虚拟机（EOS VM）：EOS是一个分散式应用平台，它使用的虚拟机是EOS VM。</li>
<li>蚂蚁区块链虚拟机（AntChain VM）微众银行虚拟机（WeBank Chain VM）百度区块链虚拟机（XuperVM）万向区块链虚拟机（WASM VM）</li>
</ol>
<p>区别：</p>
<ol>
<li>虚拟机类型：不同的区块链平台可能会使用不同类型的虚拟机，如<strong>以太坊使用基于堆栈的EVM，NEO使用基于寄存器的NeoVM等等。</strong></li>
<li>执行效率：不同的虚拟机在执行智能合约时，可能会有<strong>不同的效率和速度，这取决于虚拟机的设计和实现。</strong></li>
<li>编程语言支持：不同的虚拟机可能<strong>支持不同的编程语言和智能合约开发框架</strong>，例如以太坊支持Solidity、Vyper和Serpent等语言，NEO支持C#和Python等语言。</li>
<li>安全性和可靠性：虚拟机在执行智能合约时需要确保安全和可靠，不同的虚拟机可能会<strong>采用不同的安全机制和代码审核策略</strong>，以确保智能合约的正确性和安全性。</li>
<li><strong>社区支持和生态系统</strong>：不同的虚拟机可能有不同的社区支持和生态系统，这对于开发者和用户来说都非常重要，因为这意味着有更多的工具、文档和资源可供使用。</li>
</ol>
<h1 id="Merkle树，MPT树如何构建，有何区别-这个经常问"><a href="#Merkle树，MPT树如何构建，有何区别-这个经常问" class="headerlink" title="Merkle树，MPT树如何构建，有何区别(这个经常问)"></a>Merkle树，MPT树如何构建，有何区别(这个经常问)</h1><p>Merkle树和MPT（Merkle Patricia Trie）树都是一种<strong>哈希树数据结构</strong>，通常<strong>用于验证数据的完整性和构建区块链系统中的状态树</strong></p>
<p>构建方式：</p>
<ul>
<li><p>Merkle树：Merkle树由叶子节点和父节点组成，叶子节点是数据块的哈希值，父节点是其两个子节点的哈希值的哈希值。构建Merkle树时，需要将所有数据块的哈希值按顺序排列成叶子节点，并对相邻的叶子节点进行哈希运算，得到它们的父节点。重复这个过程，直到得到根节点，也就是整棵树的哈希值。</p>
</li>
<li><p>MPT树：健值对</p>
<ul>
<li>扩展节点（Extension Node）：只能有一个子节点。</li>
<li>分支节点（Branch Node）：可以有多个节点。</li>
<li>叶子节点（Leaf Node）：没有子节点。</li>
<li>空节点：空字符串。</li>
</ul>
<p> <img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/img/image-20230412220424100.png" alt="image-20230412220424100"></p>
</li>
</ul>
<p>区别：</p>
<ul>
<li>数据存储方式不同：<strong>Merkle树是一种二叉树，每个叶节点存储的是数据的哈希值</strong>，而非数据本身。MPT树是一种多叉树，每个节点存储的是<strong>键值对</strong>（Key-Value Pair），其中Key是数据的哈希值，而Value是数据本身。</li>
<li>数据更新方式不同：Merkle树是一种静态结构，一旦树构建完成，就<strong>不能再添加或修改数据</strong>。如果需要添加或修改数据，就需要重新构建整棵树。MPT树是一种动态结构，<strong>可以动态地添加、修改、删除数据</strong>。</li>
<li>查询方式不同：Merkle树<strong>只能支持对整个数据块的完整性进行验证</strong>，而不能支持对单个数据的验证和查询。MPT树可以<strong>支持对单个数据的验证和查询</strong>，因为每个节点存储的是Key-Value Pair，可以通过Key快速查找对应的Value。</li>
</ul>
<h1 id="以太坊是如何从POW转向POS的-Casper协议"><a href="#以太坊是如何从POW转向POS的-Casper协议" class="headerlink" title="以太坊是如何从POW转向POS的(Casper协议)"></a>以太坊是如何从POW转向POS的(Casper协议)</h1><ol>
<li>引入Casper：Casper是一种基于权益证明的共识机制，节点被分为两种角色：<strong>验证节点和提案节点。</strong>验证节点验证区块和交易的有效性，并根据其权益大小来选择提案节点。提案节点负责创建新的区块并提交到链上。</li>
<li>引入Beacon Chain：Beacon Chain是以太坊2.0版本的核心部分，是一个新的区块链，用于管理以太坊2.0中的验证器。验证器是指参与权益证明共识机制的节点，他们会投入自己的以太坊代币（ETH）来获得权益，然后运行验证器软件，对交易进行验证，并参与新块的生成。这两个区块链之间<strong>通过分片技术进行交互</strong>，共同组成了以太坊2.0的整体系统。</li>
<li>以太坊2.0上线：在经过长时间的开发和测试后，以太坊2.0于2020年12月1日正式上线。</li>
</ol>
<h1 id="以太坊使用的密码学，对两者进行介绍"><a href="#以太坊使用的密码学，对两者进行介绍" class="headerlink" title="以太坊使用的密码学，对两者进行介绍"></a>以太坊使用的密码学，对两者进行介绍</h1><p>哈希函数Keccak-256：计算数据的摘要，以确保数据的完整性和一致性</p>
<p>椭圆曲线加密算法 ECDSA：生成公钥和私钥对，并使用这些密钥对来加密和签名交易数据</p>
<h1 id="区块链怎么开启新的Epoch"><a href="#区块链怎么开启新的Epoch" class="headerlink" title="区块链怎么开启新的Epoch"></a>区块链怎么开启新的Epoch</h1><p>区块链中的<strong>Epoch是一个时间段，在该时间段内区块链网络采用相同的规则来验证和处理交易</strong>。每个Epoch的长度和开始时间都可以由区块链协议的设计者来定义。一些区块链协议（如Ethereum）使用<strong>基于区块高度的Epoch，而其他协议则使用基于时间的Epoch</strong>。</p>
<p>要开启一个新的Epoch，需要满足以下条件：</p>
<ol>
<li>规定Epoch长度：首先，设计者需要规定一个新的Epoch的长度，这通常是一定的时间段（例如1个月），也可能是特定的区块高度。</li>
<li>配置新的规则：设计者需要在新的Epoch开始之前确定新的规则，并将这些规则编码到区块链协议中。</li>
<li>更新协议版本：如果新的Epoch需要更新协议版本，则需要将新版本的协议发布到网络中。在新的Epoch开始之前，节点需要升级到新版本的协议，以确保能够正确地验证和处理交易。</li>
<li>触发新的Epoch：当达到新的Epoch的开始时间或区块高度时，节点将开始采用新的规则。新的Epoch的开始可能需要一些时间，以便所有节点都可以升级到新的协议版本并开始使用新的规则。</li>
</ol>
<p>需要注意的是，开启新的Epoch需要区块链网络中的大多数节点都同意并接受新的规则。因此，设计者需要考虑到网络中各种参与者的需求和利益，以确保新的规则得到广泛的接受和采用。</p>
<h1 id="每次fork-block的时候具体算法是什么"><a href="#每次fork-block的时候具体算法是什么" class="headerlink" title="每次fork block的时候具体算法是什么"></a>每次fork block的时候具体算法是什么</h1><ol>
<li>选择分支点：确定要创建新分支的区块链上的分支点。这个分支点通常是一个已经存在的区块，它将成为新分支的起点。</li>
<li>创建新分支：创建一个新的区块链分支，该分支从分支点开始并包含一组新的交易和一个新的区块。</li>
<li>确定新分支的长度：为了确定哪个分支是主链，需要确定每个分支的长度。这通常是通过比较每个分支的工作量来完成的。</li>
<li>解决分支冲突：如果多个节点都创建了一个新的分支，则需要解决分支冲突。这通常是通过选择具有最长长度的分支来解决的。</li>
<li>更新状态：一旦确定了主链，所有节点都将更新他们的状态，以反映新的交易和新的区块链状态。</li>
</ol>
<h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><p>是<strong>存储在区块链上的程序</strong>，它是位于以太坊区块链上一个特定地址的一系列代码（函数）和数据（状态）。 它们<strong>通常用于自动执行协议</strong>，以便所有参与者都可以立即确定结果，而<strong>无需任何中间人参与</strong>，也不会浪费时间。 它们还可以自动完成工作流程，在满足条件时触发下一个操作。</p>
<h1 id="区块链有哪些应用？"><a href="#区块链有哪些应用？" class="headerlink" title="区块链有哪些应用？"></a>区块链有哪些应用？</h1><ol>
<li>去中心化：区块链是一种去中心化的技术，没有中央机构或单一实体来管理它。相反，它<strong>由网络中的所有节点共同维护和管理</strong>。</li>
<li>不可篡改：区块链的数据是以区块的形式记录在链中，并且每个区块都包含前一个区块的哈希值。</li>
<li>透明性：区块链是公开透明的，任何人都可以查看和验证交易记录。使得区块链非常适合需要公共透明度的领域，如金融和政府监（投票选举）</li>
<li>安全性：由于区块链采用了加密技术来保护数据的完整性和安全性，因此它被认为是非常安全的技术。这使得区块链非常适合处理敏感数据和交易。</li>
<li>智能合约：区块链技术还支持智能合约，这是一种自动执行的合约，其中条件和规则被编码到合约中。这使得合约的执行非常透明和可靠，因为它们完全基于代码和算法来执行。</li>
</ol>
<p>DeFi，去中心化金融，利用区块链智能合约在链上完成资产兑换、借贷、杠杆、期货等交易。</p>
<p>数字艺术品&#x2F;NFT：唯一性、稀缺性、可交易性，通过 NFT 可使从产生到交易都可追溯，版权的保护变得更加方便。</p>
<p>数字存证&#x2F;防伪:数字身份认证确保身份信息的安全和隐私保护,技术可以被用于保护数字版权，以确保知识产权的安全和可追溯性</p>
<p>游戏:游戏数据不可篡改、玩家数据保护、虚拟物品拥有权等等的新型游戏方式</p>
<h1 id="以太坊中有哪些树（交易树、收据树、状态树）"><a href="#以太坊中有哪些树（交易树、收据树、状态树）" class="headerlink" title="以太坊中有哪些树（交易树、收据树、状态树）"></a>以太坊中有哪些树（交易树、收据树、状态树）</h1><ol>
<li>状态树（State Tree）：以太坊中的状态树是一个Merkle树，用于存储整个以太坊网络中所有账户的状态信息，包括余额、智能合约代码、合约存储器中的数据等。</li>
<li>交易树（Transaction Tree）：交易树是一个Merkle树，用于存储所有交易信息。每个区块中的交易都被添加到这个树中，并用于验证和确定区块的有效性。</li>
<li>日志树（Receipt Tree）：日志树是一个Merkle树，用于存储交易执行后的日志信息。它包含了交易执行的结果、事件触发信息等。</li>
</ol>
<h1 id="为什么需要收据树"><a href="#为什么需要收据树" class="headerlink" title="为什么需要收据树"></a>为什么需要收据树</h1><ul>
<li>向轻节点提供Merkle Proof</li>
<li>更加复杂的查找查询，比如查询过去⼗天与某⼀智能合约有关的交易、过去⼗天的众筹事件等</li>
</ul>
<h1 id="以太坊里的状态是什么，状态树怎么存的状态"><a href="#以太坊里的状态是什么，状态树怎么存的状态" class="headerlink" title="以太坊里的状态是什么，状态树怎么存的状态"></a>以太坊里的状态是什么，状态树怎么存的状态</h1><p>状态是指所有账户的集合状态，包括它们的余额、合约代码和存储在合约中的数据</p>
<p>每个账户都有一个唯一的地址（20个字节），它被用作状态树中叶子节点的键。</p>
<h1 id="以太坊的合约数据的储存形式"><a href="#以太坊的合约数据的储存形式" class="headerlink" title="以太坊的合约数据的储存形式"></a>以太坊的合约数据的储存形式</h1><p>(还是MPT。合约账户中的storage root，对应账户的storage trie)</p>
<h1 id="比特币里的交易是怎么存的"><a href="#比特币里的交易是怎么存的" class="headerlink" title="比特币里的交易是怎么存的"></a>比特币里的交易是怎么存的</h1><p>（Merkle Tree，MT）</p>
<h1 id="介绍Merkle-Tree的性质、优点，为什么用Merkle-Tree存"><a href="#介绍Merkle-Tree的性质、优点，为什么用Merkle-Tree存" class="headerlink" title="介绍Merkle Tree的性质、优点，为什么用Merkle Tree存"></a>介绍Merkle Tree的性质、优点，为什么用Merkle Tree存</h1><p>实现SPV、Merkle Proof</p>
<p>SPV是一种轻量级的验证方式，允许用户验证自己的交易和区块链数据，而无需下载和存储整个区块链的全部数据。相比于完整节点（Full Node），SPV节点只需保存区块头（block header）和一部分交易信息，可以通过少量的数据获取和验证自己的交易。</p>
<h1 id="为什么以太坊要将MT改成MPT"><a href="#为什么以太坊要将MT改成MPT" class="headerlink" title="为什么以太坊要将MT改成MPT"></a>为什么以太坊要将MT改成MPT</h1><ul>
<li>数据存储方式不同：<strong>Merkle树是一种二叉树，每个叶节点存储的是数据的哈希值</strong>，而非数据本身。MPT树是一种多叉树，每个节点存储的是<strong>键值对</strong>（Key-Value Pair），其中Key是数据的哈希值，而Value是数据本身。</li>
<li>数据更新方式不同：Merkle树是一种静态结构，一旦树构建完成，就<strong>不能再添加或修改数据</strong>。如果需要添加或修改数据，就需要重新构建整棵树。MPT树是一种动态结构，<strong>可以动态地添加、修改、删除数据</strong>。</li>
<li>查询方式不同：Merkle树<strong>只能支持对整个数据块的完整性进行验证</strong>，而不能支持对单个数据的验证和查询。MPT树可以<strong>支持对单个数据的验证和查询</strong>，因为每个节点存储的是Key-Value Pair，可以通过Key快速查找对应的Value。</li>
</ul>
<h1 id="介绍比特币的UTXO"><a href="#介绍比特币的UTXO" class="headerlink" title="介绍比特币的UTXO"></a>介绍比特币的UTXO</h1><p>UTXO代表”Unspent Transaction Output”，即未花费的交易输出。UTXO模型是比特币使用的一种账户模型，与传统的账户余额模型不同。</p>
<p>每当一个比特币交易发生时，输入和输出被创建。交易的输入引用之前交易的输出，而交易的输出定义了新的UTXO。</p>
<h1 id="比特币查询余额只能从头开始遍历整条链吗，有没有高效方法"><a href="#比特币查询余额只能从头开始遍历整条链吗，有没有高效方法" class="headerlink" title="比特币查询余额只能从头开始遍历整条链吗，有没有高效方法"></a>比特币查询余额只能从头开始遍历整条链吗，有没有高效方法</h1><ol>
<li>索引和数据库优化：区块链浏览器和钱包服务可以使用索引和数据库优化技术来加快查询速度。通过构建针对地址和UTXO的索引，可以快速定位相关的交易和UTXO，而不需要遍历整个区块链。</li>
<li>UTXO集合缓存：一些服务会在内存中维护一个UTXO集合的缓存，以提供快速的查询响应。这些缓存通常存储最近使用频繁的UTXO，使得查询余额时无需每次都遍历整个区块链。</li>
</ol>
<h1 id="比特币地址是怎么生成的"><a href="#比特币地址是怎么生成的" class="headerlink" title="比特币地址是怎么生成的"></a>比特币地址是怎么生成的</h1><p>（助记词 &lt;-&gt; seed -&gt; 私钥 -&gt; 公钥 -&gt; PubKeyHash &lt;-&gt; address, 其中&lt;-&gt;表可双向转换，-&gt;表单向转换，最后的PubKeyHash转换为address的时候用的是base58编码，base58编码的原理即辗转相除法）</p>
<h1 id="介绍Bloom-filter特点"><a href="#介绍Bloom-filter特点" class="headerlink" title="介绍Bloom filter特点"></a>介绍Bloom filter特点</h1><p>常数时间内判断一个元素是否可能属于一个集合、位数组相对于存储实际元素的集合所需的内存要小得多有一定的错误率、插入元素只需要对位数组进行哈希操作并设置相应的位删除操作在传统的Bloom filter中是不支持的、可调的错误率错误率取决于位数组的大小和哈希函数的个数</p>
<h1 id="以太坊智能合约如何执行，介绍EVM底层"><a href="#以太坊智能合约如何执行，介绍EVM底层" class="headerlink" title="以太坊智能合约如何执行，介绍EVM底层"></a>以太坊智能合约如何执行，介绍EVM底层</h1><p>编译为字节码文件 –&gt; 支付gas部署合约 –&gt; 发起交易与合约交互 –&gt; 交易上链后EVM执行合约字节码 –&gt; 合约状态更新 –&gt; 结果返回</p>
<h1 id="以太坊相比于比特币的创新点"><a href="#以太坊相比于比特币的创新点" class="headerlink" title="以太坊相比于比特币的创新点"></a>以太坊相比于比特币的创新点</h1><ol>
<li>智能合约：以太坊引入了智能合约的概念，使得开发者可以在区块链上编写和执行具有逻辑和功能的可编程合约。智能合约允许在区块链上进行复杂的业务逻辑，从简单的转账到复杂的去中心化应用（DApp）。</li>
<li>图灵完备性：与比特币的脚本语言相比，以太坊的智能合约语言Solidity是图灵完备的，这意味着它可以进行更复杂的计算和逻辑运算。这为开发者提供了更大的灵活性和创新空间。</li>
<li>共识算法：pos节省能源</li>
</ol>
<h1 id="geth中的block、transction、log、receipt数据结构"><a href="#geth中的block、transction、log、receipt数据结构" class="headerlink" title="geth中的block、transction、log、receipt数据结构"></a>geth中的block、transction、log、receipt数据结构</h1><h1 id="HP编码、RLP编码"><a href="#HP编码、RLP编码" class="headerlink" title="HP编码、RLP编码"></a>HP编码、RLP编码</h1><p>HP编码主要用于数据压缩和编码方面，通过减少编码长度来节省存储空间和传输带宽。</p>
<p>RLP编码则更适用于序列化和反序列化数据，特别是在以太坊中作为一种通用的数据编码方式，用于存储和传输合约数据、交易数据等。</p>
<h1 id="最长链原则"><a href="#最长链原则" class="headerlink" title="最长链原则"></a>最长链原则</h1><p>最长链定义：最长链是指具有最多区块的链，其中每个区块都是经过验证且有效的。</p>
<h1 id="从架构设计层面说一下以太坊的各个层的作用"><a href="#从架构设计层面说一下以太坊的各个层的作用" class="headerlink" title="从架构设计层面说一下以太坊的各个层的作用"></a>从架构设计层面说一下以太坊的各个层的作用</h1><ol>
<li>基础设施层（Infrastructure Layer）： 基础设施层是以太坊的底层基础设施，包括<strong>网络协议、点对点通信、数据同步和共识算法</strong>等。这一层负责提供以太坊网络的运行环境和支持，确保节点之间的连接和通信，以及确保区块链的一致性和安全性。</li>
<li>合约层（Contract Layer）： 合约层是以太坊的智能合约执行层，它<strong>负责处理智能合约的执行和交互</strong>。合约层包括以太坊虚拟机（EVM）和智能合约的执行环境。EVM 是一个隔离且安全的虚拟机环境，负责解释和执行智能合约的字节码。它提供了一组指令集和状态操作，使得智能合约可以在安全的环境中执行。</li>
<li>表现层（Presentation Layer）： 表现层是以太坊的用户界面层，它提供了用户与以太坊网络进行交互的界面。这包括<strong>钱包应用、区块浏览器、交易界面</strong>等。表现层为用户提供了友好的界面和功能，使他们能够方便地管理钱包、查看交易和与智能合约进行交互。</li>
<li>应用层（Application Layer）： 应用层是以太坊的最上层，包括去中心化应用（DApp）和智能合约的具体应用场景。在这一层，开发者可以基于智能合约构建各种应用，如<strong>去中心化金融（DeFi）、数字身份、供应链管理</strong>等。应用层利用以太坊提供的智能合约和区块链功能来实现特定的业务逻辑和功能，为用户提供创新和去中心化的应用体验。</li>
</ol>
<h1 id="如何理解Ai与web3之间的关系"><a href="#如何理解Ai与web3之间的关系" class="headerlink" title="如何理解Ai与web3之间的关系"></a>如何理解Ai与web3之间的关系</h1><p><strong>AI更多是生产力的发展，Web3则是生产关系的重新定义</strong> </p>
<p><strong>AI作为一种技术工具，可以在许多领域提高生产效率和效益。通过机器学习和深度学习等技术，AI能够处理大量的数据、自动化任务和决策过程</strong>，从而减少人力资源的需求，提高工作效率。例如，在制造业中，AI可以用于优化生产流程、预测设备故障、提高产品质量等方面，从而提高整体生产力。</p>
<p>另一方面，<strong>Web3代表了一种新的互联网模式，强调去中心化、自治和用户主权</strong>。它基于区块链和智能合约等技术，重新定义了生产关系和价值交换方式。在传统的Web2模式中，平台拥有者掌握着用户数据和利益分配的权力，<strong>而Web3则通过去中心化的方式，使用户能够更直接地参与到价值创造和分享中。这种重新定义的生产关系可以促进更公平、透明和可持续的经济模式。</strong></p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/Solidity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/Solidity/" class="post-title-link" itemprop="url">Solidity</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-14 00:00:00" itemprop="dateCreated datePublished" datetime="2022-12-14T00:00:00+08:00">2022-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index">
                    <span itemprop="name">区块链知识</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="solidity上如何在数组删除一个数"><a href="#solidity上如何在数组删除一个数" class="headerlink" title="solidity上如何在数组删除一个数"></a>solidity上如何在数组删除一个数</h1><p>根据下标用delete使其变为默认值，如果是动态数组可以通过pop方法移除该数组不过需要与最后一个位置的元素交换</p>
<h1 id="你是如何用以太坊实现资金托管的"><a href="#你是如何用以太坊实现资金托管的" class="headerlink" title="你是如何用以太坊实现资金托管的"></a>你是如何用以太坊实现资金托管的</h1><p>function用payable修饰，然后可以对合约账户balance</p>
<p>低级CALL调用<strong>不需要<code>payable address</code></strong>,transfer 和 send <strong>只能是 <code>payable address</code></strong></p>
<p>transfer()错误会回滚，send会返回一个bool，call也是返回bool和返回数据bytes memory</p>
<p>call的 gas 可以动态调整,transfer 和 send 只能是固定制 <code>2300</code></p>
<h1 id="如何对一个数组去重"><a href="#如何对一个数组去重" class="headerlink" title="如何对一个数组去重"></a>如何对一个数组去重</h1><p>用一个map检查数组元素有无出现，无出现就装进res</p>
<p>双重循环</p>
<p>还有其他实现吗(使用 Solidity 的 Set 数据结构进行去重，一个库）</p>
<p>跟最后一个元素互换然后pop &#x2F; 直接delete</p>
<h1 id="solidity的function的可见性"><a href="#solidity的function的可见性" class="headerlink" title="solidity的function的可见性"></a>solidity的function的可见性</h1><ul>
<li>函数有四可见型，分别是 <code>private</code> &#x2F; <code>external</code> &#x2F; <code>internal</code> &#x2F; <code>public</code></li>
<li>状态变量可以有三种可见型，分别是 <code>private</code> &#x2F; <code>internal</code> &#x2F; <code>public</code></li>
</ul>
<ol>
<li><p><strong>private</strong>: 私有，仅在当前合约中可以访问，在继承的合约内不可访问</p>
</li>
<li><p><strong>internal(默认)</strong>: 能在它们所定义的合约和派生合同中访问,它们不能被外部访问</p>
<blockquote>
<p>需要注意的是不能加前缀 this，前缀 this 是表示通过外部方式访问</p>
</blockquote>
</li>
<li><p><strong>external:</strong> 只能从智能合约外部调用。 如果要从智能合约中调用它，则必须使用this</p>
</li>
<li><p><strong>public</strong>: 公开可视(合约内部，被继承的，外部都可以调用)</p>
</li>
</ol>
<h1 id="合约发布的数据结构"><a href="#合约发布的数据结构" class="headerlink" title="合约发布的数据结构"></a>合约发布的数据结构</h1><p>合约发布的数据结构主要包括状态变量和函数：</p>
<p>状态变量（State Variables）：状态变量是在合约中声明的变量，存储在区块链上。</p>
<p>函数（Functions）：合约中的函数定义了合约的行为和操作。函数可以接受参数、返回值，并且可以修改合约的状态（通过修改状态变量）。</p>
<h1 id="solidity函数修饰器"><a href="#solidity函数修饰器" class="headerlink" title="solidity函数修饰器"></a>solidity函数修饰器</h1><p>可以将一些通用的操作提取出来，包装为函数修改器，来提高代码的复用性，改善编码效率。是函数高内聚，低耦合的延伸。</p>
<p>作用: 常用于在函数执行前检查某种前置条件。</p>
<ul>
<li>比如地址对不对，余额是否充足，参数值是否允许等</li>
<li>修改器内可以写逻辑</li>
</ul>
<p>如果同一个函数有多个修改器 modifier，它们之间以空格隔开，修改器 modifier 会依次检查执行。</p>
<p><strong>修改器不能隐式地访问或改变它们所修饰的函数的参数和返回值。</strong> 这些值只能在调用时明确地以参数传递。</p>
<p><code>_</code> 符号可以在修改器中出现多次，每处都会替换为函数体。</p>
<h1 id="Solc编译器的原理、汇编过程"><a href="#Solc编译器的原理、汇编过程" class="headerlink" title="Solc编译器的原理、汇编过程"></a>Solc编译器的原理、汇编过程</h1><p>Solc是Solidity编译器，它的主要功能是将Solidity源代码编译成EVM字节码</p>
<ol>
<li><p>原理：<strong>Solc编译器会先对Solidity源代码进行词法分析和语法分析，生成抽象语法树（AST）。然后，Solc编译器会将AST转换为中间语言（IR），并进行优化和分析。最后，Solc编译器会将IR转换为EVM字节码，并输出编译结果。</strong></p>
</li>
<li><p>汇编过程</p>
<p>（1）将Solidity源代码转换为中间语言（IR）。</p>
<p>（2）对IR进行优化和分析，包括常量折叠、死代码删除、控制流图重构等操作。</p>
<p>（3）将IR转换为EVM汇编代码，包括指令选择、寄存器分配、代码生成等操作。</p>
<p>（4）将EVM汇编代码转换为二进制字节码。</p>
<p>在上述过程中，Solc编译器使用了多种技术和算法，包括词法分析、语法分析、AST转换、中间代码优化、寄存器分配、指令选择等。这些技术和算法的目的是提高编译器的性能和生成的字节码的质量，从而使Solidity合约在EVM上的执行更加高效和安全。</p>
</li>
</ol>
<h1 id="说一下合约的安全分析方法、原理"><a href="#说一下合约的安全分析方法、原理" class="headerlink" title="说一下合约的安全分析方法、原理"></a>说一下合约的安全分析方法、原理</h1><ol>
<li><strong>静态分析：</strong>静态分析是通过<strong>检查源代码或字节码</strong>来识别潜在的安全问题。它可以帮助<strong>发现潜在的漏洞、错误和安全隐患</strong>。静态分析工具<strong>会检查代码中的常见安全问题，例如整数溢出、未经授权的访问、重入漏洞等，并给出相应的警告或错误信息。</strong></li>
<li><strong>污点分析：</strong>污点分析是一种静态或动态分析技术，用于<strong>追踪数据流中的敏感信息（称为污点）并检测潜在的漏洞</strong>。在合约中，污点分析可用于<strong>追踪用户输入数据（如交易输入、合约参数等）如何在代码中传播，并检测是否存在未经适当处理的污点数据访问或潜在的漏洞。</strong></li>
<li><strong>符号执行：</strong>符号执行是一种静态分析技术，它通过<strong>符号变量替代具体输入值</strong>，以<strong>遍历可能的执行路径并生成约束条件</strong>。通过符号执行，可以<strong>检测合约中的潜在漏洞，如条件分支错误、溢出漏洞等</strong>。然而，由于符号执行的复杂性，它在实际中的应用受到一些限制。</li>
<li><strong>模糊测试：</strong>模糊测试是一种动态测试技术，<strong>通过生成大量的随机或半随机输入来评估系统的安全性</strong>。在合约中，模糊测试可以<strong>通过生成随机交易和参数等输入来模拟潜在的攻击情景，以便发现合约中的漏洞和异常行为。</strong></li>
<li><strong>形式验证：</strong>形式验证是一种基于数学和逻辑推理的方法，用于<strong>验证合约是否满足特定的安全属性或规范</strong>。通过形式验证，可以<strong>对合约的正确性进行严格的数学证明</strong>，从而<strong>排除特定类型的漏洞</strong>。然而，<strong>形式验证通常需要高度专业的知识和复杂的建模过程，因此在实践中的应用相对较少。</strong></li>
<li><strong>动态分析：</strong>动态分析是<strong>在实际运行合约时监测和分析其行为</strong>。通过<strong>模拟不同的输入和交互场景</strong>，可以发现潜在的漏洞和异常情况。动态分析可以<strong>帮助检测运行时的安全问题，例如重入攻击、溢出等</strong>。</li>
</ol>
<h1 id="合约内部调用和外部调用"><a href="#合约内部调用和外部调用" class="headerlink" title="合约内部调用和外部调用"></a>合约内部调用和外部调用</h1><p>内部：合约内部调用是指<strong>在同一个合约内部调用另一个函数</strong>，可以直接使用函数名进行调用，无需指定地址，<strong>可以访问所有的状态变量和函数。</strong></p>
<p>外部：合约外部调用是指<strong>在一个合约中调用另一个合约的函数</strong>。在合约外部调用时，<strong>需要指定被调用合约的地址，并使用<code>call</code>、<code>delegatecall</code>或<code>staticcall</code>等函数进行调用</strong>。在合约外部调用时，<strong>只能访问公共状态变量和函数。</strong></p>
<h1 id="内部函数和外部函数区别"><a href="#内部函数和外部函数区别" class="headerlink" title="内部函数和外部函数区别"></a>内部函数和外部函数区别</h1><ol>
<li>访问权限：<strong>内部函数可以被当前合约以及继承自当前合约的合约访问</strong>，包括私有（private）和内部（internal）函数。而<strong>外部函数只能被其他合约或外部账户通过消息调用的方式访问，通过合约地址和函数签名来执行外部调用。</strong></li>
<li>调用开销：<strong>内部函数的调用不涉及 EVM 的上下文切换和消息传递</strong>，因为调用发生在同一个合约内部，没有跨合约的开销。而<strong>外部函数的调用涉及 EVM 的上下文切换和消息传递，需要通过消息调用（message call）机制执行，因此具有更高的调用开销。</strong></li>
<li>函数可见性修饰符：为了明确指定函数的可见性，<strong>内部函数使用 <code>internal</code> 修饰符进行声明，而外部函数使用 <code>external</code> 修饰符进行声明。</strong></li>
</ol>
<h1 id="Solidity引用类型storage、memory、calldata"><a href="#Solidity引用类型storage、memory、calldata" class="headerlink" title="Solidity引用类型storage、memory、calldata"></a>Solidity引用类型storage、memory、calldata</h1><p><code>storage</code>是指<strong>永久存储在区块链上的数据位置</strong>，用于<strong>存储合约状态变量</strong>和映射类型的值。</p>
<p><code>memory</code>是指<strong>临时存储在计算机内存中的数据位置</strong>，用于<strong>存储函数局部变量和函数参数</strong>。在函数内部声明的变量默认情况下会使用<code>memory</code>数据位置，<code>memory</code> 中的数据只在函数执行期间存在，并在函数执行结束后被清除。<strong>引用类型局部变量，要显式指定数据位置</strong>。</p>
<p><code>calldata</code>是指<strong>用于保存函数参数和外部函数调用数据的特殊区域</strong>，<strong>包括函数参数和函数签名等信息</strong>。在函数调用时，函数参数会被复制到<code>calldata</code>中，并传递给被调用函数。在函数内部访问函数参数时，默认情况下会使用<code>calldata</code>数据位置。<code>calldata</code> 是只读的。</p>
<p>按照函数参数:</p>
<ul>
<li>内部函数参数: (包括返回参数)都存储在<strong>memory（内存）</strong>中。</li>
<li>外部函数参数: (不包括返回参数)存储在 <code>calldata</code> 中。</li>
</ul>
<h1 id="数据赋值时何时进行值传递、何时进行引用传递"><a href="#数据赋值时何时进行值传递、何时进行引用传递" class="headerlink" title="数据赋值时何时进行值传递、何时进行引用传递"></a>数据赋值时何时进行值传递、何时进行引用传递</h1><ol>
<li><strong>在 storage 和 memory 之间两两赋值（或者从 calldata 赋值 ），值传递</strong>。</li>
<li>从 memory 到 memory 的两个引用赋值，引用传递。</li>
</ol>
<h1 id="说一下ERC20、ERC721的函数和作用、以及对应的缺点和改进的方案"><a href="#说一下ERC20、ERC721的函数和作用、以及对应的缺点和改进的方案" class="headerlink" title="说一下ERC20、ERC721的函数和作用、以及对应的缺点和改进的方案"></a>说一下ERC20、ERC721的函数和作用、以及对应的缺点和改进的方案</h1><p> <strong>标准 ERC20 接口</strong></p>
<p>3 个查询：</p>
<ul>
<li><code>balanceOf</code>: 查询指定地址的 Token 数量</li>
<li><code>totalSupply</code>: 查询当前合约的 Token 总量</li>
<li><code>allowance</code>: 查询指定地址对另外一个地址的剩余授权额度</li>
</ul>
<p>2 个交易：</p>
<ul>
<li><code>transfer</code>: 从当前调用者地址发送指定数量的 Token 到指定地址,这是一个写入方法，所以还会抛出一个 <code>Transfer</code> 事件。</li>
<li><code>transferFrom</code>: 当向另外一个合约地址存款时，对方合约必须调用 transferFrom 才可以把 Token 拿到它自己的合约中。</li>
</ul>
<p>1 个授权：<code>approve</code>: 授权指定地址可以操作调用者的最大 Token 数量。</p>
<p>缺点：ERC20标准<strong>没有考虑到代币的独特性，所有代币都是同质化的，无法区分不同的代币。</strong></p>
<p>改进方案：<strong>ERC1155标准是一种新的代币标准，它支持多种类型的代币，并且可以在一个合约中管理多种代币。</strong></p>
<p><strong>标准 ERC721 接口</strong></p>
<p>4 个查询：</p>
<ul>
<li><code>balanceOf</code>: 查询指定地址的 NFT数量</li>
<li><code>ownerOf</code>: 查询当前NFT 的所属地址</li>
<li><code>isApprovedForAll</code>: 查询一个地址是否是另一个地址的授权操作员</li>
<li><code>getApproved</code>:获取单个 NFT 的授权地址</li>
</ul>
<p>2 个交易：</p>
<ul>
<li><code>safeTransferFrom</code>: 从 <code>_from</code> 地址转移到 <code>_to</code> 地址。与 <code>transferFrom</code> 不同，<code>safeTransferFrom</code> 函数在转移代币时会进行安全性检查。它会检查接收方合约是否实现了 ERC721Receiver 接口，并调用接收方合约中的 <code>onERC721Received</code> 方法，旨在确保代币转移的目的地是一个合适的接收方，并且能够正确处理接收的代币。</li>
<li><code>transferFrom</code>:从 <code>_from</code> 地址转移到 <code>_to</code> 地址，但它并没有提供任何安全性检查机制。</li>
</ul>
<p>2个授权：</p>
<ul>
<li><code>approve</code>: 授权指定地址可以操作某个NFT</li>
<li><code>setApprovalForAll</code>：授权指定地址可以操作msg.sender地址下的所有NFT</li>
</ul>
<p>缺点：ERC721标准的转账操作比较复杂，需要调用多个函数才能完成，而且转账过程中可能会出现错误，导致代币丢失。</p>
<p>改进方案：ERC998标准是一种新的代币标准，它支持代币的组合和嵌套，可以将多个代币组合成一个更复杂的代币，并且可以在一个合约中管理多种代币。这样可以简化转账操作，减少出错的可能性。</p>
<h1 id="事件中加indexed属性的作用"><a href="#事件中加indexed属性的作用" class="headerlink" title="事件中加indexed属性的作用"></a>事件中加indexed属性的作用</h1><p>indexed 数据会被记录到 <code>topics</code> 中，可以用于检索，主题（topic）让我们可以可以搜索事件，比如在为某些事件过滤一些区块，还可以按发起事件的合同地址来过滤事件。</p>
<h1 id="映射能否被声明为memory类型、映射中的key能否为复杂类型、映射的key是keccak256哈希还是真实的值、映射能否作为返回值、映射能否嵌套"><a href="#映射能否被声明为memory类型、映射中的key能否为复杂类型、映射的key是keccak256哈希还是真实的值、映射能否作为返回值、映射能否嵌套" class="headerlink" title="映射能否被声明为memory类型、映射中的key能否为复杂类型、映射的key是keccak256哈希还是真实的值、映射能否作为返回值、映射能否嵌套"></a>映射能否被声明为memory类型、映射中的key能否为复杂类型、映射的key是keccak256哈希还是真实的值、映射能否作为返回值、映射能否嵌套</h1><ol>
<li><strong>映射不能被声明为 <code>memory</code> 类型</strong>。<code>memory</code> 类型用于临时存储和操作函数内的数据，而映射（<code>mapping</code>）是一种存储在存储器（<code>storage</code>）中的数据结构，无法在 <code>memory</code> 中声明。</li>
<li><strong>映射的键（<code>key</code>）可以是复杂类型，包括结构体、枚举和数组等。</strong>映射的键类型不仅限于基本数据类型，你可以使用复杂类型作为映射的键。</li>
<li><strong>映射的键存储它的 <code>keccak256</code> 哈希值</strong>，从而便于查询实际的值。正因为如此，映射是没有长度的，也没有 <code>key 的集合</code>或 <code>value 的集合</code>的概念</li>
<li><strong>映射不能用于合约公有函数的参数或返回值，只允许作为状态变量或作为函数内的存储引用或作为库函数的参数。</strong></li>
<li><strong>映射可以进行嵌套</strong></li>
</ol>
<h1 id="Solidity中receive函数、fallback函数"><a href="#Solidity中receive函数、fallback函数" class="headerlink" title="Solidity中receive函数、fallback函数"></a>Solidity中receive函数、fallback函数</h1><p>fallback 函数是调用合约没有的方法时候执行，同时也可以设置为允许接收网络主币。</p>
<p>receive 只负责接收主币,一个合约最多有一个 <code>receive</code> 函数，receive 函数类型必须是 <code>payable</code> 的，声明为 payable 之后，其所消耗的 gas 最大量就会被限定在 2300。</p>
<h1 id="Solidity中view函数、pure函数的作用和区别"><a href="#Solidity中view函数、pure函数的作用和区别" class="headerlink" title="Solidity中view函数、pure函数的作用和区别"></a>Solidity中view函数、pure函数的作用和区别</h1><p>pure: 既<strong>不读取也不修改状态变量</strong>，这种函数被称为<strong>纯函数</strong></p>
<p>view: 读取状态变量，但是不修改状态变量，这种函数被称为<strong>视图函数</strong>，状态变量的 Getter 方法默认是 view 函数。</p>
<h1 id="Solidity中字符串和字节有什么不同（bytes元素的内存是紧密连续存放的，不是按照-32-个字节为一单元）"><a href="#Solidity中字符串和字节有什么不同（bytes元素的内存是紧密连续存放的，不是按照-32-个字节为一单元）" class="headerlink" title="Solidity中字符串和字节有什么不同（bytes元素的内存是紧密连续存放的，不是按照 32 个字节为一单元）"></a>Solidity中字符串和字节有什么不同（bytes元素的内存是紧密连续存放的，不是按照 32 个字节为一单元）</h1><p>字节分为定长字节数组(值类型)和变长字节数组(引用类型)，字符串是引用类型</p>
<p>定长字节数组：length、下标访问元素</p>
<p>不定长字节数组：length、下标访问元素、concat 拼接、push添加单个字节、pop删除数组的最后一个元素、delete、x[start:end]:数组切片</p>
<p>字符串：无length属性、无下标访问元素、concat 拼接</p>
<p>字符串（string）是动态大小的UTF-8编码字符序列，而字节（bytes）是一个固定大小的字节数组。在存储时，字符串会占用一个指针，指向实际存储字符串内容的位置，而字节则直接存储其内容。</p>
<blockquote>
<p>比较两个字符串</p>
<ul>
<li><code>keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))</code></li>
<li><code>keccak256(bytes(s1)) == keccak256(bytes(s2))</code>:更省 gas</li>
</ul>
</blockquote>
<h1 id="bytes和bytes32的应用场景和区别"><a href="#bytes和bytes32的应用场景和区别" class="headerlink" title="bytes和bytes32的应用场景和区别"></a>bytes和bytes32的应用场景和区别</h1><p>bytes类型适用于处理动态长度的字节数组，比如存储可变长度的文本数据或二进制数据。</p>
<p>bytes32类型适用于处理固定长度的字节数组，比如存储哈希值、加密签名等固定长度的二进制数据。</p>
<p>bytes类型没有固定的长度限制，可以根据需要动态调整大小。可以进行拼接、截取、访问等操作。</p>
<p>bytes32类型具有固定的长度限制，长度为32字节（256位）。可以进行比较、运算等操作。</p>
<h1 id="Solidity中constant和immutable的作用和区别"><a href="#Solidity中constant和immutable的作用和区别" class="headerlink" title="Solidity中constant和immutable的作用和区别"></a>Solidity中constant和immutable的作用和区别</h1><p>gas 要低很多、赋值后不可以修改</p>
<p>constant常量不是储存在<code>storage</code> 上，所以函数内读取常量不算<code>view</code>，可以使用 pure</p>
<p>constant常量在编译时确定，支持的仅有<strong>值类型（包括地址类型）&#x2F;字符串&#x2F;bytes</strong>，不允许任何通过访问 storage，区块链数据（例如 <code>block.timestamp</code>,<code>address(this).balance</code> 或者 <code>block.number</code>）或执行数据（ <code>msg.value</code> 或<code>gasleft()</code> ）对其赋值，</p>
<p>immutable不可变量可以在构建时确定，<code>immutable</code>仅支持值类型</p>
<h1 id="Solidity中创建合约的两种方式的区别和应用场景"><a href="#Solidity中创建合约的两种方式的区别和应用场景" class="headerlink" title="Solidity中创建合约的两种方式的区别和应用场景"></a>Solidity中创建合约的两种方式的区别和应用场景</h1><p>通过 <code>new</code> 创建合约 &#x2F; <code>create</code>：在<strong>创建合约时根据创建合约的地址和创建合约交易时的 <code>nonce</code> 来计算合约的地址</strong>。</p>
<p>通过 <code>salt</code> 创建合约 &#x2F; <code>create2</code>：指定了一个可选的 <code>salt</code> （一个 bytes32 值），它将<strong>根据给定的 <code>salt</code></strong> ，<strong>创建合约的字节码和构造函数参数</strong>来计算创建合约的地址，不再使用 <code>nonce</code>。</p>
<p>Uniswap中利用create2创建交易对，然后通过交易对代币地址可以推测出交易对地址与之交互，确保每次实例化的合约地址都是唯一的</p>
<blockquote>
<p>salt 决定了合约地址，不能重复使用，除非之前 salt 生成的合约被销毁了。</p>
</blockquote>
<h1 id="Solidity中的错误类型（Panic和Error）出现的场景和表示意义"><a href="#Solidity中的错误类型（Panic和Error）出现的场景和表示意义" class="headerlink" title="Solidity中的错误类型（Panic和Error）出现的场景和表示意义"></a>Solidity中的错误类型（Panic和Error）出现的场景和表示意义</h1><ol>
<li>Panic（紧急情况）：<ul>
<li>场景：Panic<strong>在发生无法恢复的严重错误或异常情况时触发</strong>，例如<strong>数组越界、除零操作、无效的操作</strong>等。这些错误通常表示<strong>合约处于一个不可处理的状态，无法继续执行，需要立即停止。</strong></li>
<li>表示意义：Panic表示了<strong>一种严重的错误或异常情况，合约无法继续正常执行</strong>。它的目的是提醒开发者和用户发生了不可恢复的错误，可能需要修复合约代码或采取其他措施来处理问题。</li>
</ul>
</li>
<li>Error（错误）：<ul>
<li>场景：Error通常在<strong>可处理的错误或异常情况下触发</strong>，例如<strong>输入验证失败、外部调用返回错误结果</strong>等。这些错误通常可以<strong>通过适当的错误处理逻辑进行处理或恢复，不会导致合约无法继续执行</strong>。</li>
<li>表示意义：Error表示了<strong>一种可处理的错误或异常情况，合约可以通过适当的错误处理逻辑进行恢复</strong>。它的目的是<strong>提供一种错误处理机制，使合约能够适当地处理错误情况，继续执行或采取适当的措施。</strong></li>
</ul>
</li>
</ol>
<blockquote>
<p>Panic通常通过使用<code>revert()</code>、<code>require()</code>或<code>assert()</code>等函数来触发。这些函数会中止当前的合约执行并回滚状态改变。而Error可以通过自定义的错误处理逻辑或使用<code>try-catch</code>语句来捕获和处理</p>
</blockquote>
<h1 id="Solidity中assert和require的区别和应用场景"><a href="#Solidity中assert和require的区别和应用场景" class="headerlink" title="Solidity中assert和require的区别和应用场景"></a>Solidity中assert和require的区别和应用场景</h1><ul>
<li><code>require</code>：用于验证<strong>前置条件，例如输入验证、边界检查和约束条件的断言。</strong>返还剩余的燃气</li>
<li><code>assert</code>：用于<strong>验证合约内部的不变量和内部错误，主要用于验证内部逻辑的正确性。</strong>不返还剩余的燃气</li>
</ul>
<h1 id="Solidity中transfer、send、call转账的区别"><a href="#Solidity中transfer、send、call转账的区别" class="headerlink" title="Solidity中transfer、send、call转账的区别"></a>Solidity中transfer、send、call转账的区别</h1><p>低级CALL调用<strong>不需要<code>payable address</code></strong>,ransfer 和 send <strong>只能是 <code>payable address</code></strong></p>
<p>transfer()失败时抛出异常,send()失败时仅会返回false,不会终止执行（合约地址转账）</p>
<p>call的 gas 可以动态调整,transfer 和 send 只能是固定制 <code>2300</code></p>
<p>call除了可以转账外，可以还可以调用不知道 ABI 的方法，还可以调用的时候转账</p>
<h1 id="Solidity中call、delegatecall、staticcall、callcode区别"><a href="#Solidity中call、delegatecall、staticcall、callcode区别" class="headerlink" title="Solidity中call、delegatecall、staticcall、callcode区别"></a>Solidity中call、delegatecall、staticcall、callcode区别</h1><p>为了与不知道 ABI 的合约进行交互，Solidity 提供了函数 <code>call</code>&#x2F;<code>delegatecall</code>&#x2F;<code>staticcall</code> 直接控制编码。它们都带有一个 <code>bytes memory</code> 参数和返回执行<strong>成功状态</strong>（bool）和<strong>数据</strong>（bytes memory）。</p>
<p><strong>三种方法都提供 <code>gas</code> 选项，而 <code>value</code> 选项仅 <code>call</code> 支持</strong> 。</p>
<p>call()：被调用合约内部如果有状态变量修改，则会被修改</p>
<p>delegatecall()：<code>delegatecall</code> 只调用给定地址的代码（函数），其他状态属性如（存储，余额 …）都来自当前合约。<code>delegatecall</code> 的目的是使用另一个合约中的库代码。(用于升级合约)</p>
<p>staticcall()：与 call 基本相同，但<strong>如果被调用的函数以任何方式修改状态变量，都将回退</strong></p>
<p>callcode()：在Solidity v0.5.0版本中被废弃，用于在当前合约的上下文中调用另一个合约的函数，但<strong>共享相同的存储空间。</strong></p>
<h1 id="Solidity中的隐式转换和显示转换、函数可见性类型转换"><a href="#Solidity中的隐式转换和显示转换、函数可见性类型转换" class="headerlink" title="Solidity中的隐式转换和显示转换、函数可见性类型转换"></a>Solidity中的隐式转换和显示转换、函数可见性类型转换</h1><p><strong>隐式转换：值类型，源类型必须是目标类型的子集。</strong></p>
<p>例如，<code>uint8</code> 可以转换为 <code>uint16</code>&#x2F;<code>uint24</code>..&#x2F;<code>uint256</code>，因为<code>uint8</code>是<code>uint16</code>这些类型的子集。</p>
<p>但是 <code>int8</code> 不可以转换为 <code>uint256</code>，因为 <code>int8</code> 可以包含 <code>uint256</code> 中不允许的负值，比如 <code>-1</code>。</p>
<p><strong>显示转换：使用类型关键字，显式地将数据类型转换为另一种类型</strong></p>
<p>整型加大数据位置是从左侧增加，减小数据位置也是从左侧移除；（<strong>整型是右对齐</strong>）</p>
<p>字节加大数据位置是从右侧增加，减小数据位置也是从右侧移除；（<strong>字节是左对齐</strong>）</p>
<p>只有当字节类型和整数类型大小相同时，才可以进行转换。</p>
<p>bytes 和 bytesN 之间转换左对齐</p>
<p>bytes 与 address 转换：地址是取 <code>bytes32</code> 数据中的后 20 位，address(uint160(uint256(bytes32)))</p>
<p><strong>pure转view、view转non-payable、payable转non-payable</strong></p>
<h1 id="Solidity中合约继承方式、继承多个合约的顺序写法、super关键字作用"><a href="#Solidity中合约继承方式、继承多个合约的顺序写法、super关键字作用" class="headerlink" title="Solidity中合约继承方式、继承多个合约的顺序写法、super关键字作用"></a>Solidity中合约继承方式、继承多个合约的顺序写法、super关键字作用</h1><p>使用 <code>is</code> 实现继承：子类可以访问父类的权限修饰符只有：<code>public/internal</code>，不能是 <code>external/private</code>。</p>
<p>传参：contract C is A(“n”),B(“v”) {}   &#x2F;     constructor(string memory _name) A(_name) {}</p>
<p>一个合约<strong>同时继承 2 个合约时，这种情况叫多重继承</strong>，多重继承中不允许出现相同的<strong>函数名</strong>、<strong>事件名</strong>、<strong>修改器名</strong>以及<strong>状态变量名</strong>等，使用逗号分隔它们，并按照从左到右的顺序进行继承。</p>
<p><code>super</code>关键字作用：</p>
<ul>
<li>在子合约中，可以使用<code>super</code>关键字来引用父合约的函数和状态。</li>
<li>通过<code>super</code>关键字，可以调用父合约中的同名函数，并且可以在子合约中访问父合约的状态变量。</li>
<li>使用<code>super</code>关键字可以实现在子合约中对父合约行为的扩展或覆盖。</li>
</ul>
<h1 id="Solidity中函数重写规则"><a href="#Solidity中函数重写规则" class="headerlink" title="Solidity中函数重写规则"></a>Solidity中函数重写规则</h1><p>solidity 引入了 <code>abstract</code>, <code>virtual</code>, <code>override</code> 几个关键字，用于重写函数。<strong>父合约标记为 <code>virtual</code>函数可以在继承合约里重写(overridden)以更改他们的行为</strong>。重写的函数需要使用关键字 <code>override</code> 修饰。</p>
<p>对于多重继承，如果有多个父合约有相同定义的函数， override 关键字后必须指定所有父合约名。</p>
<p> <code>nonpayable</code> 可以被 <code>view</code> 和<code>pure</code> 覆盖。 <code>view</code> 可以被 <code>pure</code> 覆盖。 <code>payable</code>是一个例外，不能更改为任何其他可变性。</p>
<p>基础合约中可以包含没有实现代码的函数，也就是纯虚函数，那么基础合约必须声明为 <code>abstract</code>(interface)</p>
<h1 id="Solidity中的接口是什么"><a href="#Solidity中的接口是什么" class="headerlink" title="Solidity中的接口是什么"></a>Solidity中的接口是什么</h1><p>接口需要有 interface 关键字，并且内部只需要有函数的声明，不用实现，用于调用，里面的函数都没有实现且都是external，可以被继承和重写，限制：不包含变量或状态</p>
<h1 id="Solidity中的库"><a href="#Solidity中的库" class="headerlink" title="Solidity中的库"></a>Solidity中的库</h1><p>library 是智能合约的精简版，像智能合约一样，位于区块链上，通过EVM的delegatecall实现调用，库无状态变量，不能继承其他合约，如果被继承传参是引用，参数标识为storage，库合约函数的可视范围通常为internal，可变性为pure</p>
<p>直接调用库合约方法：Math.max(_x, _y);</p>
<p>using…for… 使用库合约：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using ArrayLib for uint256[];</span><br><span class="line">uint256[] public arr = [10, 11, 12, 13, 14,...];</span><br><span class="line">...</span><br><span class="line">arr.find(15); // 直接使用</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h1 id="如何分析链上交易过程、如何借助区块浏览器查询信息"><a href="#如何分析链上交易过程、如何借助区块浏览器查询信息" class="headerlink" title="如何分析链上交易过程、如何借助区块浏览器查询信息"></a>如何分析链上交易过程、如何借助区块浏览器查询信息</h1><p>搜索栏中输入要查询的信息，如<strong>交易哈希、地址或合约地址。</strong></p>
<p>显示您查询相关的信息，如<strong>交易细节、区块高度、转账金额等。</strong></p>
<p>查看交易的<strong>确认状态、合约代码、事件日志等其他相关信息。</strong></p>
<p><strong>查看交易的输入和输出</strong>，以了解合约函数的调用、转账操作等。</p>
<p><strong>检查合约事件日志</strong>，了解触发的事件和相关数据。</p>
<p>可以<strong>查看合约的源代码、合约持有人、合约创建者等详细信息</strong>。</p>
<p><strong>Tenderly：</strong></p>
<p>智能合约调试：逐步执行合约代码，查看变量值和调用栈跟踪，更容易地定位和解决合约中的 bug 和问题。</p>
<p>交易模拟和回放：测试合约的行为和效果。这对于验证合约在不同情况下的行为非常有用，并且可以帮助发现潜在的安全问题和错误。</p>
<p>监视和警报：跟踪合约的状态变化、事件触发和交易执行情况，设置自定义警报规则，及时接收关键事件的通知。</p>
<p>性能分析：分析智能合约的性能和瓶颈，识别潜在的效率问题，并提供优化建议。</p>
<p>团队协作和共享：允许多个开发人员共同使用和管理合约，并在开发过程中共享调试会话、测试结果和分析数据。</p>
<h1 id="ABI的编码方式、solidity内置的ABI相关函数"><a href="#ABI的编码方式、solidity内置的ABI相关函数" class="headerlink" title="ABI的编码方式、solidity内置的ABI相关函数"></a>ABI的编码方式、solidity内置的ABI相关函数</h1><p>ABI编码方式取决于参数的类型,以下是一些常见的数据类型和对应的ABI编码方式：</p>
<ul>
<li>布尔类型（bool）：布尔值 <code>true</code> 编码为 1，布尔值 <code>false</code> 编码为 0。</li>
<li>整数类型（uint、int）：整数类型按照固定长度进行编码，如 uint8 编码为一个字节（8 位），uint256 编码为 32 字节（256 位）。整数类型的值通过大端（big-endian）字节序进行编码。</li>
<li>地址类型（address）：地址类型编码为 20 字节，其中前面 12 个字节为 0，后面 20 个字节表示地址的真实值。</li>
<li>字符串类型（string）：字符串类型的ABI编码与动态大小的字节数组类似，也包含一个32个字节的偏移量和实际的字符串数据。</li>
<li>字节数组类型（bytes）：动态大小的字节数组的ABI编码分为两部分，第一部分是32个字节的偏移量，指示实际数据在字节数组中的位置；第二部分是实际的字节数组数据。</li>
<li>动态数组类型（uint[]、address[]、string[] 等）：动态数组类型首先编码一个固定长度的字节数组，其中包含数组元素的 ABI 编码。然后在编码的开头添加表示数组长度的 32 位整数。</li>
<li>结构体类型（struct）：结构体类型的编码方式将结构体的各个成员依次进行 ABI 编码，按顺序将编码后的值拼接在一起。</li>
</ul>
<p>以上是一些常见数据类型的ABI编码方式，对于更复杂的数据类型，如映射（mapping）和函数类型（function），其ABI编码方式会更加复杂。</p>
<p>Solidity 内置的 ABI 相关函数：进行ABI编码和解码，使得在Solidity中<strong>与其他合约进行交互更加简单和高效。</strong></p>
<ul>
<li><code>abi.encode(...) returns (bytes)</code>：将函数参数编码为字节数组</li>
<li><code>abi.encodePacked(...) returns (bytes)</code>：类似于 <code>abi.encode()</code>，但是不会为编码的参数添加长度前缀，返回一个紧凑的字节数组。</li>
<li><code>abi.decode(bytes memory encodedData, (...)) returns (...)</code>: 对给定的数据进行 ABI 解码，而数据的类型在括号中第二个参数给出 。 例如: <code>(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))</code></li>
<li><code>abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)</code>： :用于将函数名称和参数编码为一个字节数组，包括函数选择器。它接受函数选择器和函数参数列表作为参数，并返回编码后的字节数组。</li>
<li><code>abi.encodeWithSignature(string signature, ...) returns (bytes)</code>：类似于 <code>abi.encodeWithSelector()</code>，但是使用函数的完整签名来生成函数选择器。等价于 <code>abi.encodeWithSelector(bytes4(keccak256(selector), ...)</code></li>
<li><code>abi.encodeCall(function functionPointer, (...)) returns (bytes memory)</code>: 使用 tuple 类型参数 ABI 编码调用 <code>functionPointer</code> 。执行完整的类型检查, 确保类型匹配函数签名。结果和 <code>abi.encodeWithSelector(functionPointer.selector, (...))</code> 一致。</li>
</ul>
<h1 id="用户发起交易的整个过程描述一下，包括交易的数据结构、交易的过程"><a href="#用户发起交易的整个过程描述一下，包括交易的数据结构、交易的过程" class="headerlink" title="用户发起交易的整个过程描述一下，包括交易的数据结构、交易的过程"></a>用户发起交易的整个过程描述一下，包括交易的数据结构、交易的过程</h1><ol>
<li>RLP编码：首先，<strong>将交易数据按照RLP编码规则进行序列化</strong>。RLP编码会将交易的各个字段转换为字节流，并添加长度前缀以表示字段的长度。(节省空间)</li>
<li>私钥签名：<strong>使用发送者的私钥对RLP编码后的交易数据进行签名</strong>。这个过程使用<strong>椭圆曲线数字签名算法</strong>（ECDSA），通过将交易哈希与私钥进行加密生成数字签名。</li>
<li>广播交易：<strong>将签名后的交易广播到区块链网络中的节点。</strong></li>
<li>进入交易池：<strong>广播的交易首先进入待处理的交易池中。</strong>交易池是存储待处理交易的缓冲区。<strong>节点将验证交易的签名和有效性，</strong>确保交易满足一些基本的规则和约束条件。</li>
<li>排序：在交易池中，<strong>交易会按照一定的规则进行排序</strong>。常见的排序规则包括<strong>按照交易的优先级、交易费用等进行排序。</strong></li>
<li>打包进区块：<strong>矿工节点从交易池中选择一些交易，并将它们打包进一个新的区块中。</strong>矿工会将交易进行有效性验证，并根据交易费用的高低选择收入最高的交易。</li>
<li>广播上链：一旦区块被<strong>矿工节点打包完成，它会广播到网络中的其他节点。</strong>其他节点会验证该区块的有效性，并将其添加到自己的本地副本中。</li>
</ol>
<p>所提交的交易包括下列信息：</p>
<ul>
<li><code>recipient</code> – 接收地址</li>
<li><code>signature</code> – 发送者的标识符。 当通过发送者的私钥签名交易来确保发送者已授权此交易时，生成此签名。</li>
<li><code>nonce</code> - 一个连续的递增计数器，表示帐户中的交易编号。</li>
<li><code>value</code> – 发送人向接收人转移的以太币金额（以以太币的一种面值 WEI 为单位）</li>
<li><code>data</code> – 可包括任意数据的可选字段</li>
<li><code>gasLimit</code> – 交易可以消耗的最大数量的燃料单位。 燃料单位代表计算步骤</li>
<li><code>maxPriorityFeePerGas</code> - 作为验证者小费包含的最大燃料数量</li>
<li><code>maxFeePerGas</code> - 愿意为交易支付的最大燃料数量</li>
</ul>
<h1 id="函数选择器的生成方式、组成、作用、为什么只取前4字节、以及在合约执行中的作用"><a href="#函数选择器的生成方式、组成、作用、为什么只取前4字节、以及在合约执行中的作用" class="headerlink" title="函数选择器的生成方式、组成、作用、为什么只取前4字节、以及在合约执行中的作用"></a>函数选择器的生成方式、组成、作用、为什么只取前4字节、以及在合约执行中的作用</h1><p>函数选择器（Function Selector）是在以太坊智能合约中用于<strong>标识函数的唯一标识符</strong>。它由<strong>函数的签名生成，并且通常只取前4个字节。</strong></p>
<p><strong>生成方式：</strong>将函数的名称和参数类型按照特定规则进行编码，使用Keccak-256哈希算法（也称为SHA3-256）对编码后的数据进行哈希计算，从哈希结果中取前4个字节作为函数选择器。</p>
<p><strong>作用：</strong>唯一标识函数、优化函数调用 (由于函数选择器只取前4个字节，因此可以减少传输的数据量，提高交易的效率。)</p>
<p><strong>在合约执行中的作用</strong>:确定要执行的函数,确保在合约中正确地执行所需的操作。</p>
<h1 id="详细说一下基于栈的虚拟机EVM（256位）、其上下文有哪些、存储空间有哪几类（stack、memory、storage）、stack的深度、访问的最大深度"><a href="#详细说一下基于栈的虚拟机EVM（256位）、其上下文有哪些、存储空间有哪几类（stack、memory、storage）、stack的深度、访问的最大深度" class="headerlink" title="详细说一下基于栈的虚拟机EVM（256位）、其上下文有哪些、存储空间有哪几类（stack、memory、storage）、stack的深度、访问的最大深度"></a>详细说一下基于栈的虚拟机EVM（256位）、其上下文有哪些、存储空间有哪几类（stack、memory、storage）、stack的深度、访问的最大深度</h1><p>EVM使用了基于栈的执行模型，其中包含以下几个关键组件：</p>
<ol>
<li>栈（Stack）：EVM<strong>使用一个栈来存储和处理数据</strong>。栈是一种<strong>后进先出的数据结构</strong>，用于<strong>保存操作数、中间结果和返回值等</strong>。</li>
<li>存储器（Memory）：EVM提供了<strong>一个字节数组作为存储器</strong>，用于<strong>临时存储合约执行过程中的数据</strong>。存储器可以<strong>通过索引访问，并且可以动态扩展。</strong></li>
<li>存储（Storage）：EVM提供了<strong>一个持久化的键值存储</strong>，用于<strong>在合约之间共享数据。存储是永久性的，即使合约执行结束后仍然保留。</strong></li>
<li>指令集（Instruction Set）：EVM<strong>定义了一套指令集，用于执行各种操作</strong>，如算术运算、逻辑运算、内存访问、存储访问等。每个指令都有特定的操作码和操作数。</li>
<li>状态转换（State Transition）：EVM<strong>通过执行指令来改变合约的状态。每个指令都会消耗一定的气体（Gas）</strong>，而气体是以太坊中的计价单位，用于限制合约执行的资源消耗。</li>
</ol>
<p>EVM的设计目标是实现安全、确定性和可验证性。它提供了一个隔离的执行环境，<strong>确保合约的执行结果在不同节点上是一致的</strong>，并且可以通过区块链上的交易历史进行验证。</p>
<blockquote>
<p>栈的最大深度为1024个元素,每层 32 字节,当栈的深度达到1024时，进一步的栈操作将会导致栈溢出错误（Stack Overflow Error）并终止合约的执行。</p>
</blockquote>
<h1 id="详细说一下EVM的“stack-too-deep”错误"><a href="#详细说一下EVM的“stack-too-deep”错误" class="headerlink" title="详细说一下EVM的“stack too deep”错误"></a>详细说一下EVM的“stack too deep”错误</h1><p>EVM栈最多 1024 层，每层 32 字节， <strong>对EVM栈的访问并不是完全严格按照先进后出，允许将顶端的 16 个元素中的某一个复制或者交换到栈顶</strong>。每次操作<strong>只能取栈顶的若干元素，把结果压栈</strong>。也能够把<strong>栈顶元素放到 memory 或者 storage 区域保存</strong>。<strong>因此一个函数最多16个变量。</strong></p>
<h1 id="从EVM的角度阐述交易发送和调用合约的整个过程"><a href="#从EVM的角度阐述交易发送和调用合约的整个过程" class="headerlink" title="从EVM的角度阐述交易发送和调用合约的整个过程"></a>从EVM的角度阐述交易发送和调用合约的整个过程</h1><ul>
<li><strong>交易创建：</strong>用户通过以太坊钱包或其他工具<strong>创建一笔交易</strong>。交易包括发送者地址、接收者地址、数额以及其他必要的信息。交易被<strong>广播到以太坊网络中。</strong></li>
<li><strong>交易验证：</strong>矿工节点在收到交易后，首先会<strong>对交易进行验证</strong>。验证包括检查交易的签名是否有效、发送者账户是否有足够的余额支付燃气费用等。</li>
<li><strong>燃气消耗评估：</strong>在验证通过后，矿工节点会评估交易执行所需的燃气消耗。每个操作码都有对应的燃气消耗，矿工节点会根据交易中的操作码和参数来计算燃气消耗。</li>
<li><strong>合约创建&#x2F;调用：</strong>如果<strong>交易的接收者地址是一个合约地址，则是对合约的调用。如果接收者地址是空，则是合约的创建。</strong>对于合约的调用，矿工节点会<strong>加载合约的字节码和状态，并按照交易中指定的函数和参数执行合约代码。</strong>对于合约的创建，矿工节点会在以太坊网络上创建新的合约账户，并<strong>将合约的字节码存储到账户的代码字段</strong>。</li>
<li><strong>状态变更：</strong>在执行合约的过程中，<strong>EVM会根据合约的代码逻辑和数据操作来进行状态变更。</strong>这包括更新合约的存储（Storage）和内存（Memory），修改账户余额，创建新的合约账户等。<strong>状态变更会被记录在内存中</strong>，但<strong>尚未写入区块链</strong>。</li>
<li><strong>状态回滚：</strong>如果<strong>合约执行过程中发生错误或抛出异常，EVM会回滚之前的状态变更，恢复到执行前的状态。</strong></li>
<li><strong>交易广播：</strong>如果交易通过了所有验证，并且燃气消耗检查也通过，<strong>矿工节点将把交易添加到待处理交易池中</strong>，等待被打包进区块。</li>
</ul>
<h1 id="以太坊的字节码、操作码是什么、如何进行单步调试、观察栈、内存的变化"><a href="#以太坊的字节码、操作码是什么、如何进行单步调试、观察栈、内存的变化" class="headerlink" title="以太坊的字节码、操作码是什么、如何进行单步调试、观察栈、内存的变化"></a>以太坊的字节码、操作码是什么、如何进行单步调试、观察栈、内存的变化</h1><p>字节码是一种低级的<strong>指令集</strong>，用于在以太坊虚拟机（EVM）上执行智能合约。操作码是字节码中的<strong>具体指令</strong>，用于执行各种操作，例如算术运算、逻辑运算、内存访问等</p>
<p>Remix、Geth控制台、Tenderly….</p>
<h1 id="合约中的数据在存储中的组织形式、内存布局"><a href="#合约中的数据在存储中的组织形式、内存布局" class="headerlink" title="合约中的数据在存储中的组织形式、内存布局"></a>合约中的数据在存储中的组织形式、内存布局</h1><p>数据可以存储在两个地方：存储（storage）和内存（memory）。</p>
<ol>
<li>存储（Storage）：存储<strong>是永久性的，用于持久化保存合约的状态数据</strong>。存储使用键值对的形式进行组织，其中键是一个256位的整数，值可以是任意大小的字节串。存储的访问是昂贵的，每次读取或写入都会消耗燃气。存储的内容在区块链上永久保存，并且可以被其他合约或外部账户访问。</li>
<li>内存（Memory）：内存<strong>是临时性的，用于在合约执行期间存储临时数据</strong>。内存的访问速度较快，但在合约执行结束后会被清空。内存的布局是线性的，从位置0开始，可以按需分配和释放。合约可以通过指定偏移量和长度来访问内存中的数据。</li>
</ol>
<p>内存布局包括以下几个部分：</p>
<ul>
<li>栈（Stack）：栈用于存储函数调用时的局部变量、函数参数和返回值等数据。栈以先进后出的方式管理数据。</li>
<li>活动区域（Active Area）：活动区域用于存储当前正在执行的函数的局部变量和临时变量等数据。</li>
<li>自由区域（Free Area）：自由区域是未被使用的内存空间，可以用于存储额外的临时数据。</li>
</ul>
<h1 id="哪些地方会收取交易费gas？"><a href="#哪些地方会收取交易费gas？" class="headerlink" title="哪些地方会收取交易费gas？"></a>哪些地方会收取交易费gas？</h1><p>每个操作码都有一个固定的燃气成本，对存储区域的写入和读取操作都会消耗燃气</p>
<p>非cesop（constant external state operation）操作：cesop操作是指不修改合约状态的操作，如只读函数调用。这些操作不会产生燃气费用。</p>
<h1 id="合约的内联汇编是什么、如何通过内联汇编操作数据"><a href="#合约的内联汇编是什么、如何通过内联汇编操作数据" class="headerlink" title="合约的内联汇编是什么、如何通过内联汇编操作数据"></a>合约的内联汇编是什么、如何通过内联汇编操作数据</h1><p>内联汇编是一种在<strong>底层访问以太坊虚拟机的语言</strong>，实现一些高级语言无法直接表达的功能。</p>
<p>通过 <code>assembly &#123;&#125;</code> 包裹代码</p>
<h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><p>智能合约是存储在区块链上的一段程序代码，智能合约无需信任，其有几个特点：自动执行、结果可预见、记录公开可审计、透明和不可篡改、去中心化等等</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/12/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E9%A2%84%E8%A8%80%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E9%A2%84%E8%A8%80%E6%9C%BA/" class="post-title-link" itemprop="url">预言机</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-12 00:00:00" itemprop="dateCreated datePublished" datetime="2022-12-12T00:00:00+08:00">2022-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/" itemprop="url" rel="index">
                    <span itemprop="name">区块链其他</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="预言机"><a href="#预言机" class="headerlink" title="预言机"></a>预言机</h1><p>预言机是指数据馈送，它<strong>提取区块链数据源（链下）的数据并将数据存放到区块链（链上）上供智能合约使用。</strong> 因为运行在以太坊上的智能合约无法访问存储在区块链网络之外的信息，预言机是必不可少的。</p>
<p>赋予智能合约使用链下数据输入执行的能力，扩展了去中心化应用程序的价值。 例如，去中心化预测市场依靠预言机提供关于结果的信息，并且能够使用这些信息验证用户的预测。 <strong>假设 Alice 下注 20 个以太币赌谁将成为下一任美国 总统</strong>。 在这种情况下，预测市场去中心化应用程序<strong>需要预言机来确认选举结果，并判定 Alice 是否有资格获得付款。</strong></p>
<h2 id="什么是区块链预言机？"><a href="#什么是区块链预言机？" class="headerlink" title="什么是区块链预言机？"></a>什么是区块链预言机？</h2><p>预言机是指获取、验证外部信息（即<strong>存储在链下的信息</strong>）并将外部信息传送给在区块链上运行的智能合约的应用程序。 除了“拉取”链下数据并在以太坊进行广播之外，预言机还将信息从区块链“推送”到外部系统。 在用户通过以太坊交易发送费用后解锁智能锁的预言机就是一个推送信息的示例。</p>
<p><strong>预言机充当一座“桥梁”，连接区块链上的智能合约与链下数据提供者。</strong> 如果没有预言机，智能合约应用程序只能访问链上数据。 预言机提供了一种使用链下数据触发智能合约功能的机制。</p>
<p>预言机的差别在于数据来源（一种或多种来源）、信任模型（中心化或去中心化）和系统架构（立即读取、发布-订阅和请求-响应）。 我们还可以根据以下因素区分预言机：是否检索外部数据供链上合约使用（输入预言机）、将区块链中的信息发送给链下应用程序（输出预言机）或在链下执行计算任务（计算预言机）。</p>
<h2 id="智能合约为什么需要预言机？"><a href="#智能合约为什么需要预言机？" class="headerlink" title="智能合约为什么需要预言机？"></a>智能合约为什么需要预言机？</h2><p>大多数开发者只是将智能合约视为在区块链特定地址运行的代码段。 然而，对于智能合约更广义的观点是，智能合约是指在满足特定条件后能够执行各方之间协议的自执行软件程序，这解释了术语“智能合约”。</p>
<p>但是，使用智能合约执行人之间的协议并非易事，因为以太坊是确定性系统。 确<strong>定性系统是指在给定初始状态和特定输入时总是产生相同结果的系统，即在使用输入计算输出的过程中不存在随机性或变化。</strong></p>
<p>要实现确定性执行，区块链将节点限制为通过仅使用存储在区块链本身中的数据就简单的二进制 (true&#x2F;false) 问题达成共识。 这类问题的示例包括：</p>
<ul>
<li>“帐户所有者（由公钥识别）是否使用配对私钥签署该交易?”</li>
<li>“该帐户是否有足够资金支付这笔交易？”</li>
<li>“这笔交易在该智能合约中是否有效？”等等。</li>
</ul>
<p>如果区块链从外部来源（例如现实世界）接收信息，确定性将不可能实现，阻止节点就区块链状态变化的有效性达成一致。 以一个智能合约为例，该合约根据从一个传统价格应用程序接口获得的当前以太币-美元汇率执行交易。 该汇率可能会经常变动（更不用说该应用程序接口可能被弃用或遭到黑客攻击），这意味着执行相同合约代码的节点会得出不同的结果。</p>
<p>对于在世界各地有数千个节点处理交易的公共区块链，如以太坊，确定性至关重要。 由于没有中心化组织作为真实性来源，期望节点应在进行相同交易后达到相同状态。 <strong>节点 A 执行智能合约的代码并得到结果“3”，而节点 B 在运行相同交易后得到“7”，这将打破共识并消除以太坊作为去中心化计算平台的价值。</strong></p>
<p>为此，<strong>预言机通常由链上运行的智能合约和一些链下组件构成。 链上合约接收其他智能合约的数据请求，并将这些请求传送给链下组件（称为预言机节点）</strong>。 这类预言机节点可以查询数据源—例如使用应用程序接口 (API)—并发送交易将请求的数据存储在智能合约的存储中。</p>
<p>就本质而言，区块链预言机弥合了区块链和外部环境之间的信息缺口，创建了“混合智能合约”。 混合智能合约的工作原理基于链上合约代码和链下基础设施的结合。 简介部分描述的去中心化预测市场就是混合智能合约的一个很好的示例。 其他示例可能包括作物保险智能合约，在一组预言机确定某些天气现象已经发生时这些合约做出赔付。</p>
<h2 id="什么是预言机问题？"><a href="#什么是预言机问题？" class="headerlink" title="什么是预言机问题？"></a>什么是预言机问题？</h2><p>通过依赖一个实体（或多个实体）向区块链引入外部信息（即将信息存储在交易的数据有效负载中），很容易让智能合约获取链下数据。 但这带来了新问题：</p>
<ul>
<li>如何验证注入信息是从正确来源提取的或者未被篡改？</li>
<li>如何确保这些数据始终可用并且定期更新？</li>
</ul>
<p>所谓的“预言机问题”显示了使用区块链预言机给智能合约发送输入时出现的问题。 重要的是确保来自预言机的数据是正确的，否则智能合约执行会产生错误结果。 免信任也同样重要，必须“信任”预言机运营者能够可靠地提供准确信息，这会剥夺智能合约最关键的特性。</p>
<p>不同预言机在解决预言机问题方面采取的办法各不相同，我们稍后探讨这些办法。 虽然任何预言机都不是完美的，但<strong>预言机的优点</strong>应该根据它如何处理以下挑战来衡量：</p>
<ol>
<li><strong>正确性</strong>：<strong>真实性是指数据是从正确来源获取的。完整性是指数据在发送到链上前保持完好无缺（即数据未修改过）。</strong></li>
<li><strong>可用性</strong>：预言机不应延迟或阻止智能合约执行操作或触发状态变化。 该特点<strong>要求预言机提供的数据在请求时可用并且不会出现间断。</strong></li>
<li><strong>激励兼容性</strong>：<strong>预言机应激励链下数据提供者向智能合约提交正确的信息</strong>。 奖励兼容性包括可归因性和问责性。 可归因性允许将一条外部信息与其提供者关联起来，而问责性将数据提供者与其提供的信息绑定，这样就可以根据所提供信息的质量对他们进行奖励或惩罚。</li>
</ol>
<h2 id="区块链预言机服务是如何运作的？"><a href="#区块链预言机服务是如何运作的？" class="headerlink" title="区块链预言机服务是如何运作的？"></a>区块链预言机服务是如何运作的？</h2><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p><strong>用户是指需要区块链外部的信息以完成特定操作的实体（即智能合约）</strong>。 <strong>预言机服务的基本工作流程始于用户向预言机合约发送数据请求</strong>。 数据请求通常将回答下列一部分或所有问题：</p>
<ol>
<li>链下节点可以在哪些来源中查询请求的信息？</li>
<li>报告者如何处理数据来源中的信息并提取有用的数据点？</li>
<li>有多少预言机节点可以参与数据检索？</li>
<li>应如何管理预言机报告中的差异？</li>
<li>在筛选提交并将报告聚合为单个值时应该采用什么方法?</li>
</ol>
<h3 id="预言机合约"><a href="#预言机合约" class="headerlink" title="预言机合约"></a>预言机合约</h3><p>预言机合约是预言机服务的链上组成部分：它<strong>侦听其他合约发出的数据请求。将数据查询转发到预言机节点并将返回的数据向客户端合约广播</strong>。 该合约还可以对返回的数据点进行一些计算，以产生聚合值并发送给请求合约。</p>
<p>预言机合约公开了一些函数，客户端合约在发出数据请求时调用它们。 收到新查询后，<strong>智能合约将触发一个日志事件</strong>，其中有数据请求详细信息。 这将通知订阅该日志的链下节点（通常使用类似 JSON-RPC <code>eth_comment</code> 的命令），让其继续检索日志事件中定义的数据。</p>
<p>下面是 Pedro Costa 提供的预言机合约示例。 它是一个简单的预言机服务，可以在其他智能合约发出请求时查询链下应用程序接口，并在区块链上存储请求的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.21 &lt;0.6.0;</span><br><span class="line"></span><br><span class="line">contract Oracle &#123;</span><br><span class="line">  Request[] requests; //list of requests made to the contract</span><br><span class="line">  uint currentId = 0; //increasing request id</span><br><span class="line">  uint minQuorum = 2; //minimum number of responses to receive before declaring final result</span><br><span class="line">  uint totalOracleCount = 3; // Hardcoded oracle count</span><br><span class="line"></span><br><span class="line">  // defines a general api request</span><br><span class="line">  struct Request &#123;</span><br><span class="line">    uint id;                            //request id</span><br><span class="line">    string urlToQuery;                  //API url</span><br><span class="line">    string attributeToFetch;            //json attribute (key) to retrieve in the response</span><br><span class="line">    string agreedValue;                 //value from key</span><br><span class="line">    mapping(uint =&gt; string) answers;     //answers provided by the oracles</span><br><span class="line">    mapping(address =&gt; uint) quorum;    //oracles which will query the answer (1=oracle hasn&#x27;t voted, 2=oracle has voted)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //event that triggers oracle outside of the blockchain</span><br><span class="line">  event NewRequest (</span><br><span class="line">    uint id,</span><br><span class="line">    string urlToQuery,</span><br><span class="line">    string attributeToFetch</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  //triggered when there&#x27;s a consensus on the final result</span><br><span class="line">  event UpdatedRequest (</span><br><span class="line">    uint id,</span><br><span class="line">    string urlToQuery,</span><br><span class="line">    string attributeToFetch,</span><br><span class="line">    string agreedValue</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  function createRequest (</span><br><span class="line">    string memory _urlToQuery,</span><br><span class="line">    string memory _attributeToFetch</span><br><span class="line">  )</span><br><span class="line">  public</span><br><span class="line">  &#123;</span><br><span class="line">    uint length = requests.push(Request(currentId, _urlToQuery, _attributeToFetch, &quot;&quot;));</span><br><span class="line">    Request storage r = requests[length-1];</span><br><span class="line"></span><br><span class="line">    // Hardcoded oracles address</span><br><span class="line">    r.quorum[address(0x6c2339b46F41a06f09CA0051ddAD54D1e582bA77)] = 1;</span><br><span class="line">    r.quorum[address(0xb5346CF224c02186606e5f89EACC21eC25398077)] = 1;</span><br><span class="line">    r.quorum[address(0xa2997F1CA363D11a0a35bB1Ac0Ff7849bc13e914)] = 1;</span><br><span class="line"></span><br><span class="line">    // launch an event to be detected by oracle outside of blockchain</span><br><span class="line">    emit NewRequest (</span><br><span class="line">      currentId,</span><br><span class="line">      _urlToQuery,</span><br><span class="line">      _attributeToFetch</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // increase request id</span><br><span class="line">    currentId++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //called by the oracle to record its answer</span><br><span class="line">  function updateRequest (</span><br><span class="line">    uint _id,</span><br><span class="line">    string memory _valueRetrieved</span><br><span class="line">  ) public &#123;</span><br><span class="line"></span><br><span class="line">    Request storage currRequest = requests[_id];</span><br><span class="line"></span><br><span class="line">    //check if oracle is in the list of trusted oracles</span><br><span class="line">    //and if the oracle hasn&#x27;t voted yet</span><br><span class="line">    if(currRequest.quorum[address(msg.sender)] == 1)&#123;</span><br><span class="line"></span><br><span class="line">      //marking that this address has voted</span><br><span class="line">      currRequest.quorum[msg.sender] = 2;</span><br><span class="line"></span><br><span class="line">      //iterate through &quot;array&quot; of answers until a position if free and save the retrieved value</span><br><span class="line">      uint tmpI = 0;</span><br><span class="line">      bool found = false;</span><br><span class="line">      while(!found) &#123;</span><br><span class="line">        //find first empty slot</span><br><span class="line">        if(bytes(currRequest.answers[tmpI]).length == 0)&#123;</span><br><span class="line">          found = true;</span><br><span class="line">          currRequest.answers[tmpI] = _valueRetrieved;</span><br><span class="line">        &#125;</span><br><span class="line">        tmpI++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      uint currentQuorum = 0;</span><br><span class="line"></span><br><span class="line">      //iterate through oracle list and check if enough oracles(minimum quorum)</span><br><span class="line">      //have voted the same answer has the current one</span><br><span class="line">      for(uint i = 0; i &lt; totalOracleCount; i++)&#123;</span><br><span class="line">        bytes memory a = bytes(currRequest.answers[i]);</span><br><span class="line">        bytes memory b = bytes(_valueRetrieved);</span><br><span class="line"></span><br><span class="line">        if(keccak256(a) == keccak256(b))&#123;</span><br><span class="line">          currentQuorum++;</span><br><span class="line">          if(currentQuorum &gt;= minQuorum)&#123;</span><br><span class="line">            currRequest.agreedValue = _valueRetrieved;</span><br><span class="line">            emit UpdatedRequest (</span><br><span class="line">              currRequest.id,</span><br><span class="line">              currRequest.urlToQuery,</span><br><span class="line">              currRequest.attributeToFetch,</span><br><span class="line">              currRequest.agreedValue</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="预言机节点"><a href="#预言机节点" class="headerlink" title="预言机节点"></a>预言机节点</h3><p>预言机节点是预言机服务的链下组件：它从外部来源提取信息（例如在第三方服务器上托管的应用程序接口）并将信息置于链上供智能合约使用。 预言机节点侦听链上预言机合约中的事件，继而完成日志中描述的任务。</p>
<p>预言机节点的常见任务是，向应用程序接口服务发送 HTTP GET请求，解析响应以提取相关数据，设置为区块链可读的输出格式，并通过将输入包含在预言机合约的交易中将其发送到链上 在利用“真实性证明”证明所提交信息的有效性和完整性时，可能也会用到预言机节点，我们稍后会对此进行探讨。</p>
<p>计算型预言机还依赖链下节点执行密集的计算任务，考虑到燃料成本和区块大小限制，这类计算在链上执行是不切实际的。 例如，预言机节点的任务可能是生成一个可验证的随机数字（例如，用于区块链游戏）。</p>
<h2 id="预言机设计模式"><a href="#预言机设计模式" class="headerlink" title="预言机设计模式"></a>预言机设计模式</h2><p>预言机有不同的类型，包括立即读取、发布-订阅和请求-响应，后两者在太坊智能合约中最受欢迎。 下面简要介绍两类预言机服务：</p>
<h3 id="发布-订阅预言机"><a href="#发布-订阅预言机" class="headerlink" title="发布-订阅预言机"></a>发布-订阅预言机</h3><p>基于发布-订阅机制的<strong>预言机服务公开“数据馈送”，其他合约可以定期读取以获取信息</strong>。 在这种情况下，数据可能会频繁变化，因此客户端合约必须侦听预言机存储中数据的更新。 向用户提供最新以太币-美元价格的预言机便是一个很好的示例。</p>
<h3 id="请求-响应预言机"><a href="#请求-响应预言机" class="headerlink" title="请求-响应预言机"></a>请求-响应预言机</h3><p>请求-响应设置允许客户端合约请求除发布-订阅预言机所提供数据以外的任意数据。 请求-响应预言机最适合以下条件下：</p>
<ul>
<li>数据集过大，无法存储在智能合约的存储中</li>
<li>用户在任何时间点只需要一小部分数据</li>
</ul>
<p>虽然比发布-订阅预言机复杂，但请求-响应预言机基本上和我们在上一节中描述的一样。 预言机将有一个链上组件，用于接收数据请求并传送给链下节点进行处理。发起数据查询的用户必须承担从链下来源检索信息的费用。 客户端合约还必须提供资金，用以支付预言机合约通过请求中指定的回调函数返回响应所产生的燃料费用。</p>
<h2 id="预言机的类型"><a href="#预言机的类型" class="headerlink" title="预言机的类型"></a>预言机的类型</h2><h3 id="中心化预言机"><a href="#中心化预言机" class="headerlink" title="中心化预言机"></a>中心化预言机</h3><p><strong>中心化预言机由单个实体控制</strong>，该实体负责聚合链下信息并按照请求更新预言机合约的数据。 中心化预言机效率高，因为它们依赖单一真实性来源。 在专有数据集由所有者直接发布并且有公认签名的情况下，中心化预言机甚至可能是更好的选择。 但是，使用中心化预言机会带来各种问题：</p>
<ul>
<li><strong>低正确性保障：</strong>使用中心化预言机时，无法确认提供的信息是否正确。 预言机提供者可能“信誉良好”，但这并不能排除有人行为不端或黑客篡改系统的可能性。 如果预言机被破坏，智能合约将基于错误数据执行。</li>
<li><strong>可用性差：</strong>中心化预言机无法保证始终向其他智能合约提供链下数据。 如果提供者决定关闭服务或者黑客劫持了预言机的链下组件，智能合约则会面临拒绝服务 (Dos) 攻击的风险。</li>
<li><strong>激励兼容性差：</strong>中心化预言机的激励往往设计不善或根本没有激励，鼓励数据提供者发送准确&#x2F;未更改的信息。 为预言机的服务付费可能会鼓励诚实的行为，但这可能还不够。 由于智能合约控制着巨额价值，操纵预言机数据的收益是前所未有的。</li>
</ul>
<h3 id="去中心化预言机"><a href="#去中心化预言机" class="headerlink" title="去中心化预言机"></a>去中心化预言机</h3><h4 id="高正确性保障"><a href="#高正确性保障" class="headerlink" title="高正确性保障"></a>高正确性保障</h4><p>去中心化预言机尝试<strong>使用不同的方法实现数据的正确性</strong>。 其中包括使用证明来证明返回信息的真实性和完整性，以及要求多个实体就链下数据的有效性集体达成一致。</p>
<h4 id="真实性证明"><a href="#真实性证明" class="headerlink" title="真实性证明"></a>真实性证明</h4><p>真实性证明是一种加密机制，<strong>支持对从外部来源检索的信息进行独立验证</strong>。 这些证明可以验证信息的来源，并在检索后发现对数据可能进行的更改。</p>
<p>真实性证明的示例包括：</p>
<p><strong>传输层安全性 (TLS) 证明</strong>：预言机节点通常使用基于传输层安全性 (TLS) 协议的安全 HTTP 连接从外部数据源检索数据。 一些去中心化预言机使用真实性证明验证传输层安全性会话（即，确认节点和特定服务器之间的信息交换），并确认会话内容未被改动。</p>
<p><strong>可信执行环境 (TEE) 认证</strong>：可信执行环境 (TEE) 是一种沙盒计算环境，它与主机系统的操作进程隔离。 可信执行环境确保在计算环境中存储&#x2F;使用的任何应用代码或数据都保持完整性、保密性和不可变性。 用户还可以生成一个认证，证明应用程序实例正在可信执行环境中运行。</p>
<p>某些类别的去中心化预言机要求预言机节点运营者提供可信执行环境认证。 这向用户证实，节点运营者在可信执行环境中运行预言机客户端的实例。 可信执行环境防止外部进程更改或读取应用程序的代码和数据，因此，这些认证证明预言机节点保持了信息的完整性和保密性。</p>
<h4 id="基于共识的信息验证"><a href="#基于共识的信息验证" class="headerlink" title="基于共识的信息验证"></a>基于共识的信息验证</h4><p>为智能合约提供数据时，中心化预言机依靠单一真实性来源，因此有可能发布不准确的信息。 去中心化预言机依靠多个预言机节点查询链下信息，解决了这个问题。 通过对多个来源的数据进行比较，去中心化预言机降低了将无效信息传递到链上合约的风险。</p>
<p>然而，去中心化预言机必须处理从多个链下来源检索的信息中的差异。 为了尽量减少信息差异并确保传送给预言机合约的数据反映了预言机节点的集体看法，去中心化预言机采用了下列机制：</p>
<h5 id="对数据的准确性进行投票-质押"><a href="#对数据的准确性进行投票-质押" class="headerlink" title="对数据的准确性进行投票&#x2F;质押"></a>对数据的准确性进行投票&#x2F;质押</h5><p>一些去中心化预言机网络要求参与者对数据查询答案的准确性进行投票或质押（例如，“谁赢得了 2020 年美国大选?”） （例如，“谁赢得了 2020 年美国大选?”） 然后，聚合协议聚合投票和质押，并将多数参与者支持的答案作为有效答案。</p>
<p>如果节点的答案不同于多数答案，将对其进行惩罚，即将其代币分发给提供更正确值的其他节点。 强制节点在提供数据之前提供保证金将激励节点做出诚实的响应，因为假定节点是理性的经济活动参与者，意在最大限度地增加回报。</p>
<p>质押&#x2F;投票还保护去中心化预言机免受“女巫攻击”，在这种攻击中，恶意参与者创建多个身份来利用共识系统。 然而，质押机制不能防止“揩油行为”（预言机节点从其他节点复制信息）和“懒散验证”（预言机节点随大流而不亲自验证信息）。</p>
<h5 id="谢林点机制"><a href="#谢林点机制" class="headerlink" title="谢林点机制"></a>谢林点机制</h5><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Focal_point_(game_theory)">谢林点</a>是一个博弈论概念，它假设在缺乏任何沟通的情况下，多个实体总是默认对一个问题选择共同解决方案。 谢林点机制常用于去中心化预言机网络，使节点对数据请求的应答达成共识。</p>
<p>一个早期的示例是<a target="_blank" rel="noopener" href="https://blog.ethereum.org/2014/03/28/schellingcoin-a-minimal-trust-universal-data-feed/">谢林币</a>，这是一种提议的数据馈送，参与者提交“标量”问题的答案（这些问题的答案由数量描述，例如“以太币的价格是多少?”）及存款。 提供的值在第 25 和第 75 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Percentile">百分位</a>之间的用户将得到奖励，而提供的值大幅偏离中值的用户将受到惩罚。</p>
<p>虽然谢林币目前已不存在，但许多去中心化预言机—特别是 <a target="_blank" rel="noopener" href="https://docs.makerdao.com/smart-contract-modules/oracle-module">Maker 协议预言机</a>—仍使用谢林点机制来提高预言机数据的准确性。 每个 Maker 预言机均由提交抵押品资产的市场价格的链下对等节点网络（“中继者”和“馈送者”）和链上“中值器”合约组成，后者计算所有提供价值的中值。 规定的延迟期结束后，该中值成为相关资产的新参考价格。</p>
<p>使用谢林点机制的其他预言机示例包括 <a target="_blank" rel="noopener" href="https://docs.chain.link/docs/off-chain-reporting/">Chainlink 链下报告</a>和 Witnet。 在这两种系统中，对等网络中的预言机节点的答复聚合成一个单一聚合值，如平均值或中值。 根据其答复与聚合值的一致或偏离程度奖励或惩罚节点。</p>
<p>谢林点机制具有吸引力，因为这类机制能够最大限度地减少对链上的影响（只需要发送一笔交易）同时又能保证去中心化。 后者是可行的，因为节点必须批准已提交答复的列表，然后再将答复输入生成平均值&#x2F;中值的算法。</p>
<h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><p>去中心化预言机服务确保链下数据对智能合约的高可用性。 高可用性是通过对链下信息来源和负责将信息传输到链上的节点同时去中心化实现的。</p>
<p>这确保了容错，因为预言机合约能够依靠多个节点（这些节点也依靠多个数据源）执行其他合约发出的查询。 在信息来源<em>和</em>节点运营商层面实现去中心化至关重要—提供从同一来源检索的信息的预言机节点网络将遇到与中心化预言机相同的问题。</p>
<p>基于质押的预言机也可以对未能快速响应数据请求的节点运营商进行惩罚。 这极大地激励了预言机节点投资于容错基础设施并及时提供数据。</p>
<h4 id="激励兼容性好"><a href="#激励兼容性好" class="headerlink" title="激励兼容性好"></a>激励兼容性好</h4><p>去中心化预言机采纳了不同的激励设计，避免预言机节点中出现<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Byzantine_fault">拜占庭</a>行为。 具体而言，它们实现了<em>可归因性</em>和<em>问责性</em>：</p>
<ol>
<li>通常，要求去中心化预言机节点对它们为了响应数据请求而提供的数据签名。 这些信息有助于评估预言机节点的历史表现，让用户在发出数据请求时筛选掉不可靠的预言机节点。 示例包括 Chainlink 的<a target="_blank" rel="noopener" href="https://oracle.reputation.link/">预言机信誉</a>或 Witnet 的<a target="_blank" rel="noopener" href="https://docs.witnet.io/intro/about/architecture#algorithmic-reputation-system">算法信誉系统</a>。</li>
<li>如前所述，去中心化预言机可能要求节点对其提交数据的真实性的可信度进行质押。 如果声明得到证实，这笔质押可以连同诚信服务的奖励一起返还。 但是如果信息不正确，也可以对节点进行惩罚，这就提供了一定程度的问责性。</li>
</ol>
<h2 id="预言机在智能合约中的应用"><a href="#预言机在智能合约中的应用" class="headerlink" title="预言机在智能合约中的应用"></a>预言机在智能合约中的应用</h2><p>以下是以太坊中预言机的常见用例：</p>
<h3 id="检索金融数据"><a href="#检索金融数据" class="headerlink" title="检索金融数据"></a>检索金融数据</h3><p><a target="_blank" rel="noopener" href="https://ethereum.org/zh/defi/">去中心化金融</a> (DeFi) 应用程序允许点对点贷款、借款和资产交易。 通常，这需要获取不同的金融信息，包括汇率数据（用于计算加密货币的法币价值或比较两种代币的价格）和资本市场数据（用于计算代币化资产的价值，如黄金或美元）。</p>
<p>例如，如果你计划构建一个去中心化金融贷款协议，将需要查询作为抵押品存放的资产（如以太币）的当前市场价格。 这就是为什么你的智能合约可以确定抵押品资产的价值，并确定它们可以从系统中借出多少钱。</p>
<p>去中心化金融中流行的“价格预言机”（常用名称）包括 Chainlink Price Feeds、Compound Protocol 的<a target="_blank" rel="noopener" href="https://compound.finance/docs/prices">开放式喂价工具</a>、Uniswap 的<a target="_blank" rel="noopener" href="https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles">时间加权平均价格 (TWAP) </a>以及 <a target="_blank" rel="noopener" href="https://docs.makerdao.com/smart-contract-modules/oracle-module">Maker 预言机</a>。 建议将这些价格预言机集成到你的项目之前，先了解它们的注意事项。 这篇<a target="_blank" rel="noopener" href="https://blog.openzeppelin.com/secure-smart-contract-guidelines-the-dangers-of-price-oracles/">文章</a>详细分析了计划使用任何上述价格预言机时的考虑因素。</p>
<h3 id="生成可验证的随机性"><a href="#生成可验证的随机性" class="headerlink" title="生成可验证的随机性"></a>生成可验证的随机性</h3><p>某些区块链应用程序（如基于区块链的游戏或彩票方案），需要高度的不可预测性和随机性才能有效工作。 然而，区块链的确定性执行消除了任何随机性来源。</p>
<p>通常的方法是使用伪随机密码函数，例如<code>blockhash</code>，但这也适用于其他参与者[的](<a target="_blank" rel="noopener" href="https://ethereum.stackexchange.com/questions/3140/risk-of-using-blockhash-other-miners-preventing-attack#:~:text=So">https://ethereum.stackexchange.com/questions/3140/risk-of-using-blockhash-other-miners-preventing-attack#:~:text=So</a> while the miners can,to one of the players.)操作，即解决工作量证明算法的矿工。 此外，以太坊<a target="_blank" rel="noopener" href="https://ethereum.org/zh/roadmap/merge/">过渡到权益证明</a>意味着开发者不能再依靠 <code>blockhash</code> 获得链上随机性（然而，信标链的 <a target="_blank" rel="noopener" href="https://eth2book.info/altair/part2/building_blocks/randomness">RANDAO 机制</a>提供了另一种随机性来源）。</p>
<p>可以在链下生成随机值并发送到链上，但这样做对用户有很高的信任要求。 他们必须相信值确实是通过不可预测的机制产生的，并且未在传输过程中被改动。</p>
<p>为链下计算设计的预言机解决了这一问题，它们安全地生成链下随机结果并连同证实该过程不可预测性的加密证明一起在链上广播。 一个示例是 <a target="_blank" rel="noopener" href="https://docs.chain.link/docs/chainlink-vrf/">Chainlink VRF</a>（可验证随机函数），它是一个可证明公平且防篡改的随机数生成器 (RNG)，用于为依靠不可预测结果的应用程序构建可靠的智能合约。</p>
<h3 id="获取事件结果"><a href="#获取事件结果" class="headerlink" title="获取事件结果"></a>获取事件结果</h3><p>有了预言机，创建响应真实事件的智能合约并非难事。 预言机服务允许合约通过链下组件连接到外部应用程序接口并使用来自这些数据源的信息，实现这一点。 例如，前面介绍的预测去中心化应用程序可能会请求预言机返回可信链下来源（如美联社）提供的选举结果。</p>
<p>使用预言机根据实际结果检索数据支持其他新用例，包括去中心化保险应用程序。 向用户付费的保险智能合约需要准确的信息（例如，天气数据、灾难报告等）才能有效工作。</p>
<h3 id="智能合约自动化"><a href="#智能合约自动化" class="headerlink" title="智能合约自动化"></a>智能合约自动化</h3><p>与流行的说法相反，智能合约不会自动运行，外部帐户 (EOA) 或另一种合约帐户必须触发正确的函数才能执行合约的代码。 大多数情况下，合约的大部分函数是公共函数，可由外部帐户和其他合约调用。</p>
<p>但合约中也有其他合约无法访问的<em>私有函数</em>；通常它们对于去中心化应用程序的整体功能至关重要。 可能的示例包括定期为用户铸造新非同质化代币的 <code>mintERC721Token()</code> 函数、在预测市场上授予付款的函数或解锁去中心化交易所中质押的代币的函数。</p>
<p>开发者需要每隔一段时间触发这些函数，以保持应用程序平稳运行。 然而，这可能导致开发者在普通任务上浪费更多时间，这就是智能合约自动执行具有吸引力的原因。</p>
<p>一些去中心化预言机网络提供自动化服务，允许链下预言机节点根据用户定义的参数触发智能合约函数。 通常，这需要向预言机服务“注册”目标合约，提供资金支付预言机运营商，并指定触发合约的条件或时间。</p>
<p>一个示例是 Chainlink 的 <a target="_blank" rel="noopener" href="https://chain.link/keepers">Keeper 网络</a>，它为智能合约提供一些选项，以信任最小化和去中心化的方式将定期维护任务外包。 请阅读官方 <a target="_blank" rel="noopener" href="https://docs.chain.link/docs/chainlink-keepers/introduction/">Keeper 相关文档</a>，了解如何使合约与 keeper 兼容并使用 Upkeep 服务。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/12/11/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E9%92%B1%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/11/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E9%92%B1%E5%8C%85/" class="post-title-link" itemprop="url">钱包</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-11 00:00:00" itemprop="dateCreated datePublished" datetime="2022-12-11T00:00:00+08:00">2022-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-09 10:01:34" itemprop="dateModified" datetime="2023-11-09T10:01:34+08:00">2023-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/" itemprop="url" rel="index">
                    <span itemprop="name">区块链其他</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>钱包用来存钱的，在区块链中，我们的数字资产都会对应到一个账户地址上， 只有拥有账户的钥匙（私钥）才可以对资产进行消费（用私钥对消费交易签名）。<br>私钥和地址的关系如下：<img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/img/9efa20eff737374479d9c6bb86db82b3.png!wl" alt="关系"></p>
<p><strong>私钥通过椭圆曲线生成公钥， 公钥通过对私钥进行哈希函数生成地址，这两个过程都是单向的。</strong></p>
<h2 id="如何创建账号"><a href="#如何创建账号" class="headerlink" title="如何创建账号"></a>如何创建账号</h2><p>创建账号关键是生成一个私钥， 私钥是一个32个字节的数， <strong>生成一个私钥在本质上在1到2^256之间选一个数字</strong>。<br>因此生成密钥的第一步也是最重要的一步，是要找到足够安全的熵源，即随机性来源，只要选取的结果是不可预测或不可重复的，那么选取数字的具体方法并不重要。从编程的角度来看，一般是通过在一个密码学安全的随机源(不建议大家自己去写一个随机数)中取出一长串随机字节，对其使用SHA256哈希算法进行运算，这样就可以方便地产生一个256位的数字。</p>
<blockquote>
<p>实际过程需要比较下是否小于n-1（n &#x3D; 1.158 * 10^77, 略小于2^256），我们就有了一个合适的私钥。否则，我们就用另一个随机数再重复一次。这样得到的私钥就可以根据上面的方法进一步生成公钥及地址。</p>
</blockquote>
<h2 id="BIP32"><a href="#BIP32" class="headerlink" title="BIP32"></a>BIP32</h2><p>钱包也是一个私钥的容器，按照上面的方法，我们可以生成一堆私钥（一个人也有很多账号的需求，可以更好保护隐私），而每个私钥都需要备份就特别麻烦的。</p>
<blockquote>
<p>最早期的比特币钱包就是就是这样，还有一个昵称：“Just a Bunch Of Keys(一堆私钥)“</p>
</blockquote>
<p>为了解决这种麻烦，就有了<a target="_blank" rel="noopener" href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP32 提议</a>： 根据一个随机数种子通过分层确定性推导的方式得到n个私钥，这样保存的时候，只需要保存一个种子就可以，私钥可以推导出来，如图：</p>
<img src="/noteimg/区块链/区块链其他/img/50.png" alt="推导" style="zoom: 67%;" />
（图来自精通比特币）上图中的孙秘钥就可以用来签发交易。

<blockquote>
<p>补充说明下 BIP: Bitcoin Improvement Proposals 比特币改进建议, bip32是第32个改进建议。<br>BIP32提案的名字是：Hierarchical Deterministic Wallets， 就是我们所说的HD钱包。</p>
</blockquote>
<p>来分析下这个分层推导的过程，第一步推导主秘钥的过程：<br><img src="/noteimg/区块链/区块链其他/img/40.jpeg" alt="推导主秘钥的过程" style="zoom:67%;" /></p>
<p>根种子输入到HMAC-SHA512算法中就可以得到一个可用来创造主私钥(m) 和 一个主链编码（ a master chain code)这一步生成的秘钥（由私钥或公钥）及主链编码再加上一个索引号，将作为HMAC-SHA512算法的输入继续衍生出下一层的私钥及链编码，如下图：<img src="/noteimg/区块链/区块链其他/img/40-16965572565772.jpeg" alt="衍生" style="zoom:67%;" /></p>
<blockquote>
<p>衍生推导的方案其实有两个：一个用父私钥推导（称为强化衍生方程），一个用父公钥推导。同时为了区分这两种不同的衍生，在索引号也进行了区分，索引号小于2^31用于常规衍生，而2^31到2^32-1之间用于强化衍生，为了方便表示索引号i’，表示2^31+i。</p>
</blockquote>
<p>因此增加索引（水平扩展）及 通过子秘钥向下一层（深度扩展）可以无限生成私钥。</p>
<p>注意， 这个推导过程是确定（相同的输入，总是有相同的输出）也是单向的，子密钥不能推导出同层级的兄弟密钥，也不能推出父密钥。如果没有子链码也不能推导出孙密钥。现在我们已经对分层推导有了认识。</p>
<p>一句话概括下BIP32就是：<strong>为了避免管理一堆私钥的麻烦提出的分层推导方案。</strong></p>
<h3 id="秘钥路径及BIP44"><a href="#秘钥路径及BIP44" class="headerlink" title="秘钥路径及BIP44"></a>秘钥路径及BIP44</h3><p>通过这种分层（树状结构）推导出来的秘钥，通常用路径来表示，每个级别之间用斜杠 &#x2F; 来表示，由主私钥衍生出的私钥起始以“m”打头。因此，第一个母密钥生成的子私钥是m&#x2F;0。第一个公共钥匙是M&#x2F;0。第一个子密钥的子密钥就是m&#x2F;0&#x2F;1，以此类推。</p>
<p>BIP44则是为这个路径约定了一个规范的含义(也扩展了对多币种的支持)，BIP0044指定了包含5个预定义树状层级的结构：<br><code>m / purpose&#39; / coin&#39; / account&#39; / change / address_index</code><br>m是固定的, Purpose也是固定的，值为44（或者 0x8000002C）<br><strong>Coin type</strong><br>这个代表的是币种，0代表比特币，1代表比特币测试链，60代表<a target="_blank" rel="noopener" href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊</a><br>完整的币种列表地址：<a target="_blank" rel="noopener" href="https://github.com/satoshilabs/slips/blob/master/slip-0044.md">https://github.com/satoshilabs/slips/blob/master/slip-0044.md</a><br><strong>Account</strong><br>代表这个币的账户索引，从0开始<br><strong>Change</strong><br>常量0用于外部(收款地址)，常量1用于内部（也称为找零地址）。外部用于在钱包外可见的地址（例如，用于接收付款）。内部链用于在钱包外部不可见的地址，用于返回交易变更。 (所以一般使用0)<br><strong>address_index</strong><br>这就是地址索引，从0开始，代表生成第几个地址，官方建议，每个account下的address_index不要超过20</p>
<p>根据 <a target="_blank" rel="noopener" href="https://github.com/ethereum/EIPs/issues/85">EIP85提议的讨论</a>以太坊钱包也遵循BIP44标准，确定路径是<code>m/44&#39;/60&#39;/a&#39;/0/n</code><br>a 表示帐号，n 是第 n 生成的地址，60 是在 <a target="_blank" rel="noopener" href="https://github.com/satoshilabs/slips/blob/master/slip-0044.md">SLIP44 提案</a>中确定的以太坊的编码。所以我们要开发以太坊钱包同样需要对比特币的钱包提案BIP32、BIP39有所了解。</p>
<p>一句话概括下BIP44就是：<strong>给BIP32的分层路径定义规范</strong></p>
<h2 id="BIP39"><a href="#BIP39" class="headerlink" title="BIP39"></a>BIP39</h2><p>BIP32 提案可以让我们保存一个随机数种子（通常16进制数表示），而不是一堆秘钥，确实方便一些，不过用户使用起来(比如冷备份)也比较繁琐，这就出现了<a target="_blank" rel="noopener" href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP39</a>，它是使用助记词的方式，生成种子的，这样用户只需要记住12（或24）个单词，单词序列通过 PBKDF2 与 HMAC-SHA512 函数创建出随机种子作为 BIP32 的种子。</p>
<p>可以简单的做一个对比，下面那一种备份起来更友好：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机数种子</span></span><br><span class="line"><span class="number">090</span>ABCB3A6e1400e9345bC60c78a8BE7</span><br><span class="line"><span class="comment">// 助记词种子</span></span><br><span class="line">candy maple cake sugar pudding cream honey rich smooth crumble sweet treat</span><br></pre></td></tr></table></figure>

<p>使用助记词作为种子其实包含2个部分：助记词生成及助记词推导出随机种子，下面分析下这个过程。</p>
<h3 id="生成助记词"><a href="#生成助记词" class="headerlink" title="生成助记词"></a>生成助记词</h3><p>助记词生成的过程是这样的：先生成一个128位随机数，再加上对随机数做的校验4位，得到132位的一个数，然后按每11位做切分，这样就有了12个二进制数，然后用每个数去查<a target="_blank" rel="noopener" href="https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md">BIP39定义的单词表</a>，这样就得到12个助记词，这个过程图示如下：</p>
<p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/img/70.png" alt="过程图"><br>（图来源于网络）</p>
<p>下面是使用bip39生成生成助记词的一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bip39 = <span class="built_in">require</span>(<span class="string">&#x27;bip39&#x27;</span>)</span><br><span class="line"><span class="comment">// 生成助记词</span></span><br><span class="line"><span class="keyword">var</span> mnemonic = bip39.<span class="title function_">generateMnemonic</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mnemonic)</span><br></pre></td></tr></table></figure>

<h3 id="助记词推导出种子"><a href="#助记词推导出种子" class="headerlink" title="助记词推导出种子"></a>助记词推导出种子</h3><p>这个过程使用密钥拉伸（Key stretching）函数，被用来增强弱密钥的安全性，PBKDF2是常用的密钥拉伸算法中的一种。<br>PBKDF2基本原理是通过一个为随机函数(例如 HMAC 函数)，把助记词明文和盐值作为输入参数，然后重复进行运算最终产生生成一个更长的（512 位）密钥种子。这个种子再构建一个确定性钱包并派生出它的密钥。</p>
<p>密钥拉伸函数需要两个参数：助记词和盐。盐可以提高暴力破解的难度。 盐由常量字符串 “mnemonic” 及一个可选的密码组成，注意使用不同密码，则拉伸函数在使用同一个助记词的情况下会产生一个不同的种子，这个过程图示图下:</p>
<p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/img/80.png" alt="过程图"><br>（图来源于网络）</p>
<p>同样代码来表示一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hdkey = <span class="built_in">require</span>(<span class="string">&#x27;ethereumjs-wallet/hdkey&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">&#x27;ethereumjs-util&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> seed = bip39.<span class="title function_">mnemonicToSeed</span>(mnemonic, <span class="string">&quot;pwd&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> hdWallet = hdkey.<span class="title function_">fromMasterSeed</span>(seed);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> key1 = hdWallet.<span class="title function_">derivePath</span>(<span class="string">&quot;m/44&#x27;/60&#x27;/0&#x27;/0/0&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;私钥：&quot;</span>+util.<span class="title function_">bufferToHex</span>(key1.<span class="property">_hdkey</span>.<span class="property">_privateKey</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> address1 = util.<span class="title function_">pubToAddress</span>(key1.<span class="property">_hdkey</span>.<span class="property">_publicKey</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;地址：&quot;</span>+util.<span class="title function_">bufferToHex</span>(address1));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;校验和地址：&quot;</span>+ util.<span class="title function_">toChecksumAddress</span>(address1.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>)));</span><br></pre></td></tr></table></figure>

<p>校验和地址是<a target="_blank" rel="noopener" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md">EIP-55</a>中定义的对大小写有要求的一种地址形式。</p>
<p>密码可以作为一个额外的安全因子来保护种子，即使助记词的备份被窃取，也可以保证钱包的安全（也要求密码拥有足够的复杂度和长度），不过另外一方面，如果我们忘记密码，那么将无法恢复我们的数字资产。</p>
<p>一句话概括下BIP39就是：<strong>通过定义助记词让种子的备份更友好</strong></p>
<blockquote>
<p>（助记词 &lt;-&gt; seed -&gt; 私钥 -&gt; 公钥 -&gt; PubKeyHash &lt;-&gt; address, 其中&lt;-&gt;表可双向转换，-&gt;表单向转换，最后的PubKeyHash转换为address的时候用的是base58编码，base58编码的原理即辗转相除法）</p>
</blockquote>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/12/08/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E6%9C%80%E5%A4%A7%E5%8F%AF%E6%8F%90%E5%8F%96%E4%BB%B7%E5%80%BCMEV/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/08/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E6%9C%80%E5%A4%A7%E5%8F%AF%E6%8F%90%E5%8F%96%E4%BB%B7%E5%80%BCMEV/" class="post-title-link" itemprop="url">最大可提取价值MEV</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-08 00:00:00" itemprop="dateCreated datePublished" datetime="2022-12-08T00:00:00+08:00">2022-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/" itemprop="url" rel="index">
                    <span itemprop="name">区块链其他</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="最大可提取价值-MEV"><a href="#最大可提取价值-MEV" class="headerlink" title="最大可提取价值 (MEV)"></a>最大可提取价值 (MEV)</h1><p>最大可提取价值 (MEV) 是指通过在区块中添加和排除交易并更改区块中的交易顺序，可以从区块生产中提取的超过标准区块奖励和燃料费用的最大值。</p>
<h2 id="MEV-提取"><a href="#MEV-提取" class="headerlink" title="MEV 提取"></a>MEV 提取</h2><p><strong>从理论上讲，最大可提取价值完全属于验证者，因为他们是唯一可以保证执行有利可图的最大可提取价值机会的一方。</strong> 但实际上，大部分 MEV 是由称为“搜索人”的独立网络参与者提取的。 搜索人在区块链数据上运行复杂的算法来检测盈利的 MEV 机会，并且有机器人自动将这些盈利交易提交到网络。</p>
<p>无论如何，验证者确实会获得全部最大可提取价值金额的一部分，<strong>因为搜索者愿意支付高昂的燃料费用（这些费用将归验证者所有）</strong>，以换取将其有利可图的交易纳入一个区块的更高可能性。 假定搜索人在经济上是合理的。搜索人愿意支付的燃料费将是 MEV 的 100% 的金额（因为如果燃料费更高，搜索人将亏钱）。</p>
<blockquote>
<p> Flashbots 是一个独立项目，它通过一项服务扩展执行客户端，该服务允许搜索者将<strong>最大可提取价值交易提交给验证者</strong>，而无需将它们透露给公共内存池。 这就防止了交易被通用领跑者领跑。</p>
</blockquote>
<h2 id="MEV-相关案例"><a href="#MEV-相关案例" class="headerlink" title="MEV 相关案例"></a>MEV 相关案例</h2><p>最大可提取价值以几种方式出现在区块链上。</p>
<h3 id="去中心化交易所-DEX-套利"><a href="#去中心化交易所-DEX-套利" class="headerlink" title="去中心化交易所 (DEX) 套利"></a>去中心化交易所 (DEX) 套利</h3><p>去中心化交易所 (DEX) 套利是最简单和最著名的最大可提取价值机会。 因此，它也是竞争最激烈的。</p>
<p>它的作用原理就像这样：如果有两个去中心化交易所以两种不同的价格提供一种代币，有人可以通过一笔原子交易，<strong>在价格较低的去中心化交易所购买此代币，并在价格较高的去中心化交易所将其出售</strong>。 得益于区块链的机制，这是真实的无风险套利。</p>
<h3 id="清算"><a href="#清算" class="headerlink" title="清算"></a>清算</h3><p>借贷协议清算提供了另一个众所周知的最大可提取价值机会。</p>
<p>Maker 和 Aave 等借贷协议要求用户存入一些抵押品（例如以太币）。 然后将这些存入的抵押品借出给其他用户。</p>
<p>然后，用户可以根据他们的需要从其他人那里借入资产和代币（例如，如果你想在 MakerDAO 治理提案中投票，你可以借用 MKR），最高可达他们所存抵押品的一定比例。 例如，如果借款金额不超过 30%，则将 100 DAI 存入协议的用户最多可以借入价值 30 DAI 的另一种资产。 该协议确定了确切的借款能力百分比。</p>
<p>随着借款人抵押品价值的波动，他们的借款能力也会波动。 如果由于市场波动，借入资产的价值超过其抵押品价值的 30%（同样，准确的百分比由协议确定，协议通常允许任何人清算抵押品，立即偿还贷款人（这类似于传统金融中的 追加保证金通知(opens in a new tab)）。 <strong>如果清算，借款人通常必须支付大笔清算费，其中有些是流向变现人的——这是多 MEV 机会出现的地方。</strong></p>
<p>搜索人竞相以最快的速度解析区块链数据，以确定哪些借款人可以被清算，并成为第一个提交清算交易并自行收取清算费的人。</p>
<h3 id="夹心-三明治-交易"><a href="#夹心-三明治-交易" class="headerlink" title="夹心(三明治)交易"></a>夹心(三明治)交易</h3><p>夹心交易是另外一种 MEV 提取的常用方法。</p>
<p>为了实现夹心交易，搜索人会监视内存池内 DEX 的大额交易。 例如，有人想要在 Uniswap 上使用 DAI 购买 10,000 UNI。 这类大额交易会对 UNI&#x2F;DAI 对产生重大的影响，可能会显着提高 UNI 相对于 DAI 的价格。</p>
<p>搜索人可以计算该大额交易对 UNI&#x2F;DAI 对的大致价格影响，并<strong>在大额交易<em>之前</em>立即执行最优买单，低价买入 UNI，然后在大额交易<em>之后</em>立即执行卖单，以大额订单造成的更高价格卖出</strong>。</p>
<p>然而，<strong>夹心交易风险很高，因为它不是原子交易</strong>（不像上文所述的 DEX 套利），而且容易受到 <a target="_blank" rel="noopener" href="https://github.com/Defi-Cartel/salmonella">salmonella 攻击(opens in a new tab)</a>。</p>
<h3 id="NFT-MEV"><a href="#NFT-MEV" class="headerlink" title="NFT MEV"></a>NFT MEV</h3><p>NFT 领域的 MEV 是一种新兴现象，而且不一定能赚钱。</p>
<p>然而，由于 NFT 交易发生在所有其他以太坊交易共享的同一个区块链上，搜寻者也可以在 NFT 市场上使用与传统 MEV 机会类似的技术。</p>
<p>例如，如果有一个流行的 NFT 下降，并且搜索者想要某个 NFT 或一组 NFT，他们可以写一个交易，使他们成为第一个排队购买 NFT 的人，或者他们可以在一个交易中购买整个 NFT 组合。 或者，如果一个 NFT 被<a target="_blank" rel="noopener" href="https://www.theblockcrypto.com/post/113546/mistake-sees-69000-cryptopunk-sold-for-less-than-a-cent">错误地以低价挂出(opens in a new tab)</a>，搜寻者就可以抢在其他购买者前面，低价抢购。</p>
<p>NFT MEV 的一个显著例子发生在一个搜寻者花费 700 万美元来<a target="_blank" rel="noopener" href="https://etherscan.io/address/0x650dCdEB6ecF05aE3CAF30A70966E2F395d5E9E5">购买(opens in a new tab)↗</a>价格底线的每一个 Cryptopunk。 一位区块链研究员<a target="_blank" rel="noopener" href="https://twitter.com/IvanBogatyy/status/1422232184493121538">在 Twitter(opens in a new tab)↗</a>上解释了买家是如何与 MEV 供应商合作以保持其购买的秘密。</p>
<h2 id="MEV-的影响"><a href="#MEV-的影响" class="headerlink" title="MEV 的影响"></a>MEV 的影响</h2><p>MEV 并不都是坏事 - 以太坊的 MEV 既有积极的作用，也有消极的影响。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>许多 <strong>DeFi 项目</strong>依靠经济上的理性行为者，来<strong>确保其协议的有用性和稳定性</strong>。 例如，DEX 套利确保用户为他们的代币获得最好、最正确的价格，而借贷协议在借款人低于抵押率时依靠快速清算来确保贷款人得到回报。如果没有理性的搜索者寻求和修复经济上的低效率，并利用协议的经济激励，DeFi 协议和一般的 dapps 可能不会像今天这样强大。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>在应用层，某些形式的 MEV，如夹心交易，会<strong>导致用户的体验明显变差。 被夹在中间的用户面临更高的滑点和更差的交易执行。</strong></p>
<p>在网络层，一般的抢跑者和他们经常参与的矿工费拍卖（当两个或更多的先行者通过逐步提高自己交易的矿工费，从而使他们的交易被打包到下一个区块），<strong>导致网络拥堵和试图运行正常交易的其他人的高矿工费。</strong></p>
<p>除了区块<em>内</em>发生的，MEV 也可能会在区块间产生有害的影响。 <strong>如果</strong>区块中可用的<strong>最大可提取价值大幅超过标准区块奖励</strong>，验证者可能会被激励重组区块并为自己捕获最大可提取价值，从而<strong>导致区块链重组和共识不稳定</strong>。</p>
<h2 id="以太坊权益证明-POS-机制下的最大可提取价值"><a href="#以太坊权益证明-POS-机制下的最大可提取价值" class="headerlink" title="以太坊权益证明 (POS) 机制下的最大可提取价值"></a>以太坊权益证明 (POS) 机制下的最大可提取价值</h2><p>如上所述，最大可提取价值对用户综合体验和共识层安全性产生了不利影响。 但以太坊向权益证明共识的过渡（称为“合并”）还可能带来与最大可提取价值有关的新风险：</p>
<h3 id="验证者中心化"><a href="#验证者中心化" class="headerlink" title="验证者中心化"></a>验证者中心化</h3><p>更大的质押池可能会有更多的资源投资进行必要的优化，以抓住最大可提取价值机会。 这些质押池提取的最大可提取价值越多，它们用来提升最大可提取价值提取能力（并增加总收入）的资源就越多，这在本质上形成了规模经济(opens in a new tab)。由于可支配的资源较少，单独质押人可能无法从最大可提取价值机会中获利。 这种情况可能会<strong>增加独立验证者加入强大的质押池以提高收益的压力</strong>，从而<strong>削弱以太坊的去中心化</strong>。</p>
<h3 id="许可内存池"><a href="#许可内存池" class="headerlink" title="许可内存池"></a>许可内存池</h3><p>为了应对三明治攻击和抢先交易攻击，<strong>交易者可能会开始与验证者进行链下交易以确保交易隐私</strong>。 <strong>交易者将潜在的最大可提取价值交易直接发送给验证者而非公共内存池，验证者将交易添加到区块中并与交易者分配利润。</strong></p>
<p>“暗池”扩展了这种模式，是一种只供访问的许可内存池，对愿意支付一定费用的用户开放。 这一趋势将<strong>弱化以太坊的无许可和免信任特性</strong>，并有可能将区块链转变成一种有利于最高出价者的“付费参与”机制。</p>
<p>许可内存池还会增加上一节中描述的中心化风险。 运行多个验证者的大型池可能会受益于为交易者和用户提供交易隐私，增加其最大可提取价值收入。</p>
<p>在合并后的以太坊中解决这些与最大可提取价值相关的问题是一个核心研究领域。 迄今为止，为了减少最大可提取价值对合并后以太坊去中心化和安全性的负面影响，提出了两种解决方案：<strong>提议者-构建者分离 (PBS)</strong> 和<strong>构建者应用程序接口</strong>。</p>
<h3 id="提议者-构建者分离"><a href="#提议者-构建者分离" class="headerlink" title="提议者-构建者分离"></a>提议者-构建者分离</h3><p>PBS旨在减轻最大可提取价值的影响，尤其是对共识层的影响。 提议者-构建者分离的主要特点是区块生产者和区块提议者规则的分离。 验证者仍然负责提出区块并投票，但有一类新的特别实体（称为<strong>区块构建者</strong>），其任务是对交易排序和构建区块。</p>
<p>在提议者-构建者分离解决方案下，区块构建者创建一个交易包并出价将其包含在信标链区块中（作为“执行有效负载”）。 选中提出下一个区块的验证者随后查看不同的出价，并选择费用最高的交易包。 提议者-构建者分离实际上创建了一个拍卖市场，让构建者和出售区块空间的验证者谈判。</p>
<p>当前，提议者-构建者分离设计采用一种<a target="_blank" rel="noopener" href="https://gitcoin.co/blog/commit-reveal-scheme-on-ethereum/">提交-披露方案(opens in a new tab)↗</a>，即构建者仅发布对区块内容（区块头）的加密承诺及他们的出价。 在接受成交出价后，提议者创建一个包括区块头的签名区块提案。 区块构建者在看到签名区块提案后可能会发布整个区块体，并且它必须还要从验证者那里获得足够多的<a target="_blank" rel="noopener" href="https://ethereum.org/zh/glossary/#attestation">认证</a>后才能最终确定区块。</p>
<h4 id="提议者-构建者分离如何减弱最大可提取价值的影响？"><a href="#提议者-构建者分离如何减弱最大可提取价值的影响？" class="headerlink" title="提议者-构建者分离如何减弱最大可提取价值的影响？"></a>提议者-构建者分离如何减弱最大可提取价值的影响？</h4><p>协议内的提议者-构建者分离将最大可提取价值提取从验证者权限范围内移除，降低了最大可提取价值对共识的影响。 相反，运行专用硬件的区块构建者将抓住出现的最大可提取价值机会。</p>
<p>不过，这并没有完全杜绝验证者与最大可提取价值有关的收入，因为构建者必须出高价才能让验证者接受他们的区块。 然而，由于验证者不再直接关注如何尽可能提高最大可提取价值收入，时间盗贼攻击的威胁降低了。</p>
<p>提议者-构建者分离也降低了最大可提取价值中心化的风险。 例如，使用提交-披露方案，构建者就无需信任验证者不会窃取最大可提取价值机会或将其暴露给其他构建者。 这就降低了单独质押人从最大可提取价值获益的门槛，否则，构建者将倾向于支持有着链下声誉的大型池并与它们进行链下交易。</p>
<p>同样，验证者不必信任构建者不会隐藏区块体或者发布无效区块，因为付款是无条件的。 即使提出的区块不可用或被其他验证者宣称无效，验证者的费用依然会支付。 在后一种情况下，区块被直接丢弃，迫使区块构建者失去所有交易费和最大可提取价值收入。</p>
<h3 id="构建者应用程序接口"><a href="#构建者应用程序接口" class="headerlink" title="构建者应用程序接口"></a>构建者应用程序接口</h3><p>虽然提议者-构建者分离有望减弱最大可提取价值提取的影响，但实现它需要对共识协议进行更改。 具体而言，需要更新信标链的<a target="_blank" rel="noopener" href="https://ethereum.org/zh/developers/docs/consensus-mechanisms/pos/#fork-choice">分叉选择</a>规则。 <a target="_blank" rel="noopener" href="https://github.com/ethereum/builder-specs">构建者应用程序接口(opens in a new tab)↗</a>是一种临时解决方案，旨在有效实现提议者-构建者分离，然而信任假设更高。</p>
<p>构建者应用程序接口是一种改良版的<a target="_blank" rel="noopener" href="https://github.com/ethereum/execution-apis/blob/main/src/engine/common.md">引擎应用程序接口(opens in a new tab)↗</a>，共识层客户端使用它向执行层客户端请求执行有效负载。 正如<a target="_blank" rel="noopener" href="https://github.com/ethereum/consensus-specs/blob/dev/specs/bellatrix/validator.md">诚实验证者规范(opens in a new tab)↗</a>中所述，选中承担区块提出职责的验证者向连接的执行客户端请求交易包，并将交易包添加到提出的信标链区块中。</p>
<p>构建者应用程序接口还充当验证者和执行层客户端之间的中间件；不同之处是，它允许信标链上的验证者从外部实体获取区块（而不是使用执行客户端在本地构建区块）。</p>
<p>下面简述构建者应用程序接口如何运作：</p>
<ol>
<li>构建者应用程序接口将验证者连接到由运行执行层客户端的区块构建者组成的网络。 与提议者-构建者分离一样，构建者专注于投资资源密集型区块构建活动，并利用不同的策略最大程度提高从最大可提取价值 + 优先费中赚取的收入。</li>
<li>验证者（运行共识层客户端）向构建者网络请求执行有效负载及出价。 构建者的出价将包含执行有效负载标头（对有效负载内容的加密承诺）和向验证者支付的费用。</li>
<li>验证者查看收到的出价并选择费用最高的执行有效负载。 使用构建者应用程序接口，验证者创建一个仅包括其签名和执行有效负载标头的“盲”信标区块提案并发送给构建者。</li>
<li>在看到盲区块提案时，运行构建者应用程序接口的构建者可能会用完整的执行有效负载响应。 这样，验证者可以创建一个“已签名”信标区块并在整个网络中传播。</li>
<li>如果区块构建者未能及时响应，使用构建者应用程序接口的验证者仍有可能在本地构建区块，这样他们就不会错过区块提出奖励。 然而，验证者不能使用当前披露的交易或另一个集合创建另一个区块，因为这相当于<em>模棱两可</em>（对同一时隙内的两个区块签名），这是一种可受到惩罚的恶行。</li>
</ol>
<p>构建者应用程序接口的一个示例实现是 <a target="_blank" rel="noopener" href="https://github.com/flashbots/mev-boost">MEV Boost(opens in a new tab)↗</a>，它是对 <a target="_blank" rel="noopener" href="https://docs.flashbots.net/Flashbots-auction/overview/">Flashbots 拍卖机制(opens in a new tab)↗</a>的改进，旨在抑制最大可提取价值在以太坊上的负面外部性。 Flashbots 拍卖允许工作量证明下的矿工将构建可获利区块的工作外包给专门的参与方，即<strong>搜索者</strong>。</p>
<p>搜索者寻找利润丰厚的最大可提取价值机会，并向矿工发送交易包以及<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/First-price_sealed-bid_auction">价格密封出价(opens in a new tab)↗</a>，以将交易包添加到区块中。 运行 mev-geth（go-ethereum (Geth) 客户端的分叉版本）的矿工只需要选择利润最高的交易包，并将其作为新区块的一部分开采。 为了避免矿工收到垃圾交易和无效交易，交易包先通过<strong>中继者</strong>验证然后在到达矿工处。</p>
<p>MEV Boost 运行机制与原来的 Flashbots 拍卖相同，但增加了一些针对以太坊向权益证明过渡的新功能。 搜索者仍然寻找有利润的交易以便添加到区块中，但一类新的名为<strong>构建者</strong>的专门参与方负责将交易聚合并打包到区块中。 构建者接受搜索者提供的价格密封出价，并进行优化以找到利润最大的排序。</p>
<p>中继者仍然负责验证交易包并将它们传送给提议者。 然而，MEV Boost 通过存储构建者发送的区块体和验证者发送的区块头，引入了负责提供<a target="_blank" rel="noopener" href="https://ethereum.org/zh/developers/docs/data-availability/">数据可用性</a>的<strong>托管</strong>。 对于托管，连接到中继的验证者请求可用的执行有效负载，并使用 MEV Boost 的排序算法选择出价 + 最大可提取价值小费最高的有效负载标头。</p>
<h4 id="构建者应用程序接口如何减弱最大可提取价值的影响？"><a href="#构建者应用程序接口如何减弱最大可提取价值的影响？" class="headerlink" title="构建者应用程序接口如何减弱最大可提取价值的影响？"></a>构建者应用程序接口如何减弱最大可提取价值的影响？</h4><p>构建者应用程序接口的核心优势在于，它有可能让参与者平等获得最大可提取价值机会。 使用提交-披露方案消除了信任假设，降低了寻求从最大可提取价值中获益的验证者的进入门槛。 这应该可以减轻单独质押人加入大型质押池以提高最大可提取价值利润的压力。</p>
<p>构建者应用程序接口的广泛实现将鼓励区块构建者之间进行更激烈的竞争，这会增强抗审查能力。 验证者审查多个构建者的出价时，有意审查一笔或多笔用户交易的构建者必须出价高于所有其他不审查的构建者才能成功。 这大大增加了审查用户的成本并对审查有所限制。</p>
<p>一些项目（如 MEV Boost）将构建者应用程序接口作为整体结构的一部分，旨在为某些参与方（例如试图避免抢先交易攻击或三明治攻击的交易者）提供交易隐私。 这是通过在用户和区块构建者之间提供一条私密通信通道来实现的。 与前面描述的许可内存池不同，这种方法是有益处的，原因如下：</p>
<ol>
<li>市场上有多种构建者存在，使得审查变得不切实际，这是有利于用户的。 相比之下，基于信任的中心化暗池的存在将权力集中在少数区块构建者手中，增加了审查的可能性。</li>
<li>构建者应用程序接口软件是开源的，允许任何人提供区块构建者服务。 这意味着用户不会被迫使用任何特定的区块构建者，并提高了以太坊的中立和无许可特性。 此外，寻求最大可提取价值的交易者不会由于使用私密交易渠道而无意中促进中心化。</li>
</ol>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/12/06/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E6%95%B0%E6%8D%AE%E5%8F%AF%E7%94%A8%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/06/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E6%95%B0%E6%8D%AE%E5%8F%AF%E7%94%A8%E6%80%A7/" class="post-title-link" itemprop="url">数据可用性</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-06 00:00:00" itemprop="dateCreated datePublished" datetime="2022-12-06T00:00:00+08:00">2022-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/" itemprop="url" rel="index">
                    <span itemprop="name">区块链其他</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>630</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据可用性"><a href="#数据可用性" class="headerlink" title="数据可用性"></a>数据可用性</h1><p>免信任是公共区块链的大前提（“不信任，就验证”）。 以太坊减少信任假设的方法之一是强制执行数据可用性相关规则。 区块生产者需要发布每个区块的数据，参与以太坊共识的节点在本地存储这些数据。</p>
<h2 id="什么是数据可用性？"><a href="#什么是数据可用性？" class="headerlink" title="什么是数据可用性？"></a>什么是数据可用性？</h2><p>数据可用性<strong>保证区块提议者发布区块的所有交易数据并且交易数据对于其他网络参与者可用。</strong> 以太坊交易在<a target="_blank" rel="noopener" href="https://ethereum.org/zh/developers/docs/blocks/">区块</a>中处理。 这些区块连接在一起形成“区块链”。</p>
<p>每个区块有两个主要部分：</p>
<ul>
<li><strong>区块头</strong>：包含关于区块的一般信息（元数据），例如时间戳、区块哈希、区块编号等。</li>
<li><strong>区块体</strong>：包含作为区块的一部分处理的实际交易。</li>
</ul>
<p>提出新区块时，区块生产者必须发布整个区块，包括交易数据（包含在区块体中）。 然后，参与共识的节点可以下载区块的数据并重新执行交易以确认其有效性。 如果没有验证交易的节点，区块提议者可以在区块中插入恶意交易并逃脱惩罚。</p>
<h3 id="数据可用性问题"><a href="#数据可用性问题" class="headerlink" title="数据可用性问题"></a>数据可用性问题</h3><p>我们可以把数据可用性难题概括为一个问题：“我们如何验证一个新产生区块的数据是否可用？”。 <strong>数据可用性非常重要，因为以太坊的安全在于假设全节点可以获取区块数据。</strong></p>
<p>如果区块生产者在并非所有数据可用的情况下提出了一个区块，区块可以达成最终确定性但会包含无效交易。 即使区块是有效的，但那些不能完全进行验证的区块数据将对用户和网络的功能造成负面影响。</p>
<p>数据可用性问题也和<a target="_blank" rel="noopener" href="https://ethereum.org/zh/developers/docs/scaling/">扩容解决方案</a>相关，如卷叠。 <strong>这些协议通过在以太坊主网线下执行交易来增加吞吐量。</strong> <strong>然而，为了可以从以太坊获得安全性，这些协议必须在主网发布交易数据，让任何人能够验证在主链外执行的计算的正确性。</strong></p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/12/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E5%BA%94%E7%94%A8%E5%9C%BA%E5%9C%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E5%BA%94%E7%94%A8%E5%9C%BA%E5%9C%B0/" class="post-title-link" itemprop="url">应用场地</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-04 00:00:00" itemprop="dateCreated datePublished" datetime="2022-12-04T00:00:00+08:00">2022-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/" itemprop="url" rel="index">
                    <span itemprop="name">区块链其他</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="金融服务"><a href="#金融服务" class="headerlink" title="金融服务"></a>金融服务</h2><p>金融服务其实是一个很大的范畴，涉及货币、证券、债券、保险、抵押等诸多行业，不过总结来说处理的是各种交易，这是区块链最擅长的领域。 而且加密货币天生接近金融的特性，因此区块链在金融服务中也开始逐渐扮演越来越重要的角色。</p>
<p>在传统金融交易中，为了确保可靠性，很多时候需要第三方机构担保，多了一方，就会给交易带来更多的摩擦：更复杂的流程、更长的时间周期、更高的资金成本、更多出错的环节。因此，金融领域使用区块链技术会大大提高交易效率。</p>
<h3 id="跨境支付-结算"><a href="#跨境支付-结算" class="headerlink" title="跨境支付&#x2F;结算"></a>跨境支付&#x2F;结算</h3><p>加密货币不再依赖于任何机构，自身就在去中心化的全世界的网络中运行，是天然的全球性资产，尤其在<strong>区块链网络上的发行的稳定币（Token</strong>），涵括了加密货币与发币的特性，非常适合在跨境支付与结算。</p>
<p>以 USDT 稳定币为例，USDT是最早的一种由美元储备支撑的稳定币，发行方Tether承诺与美元的一对一转换比率，当下逆全球化在抬头，美国仰仗其霸权利用 SWIFT 等跨境结算体系对一些国家、企业、个人进行制裁，对被制裁者跨境交易上造成重大打击。而 USDT 作为链上资产，基于匿名性、抗审查、且在7*24小时运行在一个公开无准入的分布式平台上，让 USDT 称为重要的资产交易媒介。 例如在俄罗斯经营的中国商人用卢布在交易市场中购买USDT，随后用USDT进行自由跨境。</p>
<p>多国政府也在积极推动使用区块链技术进行跨境交易，例如：中国人民银行、国际清算银行（香港）、香港金管局、泰国中央银行、阿联酋中央银行联合建设的多边央行数字货币桥（mBridge），就使用了区块链技术。</p>
<h3 id="资产数字化-代币化"><a href="#资产数字化-代币化" class="headerlink" title="资产数字化&#x2F;代币化"></a>资产数字化&#x2F;代币化</h3><p>Token ，中文主要称为代币，也有一部分人称为通证，它是一个智能合约的标准（ ERC20），我们可以<strong>使用这个标准来定义几乎任何可以用数字表达的东西</strong>，如公司的<strong>股份、股息、房产、货币、一盎司黄金、积分、权益、门票，这里统称为资产</strong>，当资产通过 Token 的形式数字化，会极大提高资产使用效率及透明度。</p>
<p>例如，公司股票转换为区块链代币后，可以<strong>获得更大的流动性</strong>，传统股票交易有很大的地域性，无法全球交易，代币化之后，可以吸引全球的投资者。另一个例子是，可以对房产进行代币化，转换为多个代币，可实现对<strong>资产所有权拆分</strong>，对于没有足够的资金购买单套房产的投资者，可以持有房产一部分房产。</p>
<h2 id="DeFi"><a href="#DeFi" class="headerlink" title="DeFi"></a>DeFi</h2><p>DeFi，Decentralized Finance（去中心化金融）的缩写， 利用区块链智能合约在链上完成资产兑换、借贷、杠杆、期货等交易。</p>
<p>去中心化金融相比传统金融服务有很多好处：</p>
<ol>
<li>去中心化金融无审查、对任何人开放</li>
<li>资金转移效率高，在一个交易内完成（传统金融服务可能是几天）</li>
<li>资金有自己控制，而不是机构控制</li>
<li>可以 24 小时不间断交易</li>
<li>交易规则透明</li>
</ol>
<p>同时去中心化金融诞生了很多传统金融无法实现的特性，例如： 不同的金融协议衍生品可以组合在一起交易，从而实现如：无抵押借款、无风险套利。</p>
<h3 id="其他金融服务"><a href="#其他金融服务" class="headerlink" title="其他金融服务"></a>其他金融服务</h3><p>金融服务领域可以广泛使用区块链技术，还有其他的场景，如：供应链金融，众筹融资、预付款等。</p>
<h2 id="DAO-组织"><a href="#DAO-组织" class="headerlink" title="DAO 组织"></a>DAO 组织</h2><p>DAO全称是Decentralized Autonomous Organization，即<strong>去中心化自治组织</strong>，DAO是一种<strong>将组织的管理和运行规则以智能合约代码的形式编码在区块链上</strong>，<strong>DAO的决策基于组织成员持有的代币进行投票进行</strong>，投票通过的提案自动执行。<strong>这是一种全新的组织形态</strong>。相较于传统企业而言，DAO不存在中心化的节点与层级化的管理架构，DAO有一个民主化的组织，更加透明，管理也较扁平。</p>
<p>DAO 是一种平等、透明的组织，能让互联网上的陌生人合作更加可信和安全，方便让全世界志同道合的人开展合作，因此 DAO 有望打破传统的公司制架构，颠覆多种商业模式。</p>
<h2 id="数字存证-防伪"><a href="#数字存证-防伪" class="headerlink" title="数字存证&#x2F;防伪"></a>数字存证&#x2F;防伪</h2><p>区块链可以通过哈希时间戳证明某个文件或者数字内容在特定时间的存在，加之<strong>其公开、不可篡改、可溯源等特性</strong>。可以应用于<strong>产权、版权等所有权的管理和追踪，以及身份证明，司法鉴证，防伪溯源等相关领域。</strong></p>
<p>通过对文字、图片、音频视频等作品内容使用区块链技术在链上进行存证或数字签名，可以实现对作品的确权，并且版权权益也可以代币化，让版权交易更容易。 还有一些应用是在防伪溯源领域，通过供应链中应用区块链技术进行跟踪，可以应用如食品医药、农产品、酒类、奢侈品等商品的溯源。</p>
<p>基于<strong>存证特性</strong>，在数字政务也有很多应用，如：税务部门推出区块链电子发票“税链”平台，税务部门、开票方、受票方通过独一无二的数字身份加入“税链”网络，有效解决数据篡改、一票多报、偷税漏税等问题。</p>
<h2 id="NFT-数字艺术品"><a href="#NFT-数字艺术品" class="headerlink" title="NFT&#x2F;数字艺术品"></a>NFT&#x2F;数字艺术品</h2><p><strong>NFT（Non Fungible Token）非同质化代币</strong>，与 Token 一样也是智能合约的标准，Token 用来表达相同的东西不同，NFT 用来表达具有独特特性的东西（两个东西不能互换）。例如：可以<strong>用 NFT 表示有编号的彩票、收藏品、音乐、域名、指纹、座位编号、武器等</strong>。</p>
<p><strong>NFT 具有唯一性、稀缺性、可交易性，当 NFT 与艺术品相结合，给艺术行业带来了很多新的变化和影响。</strong></p>
<ol>
<li>传统数字格式艺术文件，由于易于复制、拷贝，版权难以界定让，通过 NFT 可使从产生到交易都可追溯，版权的保护变得更加方便。</li>
<li>拓展了数字艺术品的金融与社交属性，艺术品由于其稀缺性、文化价值、独特性等特征带有金融属性。NFT为艺术品提供了灵活多样的流通方式与交易场景。</li>
<li>让数字艺术容易实现组合创作、二次创作。</li>
</ol>
<h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><p>2017年11月，<strong>基于 NFT 的以太猫（CryptoKitties）游戏在以太坊上线</strong>。用户<strong>可以通过以太币购买虚拟的以太猫</strong>，<strong>然后繁育下一代</strong>，同时也可以出售自己拥有的以太猫。 以太猫和传统游戏不同的是，<strong>以太猫的拥有权完全在用户手里。每一个以太猫就是一个以太坊上的数字，而这个数字和一个以太坊的地址绑定，拥有这个地址的用户就完全拥有这只以太猫，</strong>这款游戏带来了很多狂热的粉丝，一度长时间给以太坊带来拥堵，也让大家意识到，使用区块链的游戏可以带来很多有趣的变化。</p>
<p>区块链游戏让更多的权力交还给了玩家，可以提供公平和安全的游戏环境，改善游戏的可信度。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>区块链技术还可以应用于如：共享经济、创作者经济、物联网、公共服务网络、众包、法律。 这些应用场景展现了区块链技术所具有的巨大市场潜力。</p>
<p>不过，区块链技术尽管仍处在早期阶段，还有需要有很多的问题待解决，例如：区块链合约在执行时线下需要有怎样的机制配合，如何监管链上的一些违规违法行为，链下的数据如何高效、可信的映射到链上。 这些问题还需要我们继续探索。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/11/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82/" class="post-title-link" itemprop="url">区块链底层</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-30 00:00:00" itemprop="dateCreated datePublished" datetime="2022-11-30T00:00:00+08:00">2022-11-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/" itemprop="url" rel="index">
                    <span itemprop="name">区块链其他</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>682</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="以太坊底层："><a href="#以太坊底层：" class="headerlink" title="以太坊底层："></a>以太坊底层：</h1><ol>
<li><p><strong>区块链结构：</strong>以太坊是基于区块链技术构建的。它的<strong>区块链结构是一个有序的、包含交易记录的区块链。每个区块包含一组交易，以及前一个区块的哈希值，形成了一个不断增长的链。</strong></p>
</li>
<li><p><strong>以太坊虚拟机（EVM）</strong>：以太坊虚拟机是以太坊的核心组件之一。它是<strong>一个可执行智能合约的运行环境</strong>，为开发者提供了一个统一的平台。EVM可以在不同的节点上运行，确保在整个网络中执行结果的一致性。</p>
</li>
<li><p><strong>账户：</strong>以太坊有两种类型的账户：外部账户（Externally Owned Account，EOA）和合约账户（Contract Account）。</p>
<ul>
<li>外部账户（EOA）：外部账户是由公钥和私钥对来表示的账户，类似于传统的加密货币账户。外部账户由用户控制，用于管理和转移以太币和代币资产。外部账户可以通过私钥签名交易，并通过公钥验证身份。</li>
<li>合约账户（Contract Account）：合约账户是由智能合约代码控制的特殊类型账户。合约账户没有私钥，它们由智能合约代码定义的规则和逻辑控制。合约账户可以接收和处理交易，执行与合约相关的操作，并根据预设的规则管理资产。</li>
</ul>
</li>
<li><p><strong>以太币（Ether）：以太坊的本地加密货币称为以太币</strong>（Ether，简称ETH）。以太币在以太坊网络中具有多种用途。首先，它用作支付智能合约执行的燃料费用。其次，以太币也可用作加密货币进行交易和价值储存。</p>
</li>
<li><p><strong>共识机制：</strong>以太坊采用了Pos共识机制，并获得以太币作为奖励。这种共识机制确保了网络的安全性和去中心化。</p>
</li>
<li><p><strong>网络：</strong>区块链底层通常采用P2P（peer-to-peer）网络，实现点对点的数据传输和交互。P2P网络需要解决节点发现、网络拓扑架构、数据同步等问题。</p>
</li>
</ol>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/11/25/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E5%85%AC%E5%8F%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/25/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E5%85%AC%E5%8F%B8/" class="post-title-link" itemprop="url">公司</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-25 00:00:00" itemprop="dateCreated datePublished" datetime="2022-11-25T00:00:00+08:00">2022-11-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/" itemprop="url" rel="index">
                    <span itemprop="name">区块链其他</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>969</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>币安，火币，欧科，分布，趣链，微众，登链，阿里，腾讯，华为，通付盾，巴比特，秘猿，布比，万向，绿盟，安恒，长亭 ，百度</p>
<table>
<thead>
<tr>
<th align="left">公司</th>
<th>官网</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">火币</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">欧科</td>
<td><a target="_blank" rel="noopener" href="https://app.mokahr.com/campus-recruitment/okgroup/72016#/">https://app.mokahr.com/campus-recruitment/okgroup/72016#/</a></td>
<td></td>
</tr>
<tr>
<td align="left">分布科技</td>
<td><a target="_blank" rel="noopener" href="https://app.mokahr.com/recommendation-apply/onchain/40661#/">https://app.mokahr.com/recommendation-apply/onchain/40661#/</a></td>
<td></td>
</tr>
<tr>
<td align="left">neo</td>
<td><a target="_blank" rel="noopener" href="http://zhangzihan@ngd.neo.org/">zhangzihan@ngd.neo.org</a>（邮箱）</td>
<td></td>
</tr>
<tr>
<td align="left">趣链</td>
<td><a target="_blank" rel="noopener" href="https://recruit.hyperchain.cn/social-recruitment/qulian/56024/#/job/b9625c06-f688-413a-b4e3-4456c8b75650">https://recruit.hyperchain.cn/social-recruitment/qulian/56024/#/job/b9625c06-f688-413a-b4e3-4456c8b75650</a></td>
<td></td>
</tr>
<tr>
<td align="left">微众</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">登链</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">阿里</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">腾讯</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">华为</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">通付盾</td>
<td><a target="_blank" rel="noopener" href="https://www.tongfudun.com/joinus">https://www.tongfudun.com/joinus</a></td>
<td></td>
</tr>
<tr>
<td align="left">巴比特</td>
<td><a target="_blank" rel="noopener" href="https://www.zhipin.com/gongsir/825d58d7bf3afcd41nV-3tW_.html">https://www.zhipin.com/gongsir/825d58d7bf3afcd41nV-3tW_.html</a></td>
<td></td>
</tr>
<tr>
<td align="left">秘猿</td>
<td><a target="_blank" rel="noopener" href="https://cryptape.com/join#/joinUs">https://cryptape.com/join#/joinUs</a></td>
<td></td>
</tr>
<tr>
<td align="left">布比</td>
<td><a target="_blank" rel="noopener" href="https://www.bubi.cn/join.html">https://www.bubi.cn/join.html</a></td>
<td></td>
</tr>
<tr>
<td align="left">绿盟</td>
<td><a target="_blank" rel="noopener" href="https://app.mokahr.com/campus_apply/nsfocus/40020#/">https://app.mokahr.com/campus_apply/nsfocus/40020#/</a></td>
<td></td>
</tr>
<tr>
<td align="left">安恒</td>
<td><a target="_blank" rel="noopener" href="https://ahzp.dbappsecurity.com.cn/">https://ahzp.dbappsecurity.com.cn/</a></td>
<td></td>
</tr>
<tr>
<td align="left">长亭</td>
<td><a target="_blank" rel="noopener" href="https://app.mokahr.com/apply/chaitin/4561#/?anchorName=default_joblist&sourceToken=">https://app.mokahr.com/apply/chaitin/4561#/?anchorName=default_joblist&amp;sourceToken=</a></td>
<td></td>
</tr>
<tr>
<td align="left">conflux</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">万向</td>
<td><a target="_blank" rel="noopener" href="http://www.wanxiang.com.cn/index.php/join">http://www.wanxiang.com.cn/index.php/join</a></td>
<td></td>
</tr>
<tr>
<td align="left">网易雷火</td>
<td><a target="_blank" rel="noopener" href="http://leihuo.163.com/joinus.html">http://leihuo.163.com/joinus.html</a></td>
<td></td>
</tr>
<tr>
<td align="left">慢雾</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">创宇</td>
<td><a target="_blank" rel="noopener" href="https://knownsec.zhiye.com/campus/jobs">https://knownsec.zhiye.com/campus/jobs</a></td>
<td></td>
</tr>
<tr>
<td align="left">云中戏</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">小红书</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">百度</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">b站</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">blocksec(安节)</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">欢乐互娱</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">魔珐科技（虚拟人方向</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">寺信</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">trlab</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">比特大陆</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">嘉楠</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">云中戏</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">独立开发者联盟（四川虫网科技有限公司）</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">联通数科</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">中信银行</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">兴业银行</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">中国工商银行总行</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">成都链安</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">鹏城实验室</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">元象</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">金证科技</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">天河国云（联盟链）</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">中国电信 翼支付</td>
<td><a target="_blank" rel="noopener" href="http://campus.51job.com/yzf2022/jobs.html">http://campus.51job.com/yzf2022/jobs.html</a></td>
<td></td>
</tr>
<tr>
<td align="left">铂数信息</td>
<td></td>
<td></td>
</tr>
</tbody></table>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2022/11/22/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/op%E5%BA%93_th%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/22/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/op%E5%BA%93_th%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">op库_th常见命令</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-22 00:00:00" itemprop="dateCreated datePublished" datetime="2022-11-22T00:00:00+08:00">2022-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/" itemprop="url" rel="index">
                    <span itemprop="name">区块链其他</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>401</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OP一些安全库"><a href="#OP一些安全库" class="headerlink" title="OP一些安全库"></a>OP一些安全库</h1><ol>
<li><code>SafeMath</code>：这个库提供了一些数学函数，比如加、减、乘和除法等，可以帮助避免 Solidity 整数溢出漏洞。</li>
<li><code>Ownable</code>：这个库允许合约拥有者控制某些功能，比如管理员权限或合约销毁功能等。</li>
<li><code>ERC20</code>：这个库提供了一个标准的 ERC20 代币合约，可用于创建自己的代币。</li>
<li><code>ERC721</code>：这个库提供了一个标准的 ERC721 非同质化代币合约，可用于创建自己的非同质化代币。</li>
<li><code>ReentrancyGuard</code>：这个库帮助防止重入攻击，其中一个函数锁定重入攻击，防止同一个函数在同一时间被再次调用。</li>
<li><code>Pausable</code>：这个库提供了一个暂停机制，使合约可以被暂停或恢复，以处理紧急情况或停止某些操作。</li>
<li><code>AccessControl</code>：这个库提供了一个灵活的角色权限管理系统，允许合约拥有者分配和管理不同角色的权限。</li>
<li><code>SafeERC20</code>：这个库提供了对 ERC20 代币的安全操作，包括安全的代币转账和安全的代币批准操作。</li>
</ol>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="幺柒YQ"
      src="/images/avater.png">
  <p class="site-author-name" itemprop="name">幺柒YQ</p>
  <div class="site-description" itemprop="description">努力坚持就会有希望</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">232</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kpyaoqi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kpyaoqi" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:18312386077@163.com" title="E-Mail → mailto:18312386077@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat.jpg" title="WeChat → images&#x2F;wechat.jpg"><i class="fa fa-fw fa-wechat"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/qq.jpg" title="QQ → images&#x2F;qq.jpg"><i class="fa fa-fw fa-qq"></i>QQ</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://stackoverflow.com/" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;" rel="noopener" target="_blank">Stackoverflow</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2021-11 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">幺柒YQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">899k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:37</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共379.4k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  


</body>
</html>
