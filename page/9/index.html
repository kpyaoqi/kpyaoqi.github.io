<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://kongpengyq.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="努力坚持就会有希望">
<meta property="og:type" content="website">
<meta property="og:title" content="YQ &amp; 博客">
<meta property="og:url" content="https://kongpengyq.com/page/9/index.html">
<meta property="og:site_name" content="YQ &amp; 博客">
<meta property="og:description" content="努力坚持就会有希望">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="幺柒YQ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://kongpengyq.com/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>YQ & 博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="YQ & 博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YQ & 博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2023/02/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/5-%20PAXOS-HotStuff/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/5-%20PAXOS-HotStuff/" class="post-title-link" itemprop="url">5- PAXOS-HotStuff</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-04 00:00:00" itemprop="dateCreated datePublished" datetime="2023-02-04T00:00:00+08:00">2023-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-09 10:01:34" itemprop="dateModified" datetime="2023-11-09T10:01:34+08:00">2023-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">共识算法</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="PAXOS"><a href="#PAXOS" class="headerlink" title="PAXOS"></a>PAXOS</h1><p>Paxos算法运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用大多数 (Majority) 机制<strong>保证了2F+1的容错能力，即2F+1个节点的系统最多允许F个节点同时出现故障。</strong></p>
<p>一个或多个提议进程 (Proposer) 可以发起提案 (Proposal)，Paxos算法使所有提案中的某一个提案，在所有进程中达成一致。系统中的多数派同时认可该提案，即达成了一致。最多只针对一个确定的提案达成一致。</p>
<p>Paxos将系统中的角色分为<strong>提议者 (Proposer)，决策者 (Acceptor)，和最终决策学习者 (Learner):</strong></p>
<ul>
<li><strong>Proposer</strong>: 提出提案 (Proposal)。Proposal信息包括提案编号 (Proposal ID) 和提议的值 (Value)。</li>
<li><strong>Acceptor</strong>：参与决策，回应Proposers的提案。收到Proposal后可以接受提案，若Proposal获得多数Acceptors的接受，则称该Proposal被批准。</li>
<li><strong>Learner</strong>：不参与决策，从Proposers&#x2F;Acceptors学习最新达成一致的提案（Value）。</li>
</ul>
<p>在多副本状态机中，每个副本同时具有Proposer、Acceptor、Learner三种角色。</p>
<p> <img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/img/image-20230321093843333.png" alt="image-20230321093843333"></p>
<ol>
<li><strong>第一阶段：Prepare阶段。Proposer向Acceptors发出Prepare请求，Acceptors针对收到的Prepare请求进行Promise承诺。</strong></li>
<li><strong>第二阶段：Accept阶段。Proposer收到多数Acceptors承诺的Promise后，向Acceptors发出Propose请求，Acceptors针对收到的Propose请求进行Accept处理。</strong></li>
<li><strong>第三阶段：Learn阶段。Proposer在收到多数Acceptors的Accept之后，标志着本次Accept成功，决议形成，将形成的决议发送给所有Learners。</strong></li>
</ol>
<h1 id="HotStuff"><a href="#HotStuff" class="headerlink" title="HotStuff"></a>HotStuff</h1><p>是一种<strong>优化后的三阶段bft算法</strong>，在拜占庭节点数小于总数1&#x2F;3时，保证系统的安全运行，同时提供更加高效的运行效率</p>
<p>以下是HotStuff算法的基本原理和过程：</p>
<ol>
<li>角色定义：<ul>
<li>Leader（领导者）：负责提出新区块的候选人，并驱动共识过程。</li>
<li>Validator（验证者）：参与共识的节点，验证和存储区块链数据。</li>
</ul>
</li>
<li>阶段一：投票阶段（Voting Phase）：<ul>
<li><strong>领导者提出一个新的候选区块，并将其广播给所有验证者。</strong></li>
<li><strong>验证者收到候选区块后，对其进行投票</strong>，表示接受或拒绝该候选区块。</li>
<li><strong>当一个验证者收到多数其他验证者的接受票时，它会将自己的投票广播给其他节点。</strong></li>
</ul>
</li>
<li>阶段二：证明阶段（Certify Phase）：<ul>
<li><strong>当一个验证者收到多数其他验证者的接受票时，它可以将该候选区块标记为已被证明。</strong></li>
<li><strong>该验证者会将证明消息广播给其他节点，以通知它们该候选区块已被共识接受。</strong></li>
</ul>
</li>
<li>阶段三：提交阶段（Commit Phase）：<ul>
<li><strong>一旦一个验证者收到多数其他验证者的证明消息，它可以将该候选区块提交到区块链中。</strong></li>
<li><strong>验证者将该候选区块添加到自己的本地区块链中，并广播提交消息给其他节点。</strong></li>
</ul>
</li>
</ol>
<p>HotStuff算法具有以下特点和优势：</p>
<ul>
<li>高性能：HotStuff采用了基于投票和多数决策的方式，使得共识过程具有较低的通信和计算开销。</li>
<li>简化流程：相比于传统的拜占庭容错共识算法，HotStuff的共识流程更为简化，减少了复杂性。</li>
<li>快速最终性：一旦一个候选区块被多数验证者接受，它就会被最终性地提交到区块链中，不再受到更长链的覆盖。</li>
<li>安全性：HotStuff算法基于拜占庭容错模型，可以容忍一部分节点的恶意行为或故障，保证共识结果的正确性和安全性。</li>
</ul>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2023/01/31/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/4-RAFT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/31/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/4-RAFT/" class="post-title-link" itemprop="url">4-RAFT</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-31 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-31T00:00:00+08:00">2023-01-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-09 10:01:34" itemprop="dateModified" datetime="2023-11-09T10:01:34+08:00">2023-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">共识算法</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="Raft-1"><a href="#Raft-1" class="headerlink" title="Raft"></a>Raft</h3><p>Raft（Replication and Fault Tolerant）是一个允许网络分区（Partition Tolerant）的一致性协议，它保证了在一个<strong>由N个恶意节点构成的系统中有2N+1</strong>节点正常工作的情况下的系统的一致性，比如在一个5个节点的系统中允许2个节点出现非拜占庭错误，如节点宕机、网络分区、消息延时。Raft相比于Paxos更容易理解，且被证明可以提供与Paxos相同的容错性以及性能。</p>
<h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p>在Raft算法中，每个网络节点只能如下三种身份之一：<strong>Leader</strong>、<strong>Follower</strong>以及<strong>Candidate</strong>，其中:</p>
<ul>
<li><strong>Leader</strong>：<strong>主要负责与外界交互，由Follower节点选举而来</strong>，在每一次共识过程中<strong>有且仅有一个Leader节点</strong>，由<strong>Leader全权负责从交易池中取出交易、打包交易组成区块并将区块上链；</strong></li>
<li><strong>Follower</strong>：<strong>以Leader节点为准进行同步，并在Leader节点失效时举行选举以选出新的Leader节点；</strong></li>
<li><strong>Candidate</strong>：<strong>Follower节点在竞选Leader时拥有的临时身份</strong>。</li>
</ul>
<h3 id="点ID-节点索引"><a href="#点ID-节点索引" class="headerlink" title="点ID &amp; 节点索引"></a>点ID &amp; 节点索引</h3><p>在Raft算法中，<strong>每个网络节点都会有一个固定且全局的唯一的用于表明节点身份的ID</strong>（一般是一个64字节表示数字），这称为节点ID；<strong>同时每个共识节点还会维护一份公共的共识节点列表，这个列表记录了每个共识节点的ID，而自己在这个列表中的位置被称为节点索引。</strong></p>
<h3 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h3><p><strong>Raft算法将时间划分为不定长度的任期Terms，Terms为连续的数字</strong>。每个Term以选举开始，如果选举成功，则由当前leader负责出块，<strong>如果选举失败，并没有选举出新的单一Leader，则会开启新的Term，重新开始选举。</strong></p>
<p> <img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/img/raft_terms.png" alt="../../../_images/raft_terms.png">.</p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p><strong>在Raft算法中，每个网络节点间通过发送消息进行通讯</strong>，当前Raft模块包括四种消息：<strong>VoteReq</strong>、<strong>VoteResp</strong>、<strong>Heartbeat</strong>、<strong>HeartbeatResp</strong>，其中：</p>
<ul>
<li><strong>VoteReq</strong>：投票请求，由Candidate节点主动发出，用于<strong>向网络中其他节点请求投票以竞选Leader；</strong></li>
<li><strong>VoteResp</strong>：投票响应，在节点收到投票请求后，用于<strong>对投票请求进行响应，响应内容为同意或拒绝该投票请求；</strong></li>
<li><strong>Heartbeat</strong>：心跳，<strong>由Leader节点主动周期发出</strong>，其作用有两个：(1) <strong>用于维护Leader节点身份，只要Leader能够一直正常发送心跳且被其他节点响应，Leader身份就不会发生变化</strong>；(2) 区块数据复制，<strong>当Leader节点成功打包一个区块后，会将区块数据编码至心跳中以将区块进行广播，其他节点在收到该心跳后会解码出区块数据并将区块放入自己的缓冲区中；</strong></li>
<li><strong>HeartbeatResp</strong>：心跳响应，<strong>在节点收到心跳后，用于对心跳进行响应，特别的，当收到一个包含区块数据的心跳时，该心跳的响应中会带上该区块的哈希；</strong></li>
</ul>
<p>所有消息共有的字段如下表所示：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段含义</th>
</tr>
</thead>
<tbody><tr>
<td>idx</td>
<td>自身节点索引</td>
</tr>
<tr>
<td>term</td>
<td>前节点所处在的任期</td>
</tr>
<tr>
<td>height</td>
<td>当前节点所持有的最高块的块高</td>
</tr>
<tr>
<td>blockHash</td>
<td>前节点所持有的最高块的哈希</td>
</tr>
</tbody></table>
<p>每种消息类型特有的字段如下表所示：</p>
<table>
<thead>
<tr>
<th>消息类型</th>
<th>字段名</th>
<th>字段含义</th>
</tr>
</thead>
<tbody><tr>
<td>VoteReq</td>
<td>candidate</td>
<td>Candidate自身的节点索引</td>
</tr>
<tr>
<td>lastLeaderTerm</td>
<td>Candidate见到过的最后一个Leader的Term，其详细作用见3.1.2节</td>
<td></td>
</tr>
<tr>
<td>lastBlockNumber</td>
<td>Candidate见到过的最新块的块高，其详细作用见3.1.2节</td>
<td></td>
</tr>
<tr>
<td>VoteResp</td>
<td>voteFlag</td>
<td>对投票请求的响应标志位，用以标记对是否同意投票请求，若是拒绝还会具体标记拒绝原因，其详细作用见3.1.2节</td>
</tr>
<tr>
<td>lastLeaderTerm</td>
<td>收到VoteReq的节点见到过的最新块的块高，其详细作用见3.1.2节</td>
<td></td>
</tr>
<tr>
<td>Heartbeat</td>
<td>leader</td>
<td>发出心跳的Leader节点的节点索引</td>
</tr>
<tr>
<td>uncommitedBlock</td>
<td>当Leader节点预备提交一个新块时，会先将区块数据编码进此字段以并通过心跳进行广播，其详细作用见3.2节</td>
<td></td>
</tr>
<tr>
<td>uncommitedBlockNumber</td>
<td>uncommitedBlock对应的块高，其详细作用见3.2节</td>
<td></td>
</tr>
<tr>
<td>HeartbeatResp</td>
<td>uncommitedBlockHash</td>
<td>当收到Leader发送过来的uncommitedBlock数据时，节点在心跳响应中写入uncommitedBlock对应的哈希（指纹），并发送回Leader，表明节点已经收到Leader预备提交的区块数据且已写入本地缓存，其详细作用见3.2节</td>
</tr>
</tbody></table>
<h2 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h2><p>系统框架如下图所示：</p>
<img src="/noteimg/区块链/区块链知识点总结/共识算法/img/raft_architecture.png" alt="../../../_images/raft_architecture.png" style="zoom: 80%;" /> 

<ul>
<li>Raft Sealer：负责从交易池取出交易并打包成区块，并发送至Raft Engine进行共识。区块上链后，Raft Sealer负责从交易池中删除已上链交易；</li>
<li>Raft Engine：负责在共识节点进行共识，将达成共识的区块上链。</li>
</ul>
<h2 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h2><h3 id="节点状态转换"><a href="#节点状态转换" class="headerlink" title="节点状态转换"></a>节点状态转换</h3><p>节点类型之间转换关系如下图所示，每种状态转换形式将在接下来的各个小节进行阐述：</p>
<p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/img/raft_nodes_transfer.jpg" alt="../../../_images/raft_nodes_transfer.jpg"></p>
<h4 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h4><p>Raft共识模块中<strong>使用心跳机制来触发Leader选举</strong>。当节点启动时，节点自动成为Follower且将Term置0。只要Follower从Leader或者Candidate收到有效的Heartbeat或RequestVote消息，其就会保持在Follower状态，**如果Follower在一段时间内（这段时间称为 <em>Election Timeout</em>）没收到上述消息，则它会假设系统当前的Leader已经失活，然后增加自己的Term并转换为Candidiate，开启新一轮的Leader选举流程，**流程如下:</p>
<ol>
<li>Follower增加当前的Term，转换为Candidate；</li>
<li>Candidate将票投给自己，并<strong>广播RequestVote到其他节点请求投票</strong>；</li>
<li>Candidate节点保持在Candidate状态，直到下面三种情况中的一种发生：**(1)该节点赢得选举；(2) 在等待选举期间，Candidate收到了其他节点的Heartbeat；(3) 经过<em>Election Timeout</em>后，没有Leader被选出<strong>。</strong>Raft算法采用随机定时器的方法来避免节点选票出现平均瓜分的情况**以保证大多数时候只会有一个节点超时进入Candidate状态并获得大部分节点的投票成为Leader。</li>
</ol>
<h4 id="投票"><a href="#投票" class="headerlink" title="投票"></a>投票</h4><p>节点在收到VoteReq消息后，会根据消息的内容选择不同的响应策略：</p>
<ol>
<li><p><em><strong>VoteReq的Term小于或等于自己的Term</strong></em></p>
<ul>
<li><strong>如果节点是Leader，则拒绝该投票请求</strong>，Candidate收到此响应后会放弃选举转变为Follower，并增加投票超时；</li>
<li>如果节点不是Leader：<ul>
<li><strong>如果VoteReq的Term小于自己的Term，则拒绝该投票请求</strong>，如果Candidate收到超过半数的该种响应则表明其已经过时，此时Candidate会放弃选举转变为Follower，并增加投票超时；</li>
<li><strong>如果VoteReq的Term等于自己的Term，则拒绝该投票请求</strong>，对于该投票请求不作任何处理。对于每个节点而言，只能按照先到先得的原则投票给一个Candidate，从而保证每轮选举中至多只有一个Candidate被选为Leader。</li>
</ul>
</li>
</ul>
</li>
<li><p><em><strong>VoteReq的lastLeaderTerm小于自己的lastLeaderTerm</strong></em></p>
<p>每个节点中会有一个lastLeaderTerm字段表示该节点见过的最后一个Leader的Term，lastLeaderTerm仅能由Heartbeat进行更新。<strong>如果VoteReq中的lastLeaderTerm小于自己的lastLeaderTerm，表明Leader访问这个Candidate存在问题，如果此时Candidate处于网络孤岛的环境中，会不断向外提起投票请求，因此需要打断它的投票请求，所以此时节点会拒绝该投票请求。</strong></p>
</li>
<li><p><em><strong>VoteReq的lastBlockNumber小于自己的lastBlockNumber</strong></em></p>
<p>每个节点中会有一个lastBlockNumber字段表示节点见到过的最新块的块高。在出块过程中，节点间会进行区块复制（详见3.2节），在区块复制的过程中，可能有部分节点收到了较新的区块数据而部分没有，从而导致不同节点的lastBlockNumber不一致。<strong>为了使系统能够达成一致，需要要求节点必须把票投给拥有较新数据的节点，因此在这种情况下节点会拒绝该投票请求。</strong></p>
</li>
<li><p><em><strong>节点是第一次投票</strong></em></p>
<p>为了避免出现Follower因为网络抖动导致重新发起选举，<strong>规定如果节点是第一次投票，直接拒绝该投票请求，</strong>同时会将自己的firstVote字段置为该Candidate的节点索引。</p>
</li>
<li><p><em><strong>1~4步骤中都没有拒绝投票请求</strong></em></p>
<p><strong>同意该投票请求。</strong></p>
</li>
</ol>
<h4 id="心跳超时"><a href="#心跳超时" class="headerlink" title="心跳超时"></a>心跳超时</h4><p>在Leader成为网络孤岛时，<strong>Leader可以发出心跳、Follower可以收到心跳但是Leader收不到心跳回应，</strong>这种情况下Leader此时已经出现网络异常，但是由于一直可以向外发送心跳包会导致Follower无法切换状态进行选取，系统陷入停滞。为了避免第二种情况发生，模<strong>块中设置了心跳超时机制，Leader每次收到心跳回应时会进行相应记录，一旦一段时间后记录没有更新则Leader放弃Leader身份并转换为Follower节点。</strong></p>
<h3 id="区块复制"><a href="#区块复制" class="headerlink" title="区块复制"></a>区块复制</h3><p>Raft协议强依赖Leader节点的可用性来确保集群数据的一致性，因为数据只能从Leader节点向Follower节点转移。<strong>当Raft Sealer向集群Leader提交区块数据后，Leader将该数据置为未提交（uncommitted）状态</strong>，接着<strong>Leader 节点会通过在Heartbeat中附加数据的形式并发向所有Follower节点复制数据并等待接收响应，在确保网络中超过半数节点已接收到数据后，再将区块数据写入底层存储中，此时区块数据状态已经进入已提交（committed）状态</strong>。此后Leader节点再通过Sync模块<strong>向其他Follower节点广播该区块数据</strong>，区块复制及提交的流程图如下图所示：</p>
<img src="/noteimg/区块链/区块链知识点总结/共识算法/img/image-20230614100627108.png" alt="image-20230614100627108" style="zoom:67%;" /> 

<p>其中RaftSealer验证是否当前是否能打包交易的验证条件包括：**(1) 是否为Leader；(2) 是否存在尚未完成同步的peer； (3) uncommitBlock字段是否为空，只有三个条件均符合才允许打包。**</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2023/01/27/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/3-PBFT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/27/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/3-PBFT/" class="post-title-link" itemprop="url">3-PBFT</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-27 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-27T00:00:00+08:00">2023-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-09 10:01:34" itemprop="dateModified" datetime="2023-11-09T10:01:34+08:00">2023-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">共识算法</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="PBFT-实用拜占庭容错算法"><a href="#PBFT-实用拜占庭容错算法" class="headerlink" title="PBFT 实用拜占庭容错算法"></a>PBFT <strong>实用拜占庭容错算法</strong></h2><h3 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h3><p>一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。<strong>因此，将军们必须有一个预定的方法协议，使所有忠诚的将军够达成一致</strong>。而且少数几个叛徒不能使忠诚的将军做出错误的计划。<strong>也就是说，拜占庭将军问题的实质就是要寻找一个方法，使得将军们在一个有版徒的非信任环境中建立对战斗计划的共识</strong>。</p>
<p>在该模型下，<strong>系统不会对集群中的节点做任何的限制</strong>，它们可以向其他节点发送随机数据、错误数据，也可以选择不响应其他节点的请求，这些无法预测的行为使得容错这一问题变得更加复杂。<strong>拜占庭将军问题是对分布式系统容错的最高要求</strong>。 <img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/img/image-20230321100125432.png" alt="image-20230321100125432"></p>
<p>其中C为发送请求端，0123为服务端，3为宕机的服务端，具体步骤如下：</p>
<ol>
<li>Request请求阶段：请求端C发送请求到主节点0</li>
<li>Pre-Prepare预准备阶段：客户端请求消息签名是否正确，然后广播给其他副本节点</li>
<li>Prepare准备阶段：123收到后记录并再次广播，1-&gt;023，2-&gt;013，3因为宕机无法广播</li>
<li>Commit提交阶段：如果副本节点收到了2f个验证通过的PREPARE消息，则广播Commit请求</li>
<li>Reply响应阶段：如果副本节点i收到了2f+1个验证通过的COMMIT消息，备份节点在执行完请求后，将结果发送给客户端，则对C进行反馈</li>
</ol>
<h2 id="PBFT算法的运作原理"><a href="#PBFT算法的运作原理" class="headerlink" title="PBFT算法的运作原理"></a>PBFT算法的运作原理</h2><ol>
<li>取一个副本作为主节点，其他的副本作为备份</li>
<li><strong>用户端向主节点发送使用服务操作的请求</strong></li>
<li><strong>主节点通过广播将请求发送给其他副本</strong></li>
<li>所有<strong>副本执行请求并将结果发回用户端</strong></li>
<li>用户端需要<strong>等待F+1个不同副本节点发回相同的结果</strong>，作为整个操作的最终结果。</li>
</ol>
<h2 id="主节点的选择"><a href="#主节点的选择" class="headerlink" title="主节点的选择"></a>主节点的选择</h2><p>在PBFT算法中，主节点的选择是通过一种基于视图号（View）和轮次（Round）的选举机制完成的。以下是主节点选择的基本过程：</p>
<ol>
<li><strong>视图切换：</strong><ul>
<li>PBFT算法中的视图是一个递增的编号，代表了系统中的不同状态。</li>
<li>初始状态下，系统进入视图1。</li>
<li><strong>如果系统中的节点检测到当前视图的主节点发生故障或无法正常运行，它们可以发起视图切换</strong>。</li>
</ul>
</li>
<li><strong>视图切换请求：</strong><ul>
<li><strong>当节点检测到主节点故障时，它们会广播一个视图切换请求。</strong></li>
<li><strong>视图切换请求包含了提议新主节点的信息，</strong>如节点的标识符和签名。</li>
</ul>
</li>
<li><strong>视图切换预准备：</strong><ul>
<li>其他节点在收到视图切换请求后，首先验证请求的合法性。</li>
<li><strong>如果请求合法，节点会将其广播给其他节点，以便获得足够数量的预准备消息。</strong></li>
</ul>
</li>
<li><strong>视图切换准备：</strong><ul>
<li><strong>节点在收到足够数量的预准备消息后，可以生成视图切换准备消息并广播给其他节点。</strong></li>
<li>视图切换准备消息中包含了足够数量的预准备消息的摘要。</li>
</ul>
</li>
<li><strong>视图切换提交：</strong><ul>
<li><strong>节点在收到足够数量的准备消息后，可以生成视图切换提交消息并广播给其他节点。</strong></li>
<li>视图切换提交消息中包含了足够数量的准备消息的摘要。</li>
</ul>
</li>
<li><strong>新视图的主节点选举：</strong><ul>
<li><strong>当节点收到足够数量的视图切换提交消息后，可以认为新视图已经达成共识。</strong></li>
<li>节点根据一定的规则从候选主节点中选择新的主节点，例如，<strong>可以选择具有最高编号的节点作为新的主节点。</strong></li>
</ul>
</li>
</ol>
<p>需要注意的是，<strong>视图切换是通过多数投票的方式完成的</strong>。即系统中的节点需要达成一致，并广播足够数量的消息来确保选举结果的合法性。只有在新的主节点被选举出来后，系统才能进入新的视图并继续执行PBFT算法的各个阶段。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>优点：高速、可扩展。缺点：通常用于私有网络和许可网络。(f是有可能失效的副本的最大个数)</p>
<ol>
<li>计算效率依赖于参与协议的节点数量，不适用于节点数量过大的区块链系统，扩展性差。</li>
<li>系统节点是固定的，无法应对公有链的开放环境，只适用于联盟链或私有链环境。</li>
<li>PBFT算法要求总节点数n&gt;&#x3D;3f+1(其中，f代表作恶节点数)。系统的失效节点数量不得超过全网节点的1&#x2F;3，容错率相对较低</li>
<li>尽管可以存在多于3f+1个副本，但是额外的副本除了降低性能之外不能提高可靠性。</li>
</ol>
<h2 id="DBFT-授权拜占庭容错算法"><a href="#DBFT-授权拜占庭容错算法" class="headerlink" title="DBFT 授权拜占庭容错算法"></a>DBFT <strong>授权拜占庭容错算法</strong></h2><p><strong>在这个机制当中，存在两个参与者，一个是专业记账的“记账节点”，一个是系统当中的普通用户</strong>。</p>
<p><strong>普通用户基于持有权益的比例来投票决定记账节点</strong>，当<strong>需要通过一项共识时，在这些记账节点中随机推选出一名发言人拟定方案</strong>，然后由其他记账节点根据<strong>拜占庭容错算法，即少数服从多数的原则进行表态，如果超过66%的节点表示同意发言人方案</strong>，则共识达成；否则，重新推选发言人，重复投票过程。</p>
<p><strong>所以说，dBFT机制实际使用了一种迭代共识的方法来保证系统达成一致决定。</strong>然而，<strong>这种机制的缺点在于，当系统中有超过三分之一的记账节点停止工作时，整个区块链网络将无法提供正常的服务</strong>；当超过三分之一的节点联合作恶时，区块链将有可能发生分叉。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2023/01/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/1-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/1-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">1-共识算法</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-23 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-23T00:00:00+08:00">2023-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">共识算法</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h1><p>共识算法（Consensus algorithm）是指<strong>在分布式系统中，参与者就某个共享状态达成一致的过程或协议</strong>。<strong>在分布式系统中，各个节点可能由于网络延迟、节点故障或恶意行为等原因导致信息不同步，因此需要通过共识算法来解决一致性问题。</strong></p>
<p>共识算法的目标是<strong>确保分布式系统中的节点就某个共享状态达成一致，并且保证系统的安全性、可用性和正确性</strong>。常见的应用场景包括区块链系统、分布式数据库、分布式存储系统等。</p>
<h1 id="以太坊的POS"><a href="#以太坊的POS" class="headerlink" title="以太坊的POS"></a>以太坊的POS</h1><p>以太坊采用权益证明机制，在该机制下，<strong>验证者明确地通过以太币将资本质押到以太坊上的智能合约中</strong>。 这些质押的以太币充当抵押品，<strong>如果验证者有失信行为或者消极怠工，那么可以销毁抵押品。</strong> 之后，<strong>验证者负责检查在网络上传播的新区块是否有效，并偶尔自己也创建和传播新区块。</strong></p>
<h3 id="验证者"><a href="#验证者" class="headerlink" title="验证者"></a>验证者</h3><p>要想作为验证者参与，<strong>用户必须向存款合约存入 32 个以太币并运行三种独立的软件：执行客户端、共识客户端和验证者</strong>。 存入以太币时，用户会进入一个激活队列，限制新验证者加入网络的速度。 <strong>激活后，验证者将从以太坊网络上的对等节点接收新区块</strong>。 区块中交付的交易会被重新执行，并且对区块签名进行检查以确保区块是有效的。 然后<strong>验证者在整个网络上发送支持该区块的投票</strong>（称为认证）。</p>
<p>在工作量证明中，生成区块的时间是由挖矿难度决定的，而在权益证明中，节奏是固定的。 权益证明以太坊中的时间分为时隙（12 秒）和时段（32 个时隙）。 <strong>在每个时隙中随机选择一位验证者作为区块提议者。 该验证者负责创建新区块并发送给网络上的其他节点。 另外在每个时隙中，都会随机选择一个验证者委员会，通过他们的投票确定所提议区块的有效性</strong></p>
<h3 id="区块创建"><a href="#区块创建" class="headerlink" title="区块创建"></a>区块创建</h3><p>验证者创建区块。 <strong>每个时隙中都会随机选择一个验证者成为区块提议者。 区块提议者的共识客户端请求配对执行客户端对交易打包，</strong>作为“执行负载”。 然后它们<strong>将“执行负载”包装成共识数据并形成一个区块</strong>，再把这个区块发送给以太坊网络上的其他节点。 这样的区块生产会得到以太币奖励。 <strong>在极少数情况下，一个时隙中产生了多个可能的区块，或节点在不同时间收到区块，</strong>分叉选择算法就<strong>会选择使形成的链具有最大认证权重的那个区块</strong>（<strong>认证权重是指为该区块提供认证的验证者数量</strong>，并根据验证者质押的以太币余额调整）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>没有最好的算法，只有最适合自己的算法</strong>。共识算法的选择与应用场景高度相关，可信环境使用Paxos 或者RAFT，带许可的联盟可使用PBFT ，非许可链可以是PoW，PoS，Ripple共识等。根据根据自己的实际需求选择共识算法，才是最优解。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2023/01/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/2-pow-pos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/2-pow-pos/" class="post-title-link" itemprop="url">2-pow-pos</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-23 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-23T00:00:00+08:00">2023-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">共识算法</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="POW-工作量证明"><a href="#POW-工作量证明" class="headerlink" title="POW 工作量证明"></a>POW <strong>工作量证明</strong></h2><p><strong>提交一份用来确认你做过一定量的工作的证明。</strong>监测工作的整个过程通常是极为低效的，而<strong>通过对工作的结果进行认证来证明完成了相应的工作量是一种非常高效的方式。</strong></p>
<p>工作量证明最常用的技术原理是哈希函数。由于输入哈希函数h的任意值n，会对应到一个h(n)结果，而n只要变动一个位元，就会引起雪崩效应，所以几乎无法从h(n)反推回n，因此借由指定查找h(n)的特征，<strong>让用户进行大量的穷举运算，就可以达成工作量证明</strong>。</p>
<p><strong>特点</strong>：稳定可靠(攻击者必须投入超过总体一半的运算量51%攻击，难于实现)</p>
<p>​			非常浪费能源，技术人员开发出了由ASIC组成的特制计算设备（矿机），垄断算力</p>
<h2 id="POS-权益证明"><a href="#POS-权益证明" class="headerlink" title="POS 权益证明"></a>POS <strong>权益证明</strong></h2><p>Pow带来的问题最主要的是能耗问题，通过挖矿比拼的是设备的数量，其实也就是拼钱。因此为什么不直接拼钱来分成奖励呢？省下了不必要的挖矿过程。因此基于这个理论，提出权益证明。</p>
<p>权益证明的原理是指<strong>通过抵押代币，并计算抵押的代币数量和抵押时间的乘积，也就是币龄。每次出块时，币龄最大的矿工获得出块权。产生区块后，该矿工获得出块奖励，同时币龄清零并重新开始计算，如此类推。</strong></p>
<p><strong>特点</strong>:硬件要求低，不需要消耗巨大的能源，出块速度更快。缺点是：去中心化程度不高</p>
<h2 id="DPOW-延迟工作量证明"><a href="#DPOW-延迟工作量证明" class="headerlink" title="DPOW 延迟工作量证明"></a>DPOW <strong>延迟工作量证明</strong></h2><p>DPow的原理是<strong>允许一个区块链利用第二个区块链的哈希算力所提供的安全。</strong>该机制是通过一组公证员节点实现的。公证员节点实现将第一个区块链的数据添加到第二个区块链中。进而，第二个区块链请求在两个区块链间达成妥协，弱化第一个区块链的安全。</p>
<p><strong>DPOW系统中有两种类型的节点：公证人节点和正常节点</strong></p>
<p>64 个公证人节点是由 DPoW 区块链的权益持有者（stakeholder）选举产生的，它们可从 DPoW 区块链向所附加的 PoW 区块链添加经公证确认的块。<strong>一旦添加了一个块，该块的哈希值将被添加到由 33 个公证人节点签署的 Bitcoin 交易中，并创建一个哈希到 Bitcoin 区块链的 dPow 块记录</strong>。该记录已被网络中的大多数公证人节点公证。</p>
<p>为避免公证人节点间在挖矿上产生战争，进而降低网络的效率，Komodo 设计采用轮询机制的挖矿方法，该方法具有两种运行模式。</p>
<p><strong>在“无公证人”（No Notary）模式下，支持所有网络节点参与挖矿，这类似于传统 PoW 共识机制。而在“公证人激活”（Notaries Active）模式下，网络公证人使用一种显著降低的网络难度率挖矿</strong>。“公证人激活”模式下，允许每位公证人使用其当前的难度挖掘一个区块，而其它公证人节点必须采用 10 倍难度挖矿，所有正常节点使用公证人节点难度的 100 倍挖矿。</p>
<p><strong>特点：</strong>只有使用PoW或PoS的区块链，才能采用这种共识算法；在“公证员激活”模式下，必须校准不同节点的哈希率</p>
<h2 id="DPOS-委托权益证明"><a href="#DPOS-委托权益证明" class="headerlink" title="DPOS 委托权益证明"></a>DPOS <strong>委托权益证明</strong></h2><p>先<strong>由代币持有者投票选出若干个见证人</strong>，<strong>又称为超级节点</strong>，<strong>再由这些见证人轮流出块</strong>。这种做法是在运行效率和去中心化两者中获得平衡。见证人类似于股份制公司里的董事会成员。<strong>普通的代币持有者只有进行投票的权利，持有的代币越多，他能投的票数也越多。获得投票数最高的若干候选人将当选见证人。</strong>见证人有任期，一般是一周。一周过后重新选举新的见证人。<strong>每个区块如果能获得一定比例（EOS为大于2&#x2F;3）的所有见证人的同意，这个区块就是有效的。</strong>区块链上的所有的升级和提议，都必须经过委员会（由所有见证人组成）的同意才能执行。</p>
<p><strong>特点：</strong>不需要消耗巨大的能源，运行效率更高，出块速度更快，不容易产生分叉。缺点是：去中心化程度不高，容易出现贿选问题</p>
<h2 id="PoB（Proof-of-Burn）焚烧证明机制"><a href="#PoB（Proof-of-Burn）焚烧证明机制" class="headerlink" title="PoB（Proof of Burn）焚烧证明机制"></a><strong>PoB（Proof of Burn）焚烧证明机制</strong></h2><p><strong>是一种通过焚烧自己手中的代币来表决谁拥有对网络的领导地位的承诺</strong></p>
<p>在基于DPoW的区块链中，矿工挖矿所获得的不再是奖励的代币，而是可以焚烧的“wood”——燃木。矿工使用自己的算力，通过哈希算法，最终证明自己的工作量之后，获取对应的wood，wood不可交易。当wood积攒到一定量之后，可以前往燃烧场地燃烧wood。<strong>通过一组算法计算后，燃烧较多wood的人或者BP或者一组BP可以获取下个事件段出块的权利，成功出块后获取奖励（代币）</strong>。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2023/01/22/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV3/V3%E5%90%88%E7%BA%A6%E5%AF%BC%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/22/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV3/V3%E5%90%88%E7%BA%A6%E5%AF%BC%E8%AF%BB/" class="post-title-link" itemprop="url">V3合约导读</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-22 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-22T00:00:00+08:00">2023-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-09 10:01:34" itemprop="dateModified" datetime="2023-11-09T10:01:34+08:00">2023-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UniswapV3/" itemprop="url" rel="index">
                    <span itemprop="name">UniswapV3</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UniswapV3-合约导读"><a href="#UniswapV3-合约导读" class="headerlink" title="UniswapV3 合约导读"></a>UniswapV3 合约导读</h1><img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/ExactInput.png" alt="ExactInput"  />

<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><h3 id="core"><a href="#core" class="headerlink" title="core"></a>core</h3><ul>
<li><strong>UniswapV3Factory</strong>: 提供<strong>创建 pool 的接口，并且追踪所有的 pool</strong></li>
<li><strong>UniswapV3Pool</strong>: 实现<strong>代币交易，流动性管理，交易手续费的收取</strong>，oracle 数据管理。接口的实现粒度比较低，不适合普通用户使用，错误的调用其中的接口可能会造成经济上的损失。</li>
</ul>
<h3 id="periphery"><a href="#periphery" class="headerlink" title="periphery"></a>periphery</h3><ul>
<li><strong>SwapRouter</strong>: 提供<strong>代币交易的接口</strong>，它是对 UniswapV3Pool 合约中交易相关接口的进一步封装，前端界面主要与这个合约来进行对接。</li>
<li><strong>NonfungiblePositionManager</strong>: 用来<strong>增加&#x2F;移除&#x2F;修改 Pool 的流动性，并且通过 NFT token 将流动性代币化。使用 ERC721 token（v2 使用的是 ERC20）的原因是同一个池的多个流动性并不能等价替换</strong>（v3 的集中流性动功能）。</li>
</ul>
<h2 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h2><h3 id="NonfungiblePositionManager"><a href="#NonfungiblePositionManager" class="headerlink" title="NonfungiblePositionManager"></a>NonfungiblePositionManager</h3><h4 id="CreatePool"><a href="#CreatePool" class="headerlink" title="CreatePool"></a>CreatePool</h4><p><a target="_blank" rel="noopener" href="https://github.com/Dapp-Learning-DAO/Dapp-Learning/blob/main/defi/Uniswap-V3/contractGuide/img/create-pool.png"><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV3/img/create-pool.png" alt="创建交易对流程图"></a></p>
<p>用户首先调用 <code>NonfungiblePositionManager</code> 合约的 <code>createAndInitializePoolIfNecessary</code> 方法创建交易对，传入的参数为交易对的 token0, token1, fee 和初始价格 sqrtPrice.</p>
<ul>
<li>调用<code>Factory.getPool(tokenA, tokenB, fee)</code>获取 Pool 地址</li>
<li>如果 Pool 地址为 0，说明 Pool 还未创建<ul>
<li>调用Factory.createPool(tokenA, tokenB, fee)，创建 Pool<ul>
<li>Factory调用 <code>Pool.deploy</code> 部署Pool合约</li>
</ul>
</li>
<li>调用<code>Pool.initialize(sqrtPriceX96)</code>对 Pool 初始化</li>
</ul>
</li>
<li>如果 Pool 地址不为 0 ，说明 Pool 已存在<ul>
<li>检查 Pool 的价格，若为 0，调用<code>Pool.initialize(sqrtPriceX96)</code>对 Pool 初始化</li>
</ul>
</li>
</ul>
<h4 id="mint"><a href="#mint" class="headerlink" title="mint"></a>mint</h4><p>铸造代表流动性头寸的ERC721代币返回给用户</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Dapp-Learning-DAO/Dapp-Learning/blob/main/defi/Uniswap-V3/contractGuide/img/add-liquidity.png"><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV3/img/add-liquidity.png" alt="添加流动性对流程图"></a></p>
<p>用户调用 <code>Manager.mint</code>创建Position并添加流动性：</p>
<ul>
<li>Manager内部调用 <code>Manager.addLiquidity</code></li>
<li>Manager调用<code>Pool.mint</code><ul>
<li>修改用户的position状态</li>
<li>调用manager的mint回调函数，进行token的转帐操作</li>
</ul>
</li>
<li>Manager内部调用<code>Manager.mint</code>，返回<code>amount0</code> <code>amount1</code>(token0,token1 的实际注入数量)<ul>
<li>将代表相关流动性postion的ERC721代币返回给用户</li>
<li>创建流动性头寸存入Manager</li>
</ul>
</li>
<li>广播 <code>IncreaseLiquidity(tokenId, liquidity, amount0, amount1)</code></li>
</ul>
<h4 id="increaseLiquidity"><a href="#increaseLiquidity" class="headerlink" title="increaseLiquidity"></a>increaseLiquidity</h4><p>用户调用 <code>Manager.increaseLiquidity</code> 向已有Position添加流动性：</p>
<ul>
<li>Manager内部调用 <code>Manager.addLiquidity</code></li>
<li>从Pool中获取position最新的手续费数值</li>
<li>将手续费加到position的记录中（两种token分别记录）</li>
<li>广播 <code>IncreaseLiquidity(tokenId, liquidity, amount0, amount1)</code></li>
</ul>
<p>注意：<strong>添加或移除流动性都会触发Manager从Pool中更新手续费数据</strong>，但不会提取</p>
<h4 id="decreaseLiquidity"><a href="#decreaseLiquidity" class="headerlink" title="decreaseLiquidity"></a>decreaseLiquidity</h4><p>用户调用 <code>Manager.decreaseLiquidity</code> 移除已有Position的流动性：</p>
<ul>
<li>检查入参，position现有流动性 &gt;&#x3D; 传入的流动性</li>
<li>调用<code>Pool.burn</code> 返回实际移除的流动性转换为token的数量（amount0, amount1）</li>
<li>回收用户在Pool中积累的手续费<ul>
<li>先获取Pool中手续费数值</li>
<li>手续费增量 &#x3D; Pool手续费数值 - position中记录的手续费数值</li>
<li>将手续费增量累加到position的待取token数量中</li>
<li>更新 position中记录的手续费数值</li>
</ul>
</li>
<li>更新 position中记录的流动性</li>
<li>广播 <code>IncreaseLiquidity(tokenId, liquidity, amount0, amount1)</code></li>
</ul>
<h4 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h4><p>用户调用 <code>Manager.collect</code> 回收Pool中累计的手续费收益：</p>
<ul>
<li>检查入参<ul>
<li>回收手续费最大数量需要 &gt; 0</li>
<li>当入参recipient为0，设为本Manager合约地址</li>
</ul>
</li>
<li>如果position流动性 &gt; 0，触发Pool更新手续费相关数据的快照<ul>
<li>调用<code>Pool.burn</code>触发更新手续费相关的数据，这里数量传0，并不会真的移除流动性</li>
<li>Pool的手续费 - Manager中记录的手续费 &#x3D; 手续费增量（即本次可取的手续费数量）</li>
<li>期望取回的手续费数量 &#x3D; max(手续费增量，入参的手续费最大值)</li>
</ul>
</li>
<li>调用 <code>Pool.collect</code> ，Pool将手续费转给接收者，返回实际取回的手续费数量</li>
<li>更新Manager中手续费数据与Pool同步</li>
<li>广播 <code>Collect(params.tokenId, recipient, amount0Collect, amount1Collect)</code></li>
</ul>
<h4 id="burn"><a href="#burn" class="headerlink" title="burn"></a>burn</h4><p>用户调用 <code>Manager.burn</code>，移除position，并销毁ERC721token</p>
<h3 id="SwapRouter"><a href="#SwapRouter" class="headerlink" title="SwapRouter"></a>SwapRouter</h3><h4 id="exactInput"><a href="#exactInput" class="headerlink" title="exactInput"></a>exactInput</h4><p>指定交易对路径，给出期望的输入数量，返回实际的交易数量。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Dapp-Learning-DAO/Dapp-Learning/blob/main/defi/Uniswap-V3/contractGuide/img/swap-exact-input.png"><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV3/img/swap-exact-input.png" alt="exactInput"></a></p>
<h5 id="路径选择"><a href="#路径选择" class="headerlink" title="路径选择"></a>路径选择</h5><p>在进行两个代币交易时，是首先需要在链下计算出交易的路径，例如使用 <code>ETH</code> -&gt; <code>DAI</code> ：</p>
<ul>
<li>可以直接通过 <code>ETH</code>&#x2F;<code>DAI</code> 的交易池完成</li>
<li>也可以通过 <code>ETH</code> -&gt; <code>USDC</code> -&gt; <code>DAI</code> 路径，即经过 <code>ETH/USDC</code>, <code>USDC/DAI</code> 两个交易池完成交易</li>
<li>token地址没有排序限制</li>
</ul>
<h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h5><p>这里流程比较多，建议配合xmind流程图梳理。</p>
<p>用户调用 <code>Router.exactInput</code>：</p>
<ol>
<li><p>将支付者payer设置为交易发起者（用户）</p>
</li>
<li><p>进入while循环，对当前交易对执行具体的交易操作</p>
</li>
<li><p>获取 <code>hasMultiplePools</code> </p>
<p>a. <code>path.length &gt;= 3 * tokenAddressLength + 2 * feeLength</code> 的布尔值</p>
<p>b. <code>token + fee + token</code> 组成一个交易对，即 PoolKey </p>
<p>c. 这里是判断是否存在1个以上的交易对，即交易是否需要中转交易（A-&gt;B-&gt;C)</p>
</li>
<li><p>调用<code>Router.exactInputInternal</code>exactInput的内部方法 </p>
<p>a. recipient若为0，则改为本router合约地址 </p>
<p>b. 从交易链路path中解析出tokenIn,fee, tokenOut, 即当前第一个 Pool 的关键信息，以此可计算出Pool的地址 </p>
<p>c. 获取zeroForOne，即tokenIn &lt; tokenOut的布尔值</p>
<ul>
<li>在Pool中价格始终以 <code>y/x</code> 表示，这里 <code>address(x) &lt; address(y)</code></li>
<li><code>zeroForOne</code> 代表的是交易的方向，即<code>tokenIn</code>是作为x还是y，<code>tokenOut</code>反之 d. 调用 <code>Pool.swap</code> 执行实际的交易方法</li>
<li><code>amountIn</code> 入参是 <code>int256</code> 类型，即有符号，若传负数，则表示 exactOutinput 模式，这里是 exactInput，传入的是正数</li>
<li><code>priceLimit</code> 是交易执行的价格限制，一旦触及即停止交易。这里传0，代表以市价执行交易</li>
<li><code>SwapCallbackData</code> 是交易回调函数</li>
<li>在<code>Pool.swap</code>中交易是分段执行，具体细节参见其代码。swap函数在计算完实际交易量后，会先把输出token转账给接收者，然后调用回调将输入token从发送者转账到Pool合约 e. 返回实际的输入输出交易数量</li>
</ul>
</li>
<li><p>根据hasMultiplePools判断循环是否继续 a. true 交易路径中仍有待执行的交易对</p>
<ul>
<li>将支付者payer设为本router合约地址</li>
<li><code>path</code>剔除掉第一个token和fee的信息，继续使用后续的token地址和fee信息组成交易对</li>
<li>回到2继续执行 b. false 交易完成，跳出while循环，返回 <code>amountOut</code> 实际的输出token数量</li>
</ul>
</li>
<li><p>最后检查交易实际的输出量是否满足用户设置的最小输出数量</p>
</li>
</ol>
<h4 id="exactOutput"><a href="#exactOutput" class="headerlink" title="exactOutput"></a>exactOutput</h4><p>指定交易对路径，给出期望的输出数量，返回实际的交易数量。</p>
<p>程序逻辑和 exactInput 类似</p>
<h3 id="flash-swap"><a href="#flash-swap" class="headerlink" title="flash swap"></a>flash swap</h3><p>闪电贷接口，无需抵押和零信任的借贷，借贷到还贷需要在一个区块内完成。</p>
<p>Uniswap v3 版本中，和 v2 一样也有两种闪电贷的方式，但是是通过不同的函数接口来完成的。</p>
<ul>
<li><code>Pool.flash</code> 借出和归还是同一币种</li>
<li><code>Pool.swap</code> 借出swap函数先将输出token转给接收者，再通过回调将输入token转给Pool的机制，实现了借出和归还不同币种的闪电贷</li>
</ul>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2023/01/22/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UnswapV4/UnsiwapV4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/22/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UnswapV4/UnsiwapV4/" class="post-title-link" itemprop="url">UnsiwapV4</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-22 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-22T00:00:00+08:00">2023-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UnswapV4/" itemprop="url" rel="index">
                    <span itemprop="name">UnswapV4</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>798</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uniswap-v4"><a href="#uniswap-v4" class="headerlink" title="uniswap_v4"></a>uniswap_v4</h1><h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><p>v4 实现了 8 个回掉函数：</p>
<ul>
<li>beforeInitialize &#x2F; afterInitialize</li>
<li>beforeModifyPosition &#x2F; afterModifyPosition</li>
<li>beforeSwap &#x2F; afterSwap</li>
<li>beforeDonate &#x2F; afterDonate</li>
</ul>
<p>当有人在 v4 上创建一个 pool 时，可以指定一个 hooks 合约。通过 hooks 合约可以对 swap 和 withdrawLiquidity 操作收取费用，并自定义收费策略。或者进行其他操作。</p>
<h3 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h3><p>v4 使用一个 contract 完成所有 token 的保管。在 v4 上创建 pool 会改变 contarct 状态，而不是像 v3 一样新建 contract。这减少了新建 pool 的 gas 费用。</p>
<h3 id="Flash-Accouting"><a href="#Flash-Accouting" class="headerlink" title="Flash Accouting"></a>Flash Accouting</h3><p>在 v3 上执行多跳 swap 需要在每个 swap 完成之后执行 transfer。但由于 Singleton，在 v4 中每个 swap 都只会更新内部 balance，仅在全部 swap 结束之后进行 transfer。这减少了多跳 swap 的 gas 费用。</p>
<h3 id="Native-ETH"><a href="#Native-ETH" class="headerlink" title="Native ETH"></a>Native ETH</h3><p>v4 支持原生 ETH，相比 v3 使用的 weth 减少了 Gas 的使用。</p>
<h3 id="ERC1155-Accounting"><a href="#ERC1155-Accounting" class="headerlink" title="ERC1155 Accounting"></a>ERC1155 Accounting</h3><p>v4 使用 ERC1155 用于额外 token 的记账，用户可以将 token 保留在 contract 中，避免将 token 频繁转入或转出，以节约 gas。</p>
<h3 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h3><p>v4 引入 hooks 使得协议内嵌的价格预言机变得不再必要，一些 pool 可以完全放弃预言机，并在每个 pool 在 block 中的第一次 swap 中节省 gas。</p>
<h3 id="Donate"><a href="#Donate" class="headerlink" title="Donate"></a>Donate</h3><p>v4 允许给特定范围内的流动性提供者支付 token，可以是池中的任意一种或两种代币。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>v4 对 v3 的改进主要在提出 hooks 和节约 gas 上，虽然新的使用场景还不明朗，但新协议往往就是新的机会，现在就开始研究是有价值的。</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2023/01/22/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV3/V3%E7%99%BD%E7%9A%AE%E4%B9%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/22/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV3/V3%E7%99%BD%E7%9A%AE%E4%B9%A6/" class="post-title-link" itemprop="url">V3白皮书</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-22 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-22T00:00:00+08:00">2023-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-09 10:01:34" itemprop="dateModified" datetime="2023-11-09T10:01:34+08:00">2023-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UniswapV3/" itemprop="url" rel="index">
                    <span itemprop="name">UniswapV3</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UniswapV3白皮书"><a href="#UniswapV3白皮书" class="headerlink" title="UniswapV3白皮书"></a>UniswapV3白皮书</h1><h2 id="资金利用率"><a href="#资金利用率" class="headerlink" title="资金利用率"></a>资金利用率</h2><p>价格区间(0, ∞)看起来很理想，我们的资金在任何时候（任意价格点）都能为我们赚取手续费。</p>
<p>但我们忽略了另一个影响收益的重要因素，那就是资金的利用率。<strong>当一个用户来用我们的池子做交易时，其交易的量相比我们的流动性来说是很小的</strong>。</p>
<p>比如，ETH的历史价格大致在 $0.75 到 $4,800 这个区间。在今天（2022年6月），1 个 ETH 的现货价格是 $1800，没有人会愿意用 $5000 购买一个 ETH，所以在这个价格上提供流动性是毫无用处的。因此，在远离当前价格区间的、永远不会达到的某个点上提供流动性是毫无意义的。</p>
<p>假设现在池子内资产 X 和 Y 都有 8 个，价格 p 为 1。现在有一笔订单，<strong>用 1 个 X 来换取 1 个 Y</strong>，我们先不考虑滑点和手续费的影响，这一笔交易为我们带来的手续费收益是 <code>fee = 1 * 0.3%</code>，实际参与赚取手续费的流动性就是输出的 1 个 y，这相比于总流动性是很小的，在这一笔交易中，<strong>资金利用率是大约是 <code>1 / 8</code>。</strong>也就是说，我们<strong>只需要极少一部分流动性就能承载这一笔交易</strong>，而大部分流动性在交易过程中只是躺在那做收益的分母而已……</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Dapp-Learning-DAO/Dapp-Learning/blob/main/defi/Uniswap-V3/whitepaperGuide/img/understanding-02-liquidityrate.png"><img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/understanding-02-liquidityrate.png" alt="liquidity rate" style="zoom:50%;" /></a> </p>
<h2 id="集中流动性"><a href="#集中流动性" class="headerlink" title="集中流动性"></a>集中流动性</h2><p>Uniswap V3 引入了 <em>集中流动性(concentrated liquidity)</em> 的概念：<strong>LP 可以选择他们希望在哪个价格区间提供流动性</strong>。这个机制通过将更多的流动性提供在一个相对狭窄的价格区间，来大大提高资产利用效率；这也使 Uniswap 的使用场景更加多样化：<strong>它现在可以对于不同价格波动性的池子进行不同的配置。</strong>这就是 V3 相对于 V2 的主要提升点。</p>
<p>简单地来说，<strong>一个 Uniswap V3 的交易对由许多个 Uniswap V2 的交易对构成。</strong>V2 与 V3 的区别是，<strong>在 V3 中，一个交易对有许多的价格区间</strong>，而每个价格区间内都有<strong>一定数量的资产</strong>。从零到正无穷的整个价格区间被划分成了许多个小的价格区间，<strong>每一个区间中都有一定数量的流动性</strong>。而更关键的点在于，在每个小的价格区间中，<strong>工作机制与 Uniswap V2</strong> 完全一样。这也是为什么我们说一个 Uniswap V3 的池子就是许多个 V2 的池子。</p>
<p>下面，我们来对这种机制进行可视化。我们并不是重新选择一个有限的曲线，而是我们把它在价格 a 与价格 b之间的部分截取出来，把它们当作是是曲线的边界。更进一步，我们把曲线进行平移使得边界点落在坐标轴上，于是得到了下图：</p>
<img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/curve_finite.png" alt="Uniswap V3 price range" style="zoom:50%;" /> 

<blockquote>
<p>它看起来或许有点单调， 因此 Uniswap V3 有许多的价格区间——这样它们就不会感到孤单了 🙂</p>
</blockquote>
<blockquote>
<p>一个有趣的事实：根据这个原理，可以利用V3的价格区间来挂限价单。</p>
</blockquote>
<h3 id="限价单"><a href="#限价单" class="headerlink" title="限价单"></a>限价单</h3><p>事实上，这种资产 X 全部转为资产 Y 的特性并不能算是缺陷，反而是一种可以利用的特性。比如当我们与市场看法相反的时候，<strong>市场大部分人看好 X，而你却看好 Y（或者看空 X）</strong>，于是你故意<strong>设置了一个比较窄的价格区间</strong>（容易被价格穿过），放在比当前价格高的地方，此时注入流动性，将会全部是资产 X。当资产 X 价格上涨时，先进入你的流动性价格区间，不断有人用资产 Y 换走你池内的资产 X，直至价格完全穿过价格区间的上限，<strong>池内的资产 X 被全部换成了资产 Y。</strong></p>
<p>下面一图展示了 <a target="_blank" rel="noopener" href="https://info.uniswap.org/#/pools/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8">USDC&#x2F;ETH 池子的流动性分布</a>:</p>
<img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/usdceth_liquidity.png" alt="Liquidity in the real USDC/ETH pool" style="zoom: 33%;" /> 

<p>可以看到，大量流动性集中在现价的附近，而较远的价格区间中的流动性较少——这是因为 LP 更希望提高它们的资产利用效率。当然，整个区间也不是无穷的，在图片右侧也显示了其上界。</p>
<h2 id="价格区间的风险与收益"><a href="#价格区间的风险与收益" class="headerlink" title="价格区间的风险与收益"></a>价格区间的风险与收益</h2><p><strong>当出现价格在区间以外的情况，此时流动性头寸不但不能继续赚取手续费，同时必定全部变成了单一资产</strong>，且一定是当时市场中处于弱势一方的资产。比如当资产 Y 涨价，将会有大量订单用资产 X 从池子中换取 Y，于是池子中的 X 越来越多，而 Y 最终会清零。因为 AMM 自动做市，实际上也是一种被动的做市，永远需要和市场中的订单做对手盘。</p>
<p>也就是说，价格区间越窄，价格移出区间的概率越大，风险越大，而区间越宽，风险就越小。如果你厌恶这种价格移出区间的风险，那么大可<strong>直接将价格区间设置为 (0, ∞)</strong> ，官方的 UI 界面也支持这个操作，那么你就会得到一个完全没有虚拟流动性，和 V2 差不多的全价格区间流动性了。</p>
<p>当然这么做的代价就是，<strong>资金利用率和 V2 也没差别，非常的低</strong>。这就相当于你将资金均匀分散到一个很长的价格轴上，虽然每次交易都能赚取手续费，但由于资金在每个价格点上被摊薄的太厉害，导致<strong>每次赚取手续费的占比权重非常低</strong>。</p>
<h2 id="Uniswap-V3-的数学原理"><a href="#Uniswap-V3-的数学原理" class="headerlink" title="Uniswap V3 的数学原理"></a>Uniswap V3 的数学原理</h2><p>在数学原理上，V3 是基于 V2 的：它们使用了相同的底层公式，但实际上 V3 使用的是<em>增强版</em>。</p>
<p>为了处理价格区间之间的转换，简化流动性管理，以及避免取整出现问题，V3 使用了下面这些新的标识：</p>
<img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230612212257348.png" alt="image-20230612212257348" style="zoom:67%;" /> 

<p><em>L</em> 被称作 <em>流动性数量</em>。池子中的流动性是两种 token 资产数量的组合。我们知道，按照公式，两种代币数量乘积为 <em>k</em>，因此我们可以用<strong>sqrt(x<em>y</em>)</strong> 来衡量池子流动性。<em>L</em> 实际上是 <em>x</em> 和 <em>y</em> 的几何平均数。</p>
<p><em>y</em>&#x2F;<em>x</em> 是 token0 相对于 token1 的价格。由于池子里两种代币的价格互为倒数，我们在计算中仅使用其中一个( Uniswap V3使用的是 y*&#x2F;<em>x</em>)。token1 相对于 token0 的价格即为 1&#x2F;(<em>y</em>&#x2F;<em>x</em>)&#x3D;x&#x2F;y*。类似地，1&#x2F;sqrt(p) &#x3D; 1&#x2F;sqrt(<em>y</em>&#x2F;<em>x</em>)&#x3D;sqrt(x&#x2F;y)</p>
<p>我们使用 sqrt(<em>P</em>) 而不是 <em>P</em> 有两个原因：</p>
<ol>
<li><p>平方根计算并不精确并且会引入取整的问题。因此，更简单的方法是我们干脆就在合约中存平方根的结果，而不是在合约中计算它。合约中并不存储 x 和 y</p>
</li>
<li><p>sqrt(P) 与 <em>L</em> 之间有一个有趣的关系：L也表示了输出数量的变化与 sqrt(P) 的变化之间的关系：</p>
<img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230612213006843.png" alt="image-20230612213006843" style="zoom:67%;" /></li>
</ol>
<h2 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h2><p>同样，我们并不需要计算准确的价格——我们可以直接计算获得的token数量。并且，由于我们在合约中并不存储 x 和 <em>y</em>，我们将仅通过 <em>L</em> 和 sqrt(<em>P</em>) 进行计算。</p>
<p>根据上文中的公式，我们能得到Δ<em>y</em>：</p>
<img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230612213108342.png" alt="image-20230612213108342" style="zoom:67%;" /> 

<h2 id="Ticks"><a href="#Ticks" class="headerlink" title="Ticks"></a>Ticks</h2><p>正如我们前面说到的，V2 中的无穷价格区间在 V3 中被分成了更小的价格区间，每个区间都由上下界端点进行限制。为了进行这些边界的协调，V3引入了 <em>ticks</em>。</p>
<img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/ticks_and_ranges.png" alt="Price ranges and ticks" style="zoom:67%;" /> 

<p>在 V3，整个价格区间由离散的、均匀分布的 ticks 进行标定。每个 tick 有一个 index 和对应的价格：</p>
<p><em>p</em>(<em>i</em>)&#x3D;1.0001^<em>i</em></p>
<p><em>p</em>(<em>i</em>) 即为 tick <em>i</em> 的价格. 使用 1.0001 的幂次作为标定有一个很好的性质：两个相邻 tick 之间的差距为 0.01% 或者<em>一个基点。</em></p>
<blockquote>
<p>基点 (1% 的百分之一，或者 0.01%，或者 0.0001)是在金融中用来衡量百分比的一个单位。你可能在央行宣布对于利率的调整中听过基点这个名词。</p>
</blockquote>
<img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230612213210938.png" alt="image-20230612213210938" style="zoom: 67%;" /> 

<p>Ticks 可以为正也可以为负，并且显然它不是无穷的。V3 把sqrt(<em>P</em> )存储为一个 Q64.96 类型的定点数，使用 64 位作为整数部分，使用 96 位作为小数部分。因此，价格的取值范围是 [2^(−128),2^128][2−128,2128]，ticks 的取值范围是：</p>
<img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230612213253656.png" alt="image-20230612213253656" style="zoom:67%;" /> 

<h2 id="预言机"><a href="#预言机" class="headerlink" title="预言机"></a>预言机</h2><p>V2 的预言机提供了 TWAP (time-weighted average price 时间加权平均价格)，更新时间是每个区块的第一笔交易的价格，其数值是上一次的数值加上当前价格乘以时间差。</p>
<img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230613092300794.png" alt="image-20230613092300794" style="zoom:80%;" /> 

<p>外部用户可以通过记录该数值的变化和时间点，获得在一段时间内受短期波动影响较小的时间加权价格。</p>
<img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230613092310737.png" alt="image-20230613092310737" style="zoom:80%;" /> 

<p>上述公式得出了在 t1 到 t2 的时间内，预言机提供的时间加权价格。因为其值是经过时间加权的（累加的是价格乘以时间差），所以受短期波动影响较小，这样能有效防止恶意的价格波动。</p>
<p><strong>V2 的预言机在核心合约上只保留最新的一个值，所以如果外部用户想要使用这个预言机，需要自己搭建一套监控和记录的设施，增加了使用者成本。</strong></p>
<p>V3 相比于 V2 的预言机，有以下较大改动：</p>
<ol>
<li>相比 V2 累加的是价格的加权数值，V3 累加的是价格的 log 值，即 <code>log(price, 1.0001)</code></li>
<li>在核心合约中增加了存储预言机数值的空间，最大 65536 个数值，至少 9 天的数值，建立监控和记录设施不再是必要条件</li>
<li>增加关于流动性的预言机数值，记录周期和价格一致（每个区块的第一笔交易），其值是当前激活状态的流动性数量的倒数，即 <code>1/liquidity</code></li>
</ol>
<h3 id="算术平均与几何平均"><a href="#算术平均与几何平均" class="headerlink" title="算术平均与几何平均"></a>算术平均与几何平均</h3><p>V2 的方式是直接记录价格的累加值，而使用时再除以时间间隔，这就是一种<strong>算术平均</strong> (arithmetic mean)。而 V3 累加的是 <code>log(price, 1.0001)</code> 也就是价格的幂，使用时再除以时间间隔，这是<strong>几何平均</strong> (geometric mean)。</p>
<p>所以 V3 的预言机公式需要改成如下:</p>
<p><code>a(t)</code> 是时间 t 时，预言机记录的值（累加价格的 log 值）。</p>
<img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230613092344185.png" alt="image-20230613092344185" style="zoom:80%;" /> 

<p>这里的 log 数值后面其实还有一个 <code>* 1s</code> 即以每秒作为时间间隔。然而实际情况中，合约中是以区块的时间戳作为标记时间的，所以合约中的代码跟公式不同。每个区块的头一笔交易时更新，此时距离上一次更新时间间隔肯定大于 1s，所以需要将更新值乘以两个区块的时间戳的差。<code>tickCumulative</code> 是 tick 序号的累计值，tick 的序号就是 <code>log(√price, 1.0001)</code>。</p>
<img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230613092409473.png" alt="image-20230613092409473" style="zoom:80%;" /> 

<p>当外部用户使用时，求 t1 到 t2 时间内的时间加权价格 <code>p(t1,t2)</code> ，需要计算两个时间点的累计值的差 <code>a(t2) - a(t1)</code> 除以时间差。</p>
<img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230613092421643.png" alt="image-20230613092421643" style="zoom:80%;" /> 

<p>使用几何平均的原因：</p>
<ul>
<li>因为合约中记录了 tick 序号，序号是整型，且跟价格相关，所以直接计算序号更加节省 gas。（全局变量中存储的不是价格，而是根号价格，如果直接用价格来记录，要多比较复杂的计算）</li>
<li>V2 中算数平均价格并不总是倒数关系（以 token1 计价 token0，或反过来），所以需要记录两种价格。V3 中使用几何平均不存在该问题，只需要记录一种价格。<ul>
<li>举个例子，在 V2 中如果 USD&#x2F;ETH 价格在区块 1 中是 100，在区块 2 中是 300，USD&#x2F;ETH 的均价是 200 USD&#x2F;ETH，但是 ETH&#x2F;USD 的均价是 1&#x2F;150</li>
</ul>
</li>
<li><strong>几何平均比算数平均能更好的反应真实的价格，受短期波动影响更小。</strong>白皮书中的引用提到在几何布朗运动中，算数平均会受到高价格的影响更多。</li>
</ul>
<blockquote>
<p>我在 <a target="_blank" rel="noopener" href="https://github.com/Dapp-Learning-DAO/Dapp-Learning/blob/main/defi/Uniswap-V3/whitepaperGuide/oracleCompare.ipynb">oracleCompare.ipynb</a> 中简单模拟了算数平均和几何平均的预言机机制，实际结果是算数平均受高价影响较大，而几何平均受低价影响较大。</p>
</blockquote>
<h3 id="流动性预言机"><a href="#流动性预言机" class="headerlink" title="流动性预言机"></a>流动性预言机</h3><p>相比于 V2，任何时刻活跃的流动性就是池子内所有流动性数量总和（因为都是全价格区间），V3 有了不同价格区间，所以不同时刻，激活状态的流动性数量并不是池子内的总流动性数量。为了便于外部使用者更好的观测激活流动性的数量，V3 添加了预言机的 <code>secondsPerLiquidityCumulative</code> 变量。</p>
<img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230613092504648.png" alt="image-20230613092504648" style="zoom:80%;" /> 

<p>（因为 liquidity 可能为 0，此时分母为 1）</p>
<p>这里的具体含义是每单位流动性参与的做市时长，即一段时间内，参与的流动性越多，那么每单位流动性参与的时长越短，因为分摊收益的流动性数量变多了，反之亦然。</p>
<p>其记录机制和价格逻辑一致，不再赘述。这里介绍一下它的用途。</p>
<h3 id="Tick-上辅助预言机计算的数据"><a href="#Tick-上辅助预言机计算的数据" class="headerlink" title="Tick 上辅助预言机计算的数据"></a>Tick 上辅助预言机计算的数据</h3><p>每个已初始化的 tick 上（有流动性添加的），不光有流动性数量和手续费相关的变量(<code>liquidityNet</code>, <code>liquidityGross</code>, <code>feeGrowthOutside</code>)，还有三个可用于做市策略。</p>
<p>tick 变量一览：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Variable Name</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>int128</td>
<td>liquidityNet</td>
<td>流动性数量净含量</td>
</tr>
<tr>
<td>int128</td>
<td>liquidityGross</td>
<td>流动性数量总量</td>
</tr>
<tr>
<td>int256</td>
<td>feeGrowthOutside0X128</td>
<td>以 token0 收取的 outside 的手续费总量</td>
</tr>
<tr>
<td>int256</td>
<td>feeGrowthOutside1X128</td>
<td>以 token1 收取的 outside 的手续费总量</td>
</tr>
<tr>
<td>int256</td>
<td>secondsOutside</td>
<td>价格在 outside 的总时间</td>
</tr>
<tr>
<td>int256</td>
<td>tickCumulativeOutside</td>
<td>价格在 outside 的 tick 序号累加</td>
</tr>
<tr>
<td>int256</td>
<td>secondsPerLiquidityOutsideX128</td>
<td>价格在 outside 的每单位流动性参与时长</td>
</tr>
</tbody></table>
<p>outside 的含义参考手续费部分的讲解，这些变量前几个都是手续费部分用到的，最后三个则是预言机相关的数据。</p>
<p>tick 辅助预言机的变量的使用方法：</p>
<ol>
<li><code>secondsOutside</code>： 用池子创建以来的总时间减去价格区间两边 tick 上的该变量，就能得出该区间做市的总时长</li>
<li><code>tickCumulativeOutside</code>： 用预言机的 <code>tickCumulative</code> 减去价格区间两边 tick 上的该变量，除以做市时长，就能得出该区间平均的做市价格（tick 序号）</li>
<li><code>secondsPerLiquidityOutsideX128</code>： 用预言机的 <code>secondsPerLiquidityCumulative</code> 减去价格区间两边 tick 上的该变量，就是该区间内的每单位流动性的做市时长（使用该结果乘以你的流动性数量，得出你的流动性参与的做市时长，这个时长比上 1 的结果，就是你在该区间赚取的手续费比例）。</li>
</ol>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2023/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV2/UniswapV2Router02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV2/UniswapV2Router02/" class="post-title-link" itemprop="url">UniswapV2Router02</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-21 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-21T00:00:00+08:00">2023-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UniswapV2/" itemprop="url" rel="index">
                    <span itemprop="name">UniswapV2</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UniswapV2Router02"><a href="#UniswapV2Router02" class="headerlink" title="UniswapV2Router02"></a>UniswapV2Router02</h1><p>在构造函数中传入factory合约和WETH合约地址，WETH的作用是将以太币包装成ERC-20代币，Route合约是与pair交易对进行交互的合约，常用于添加流动性、移除流动性、兑换、获取交易对信息……</p>
<p><strong>其中amountMin用于控制滑点，若amount_min &#x3D; amount_desired - (amount_desired * 0.01)  表示 1%滑点容忍度</strong></p>
<h2 id="合约当中比较重要的方法有："><a href="#合约当中比较重要的方法有：" class="headerlink" title="合约当中比较重要的方法有："></a>合约当中比较重要的方法有：</h2><h4 id="addLiquidity：-address-tokenA-address-tokenB-uint-amountADesired-uint-amountBDesired-uint-amountAMin-uint-amountBMin-address-to-uint-deadline-ensure-deadline-returns-uint-amountA-uint-amountB-uint-liquidity"><a href="#addLiquidity：-address-tokenA-address-tokenB-uint-amountADesired-uint-amountBDesired-uint-amountAMin-uint-amountBMin-address-to-uint-deadline-ensure-deadline-returns-uint-amountA-uint-amountB-uint-liquidity" class="headerlink" title="addLiquidity：(address tokenA, address tokenB,uint amountADesired,uint amountBDesired,uint amountAMin,uint amountBMin,address to,uint deadline) ensure(deadline) returns (uint amountA, uint amountB, uint liquidity)"></a>addLiquidity：(address tokenA, address tokenB,uint amountADesired,uint amountBDesired,uint amountAMin,uint amountBMin,address to,uint deadline) ensure(deadline) returns (uint amountA, uint amountB, uint liquidity)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1.调用 _addLiquidity方法，返回amountA，amountB</span><br><span class="line">// 2.获取两个token的pair合约地址,并转账两个token</span><br><span class="line">address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);</span><br><span class="line">TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);</span><br><span class="line">TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);</span><br><span class="line">// 3.向to地址铸造lptoken</span><br><span class="line">liquidity = IUniswapV2Pair(pair).mint(to);</span><br></pre></td></tr></table></figure>

<p>添加流动性方法：通过_addLiquidity方法传入期望添加token的数量和愿意接受的最低token数量返回实际添加到资金池中token的数量，想pair合约转账token并铸造lptoken</p>
<h4 id="removeLiquidity：-address-tokenA-address-tokenB-uint-liquidity-uint-amountAMin-uint-amountBMin-address-to-uint-deadline-ensure-deadline-returns-uint-amountA-uint-amountB"><a href="#removeLiquidity：-address-tokenA-address-tokenB-uint-liquidity-uint-amountAMin-uint-amountBMin-address-to-uint-deadline-ensure-deadline-returns-uint-amountA-uint-amountB" class="headerlink" title="removeLiquidity：(address tokenA, address tokenB,uint liquidity,uint amountAMin,uint amountBMin,address to,uint deadline) ensure(deadline) returns (uint amountA, uint amountB)"></a>removeLiquidity：(address tokenA, address tokenB,uint liquidity,uint amountAMin,uint amountBMin,address to,uint deadline) ensure(deadline) returns (uint amountA, uint amountB)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1.获取两个token的pair合约地址并将lptoken发送到pair合约</span><br><span class="line">address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);</span><br><span class="line">IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity);</span><br><span class="line">// 2.销毁lptoken，返回销毁lptoken获得两种token的数量</span><br><span class="line">(uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);</span><br></pre></td></tr></table></figure>

<p>移除流动性方法：通过pair合约销毁lptoken移除流动性，获得的两个token需要大于愿意接受的最低token数量</p>
<h4 id="swapExactTokensForTokens：-uint-amountIn-uint-amountOutMin-address-calldata-path-address-to-uint-deadline-ensure-deadline-returns-uint-memory-amounts"><a href="#swapExactTokensForTokens：-uint-amountIn-uint-amountOutMin-address-calldata-path-address-to-uint-deadline-ensure-deadline-returns-uint-memory-amounts" class="headerlink" title="swapExactTokensForTokens：(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline ) ensure(deadline) returns (uint[] memory amounts)"></a>swapExactTokensForTokens：(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline ) ensure(deadline) returns (uint[] memory amounts)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 根据传入的tokenA的数量和path获得amounts</span><br><span class="line">amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);</span><br><span class="line">// 判断最终获得的tokenB的数量是否大于amountOutMin</span><br><span class="line">require(amounts[amounts.length - 1] &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27;);</span><br><span class="line">// 将tokenA传入第一对交易对中</span><br><span class="line">TransferHelper.safeTransferFrom(path[0],msg.sender,UniswapV2Library.pairFor(factory, path[0], path[1]),amounts[0]);</span><br><span class="line">// 兑换</span><br><span class="line">_swap(amounts, path, to);</span><br></pre></td></tr></table></figure>

<p>兑换：根据确切的tokenA的数量兑换tokenB</p>
<h2 id="合约内部调用的方法："><a href="#合约内部调用的方法：" class="headerlink" title="合约内部调用的方法："></a>合约内部调用的方法：</h2><h4 id="addLiquidity：-address-tokenA-address-tokenB-uint-amountADesired-uint-amountBDesired-uint-amountAMin-uint-amountBMin-returns-uint-amountA-uint-amountB-uint-liquidity"><a href="#addLiquidity：-address-tokenA-address-tokenB-uint-amountADesired-uint-amountBDesired-uint-amountAMin-uint-amountBMin-returns-uint-amountA-uint-amountB-uint-liquidity" class="headerlink" title="_addLiquidity：(address tokenA, address tokenB,uint amountADesired,uint amountBDesired,uint amountAMin,uint amountBMin)  returns (uint amountA, uint amountB uint liquidity)"></a>_addLiquidity：(address tokenA, address tokenB,uint amountADesired,uint amountBDesired,uint amountAMin,uint amountBMin)  returns (uint amountA, uint amountB uint liquidity)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1.获取两个token的pair地址，若不存则创建新的交易对</span><br><span class="line">// 2.获取储备量并且不等于零</span><br><span class="line">// 根据两种token的储备量和期望tokenA的数额获取tokenB最佳的数额</span><br><span class="line">uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);</span><br><span class="line">// 3.根据期望值和愿意接受的最低token数量通过判断返回amountA，amountB</span><br></pre></td></tr></table></figure>

<h4 id="swap：-uint-memory-amounts-address-memory-path-address-to"><a href="#swap：-uint-memory-amounts-address-memory-path-address-to" class="headerlink" title="_swap：(uint[] memory amounts, address[] memory path, address _to)"></a>_swap：(uint[] memory amounts, address[] memory path, address _to)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1.循环path路径</span><br><span class="line">// 2.计算每对交易对的兑换量</span><br><span class="line">// 3.如果中间还有其他的路径，to地址为其中交易对的pair地址</span><br><span class="line">address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;</span><br><span class="line">// 进行兑换</span><br><span class="line">IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(amount0Out,amount1Out,to,new bytes(0));</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongpengyq.com/2023/01/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV2/UniswapV2Pair/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.png">
      <meta itemprop="name" content="幺柒YQ">
      <meta itemprop="description" content="努力坚持就会有希望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQ & 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV2/UniswapV2Pair/" class="post-title-link" itemprop="url">UniswapV2Pair</a>
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-17 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-17T00:00:00+08:00">2023-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-27 16:03:09" itemprop="dateModified" datetime="2023-10-27T16:03:09+08:00">2023-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UniswapV2/" itemprop="url" rel="index">
                    <span itemprop="name">UniswapV2</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UniswapV2Pair"><a href="#UniswapV2Pair" class="headerlink" title="UniswapV2Pair"></a>UniswapV2Pair</h1><p>在构造函数中factory地址为msg.sender，因为该合约是由UniswapV2Factory进行部署，该合约继承了UniswapV2ERC20，主要用于管理以及操作交易对，托管两种token</p>
<h2 id="合约当中比较重要的方法有-lptoken即UniswapV2ERC20"><a href="#合约当中比较重要的方法有-lptoken即UniswapV2ERC20" class="headerlink" title="合约当中比较重要的方法有(lptoken即UniswapV2ERC20):"></a>合约当中比较重要的方法有(lptoken即UniswapV2ERC20):</h2><p>  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external：判断签名的有效性</p>
<p>  function mint(address to) external returns (uint liquidity)：铸造lptoken</p>
<p>  function burn(address to) external returns (uint amount0, uint amount1)：销毁lptoken退出流动性</p>
<p>  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external：根据tokenA的数量在交易池中进行兑换tokenB</p>
<p>  function skim(address to) external：使两个token的余额与储备相等</p>
<p>  function sync() external：使两个token的储备与余额相匹配</p>
<p>  function initialize(address, address) external：设置pair地址交易对的两种token</p>
<h4 id="permit-address-owner-address-spender-uint-value-uint-deadline-uint8-v-bytes32-r-bytes32-s"><a href="#permit-address-owner-address-spender-uint-value-uint-deadline-uint8-v-bytes32-r-bytes32-s" class="headerlink" title="permit:(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s)"></a>permit:(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ecrecover 函数可以返回与签名者对应的公钥地址</span><br><span class="line">address recoveredAddress = ecrecover(digest, v, r, s);</span><br><span class="line">// 判断签名者对应的公钥地址与授权地址是否一致</span><br><span class="line">require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &#x27;UniswapV2: INVALID_SIGNATURE&#x27;);</span><br><span class="line">_approve(owner, spender, value);</span><br></pre></td></tr></table></figure>

<p>用户现在签名一笔交易，用该方法可有判断该签名的有效性,如果通过判断，则进行授权</p>
<h4 id="mint：-address-to-lock-returns-uint-liquidity"><a href="#mint：-address-to-lock-returns-uint-liquidity" class="headerlink" title="mint：(address to) lock returns (uint liquidity)"></a>mint：(address to) lock returns (uint liquidity)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 1.获取进行添加流动性的两个token的数量</span><br><span class="line">(uint112 _reserve0, uint112 _reserve1, ) = getReserves();</span><br><span class="line">uint balance0 = IERC20(token0).balanceOf(address(this));</span><br><span class="line">uint balance1 = IERC20(token1).balanceOf(address(this));</span><br><span class="line">uint amount0 = balance0.sub(_reserve0);</span><br><span class="line">uint amount1 = balance1.sub(_reserve1);</span><br><span class="line">// 2.调用_mintFee方法</span><br><span class="line">// 3.添加流动性所获得的lptoken数量(进行添加流动性的两种token的数量*目前lptoken的数量/当前token的储备量--&gt;取较小值)</span><br><span class="line">liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);</span><br><span class="line">// 4.铸造lptoken函数和更新储备函数</span><br><span class="line">_mint(to, liquidity);</span><br><span class="line">_update(balance0, balance1, _reserve0, _reserve1);</span><br></pre></td></tr></table></figure>

<p>主要是根据两个token在交易对的增量计算出应该铸造lptoken的数量，然后将lptoken铸造给to地址，具有防重入锁lock</p>
<h4 id="burn：-address-to-lock-returns-uint-amount0-uint-amount1"><a href="#burn：-address-to-lock-returns-uint-amount0-uint-amount1" class="headerlink" title="burn：(address to) lock returns (uint amount0, uint amount1)"></a>burn：(address to) lock returns (uint amount0, uint amount1)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 1.为什么用addres(this)?--&gt;因为获取退出lptoken数量时，是在Route合约中先将lptoken转到当前合约，然后直接获得当前合约lptoken的数量</span><br><span class="line">uint liquidity = balanceOf[address(this)];</span><br><span class="line">// 2.调用_mintFee方法</span><br><span class="line">// 3.使用余额确保按比例分配--&gt;(持有lptoken/总lptoken)*合约中持有token的数量</span><br><span class="line">amount0 = liquidity.mul(balance0) / _totalSupply; </span><br><span class="line">amount1 = liquidity.mul(balance1) / _totalSupply; </span><br><span class="line">// 4.转账两种token并更新储备量</span><br><span class="line">_safeTransfer(_token0, to, amount0);</span><br><span class="line">_safeTransfer(_token1, to, amount1);</span><br><span class="line">balance0 = IERC20(_token0).balanceOf(address(this));</span><br><span class="line">balance1 = IERC20(_token1).balanceOf(address(this));</span><br><span class="line">_update(balance0, balance1, _reserve0, _reserve1);</span><br></pre></td></tr></table></figure>

<p>根据lptokne的比例计算出两种token的各自的数量，然后销毁lptoken并将转账两种token给to地址</p>
<h4 id="swap：-uint-amount0Out-uint-amount1Out-address-to-bytes-calldata-data"><a href="#swap：-uint-amount0Out-uint-amount1Out-address-to-bytes-calldata-data" class="headerlink" title="swap：(uint amount0Out, uint amount1Out, address to, bytes calldata data)"></a>swap：(uint amount0Out, uint amount1Out, address to, bytes calldata data)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1.转移代币</span><br><span class="line">if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); </span><br><span class="line">if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); </span><br><span class="line">// 2.用于回调合约来实现一些特定的业务逻辑或其他自定义功能(例如：闪电贷....)</span><br><span class="line">if (data.length &gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);</span><br><span class="line">// 3.确保在交易完成后，资金池的储备量满足 Uniswap V2 中的 K 恒定公式，即 K = _reserve0 * _reserve1</span><br><span class="line">// 4.更新储备</span><br></pre></td></tr></table></figure>

<p>1.在Route合约用户已经将需要兑换的tokenA转入pair合约中，在Route合约中传入需要输出的tokenB的数量和一个data，转移tokenB后判断data长度是否大于零去进行回调合约</p>
<p>2.直接调用swap方法进行回调合约获得套利，只要套利后满足后续条件即可</p>
<h2 id="合约内部调用的方法："><a href="#合约内部调用的方法：" class="headerlink" title="合约内部调用的方法："></a>合约内部调用的方法：</h2><h4 id="update：-uint-balance0-uint-balance1-uint112-reserve0-uint112-reserve1-private"><a href="#update：-uint-balance0-uint-balance1-uint112-reserve0-uint112-reserve1-private" class="headerlink" title="_update：(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private"></a>_update：(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1.更新priceCumulativeLast，永远不会溢出，+ overflow是理想的</span><br><span class="line">price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;</span><br><span class="line">price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;</span><br><span class="line">// 2.更新储备量</span><br><span class="line">reserve0 = uint112(balance0);</span><br><span class="line">reserve1 = uint112(balance1);</span><br></pre></td></tr></table></figure>

<p>更新储备方法：四个参数前两个为更新后两个token的储备量，后两个为更新前两个token的储备量</p>
<h4 id="mintFee：-uint112-reserve0-uint112-reserve1-private-returns-bool-feeOn"><a href="#mintFee：-uint112-reserve0-uint112-reserve1-private-returns-bool-feeOn" class="headerlink" title="_mintFee：(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn)"></a>_mintFee：(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1.获取收取手续费的地址如果不是零地址并且kLast!=0则继续下面部分</span><br><span class="line">// 2.获取上一次交易后和目前交易对中的K值</span><br><span class="line">uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));</span><br><span class="line">uint rootKLast = Math.sqrt(_kLast);</span><br><span class="line">// 3.如果rootK&gt;rootKLast</span><br><span class="line">uint numerator = totalSupply.mul(rootK.sub(rootKLast));</span><br><span class="line">uint denominator = rootK.mul(5).add(rootKLast);</span><br><span class="line">uint liquidity = numerator / denominator;</span><br><span class="line">// 4.如果liquidity大于零为收取手续费地址铸造lptoken </span><br><span class="line">if (liquidity &gt; 0) _mint(feeTo, liquidity);</span><br></pre></td></tr></table></figure>

<p>收取手续费方法，参数为当前两个token的储备量</p>

      
    </div>

    
    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="幺柒YQ"
      src="/images/avater.png">
  <p class="site-author-name" itemprop="name">幺柒YQ</p>
  <div class="site-description" itemprop="description">努力坚持就会有希望</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">232</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kpyaoqi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kpyaoqi" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:18312386077@163.com" title="E-Mail → mailto:18312386077@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat.jpg" title="WeChat → images&#x2F;wechat.jpg"><i class="fa fa-fw fa-wechat"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/qq.jpg" title="QQ → images&#x2F;qq.jpg"><i class="fa fa-fw fa-qq"></i>QQ</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://stackoverflow.com/" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;" rel="noopener" target="_blank">Stackoverflow</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2021-11 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">幺柒YQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">899k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:37</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共379.4k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  


</body>
</html>
