<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1-Geth启动命令</title>
      <link href="/2023/11/05/Geth/1-Geth%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/11/05/Geth/1-Geth%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>account                账户管理</p><p>attach                启动一个交互式JavaScript环境(连接到节点)</p><p>console                启动一个交互式JavaScript环境</p><p>db    数据库低级操作</p><p>dump    从存储中转储指定块</p><p>dumpconfig   以TOML格式导出配置值</p><p>dumpgenesi   s将创世块JSON配置转储到stdout</p><p>export                 导出区块链到文件</p><p>export-preimages       将预映像数据库导出为RLP流</p><p>import                 导入区块链文件</p><p>import-preimages       从RLP流导入预映像数据库</p><p>init                   Bootstrap并初始化一个新的创世块</p><p>js                     (DEPRECATED)执行指定的JavaScript文件</p><p>license显示license信息</p><p>removedb删除区块链和状态数据库</p><p>Show -deprecated-flags显示已弃用的标志</p><p>snapshot基于快照的命令集</p><p>verkle一组实验性的verkle树管理命令</p><p>version打印版本号</p><p>version-check检查(在线)已知的Geth安全漏洞</p><p>wallet                 管理以太坊预售钱包</p><p>help, h显示命令列表或命令的帮助信息</p><h1 id="全局选项"><a href="#全局选项" class="headerlink" title="全局选项"></a>全局选项</h1><h2 id="账户"><a href="#账户" class="headerlink" title="账户"></a>账户</h2><p>​    –allow-insecure-unlock        (default: false)<br>​          当http协议暴露了与帐号相关的rpc时，允许不安全的帐号解锁</p><p>​    –keystore value<br>​          密钥存储库的目录 (default &#x3D; inside the datadir)</p><p>​    –lightkdf                     (default: false)<br>​          以牺牲KDF强度为代价减少密钥派生RAM和CPU的使用</p><p>​    –password value<br>​          用于非交互式密码输入的密码文件</p><p>​    –pcscdpath value<br>​         智能卡守护进程(pcscd)套接字文件的路径</p><p>​    –signer value<br>​          外部签名者(url或路径到ipc文件)</p><p>​    –unlock value<br>​          要解锁的帐户列表，以逗号分隔</p><p>​    –usb                          (default: false)<br>​         启用USB硬件钱包的监控和管理</p><h2 id="别名-弃用"><a href="#别名-弃用" class="headerlink" title="别名(弃用)"></a>别名(弃用)</h2><p>​    –nousb                        (default: false)<br>​        禁止监控和管理USB硬件钱包(已弃用)</p><p>–whitelist value<br>      逗号分隔的块编号到哈希值的映射强制执行(<number>&#x3D;<hash>)</p><p>​(已弃用，支持——eth.requiredblocks)</p><h2 id="API和控制台"><a href="#API和控制台" class="headerlink" title="API和控制台"></a>API和控制台</h2><p>​    –authrpc.addr value           (default: “localhost”)<br>​         已认证api的监听地址</p><p>​    –authrpc.jwtsecret value<br>​         用于经过身份验证的RPC端点的JWT秘密的路径</p><p>​    –authrpc.port value           (default: 8551)<br>​         认证api的监听端口</p><p>​    –authrpc.vhosts value         (default: “localhost”)<br>​          接受请求的虚拟主机名列表(服务器强制)，以逗号分隔。接受’*’通配符。</p><p>​    –exec value<br>​          执行JavaScript语句</p><p>–graphql                      (default: false)<br>      在HTTP-RPC服务器上启用GraphQL。注意，GraphQL只能在以下情况下启动：同时也启动了一个HTTP服务器。</p><p>​    –graphql.corsdomain value<br>​          接受跨域请求的域列表，以逗号分隔<br>​          (browser enforced)</p><p>–graphql.vhosts value         (default: “localhost”)<br>    接受请求的虚拟主机名列表(以逗号分隔)。接受’*’通配符。</p><p>–header value, -H value<br>      当使用–remotedb或geth attach时，将自定义报头传递给RPC服务。这个标志可以多次出现。</p><p>​    –http                         (default: false)<br>​        启用HTTP-RPC服务器</p><p>​    –http.addr value              (default: “localhost”)<br>​        HTTP-RPC服务器监听接口</p><p>​    –http.api value<br>​        通过HTTP-RPC接口提供的API</p><p>​    –http.corsdomain value<br>​         接受跨域请求的域列表，以逗号分隔<br>​          (browser enforced)</p><p>​    –http.port value              (default: 8545)<br>​        HTTP-RPC服务器监听端口</p><p>​    –http.rpcprefix value<br>​          HTTP路径JSON-RPC服务的路径前缀。使用’&#x2F;‘服务于所有路径</p><p>–http.vhosts value            (default: “localhost”)<br>      接受请求的虚拟主机名列表(以逗号分隔)接受’*’通配符。</p><p>​    –ipcdisable                   (default: false)<br>​          关闭IPC-RPC服务器</p><p>​    –ipcpath value<br>​        数据目录中IPC套接字&#x2F;管道的文件名(显式路径转义它)</p><p>​    –jspath value                 (default: .)<br>​         loadScript的根路径</p><p>​    –preload value<br>​         要预加载到控制台的JavaScript文件列表，以逗号分隔</p><p>​    –rpc.allow-unprotected-txs    (default: false)<br>​        允许通过RPC提交未受保护(非EIP155签名)的事务</p><p>​    –rpc.enabledeprecatedpersonal (default: false)<br>​          启用(已弃用的)个人名称空间</p><p>​    –rpc.evmtimeout value         (default: 5s)<br>​          设置eth_call (0&#x3D;infinite)的超时时间</p><p>​    –rpc.gascap value             (default: 50000000)<br>​          设置可以在eth_call&#x2F;estimateGas中使用的gas上限(0&#x3D;infinite)</p><p>​    –rpc.txfeecap value           (default: 1)<br>​          设置可以通过RPC api(0 &#x3D;)发送的交易费用上限(以以太为单位)(0 &#x3D;no cap)</p><p>​    –ws                           (default: false)<br>​          启用WS-RPC服务器</p><p>​    –ws.addr value                (default: “localhost”)<br>​          WS-RPC服务器监听接口</p><p>​    –ws.api value<br>​         通过WS-RPC接口提供的API</p><p>​    –ws.origins value<br>​        接受websockets请求的来源</p><p>​    –ws.port value                (default: 8546)<br>​          WS-RPC服务器侦听端口</p><p>​    –ws.rpcprefix value<br>​        为JSON-RPC提供服务的HTTP路径前缀。使用’&#x2F;‘服务于所有路径。</p><h2 id="开发人员链"><a href="#开发人员链" class="headerlink" title="开发人员链"></a>开发人员链</h2><p>​    –dev                          (default: false)<br>​          Ephemeral proof-of-authority network with a pre-funded developer account, mining<br>​          enabled</p><p>​    –dev.gaslimit value           (default: 11500000)<br>​          Initial block gas limit</p><p>​    –dev.period value             (default: 0)<br>​          Block period to use in developer mode (0 &#x3D; mine only if transaction pending)</p><h2 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h2><p>​    –bloomfilter.size value       (default: 2048)<br>​          Megabytes of memory allocated to bloom-filter for pruning</p><p>​    –config value<br>​          TOML configuration file</p><p>​    –datadir value                (default: &#x2F;Users&#x2F;fjl&#x2F;Library&#x2F;Ethereum)<br>​          Data directory for the databases and keystore</p><p>​    –datadir.ancient value<br>​          Root directory for ancient data (default &#x3D; inside chaindata)</p><p>​    –datadir.minfreedisk value<br>​          Minimum free disk space in MB, once reached triggers auto shut down (default &#x3D;<br>​          –cache.gc converted to MB, 0 &#x3D; disabled)</p><p>​    –db.engine value              (default: “leveldb”)<br>​          Backing database implementation to use (‘leveldb’ or ‘pebble’)</p><p>​    –eth.requiredblocks value<br>​          Comma separated block number-to-hash mappings to require for peering<br>​          (<number>&#x3D;<hash>)</p><p>​    –exitwhensynced               (default: false)<br>​          Exits after block synchronisation completes</p><p>​    –gcmode value                 (default: “full”)<br>​          Blockchain garbage collection mode (“full”, “archive”)</p><p>​    –goerli                       (default: false)<br>​          Görli network: pre-configured proof-of-authority test network</p><p>​    –mainnet                      (default: false)<br>​          Ethereum mainnet</p><p>​    –networkid value              (default: 1)<br>​          Explicitly set network id (integer)(For testnets: use –rinkeby, –goerli,<br>​          –sepolia instead)</p><p>​    –override.shanghai value      (default: 0)<br>​          Manually specify the Shanghai fork timestamp, overriding the bundled setting</p><p>​    –rinkeby                      (default: false)<br>​          Rinkeby network: pre-configured proof-of-authority test network</p><p>​    –sepolia                      (default: false)<br>​          Sepolia network: pre-configured proof-of-work test network</p><p>​    –snapshot                     (default: true)<br>​          Enables snapshot-database mode (default &#x3D; enable)</p><p>​    –syncmode value               (default: snap)<br>​          Blockchain sync mode (“snap”, “full” or “light”)</p><p>​    –txlookuplimit value          (default: 2350000)<br>​          Number of recent blocks to maintain transactions index for (default &#x3D; about one<br>​          year, 0 &#x3D; entire chain)</p><h2 id="天然气价格预测"><a href="#天然气价格预测" class="headerlink" title="天然气价格预测"></a>天然气价格预测</h2><p>​    –gpo.blocks value             (default: 20)<br>​          Number of recent blocks to check for gas prices</p><p>​    –gpo.ignoreprice value        (default: 2)<br>​          Gas price below which gpo will ignore transactions</p><p>​    –gpo.maxprice value           (default: 500000000000)<br>​          Maximum transaction priority fee (or gasprice before London fork) to be<br>​          recommended by gpo</p><p>​    –gpo.percentile value         (default: 60)<br>​          Suggested gas price is the given percentile of a set of recent transaction gas<br>​          prices</p><h2 id="轻客户端"><a href="#轻客户端" class="headerlink" title="轻客户端"></a>轻客户端</h2><p>​    –light.egress value           (default: 0)<br>​          Outgoing bandwidth limit for serving light clients (kilobytes&#x2F;sec, 0 &#x3D;<br>​          unlimited)</p><p>​    –light.ingress value          (default: 0)<br>​          Incoming bandwidth limit for serving light clients (kilobytes&#x2F;sec, 0 &#x3D;<br>​          unlimited)</p><p>​    –light.maxpeers value         (default: 100)<br>​          Maximum number of light clients to serve, or light servers to attach to</p><p>​    –light.nopruning              (default: false)<br>​          Disable ancient light chain data pruning</p><p>​    –light.nosyncserve            (default: false)<br>​          Enables serving light clients before syncing</p><p>​    –light.serve value            (default: 0)<br>​          Maximum percentage of time allowed for serving LES requests (multi-threaded<br>​          processing allows values over 100)</p><p>​    –ulc.fraction value           (default: 75)<br>​          Minimum % of trusted ultra-light servers required to announce a new head</p><p>​    –ulc.onlyannounce             (default: false)<br>​          Ultra light server sends announcements only</p><p>​    –ulc.servers value<br>​          List of trusted ultra-light servers</p><h2 id="日志记录和调试"><a href="#日志记录和调试" class="headerlink" title="日志记录和调试"></a>日志记录和调试</h2><p>​    –fakepow                      (default: false)<br>​          Disables proof-of-work verification</p><p>​    –log.backtrace value<br>​          Request a stack trace at a specific logging statement (e.g. “block.go:271”)</p><p>​    –log.debug                    (default: false)<br>​          Prepends log messages with call-site location (file and line number)</p><p>​    –log.file value<br>​          Write logs to a file</p><p>​    –log.json                     (default: false)<br>​          Format logs with JSON</p><p>​    –nocompaction                 (default: false)<br>​          Disables db compaction after import</p><p>​    –pprof                        (default: false)<br>​          Enable the pprof HTTP server</p><p>​    –pprof.addr value             (default: “127.0.0.1”)<br>​          pprof HTTP server listening interface</p><p>​    –pprof.blockprofilerate value (default: 0)<br>​          Turn on block profiling with the given rate</p><p>​    –pprof.cpuprofile value<br>​          Write CPU profile to the given file</p><p>​    –pprof.memprofilerate value   (default: 524288)<br>​          Turn on memory profiling with the given rate</p><p>​    –pprof.port value             (default: 6060)<br>​          pprof HTTP server listening port</p><p>​    –remotedb value<br>​          URL for remote database</p><p>​    –trace value<br>​          Write execution trace to the given file</p><p>​    –verbosity value              (default: 3)<br>​          Logging verbosity: 0&#x3D;silent, 1&#x3D;error, 2&#x3D;warn, 3&#x3D;info, 4&#x3D;debug, 5&#x3D;detail</p><p>​    –vmodule value<br>​          Per-module verbosity: comma-separated list of <pattern>&#x3D;<level> (e.g.<br>​          eth&#x2F;*&#x3D;5,p2p&#x3D;4)</p><h2 id="指标和统计数据"><a href="#指标和统计数据" class="headerlink" title="指标和统计数据"></a>指标和统计数据</h2><p>​    –ethstats value<br>​          Reporting URL of a ethstats service (nodename:secret@host:port)</p><p>​    –metrics                      (default: false)<br>​          Enable metrics collection and reporting</p><p>​    –metrics.addr value<br>​          Enable stand-alone metrics HTTP server listening interface.</p><p>​    –metrics.expensive            (default: false)<br>​          Enable expensive metrics collection and reporting</p><p>​    –metrics.influxdb             (default: false)<br>​          Enable metrics export&#x2F;push to an external InfluxDB database</p><p>​    –metrics.influxdb.bucket value (default: “geth”)<br>​          InfluxDB bucket name to push reported metrics to (v2 only)</p><p>​    –metrics.influxdb.database value (default: “geth”)<br>​          InfluxDB database name to push reported metrics to</p><p>​    –metrics.influxdb.endpoint value (default: “<a href="http://localhost:8086/">http://localhost:8086</a>“)<br>​          InfluxDB API endpoint to report metrics to</p><p>​    –metrics.influxdb.organization value (default: “geth”)<br>​          InfluxDB organization name (v2 only)</p><p>​    –metrics.influxdb.password value (default: “test”)<br>​          Password to authorize access to the database</p><p>​    –metrics.influxdb.tags value  (default: “host&#x3D;localhost”)<br>​          Comma-separated InfluxDB tags (key&#x2F;values) attached to all measurements</p><p>​    –metrics.influxdb.token value (default: “test”)<br>​          Token to authorize access to the database (v2 only)</p><p>​    –metrics.influxdb.username value (default: “test”)<br>​          Username to authorize access to the database</p><p>​    –metrics.influxdbv2           (default: false)<br>​          Enable metrics export&#x2F;push to an external InfluxDB v2 database</p><p>​    –metrics.port value           (default: 6060)<br>​          Metrics HTTP server listening port.<br>​          Please note that –metrics.addr must be set<br>​          to start the server.</p><h2 id="矿工"><a href="#矿工" class="headerlink" title="矿工"></a>矿工</h2><p>​    –mine                         (default: false)<br>​          Enable mining</p><p>​    –miner.etherbase value<br>​          0x prefixed public address for block mining rewards</p><p>​    –miner.extradata value<br>​          Block extra data set by the miner (default &#x3D; client version)</p><p>​    –miner.gaslimit value         (default: 30000000)<br>​          Target gas ceiling for mined blocks</p><p>​    –miner.gasprice value         (default: 0)<br>​          Minimum gas price for mining a transaction</p><p>​    –miner.newpayload-timeout value (default: 2s)<br>​          Specify the maximum time allowance for creating a new payload</p><p>​    –miner.recommit value         (default: 2s)<br>​          Time interval to recreate the block being mined</p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><p>​    –help, -h                     (default: false)<br>​          show help</p><p>​    –synctarget value<br>​          File for containing the hex-encoded block-rlp as sync target(dev feature)</p><p>​    –version, -v                  (default: false)<br>​          print the version</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>​    –bootnodes value<br>​          Comma separated enode URLs for P2P discovery bootstrap</p><p>​    –discovery.dns value<br>​          Sets DNS discovery entry points (use “” to disable DNS)</p><p>​    –discovery.port value         (default: 30303)<br>​          Use a custom UDP port for P2P discovery</p><p>​    –identity value<br>​          Custom node name</p><p>​    –maxpeers value               (default: 50)<br>​          Maximum number of network peers (network disabled if set to 0)</p><p>​    –maxpendpeers value           (default: 0)<br>​          Maximum number of pending connection attempts (defaults used if set to 0)</p><p>​    –nat value                    (default: “any”)<br>​          NAT port mapping mechanism (any|none|upnp|pmp|pmp:<IP>|extip:<IP>)</p><p>​    –netrestrict value<br>​          Restricts network communication to the given IP networks (CIDR masks)</p><p>​    –nodekey value<br>​          P2P node key file</p><p>​    –nodekeyhex value<br>​          P2P node key as hex (for testing)</p><p>​    –nodiscover                   (default: false)<br>​          Disables the peer discovery mechanism (manual peer addition)</p><p>​    –port value                   (default: 30303)<br>​          Network listening port</p><p>​    –v5disc                       (default: false)<br>​          Enables the experimental RLPx V5 (Topic Discovery) mechanism</p><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><p>​    –cache value                  (default: 1024)<br>​          Megabytes of memory allocated to internal caching (default &#x3D; 4096 mainnet full<br>​          node, 128 light mode)</p><p>​    –cache.blocklogs value        (default: 32)<br>​          Size (in number of blocks) of the log cache for filtering</p><p>​    –cache.database value         (default: 50)<br>​          Percentage of cache memory allowance to use for database io</p><p>​    –cache.gc value               (default: 25)<br>​          Percentage of cache memory allowance to use for trie pruning (default &#x3D; 25% full<br>​          mode, 0% archive mode)</p><p>​    –cache.noprefetch             (default: false)<br>​          Disable heuristic state prefetch during block import (less CPU and disk IO, more<br>​          time waiting for data)</p><p>​    –cache.preimages              (default: false)<br>​          Enable recording the SHA3&#x2F;keccak preimages of trie keys</p><p>​    –cache.snapshot value         (default: 10)<br>​          Percentage of cache memory allowance to use for snapshot caching (default &#x3D; 10%<br>​          full mode, 20% archive mode)</p><p>​    –cache.trie value             (default: 15)<br>​          Percentage of cache memory allowance to use for trie caching (default &#x3D; 15% full<br>​          mode, 30% archive mode)</p><p>​    –cache.trie.journal value     (default: “triecache”)<br>​          Disk journal directory for trie cache to survive node restarts</p><p>​    –cache.trie.rejournal value   (default: 1h0m0s)<br>​          Time interval to regenerate the trie cache journal</p><p>​    –fdlimit value                (default: 0)<br>​          Raise the open file descriptor resource limit (default &#x3D; system fd limit)</p><h2 id="交易池"><a href="#交易池" class="headerlink" title="交易池"></a>交易池</h2><p>​    –txpool.accountqueue value    (default: 64)<br>​          Maximum number of non-executable transaction slots permitted per account</p><p>​    –txpool.accountslots value    (default: 16)<br>​          Minimum number of executable transaction slots guaranteed per account</p><p>​    –txpool.globalqueue value     (default: 1024)<br>​          Maximum number of non-executable transaction slots for all accounts</p><p>​    –txpool.globalslots value     (default: 5120)<br>​          Maximum number of executable transaction slots for all accounts</p><p>​    –txpool.journal value         (default: “transactions.rlp”)<br>​          Disk journal for local transaction to survive node restarts</p><p>​    –txpool.lifetime value        (default: 3h0m0s)<br>​          Maximum amount of time non-executable transaction are queued</p><p>​    –txpool.locals value<br>​          Comma separated accounts to treat as locals (no flush, priority inclusion)</p><p>​    –txpool.nolocals              (default: false)<br>​          Disables price exemptions for locally submitted transactions</p><p>​    –txpool.pricebump value       (default: 10)<br>​          Price bump percentage to replace an already existing transaction</p><p>​    –txpool.pricelimit value      (default: 1)<br>​          Minimum gas price limit to enforce for acceptance into the pool</p><p>​    –txpool.rejournal value       (default: 1h0m0s)<br>​          Time interval to regenerate the local transaction journal</p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>​    –vmdebug                      (default: false)<br>​          Record information useful for VM and contract debugging</p>]]></content>
      
      
      <categories>
          
          <category> Geth </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Geth </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome to Yao Qi&#39;s personal blog！</title>
      <link href="/2023/10/27/Home/"/>
      <url>/2023/10/27/Home/</url>
      
        <content type="html"><![CDATA[<p>开通博客是为了能够记录一下自己每一阶段的学习，分享一下自己的收获，也便于好复习。在本博客中，有很大一部分是自己在学习中总结的一些知识内容，还有一些结合其它优秀的文章来进行输出。由于本人学历尚浅，有些地方见解可能不够，还望各位道友多多指教。最后，希望看我博客的小伙伴们大家可以一起成长，生活不易，让我们一起 Fighting !</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Typora快捷键</title>
      <link href="/2023/10/22/%E5%85%B6%E4%BB%96/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2023/10/22/%E5%85%B6%E4%BB%96/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>Ctrl + 1~6(最多六级标题)</p><h1 id="引用（Ctrl-shift-Q）"><a href="#引用（Ctrl-shift-Q）" class="headerlink" title="引用（Ctrl+shift+Q）"></a>引用（Ctrl+shift+Q）</h1><blockquote><p>或者（&gt;+空格）</p></blockquote><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>增加缩进（Ctrl+]），减少缩进(Ctrl+[)</p><ul><li><p>无序列表（Ctrl+shift+]）</p><ul><li>子列表（Tab）</li></ul></li><li><p>回到上一层（shift+Tab）</p></li></ul><ol><li>有序列表（Ctrl+shift+[）<ol><li>子列表（Tab）</li></ol></li><li>回到上一层（shift+Tab）</li></ol><h1 id="链接-Ctrl-K"><a href="#链接-Ctrl-K" class="headerlink" title="链接(Ctrl+K)"></a>链接(Ctrl+K)</h1><p><a href="www.baidu.com">百度一下你就知道</a>—–右键点击打开</p><h1 id="图片-ctrl-shift-i"><a href="#图片-ctrl-shift-i" class="headerlink" title="图片(ctrl+shift+i)"></a>图片(ctrl+shift+i)</h1><p>直接拖动（复制粘贴）到指定位置即可</p><h1 id="高亮（-内容-）"><a href="#高亮（-内容-）" class="headerlink" title="高亮（&#x3D;&#x3D; 内容 &#x3D;&#x3D;）"></a>高亮（&#x3D;&#x3D; 内容 &#x3D;&#x3D;）</h1><p>&#x3D;&#x3D;高亮显示&#x3D;&#x3D;</p><h1 id="划重点"><a href="#划重点" class="headerlink" title="划重点"></a>划重点</h1><p>1.加粗： Ctrl+B：<strong>加粗</strong></p><p> 2.代码：Ctrl+shift+&#96;</p><p> 3.删除线： Alt+shift+5:<del>这是删除线</del></p><p> 4.斜体： Ctrl+I:<em>这就是斜体</em></p><p> 5.下划线：Ctrl+U: <u>这就是下划线</u></p><h1 id="表格（Ctrl-T）"><a href="#表格（Ctrl-T）" class="headerlink" title="表格（Ctrl+T）"></a>表格（Ctrl+T）</h1><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h1 id="代码块（Ctrl-Shift-k）"><a href="#代码块（Ctrl-Shift-k）" class="headerlink" title="代码块（Ctrl+Shift+k）"></a>代码块（Ctrl+Shift+k）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内容</span><br></pre></td></tr></table></figure><h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><p>当前行句（Ctrl+L）、当前格式文本（Ctrl+E）、当前词（Ctrl+D）</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法面经</title>
      <link href="/2023/10/08/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F/"/>
      <url>/2023/10/08/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="口撕链表是否有环"><a href="#口撕链表是否有环" class="headerlink" title="口撕链表是否有环"></a>口撕链表是否有环</h3><p>给 2 个指针，一个指针是另外一个指针的下一个指针。快指针一次走 2 格，慢指针一次走 1 格。如果存在环，那么前一个指针一定会经过若干圈之后追上慢的指针。</p><h3 id="堆排序、快速排序的时间复杂度以及分别适用什么场景"><a href="#堆排序、快速排序的时间复杂度以及分别适用什么场景" class="headerlink" title="堆排序、快速排序的时间复杂度以及分别适用什么场景"></a>堆排序、快速排序的时间复杂度以及分别适用什么场景</h3><p>快排：时间复杂度：平均情况下为O(nlogn)，最坏情况下为O(n^2)，空间复杂度：O(logn)。快速排序在大多数情况下都表现出良好的性能，特别是对于大规模数据集。它是一种原地排序算法，需要额外的空间很少。</p><p>堆排：时间复杂度：始终为O(nlogn)，空间复杂度：O(1)。适用场景：堆排序适用于需要原地排序的情况，但相比于快速排序和归并排序，它的性能稍差。它对于大规模数据集的排序也相对较慢。</p><h3 id="手撕快排"><a href="#手撕快排" class="headerlink" title="手撕快排"></a>手撕快排</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用分治的思想，算法首先选择最后一个元素作为基准，并将数组划分为两部分。然后，它通过比较元素与基准的大小，将小于等于基准的元素交换到前面，大于基准的元素交换到后面。最后，递归地对划分的两部分进行排序。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(arr []<span class="type">int</span>, low, high <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> low &lt; high &#123;</span><br><span class="line">        pivot := partition(arr, low, high)</span><br><span class="line">        QuickSort(arr, low, pivot<span class="number">-1</span>)</span><br><span class="line">        QuickSort(arr, pivot+<span class="number">1</span>, high)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(arr []<span class="type">int</span>, low, high <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    pivot := arr[high]</span><br><span class="line">    <span class="comment">//记录基准元素最后的位置</span></span><br><span class="line">    i := low - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j := low; j &lt; high; j++ &#123;</span><br><span class="line">        <span class="comment">//将小于等于基准的元素交换到前面</span></span><br><span class="line">        <span class="keyword">if</span> arr[j] &lt; pivot &#123;</span><br><span class="line">            i++</span><br><span class="line">            arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//大于基准的元素交换到后面</span></span><br><span class="line">    arr[i+<span class="number">1</span>], arr[high] = arr[high], arr[i+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(root *TreeNode, val <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;TreeNode&#123;Val: val&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> val &lt; root.Val &#123;</span><br><span class="line">root.Left = insert(root.Left, val)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root.Right = insert(root.Right, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉排序平衡树"><a href="#二叉排序平衡树" class="headerlink" title="二叉排序平衡树"></a>二叉排序平衡树</h3><p>是一种特殊的二叉排序树，它在插入和删除节点时会自动进行平衡操作，以保持树的平衡性，平衡因子是指节点的左子树高度减去右子树高度的值，其取值范围为-1、0、1，当插入或删除节点导致某个节点的平衡因子超出范围时，需要通过旋转操作来调整树的结构，使得树重新达到平衡状态。</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树的每个节点都被标记为红色或黑色，同时满足以下五个性质：</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL节点，空节点）是黑色。</li><li>如果一个节点是红色，则它的两个子节点都是黑色。</li><li>对于每个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的黑色节点。</li></ol><p>这些性质保证了红黑树的关键特性：从根节点到任意叶子节点的最长路径不超过最短路径的两倍，因此红黑树是近似平衡的。</p><h3 id="最小生成树（两个算法）"><a href="#最小生成树（两个算法）" class="headerlink" title="最小生成树（两个算法）"></a>最小生成树（两个算法）</h3><p>最小生成树（Minimum Spanning Tree，简称MST）是指在一个<strong>连通无向图中，找到一棵包含所有顶点且边权值之和最小的树。</strong>最小生成树常用于解决网络设计、电力传输、通信网络等问题。</p><p>常见的求解最小生成树的算法有Prim算法和Kruskal算法。</p><ol><li>Prim算法：<ul><li>选择一个起始顶点，将其加入最小生成树中。</li><li>从与最小生成树相邻的顶点中选择一个权值最小的边，将其加入最小生成树中。</li><li>重复上述步骤，直到最小生成树包含所有顶点。</li></ul></li><li>Kruskal算法：<ul><li>将图中的所有边按照权值从小到大排序。</li><li>依次选择权值最小的边，如果该边的两个顶点不在同一个连通分量中，则将该边加入最小生成树中，并合并这两个连通分量。</li><li>重复上述步骤，直到最小生成树包含所有顶点。</li></ul></li></ol><p>这两种算法都能够求解最小生成树，选择哪种算法取决于具体的应用场景和图的规模。</p><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>Dijkstra算法是一种用于求解单源最短路径的经典算法，它能够找到从起始顶点到图中所有其他顶点的最短路径。</p><p>以下是Dijkstra算法的基本步骤：</p><ol><li>创建一个距离数组dist[]，用于存储起始顶点到各个顶点的最短距离。初始时，将起始顶点的距离设为0，其他顶点的距离设为无穷大。</li><li>创建一个集合visited[]，用于记录已经确定最短路径的顶点。</li><li>重复以下步骤，直到visited[]包含所有顶点：<ul><li>从未访问的顶点中选择一个距离最小的顶点u，并将其加入visited[]中。</li><li>对于顶点u的每个邻接顶点v，如果通过顶点u到达顶点v的路径比当前记录的最短路径更短，则更新dist[v]的值为新的最短路径长度。</li></ul></li><li>最终，dist[]数组中存储的就是起始顶点到图中所有其他顶点的最短路径长度。</li></ol><p>Dijkstra算法的核心思想是通过不断选择距离最小的顶点来逐步确定最短路径，直到所有顶点都被确定。该算法适用于没有负权边的图。</p><p>需要注意的是，Dijkstra算法只能求解单源最短路径，即从一个起始顶点到其他所有顶点的最短路径。如果需要求解任意两个顶点之间的最短路径，则可以使用Floyd-Warshall算法或者Bellman-Ford算法。</p><h3 id="100桶酒，其中一桶有毒，一只实验老鼠喝了酒之后一小时有结果，问一小时之内最少几只老鼠可以试出毒酒。"><a href="#100桶酒，其中一桶有毒，一只实验老鼠喝了酒之后一小时有结果，问一小时之内最少几只老鼠可以试出毒酒。" class="headerlink" title="100桶酒，其中一桶有毒，一只实验老鼠喝了酒之后一小时有结果，问一小时之内最少几只老鼠可以试出毒酒。"></a>100桶酒，其中一桶有毒，一只实验老鼠喝了酒之后一小时有结果，问一小时之内最少几只老鼠可以试出毒酒。</h3><p>最少需要7只老鼠，100桶酒可以用7位二进制数表示（从0000000到1111111），7只老鼠编号，我们将每一只老鼠与二进制数的一位对应起来</p>]]></content>
      
      
      <categories>
          
          <category> 算法练习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法练习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2023/10/07/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2023/10/07/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡排序（Bubble-Sort）："><a href="#冒泡排序（Bubble-Sort）：" class="headerlink" title="冒泡排序（Bubble Sort）："></a>冒泡排序（Bubble Sort）：</h1><ul><li>时间复杂度：平均情况下为O(n^2)。</li><li>空间复杂度：O(1)。</li><li>适用场景：冒泡排序简单易实现，适用于小规模数据集的排序。但是它的性能较差，不适合大规模数据集。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入排序（Insertion-Sort）："><a href="#插入排序（Insertion-Sort）：" class="headerlink" title="插入排序（Insertion Sort）："></a>插入排序（Insertion Sort）：</h1><ul><li>时间复杂度：平均情况下为O(n^2)。</li><li>空间复杂度：O(1)。</li><li>适用场景：插入排序适用于小规模或基本有序的数据集。它对于部分有序的数据集表现良好，且是稳定的排序算法。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它通过构建有序序列，对于未排序的数据，在已排序序列中从后向前扫描，找到相应位置并插入。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertionSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        key := arr[i]</span><br><span class="line">        j := i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key &#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j]</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = key</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="选择排序（Selection-Sort）："><a href="#选择排序（Selection-Sort）：" class="headerlink" title="选择排序（Selection Sort）："></a>选择排序（Selection Sort）：</h1><ul><li>时间复杂度：始终为O(n^2)。</li><li>空间复杂度：O(1)。</li><li>适用场景：选择排序简单易实现，适用于小规模数据集的排序。但是它的性能较差，不适合大规模数据集。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次从未排序的部分中选择最小(或最大)的元素，并将其放到已排序部分的首部(或末尾)。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SelectionSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        minIdx := i</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[minIdx] &#123;</span><br><span class="line">                minIdx = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i], arr[minIdx] = arr[minIdx], arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序（Quick-Sort）："><a href="#快速排序（Quick-Sort）：" class="headerlink" title="快速排序（Quick Sort）："></a>快速排序（Quick Sort）：</h1><ul><li>时间复杂度：平均情况下为O(nlogn)，最坏情况下为O(n^2)。</li><li>空间复杂度：O(logn)。</li><li>适用场景：快速排序在大多数情况下都表现出良好的性能，特别是对于大规模数据集。它是一种原地排序算法，不需要额外的空间。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用分治的思想，算法首先选择最后一个元素作为基准，并将数组划分为两部分。然后，它通过比较元素与基准的大小，将小于等于基准的元素交换到前面，大于基准的元素交换到后面。最后，递归地对划分的两部分进行排序。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(arr []<span class="type">int</span>, low, high <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> low &lt; high &#123;</span><br><span class="line">        pivot := partition(arr, low, high)</span><br><span class="line">        QuickSort(arr, low, pivot<span class="number">-1</span>)</span><br><span class="line">        QuickSort(arr, pivot+<span class="number">1</span>, high)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(arr []<span class="type">int</span>, low, high <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    pivot := arr[high]</span><br><span class="line">    <span class="comment">//记录基准元素最后的位置</span></span><br><span class="line">    i := low - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j := low; j &lt; high; j++ &#123;</span><br><span class="line">        <span class="comment">//将小于等于基准的元素交换到前面</span></span><br><span class="line">        <span class="keyword">if</span> arr[j] &lt; pivot &#123;</span><br><span class="line">            i++</span><br><span class="line">            arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//大于基准的元素交换到后面</span></span><br><span class="line">    arr[i+<span class="number">1</span>], arr[high] = arr[high], arr[i+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序（Merge-Sort）："><a href="#归并排序（Merge-Sort）：" class="headerlink" title="归并排序（Merge Sort）："></a>归并排序（Merge Sort）：</h1><ul><li>时间复杂度：始终为O(nlogn)。</li><li>空间复杂度：O(n)。</li><li>适用场景：归并排序稳定且效率高，适用于各种规模的数据集。它需要额外的空间来存储临时数组，因此对于内存受限的环境可能不太适合。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//它采用分治的思想，算法首先将数组递归地分成两半，然后对这两个子数组进行排序。最后，它将两个有序的子数组合并成一个有序的数组。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergeSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数组分成两半</span></span><br><span class="line">    mid := <span class="built_in">len</span>(arr) / <span class="number">2</span></span><br><span class="line">    left := MergeSort(arr[:mid])</span><br><span class="line">    right := MergeSort(arr[mid:])</span><br><span class="line">    <span class="comment">// 合并两个有序的子数组</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    merged := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(left) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(right) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>] &#123;</span><br><span class="line">            merged = <span class="built_in">append</span>(merged, left[<span class="number">0</span>])</span><br><span class="line">            left = left[<span class="number">1</span>:]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            merged = <span class="built_in">append</span>(merged, right[<span class="number">0</span>])</span><br><span class="line">            right = right[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将剩余的元素添加到结果中</span></span><br><span class="line">    merged = <span class="built_in">append</span>(merged, left...)</span><br><span class="line">    merged = <span class="built_in">append</span>(merged, right...)</span><br><span class="line">    <span class="keyword">return</span> merged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序（Heap-Sort）："><a href="#堆排序（Heap-Sort）：" class="headerlink" title="堆排序（Heap Sort）："></a>堆排序（Heap Sort）：</h1><ul><li>时间复杂度：始终为O(nlogn)。</li><li>空间复杂度：O(1)。</li><li>适用场景：堆排序适用于需要原地排序的情况，但相比于快速排序和归并排序，它的性能稍差。它对于大规模数据集的排序也相对较慢。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一种基于二叉堆的排序算法，它利用了堆的性质来进行排序。堆是一种特殊的完全二叉树，其中每个节点的值都大于等于（或小于等于）其子节点的值。</span></span><br><span class="line"><span class="comment">//算法首先构建一个最大堆，然后逐个将堆顶元素移到数组末尾，并重新调整堆。最终得到的数组就是有序的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="comment">// 构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> i := n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逐个将堆顶元素移到数组末尾，并重新调整堆</span></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span><br><span class="line">        heapify(arr, i, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(arr []<span class="type">int</span>, n, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 结点</span></span><br><span class="line">    largest := i</span><br><span class="line">    left := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">    right := <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line">    <span class="comment">// 找到左子节点和右子节点中的最大值</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; n &amp;&amp; arr[left] &gt; arr[largest] &#123;</span><br><span class="line">        largest = left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> right &lt; n &amp;&amp; arr[right] &gt; arr[largest] &#123;</span><br><span class="line">        largest = right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果最大值不是当前节点，则交换并继续调整堆</span></span><br><span class="line">    <span class="keyword">if</span> largest != i &#123;</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计数排序（Counting-Sort）："><a href="#计数排序（Counting-Sort）：" class="headerlink" title="计数排序（Counting Sort）："></a>计数排序（Counting Sort）：</h1><ul><li>时间复杂度：O(n+k)，其中k是数据范围。</li><li>空间复杂度：O(n+k)。</li><li>适用场景：计数排序适用于数据范围较小且已知的情况。它是一种稳定的排序算法，但需要额外的空间来存储计数数组。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountingSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    max := findMax(arr)</span><br><span class="line">    count := <span class="built_in">make</span>([]<span class="type">int</span>, max+<span class="number">1</span>)</span><br><span class="line">    sorted := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(arr))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        count[num]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= max; i++ &#123;</span><br><span class="line">        count[i] += count[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(arr) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        num := arr[i]</span><br><span class="line">        index := count[num] - <span class="number">1</span></span><br><span class="line">        sorted[index] = num</span><br><span class="line">        count[num]--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(arr, sorted)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMax</span><span class="params">(arr []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    max := arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        <span class="keyword">if</span> num &gt; max &#123;</span><br><span class="line">            max = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基数排序（Radix-Sort）："><a href="#基数排序（Radix-Sort）：" class="headerlink" title="基数排序（Radix Sort）："></a>基数排序（Radix Sort）：</h1><ul><li>时间复杂度：O(d * (n + k))，其中d是最大数字的位数，n是待排序元素的数量，k是每个位可能的取值范围，可以简化为O(n * k)。</li><li>空间复杂度：O(n+k)。</li><li>适用场景：性能受到位数和取值范围的影响。当位数较大或者取值范围很大时，基数排序可能不适合使用。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">radixSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="comment">// 找到数组中的最大值</span></span><br><span class="line">    max := arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> arr[i] &gt; max &#123;</span><br><span class="line">            max = arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对每个位数进行计数排序</span></span><br><span class="line">    <span class="keyword">for</span> exp := <span class="number">1</span>; max/exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span> &#123;</span><br><span class="line">        countingSortByDigit(arr, n, exp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSortByDigit</span><span class="params">(arr []<span class="type">int</span>, n, exp <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    output := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    count := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="comment">// 初始化计数数组为0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        count[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计每个数字出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        digit := (arr[i] / exp) % <span class="number">10</span></span><br><span class="line">        count[digit]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算累加次数</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        count[i] += count[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据计数数组将元素放入输出数组中</span></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        digit := (arr[i] / exp) % <span class="number">10</span></span><br><span class="line">        output[count[digit]<span class="number">-1</span>] = arr[i]</span><br><span class="line">        count[digit]--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将输出数组复制到原始数组中</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        arr[i] = output[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="希尔排序（Shell-Sort）："><a href="#希尔排序（Shell-Sort）：" class="headerlink" title="希尔排序（Shell Sort）："></a>希尔排序（Shell Sort）：</h1><ul><li>时间复杂度：取决于增量序列的选择，最坏情况下为O(n^2)，最好情况下为O(nlogn)。</li><li>空间复杂度：O(1)。</li><li>适用场景：希尔排序适用于中等规模的数据集。它是一种不稳定的排序算法，但相比于插入排序和选择排序，它的性能更好。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确定初始的间隔（gap），然后根据间隔将数组分成多个子序列，对每个子序列进行插入排序。然后逐渐减小间隔，重复上述步骤，直到间隔为1时完成最后一次插入排序。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shellSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(arr)</span><br><span class="line">gap := n / <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> gap &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := gap; i &lt; n; i++ &#123;</span><br><span class="line">temp := arr[i]</span><br><span class="line">j := i</span><br><span class="line"><span class="keyword">for</span> j &gt;= gap &amp;&amp; arr[j-gap] &gt; temp &#123;</span><br><span class="line">arr[j] = arr[j-gap]</span><br><span class="line">j -= gap</span><br><span class="line">&#125;</span><br><span class="line">arr[j] = temp</span><br><span class="line">&#125;</span><br><span class="line">gap /= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法练习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法练习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-数学</title>
      <link href="/2023/10/01/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/8-%E6%95%B0%E5%AD%A6/"/>
      <url>/2023/10/01/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/8-%E6%95%B0%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Fizz-Buzz"><a href="#1-Fizz-Buzz" class="headerlink" title="1.Fizz Buzz"></a>1.Fizz Buzz</h1><p>给你一个整数 n ，找出从 1 到 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中：</p><p>answer[i] &#x3D;&#x3D; “FizzBuzz” 如果 i 同时是 3 和 5 的倍数。<br>answer[i] &#x3D;&#x3D; “Fizz” 如果 i 是 3 的倍数。<br>answer[i] &#x3D;&#x3D; “Buzz” 如果 i 是 5 的倍数。<br>answer[i] &#x3D;&#x3D; i （以字符串形式）如果上述条件全不满足。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>make一个string切片，遍历n，依次判断是否为15、3、5的倍数，否则为1</p><h1 id="2-计数质数"><a href="#2-计数质数" class="headerlink" title="2.计数质数"></a>2.计数质数</h1><p>给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。</p><h3 id="示例-："><a href="#示例-：" class="headerlink" title="示例 ："></a>示例 ：</h3><p>输入：n &#x3D; 10<br>输出：4<br>解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>埃拉托斯特尼筛法（Sieve of Eratosthenes）来生成质数列表，然后使用了 <code>sort.SearchInts(primes, n)</code> 函数在 <code>primes</code> 列表中查找最后一个小于等于 <code>n</code> 的质数的索引，然后返回这个索引加1，以计算质数的数量</p><h1 id="3-3的幂"><a href="#3-3的幂" class="headerlink" title="3.3的幂"></a>3.3的幂</h1><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。</p><p>整数 n 是 3 的幂次方需满足：存在整数 x 使得 n &#x3D;&#x3D; 3x</p><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n &gt; <span class="number">3</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">3</span> != <span class="number">0</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    n /= <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n == <span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="4-罗马数字转整数"><a href="#4-罗马数字转整数" class="headerlink" title="4.罗马数字转整数"></a>4.罗马数字转整数</h1><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</p><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><pre><code>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</code></pre><p>给定一个罗马数字，将其转换成整数。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例 :"></a>示例 :</h3><p>输入: s &#x3D; “III”<br>输出: 3</p><h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>设置一个保存前一个值，循环判断如果当前大于之前则-</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">byte2Int := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>&#123;<span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;L&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">500</span>, <span class="string">&#x27;M&#x27;</span>: <span class="number">1000</span>&#125;</span><br><span class="line">result := <span class="number">0</span></span><br><span class="line">prev := <span class="number">0</span> <span class="comment">// 用于存储前一个字符的值</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(s) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">    cur := byte2Int[s[i]]</span><br><span class="line">    <span class="keyword">if</span> cur &lt; prev &#123;</span><br><span class="line">        result -= cur <span class="comment">// 当前字符小于前一个字符时，减去当前字符的值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result += cur <span class="comment">// 否则加上当前字符的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    prev = cur <span class="comment">// 更新前一个字符的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 初级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法练习笔记 </tag>
            
            <tag> 初级算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-设计问题</title>
      <link href="/2023/09/25/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/7-%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98/"/>
      <url>/2023/09/25/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/7-%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-打乱数组"><a href="#1-打乱数组" class="headerlink" title="1.打乱数组"></a>1.打乱数组</h1><p>给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 等可能 的。</p><p>实现 Solution class:</p><pre><code>Solution(int[] nums) 使用整数数组 nums 初始化对象int[] reset() 重设数组到它的初始状态并返回int[] shuffle() 返回数组随机打乱后的结果</code></pre><h3 id="示例-："><a href="#示例-：" class="headerlink" title="示例 ："></a>示例 ：</h3><p>输入<br>[“Solution”, “shuffle”, “reset”, “shuffle”]<br>[[[1, 2, 3]], [], [], []]<br>输出<br>[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]</p><p>解释<br>Solution solution &#x3D; new Solution([1, 2, 3]);<br>solution.shuffle();    &#x2F;&#x2F; 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]<br>solution.reset();      &#x2F;&#x2F; 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]<br>solution.shuffle();    &#x2F;&#x2F; 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]</p><h1 id="2-最小栈"><a href="#2-最小栈" class="headerlink" title="2.最小栈"></a>2.最小栈</h1><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 MinStack 类:</p><pre><code>MinStack() 初始化堆栈对象。void push(int val) 将元素val推入堆栈。void pop() 删除堆栈顶部的元素。int top() 获取堆栈顶部的元素。int getMin() 获取堆栈中的最小元素。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例 :"></a>示例 :</h3><p>输入：<br>[“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]</p><p>输出：<br>[null,null,null,null,-3,null,0,-2]</p><p>解释：<br>MinStack minStack &#x3D; new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p>]]></content>
      
      
      <categories>
          
          <category> 初级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法练习笔记 </tag>
            
            <tag> 初级算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-动态规划</title>
      <link href="/2023/09/23/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/6-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2023/09/23/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/6-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="1-爬楼梯"><a href="#1-爬楼梯" class="headerlink" title="1.爬楼梯"></a>1.爬楼梯</h1><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">    dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h1 id="2-买卖股票的最佳时机"><a href="#2-买卖股票的最佳时机" class="headerlink" title="2.买卖股票的最佳时机"></a>2.买卖股票的最佳时机</h1><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><h3 id="示例-："><a href="#示例-：" class="headerlink" title="示例 ："></a>示例 ：</h3><p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>             注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格</p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">min, maxProfit := prices[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> prices[i]-min &gt; maxProfit &#123;</span><br><span class="line">        maxProfit = prices[i] - min</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> prices[i] &lt; min &#123;</span><br><span class="line">        min = prices[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxProfit</span><br></pre></td></tr></table></figure><h1 id="3-最大子序和"><a href="#3-最大子序和" class="headerlink" title="3.最大子序和"></a>3.最大子序和</h1><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组 是数组中的一个连续部分。</p><h3 id="示例-：-1"><a href="#示例-：-1" class="headerlink" title="示例 ："></a>示例 ：</h3><p>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dp, res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums)), nums[<span class="number">0</span>]</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> dp[i<span class="number">-1</span>] &gt; <span class="number">0</span> &#123;</span><br><span class="line">        dp[i] = nums[i] + dp[i<span class="number">-1</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i] = nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    res = max(res, dp[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><code>dp[i]</code> 表示 <code>[0,i]</code> 区间内各个子区间和的最大值，状态转移方程是 <code>dp[i] = nums[i] + dp[i-1] (dp[i-1] &gt; 0)</code>，<code>dp[i] = nums[i] (dp[i-1] ≤ 0)</code>。</p><h1 id="4-打家劫舍"><a href="#4-打家劫舍" class="headerlink" title="4.打家劫舍"></a>4.打家劫舍</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><h3 id="示例-：-2"><a href="#示例-：-2" class="headerlink" title="示例 ："></a>示例 ：</h3><p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p><h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">dp[<span class="number">0</span>], dp[<span class="number">1</span>] = nums[<span class="number">0</span>], max(nums[<span class="number">1</span>], nums[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">2</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">    dp[i] = max(dp[i<span class="number">-1</span>], nums[i]+dp[i<span class="number">-2</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">curMax, preMax := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">    tmp := curMax</span><br><span class="line">    curMax = max(curMax, nums[i]+preMax)</span><br><span class="line">    preMax = tmp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> curMax</span><br></pre></td></tr></table></figure><p>DP 的状态定义是：<code>dp[i]</code> 代表抢 <code>nums[0,i]</code> 这个区间内房子的最大值，状态转移方程是 <code>dp[i] = max(dp[i-1], nums[i]+dp[i-2])</code>  。可以优化迭代的过程，用两个临时变量来存储中间结果，以节约辅助空间。</p>]]></content>
      
      
      <categories>
          
          <category> 初级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法练习笔记 </tag>
            
            <tag> 初级算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-树</title>
      <link href="/2023/09/20/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/4-%E6%A0%91/"/>
      <url>/2023/09/20/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/4-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="1-二叉树的最大深度"><a href="#1-二叉树的最大深度" class="headerlink" title="1.二叉树的最大深度"></a>1.二叉树的最大深度</h1><p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>给定二叉树 [3,9,20,null,null,15,7]，</p><p>​3</p><p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7</p><p>返回它的最大深度 3 。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>递归遍历就可，遍历根节点的左孩子的高度和根节点右孩子的高度，取出两者的最大值再加一即为总高度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> max(maxDepth(root.Left), maxDepth(root.Right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="2-验证二叉搜索树"><a href="#2-验证二叉搜索树" class="headerlink" title="2.验证二叉搜索树"></a>2.验证二叉搜索树</h1><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><h3 id="示例-："><a href="#示例-：" class="headerlink" title="示例 ："></a>示例 ：</h3><p>输入：root &#x3D; [2,1,3]<br>输出：true</p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidbst</span><span class="params">(root *TreeNode, min, max <span class="type">float64</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">v := <span class="type">float64</span>(root.Val)</span><br><span class="line"><span class="keyword">return</span> v &lt; max &amp;&amp; v &gt; min &amp;&amp; isValidbst(root.Left, min, v) &amp;&amp; isValidbst(root.Right, v, max)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二：中序遍历到数组，看数组是否有序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inOrder</span><span class="params">(root *TreeNode, arr *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">inOrder(root.Left, arr)</span><br><span class="line">*arr = <span class="built_in">append</span>(*arr, root.Val)</span><br><span class="line">inOrder(root.Right, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-对称二叉树"><a href="#3-对称二叉树" class="headerlink" title="3.对称二叉树"></a>3.对称二叉树</h1><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><p><img src="/noteimg/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/img/image-20230612192528623.png" alt="image-20230612192528623"> </p><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMirror</span><span class="params">(left *TreeNode, right *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> left == <span class="literal">nil</span> &amp;&amp; right == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> left == <span class="literal">nil</span> || right == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (left.Val == right.Val) &amp;&amp; isMirror(left.Left, right.Right) &amp;&amp; isMirror(left.Right, right.Left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-二叉树的层序遍历"><a href="#4-二叉树的层序遍历" class="headerlink" title="4.二叉树的层序遍历"></a>4.二叉树的层序遍历</h1><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）</p><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><p><img src="/noteimg/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/img/image-20230612193627829.png" alt="image-20230612193627829"> </p><p>输出：[[3],[9,20],[15,7]]</p><h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder1</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> dfsLevel <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, level <span class="type">int</span>)</span></span></span><br><span class="line">dfsLevel = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, level <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(res) == level &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, []<span class="type">int</span>&#123;node.Val&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res[level] = <span class="built_in">append</span>(res[level], node.Val)</span><br><span class="line">&#125;</span><br><span class="line">dfsLevel(node.Left, level+<span class="number">1</span>)</span><br><span class="line">dfsLevel(node.Right, level+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">dfsLevel(root, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-将有序数组转换为二叉搜索树"><a href="#5-将有序数组转换为二叉搜索树" class="headerlink" title="5.将有序数组转换为二叉搜索树"></a>5.将有序数组转换为二叉搜索树</h1><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><p><img src="/noteimg/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/img/image-20230612200628809.png" alt="image-20230612200628809"> </p><h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedArrayToBST</span><span class="params">(nums []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;TreeNode&#123;Val: nums[<span class="built_in">len</span>(nums)/<span class="number">2</span>], Left: sortedArrayToBST(nums[:<span class="built_in">len</span>(nums)/<span class="number">2</span>]), Right: sortedArrayToBST(nums[<span class="built_in">len</span>(nums)/<span class="number">2</span>+<span class="number">1</span>:])&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 初级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法练习笔记 </tag>
            
            <tag> 初级算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-排序和搜索</title>
      <link href="/2023/09/20/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/5-%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/"/>
      <url>/2023/09/20/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/5-%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-合并两个有序数组"><a href="#1-合并两个有序数组" class="headerlink" title="1.合并两个有序数组"></a>1.合并两个有序数组</h1><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3<br>输出：[1,2,2,3,5,6]<br>解释：需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>双指针法：<img src="C:\Users\zhuba\Desktop\PersonalBlog\source_posts\算法练习笔记\初级算法\img\image-20231011102419326.png" alt="image-20231011102419326"></p><h1 id="2-第一个错误的版本"><a href="#2-第一个错误的版本" class="headerlink" title="2.第一个错误的版本"></a>2.第一个错误的版本</h1><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><h3 id="示例-："><a href="#示例-：" class="headerlink" title="示例 ："></a>示例 ：</h3><p>输入：n &#x3D; 5, bad &#x3D; 4<br>输出：4<br>解释：<br>调用 isBadVersion(3) -&gt; false<br>调用 isBadVersion(5) -&gt; true<br>调用 isBadVersion(4) -&gt; true<br>所以，4 是第一个错误的版本。</p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>二分查找</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">left := <span class="number">1</span></span><br><span class="line">right := n</span><br><span class="line"><span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">    mid := (right+left)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> isBadVersion(mid) &#123;</span><br><span class="line">        right = mid</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 初级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法练习笔记 </tag>
            
            <tag> 初级算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3_链表</title>
      <link href="/2023/09/16/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/3_%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/09/16/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/3_%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-删除链表中的节点"><a href="#1-删除链表中的节点" class="headerlink" title="1.删除链表中的节点"></a>1.删除链表中的节点</h1><p>有一个单链表的 head，我们想删除它其中的一个节点 node。</p><p>给你一个需要删除的节点 node 。你将无法访问 第一个节点  head。</p><p>链表的所有值都是唯一的，并且保证给定的节点 node 不是链表中的最后一个节点。</p><h3 id="示例-："><a href="#示例-：" class="headerlink" title="示例 ："></a>示例 ：</h3><p>输入：head &#x3D; [4,5,1,9], node &#x3D; 5<br>输出：[4,1,9]<br>解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(node *ListNode)</span></span> &#123;</span><br><span class="line">   node.Val = node.Next.Val</span><br><span class="line">   node.Next = node.Next.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-删除链表的倒数第N个节点"><a href="#2-删除链表的倒数第N个节点" class="headerlink" title="2.删除链表的倒数第N个节点"></a>2.删除链表的倒数第N个节点</h1><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><h3 id="示例-：-1"><a href="#示例-：-1" class="headerlink" title="示例 ："></a><strong>示例 ：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>这道题有一种特别简单的解法。设置 2 个指针，一个指针距离前一个指针 n 个距离。同时移动 2 个指针，2 个指针都移动相同的距离。当一个指针移动到了终点，那么前一个指针就是倒数第 n 个节点了。</p><p><img src="/noteimg/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/img/image-20230529204356720.png" alt="image-20230529204356720"> </p><h1 id="3-反转链表"><a href="#3-反转链表" class="headerlink" title="3.反转链表"></a>3.反转链表</h1><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p><img src="/noteimg/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/img/image-20230529210325406.png" alt="image-20230529210325406"> </p><h1 id="4-合并两个有序链表"><a href="#4-合并两个有序链表" class="headerlink" title="4.合并两个有序链表"></a>4.合并两个有序链表</h1><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line"><span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> l2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> l1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l1.Val &lt; l2.Val &#123;</span><br><span class="line">l1.Next = mergeTwoLists(l1.Next, l2)</span><br><span class="line"><span class="keyword">return</span> l1</span><br><span class="line">&#125;</span><br><span class="line">l2.Next = mergeTwoLists(l1, l2.Next)</span><br><span class="line"><span class="keyword">return</span> l2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-回文链表"><a href="#5-回文链表" class="headerlink" title="5.回文链表"></a>5.回文链表</h1><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><p>循环链表逐一添加到slice中，循环i, j :&#x3D; 0, len(slice)-1; i &lt; j;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if slice[i] != slice[j] &#123;</span><br><span class="line">   return false</span><br><span class="line">&#125;</span><br><span class="line">i++</span><br><span class="line">j--</span><br></pre></td></tr></table></figure><h1 id="6-环形链表"><a href="#6-环形链表" class="headerlink" title="6.环形链表"></a>6.环形链表</h1><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><p>给 2 个指针，一个指针是另外一个指针的下一个指针。快指针一次走 2 格，慢指针一次走 1 格。如果存在环，那么前一个指针一定会经过若干圈之后追上慢的指针。</p>]]></content>
      
      
      <categories>
          
          <category> 初级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法练习笔记 </tag>
            
            <tag> 初级算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2_字符串</title>
      <link href="/2023/09/10/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/2_%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/09/10/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/2_%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-反转字符串"><a href="#1-反转字符串" class="headerlink" title="1.反转字符串"></a>1.反转字符串</h1><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>输入：s &#x3D; [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p><img src="/noteimg/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/img/image-20230519210434968.png" alt="image-20230519210434968"> </p><h1 id="2-整数反转"><a href="#2-整数反转" class="headerlink" title="2.整数反转"></a>2.整数反转</h1><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。<br>假设环境不允许存储 64 位整数（有符号或无符号）</p><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><p>输入：x &#x3D; 123     输出：321</p><p>输入：x &#x3D; -123输出：-321</p><p>输入：x &#x3D; 120输出：21</p><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p><img src="/noteimg/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/img/image-20230519212155045.png" alt="image-20230519212155045">设置一个变量tmp:&#x3D;0,for循环x!&#x3D;0，然后执行tmp&#x3D;tmp*10+x%10,x&#x2F;&#x3D;10,最后判断是否有效</p><h1 id="3-字符串中的第一个唯一字符"><a href="#3-字符串中的第一个唯一字符" class="headerlink" title="3.字符串中的第一个唯一字符"></a>3.字符串中的第一个唯一字符</h1><p>给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。</p><h4 id="示例-："><a href="#示例-：" class="headerlink" title="示例 ："></a>示例 ：</h4><p>输入: s &#x3D; “leetcode” 输出: 0</p><p>输入: s &#x3D; “loveleetcode” 输出: 2</p><p>输入: s &#x3D; “aabb” 输出: -1</p><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>定义一个make([]int,26),循环字符串–&gt;result[s[i]-‘a’]++，最后再循环一边–&gt;值为1，返回i</p><h1 id="4-有效的字母异位词"><a href="#4-有效的字母异位词" class="headerlink" title="4.有效的字母异位词"></a>4.有效的字母异位词</h1><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例 :"></a>示例 :</h4><p>输入: s &#x3D; “anagram”, t &#x3D; “nagaram”输出: true</p><p>输入: s &#x3D; “rat”, t &#x3D; “car”输出: false</p><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><p><img src="/noteimg/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/img/image-20230519214607609.png" alt="image-20230519214607609"> </p><h1 id="5-验证回文串"><a href="#5-验证回文串" class="headerlink" title="5.验证回文串"></a>5.验证回文串</h1><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。字母和数字都属于字母数字字符。给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。</p><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><p>输入: s &#x3D; “A man, a plan, a canal: Panama”<br>输出：true<br>解释：”amanaplanacanalpanama” 是回文串。</p><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><p>通过strings.ToLower(s)将字符串变为小写，定义 i,j:&#x3D;0,len(s)-1 ，for i &lt; j 然后判断s[i]或者s[j]是否为字母数字字符，若不是啧i++或j++，判断s[i] !&#x3D; s[j]返回false，最后返回true</p><h1 id="6-字符串转换整数"><a href="#6-字符串转换整数" class="headerlink" title="6.字符串转换整数"></a>6.字符串转换整数</h1><p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 atoi 函数）。</p><p>函数 myAtoi(string s) 的算法如下：</p><pre><code>读入字符串并丢弃无用的前导空格检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。将前面步骤读入的这些数字转换为整数（即，&quot;123&quot; -&gt; 123， &quot;0032&quot; -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。返回整数作为最终结果。</code></pre><p>注意：</p><pre><code>本题中的空白字符只包括空格字符 &#39; &#39; 。除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</code></pre><h4 id="示例-：-1"><a href="#示例-：-1" class="headerlink" title="示例 ："></a>示例 ：</h4><p>输入：s &#x3D; “42”输出：42</p><p>输入：s &#x3D; “   -42”输出：-42</p><p>输入：s &#x3D; “4193 with words”输出：4193</p><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><p><img src="/noteimg/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/img/image-20230526170706326.png" alt="image-20230526170706326"> </p><h1 id="7-实现-strStr"><a href="#7-实现-strStr" class="headerlink" title="7.实现 strStr()"></a>7.实现 strStr()</h1><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p><h4 id="示例-：-2"><a href="#示例-：-2" class="headerlink" title="示例 ："></a>示例 ：</h4><p>输入：haystack &#x3D; “sadbutsad”, needle &#x3D; “sad”<br>输出：0<br>解释：”sad” 在下标 0 和 6 处匹配。<br>第一个匹配项的下标是 0 ，所以返回 0 。</p><h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><p>双层循环，逐一比较，当j &#x3D;&#x3D; len(needle) –&gt; return i</p><h1 id="8-外观数列"><a href="#8-外观数列" class="headerlink" title="8.外观数列"></a>8.外观数列</h1><h1 id="9-最长公共前缀"><a href="#9-最长公共前缀" class="headerlink" title="9.最长公共前缀"></a>9.最长公共前缀</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。</p><h4 id="示例-：-3"><a href="#示例-：-3" class="headerlink" title="示例 ："></a>示例 ：</h4><p>输入：strs &#x3D; [“flower”,”flow”,”flight”]输出：”fl”</p><h4 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h4>]]></content>
      
      
      <categories>
          
          <category> 初级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法练习笔记 </tag>
            
            <tag> 初级算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-9-9</title>
      <link href="/2023/09/05/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-9-9/"/>
      <url>/2023/09/05/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-9-9/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun（Cancun-Deneb）升级"><a href="#Dencun（Cancun-Deneb）升级" class="headerlink" title="Dencun（Cancun + Deneb）升级"></a>Dencun（Cancun + Deneb）升级</h2><ul><li><p>最新的所有核心开发人员 - 执行 (ACDE)视频会议。Christine Kim的记录：</p><ul><li>在 devnet-8 上继续测试</li><li>计划于 9 月 19 日星期二进行 devnet-9</li><li>EIP4844 每个区块的 blob：<a href="https://docs.google.com/presentation/d/1glx__evliifIRyS3GnbzADd0rVPV4CFPh92INEsRdX8">大区块分析</a> 报告，目前没有对 3&#x2F;6（目标值&#x2F;最大值）做任何更改</li><li>提议添加到 Dencun（开放给社区输入）：<a href="https://twitter.com/philngo_/status/1699805844748030383">最大epoch churn 限制</a>作为验证者集大小增长的短期修复，ACDE 上讨论是否包含在 Dencun 中<br>​</li></ul></li></ul><h2 id="中心化观察：威胁你-ETH-的价值"><a href="#中心化观察：威胁你-ETH-的价值" class="headerlink" title="中心化观察：威胁你 ETH 的价值"></a>中心化观察：威胁你 ETH 的价值</h2><ul><li><p>🚨 <a href="https://dune.com/hildobby/eth2-staking">Lido 达到 32.4%</a>非常接近危险的<a href="https://notes.ethereum.org/@djrtwo/risks-of-lsd">33%阈值</a></p></li><li><p>客户端多样性（通过clientdiversity.org）：</p><ul><li>执行层：Geth 超过半数，可能导致链分叉</li><li>共识层：Prysm 和 Lighthouse 超过 33%，一个错误可能导致丧失活性(liveness)</li></ul></li><li><p>需要更多的<a href="https://nodewatch.io/">地理多样性，包括质押者和节点</a>，特别是在美国&#x2F;加拿大&#x2F;欧盟之外<br>​</p></li></ul><h2 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h2><ul><li><a href="https://github.com/flashbots/mempool-dumpster#readme">Mempool Dumpster</a>：以 Parquet 和 CSV 格式导出 EL 节点交易池中的交易</li><li>MEV-Boost：<ul><li><a href="https://ethresear.ch/t/strong-builder-identity-for-combating-builder-imposter-attacks/16550">增强构建者身份</a>：提议用于对抗冒名顶替攻击（Titan 曾有冒名顶替者）</li><li>Prestwich：<a href="https://prestwich.substack.com/p/has-anyone-checked-on-eip-1559-recently">提议者和构建者可能串通</a>，限制gas以最小化基础费用（base fee）</li></ul></li><li><a href="https://twitter.com/dapplion/status/1700222295719952534">Whisk devnet</a>：在 Lighthouse + Geth 的分叉上进行概念验证的单一秘密领导者选举（SSLE）<br>​</li></ul><h2 id="给质押者"><a href="#给质押者" class="headerlink" title="给质押者"></a>给质押者</h2><ul><li><a href="https://twitter.com/stakedirectory/status/1699346477598843269">质押大全站点（Staking directory）</a>：添加了关于网络共享和自我限制质押的信息<br>​</li></ul><h2 id="Holesky-测试网的客户端发布"><a href="#Holesky-测试网的客户端发布" class="headerlink" title="Holešky 测试网的客户端发布"></a>Holešky 测试网的客户端发布</h2><ul><li><p>共识层：</p><ul><li>Lighthouse <a href="https://github.com/sigp/lighthouse/releases/tag/v4.4.1">v4.4.1</a></li><li>Lodestar <a href="https://github.com/ChainSafe/lodestar/releases/tag/v1.11.1">v1.11.1</a></li><li>Teku <a href="https://github.com/Consensys/teku/releases/tag/23.9.0">v23.9.0</a></li></ul></li><li><p>执行层：</p><ul><li><p>Besu <a href="https://github.com/hyperledger/besu/releases/tag/23.7.2">v23.7.2</a></p></li><li><p>Erigon v2.49.0</p><ul><li>Otterscan <a href="https://github.com/otterscan/otterscan/releases/tag/v2.0.0">v2.0.0 alpha</a>：添加了节点内的token索引器</li></ul></li></ul><p>​</p></li></ul><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><ul><li>Terence 的<a href="https://hackmd.io/@ttsao/ByhnIFXR2">EIP4844+</a>（Dencun 升级后扩展 blob 的想法）：擦除代码以增加目标&#x2F;最大 blob 数为 6&#x2F;12，并应用数据可用性抽样</li><li><a href="https://ethresear.ch/t/peerdas-a-simpler-das-approach-using-battle-tested-p2p-components/16541">PeerDAS</a>：重用 P2P 组件的数据可用性抽样方法，以实现无需 DHT 的扩展</li><li>Barnabe：<a href="https://ethresear.ch/t/fun-and-games-with-inclusion-lists/16557">包含列表游戏</a>，建设者可能会被激励填充区块，提议者可能会试图贿赂&#x2F;勒索对方</li></ul><h2 id="Layer2"><a href="#Layer2" class="headerlink" title="Layer2"></a>Layer2</h2><ul><li>Base <a href="https://status.base.org/incidents/n3q0q4z24b7h">区块生产延迟</a>为 45 分钟</li><li>Barry Whitehat 的<a href="https://ethresear.ch/t/plasma-free/16570">Plasma Free</a>提案：免费交易，但如果数据不可用，用户需要进行强制交易（基于在线用户的假设）</li></ul><h2 id="EIPs-标准"><a href="#EIPs-标准" class="headerlink" title="EIPs&#x2F;标准"></a>EIPs&#x2F;标准</h2><ul><li>EIPs<ul><li><a href="https://github.com/ethereum/EIPs/pull/7668/files">EIP7514</a>：添加最大epoch churn限制</li></ul></li><li>ERCs（应用层）：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7634/files">ERC7507</a>：多用户NFT扩展（ERC721 扩展）</li><li><a href="https://eips.ethereum.org/EIPS/eip-7508">ERC7508</a>：动态的链上Token属性存储库</li><li><a href="https://github.com/ethereum/EIPs/pull/7651/files">ERC7509</a>：实体组件系统</li><li><a href="https://github.com/ethereum/EIPs/pull/7638/files">ERC7510</a>：跨合约分层NFT（ERC721 扩展）</li><li><a href="https://eips.ethereum.org/EIPS/eip-7511">ERC7511</a>：带有 PUSH0 的最小代理合约</li><li><a href="https://eips.ethereum.org/EIPS/eip-7512">ERC7512</a>：用于审计的链上表示</li><li><a href="https://github.com/ethereum/EIPs/pull/7656/files">ERC7513</a>：NFT 绑定的模块化合约（ERC1155 扩展）</li></ul></li></ul><h2 id="开发者相关内容"><a href="#开发者相关内容" class="headerlink" title="开发者相关内容"></a>开发者相关内容</h2><ul><li>Foundry:<ul><li>Forge-std <a href="https://github.com/foundry-rs/forge-std/releases/tag/v1.6.1">v1.6.1</a>：新的作弊码，用于获取映射的键、文件系统作弊码 和 JSON 解析</li><li><a href="https://www.reddit.com/r/ethdev/comments/16d3jma/meet_catapulta_your_automation_tool_for_foundry/">Catapulta</a>（Foundry 部署自动化）：抽象了 RPC 配置和Etherscan keys，在 alpha 版本期间免费</li><li><a href="https://github.com/devtooligan/solpretty#readme">Solpretty</a>：用于漂亮打印数字的Solidity库</li></ul></li><li>RareSkills：<a href="https://www.rareskills.io/post/gas-optimization">gas优化</a>指南</li><li><a href="https://hackmd.io/@pcaversaccio/how-vyper-compiles-into-bytecode">Vyper 编译流程指南</a></li><li><a href="https://github.com/fp-crypto/ape-roll#readme">Ape-roll</a>：Ape Framework 的 weiroll（操作链接&#x2F;脚本语言）客户端</li><li>ApeWorX <a href="https://twitter.com/ApeFramework/status/1700221649084129644">cHaOSneT</a>（beta）：付费测试网服务，使用机器人模拟活动</li><li>Heimdall-rs <a href="https://github.com/Jon-Becker/heimdall-rs/releases/tag/0.5.3">v0.5.3</a>：提高解码准确性，并添加了帮助解码非标准字节大小交易的标志</li><li><a href="https://tonk.notion.site/Eternal-Privacy-Playgrounds-6cb0ebb4042b42888a15a112a7040cbe">隐私游乐场 playgrounds </a>（维基）：链上游戏的隐藏信息机制</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>Stake：主网和侧链热钱包被盗 <a href="https://rekt.news/stake-rekt/">$4100 万</a>；<a href="https://www.fbi.gov/news/press-releases/fbi-identifies-lazarus-group-cyber-actors-as-responsible-for-theft-of-41-million-from-stakecom">FBI 指责 Lazarus</a></li><li>GMBL Computer 在 Arbitrum 上通过推荐系统发生了<a href="https://gmblcomputer.medium.com/gmbl-computer-exploit-postmortem-a09aa3297405">~$100 万的攻击</a></li><li>FloorDAO 通过 backlog 的 rebase 操作进行了<a href="https://twitter.com/FloorDAO/status/1699078468678377679">40 ETH 的攻击</a></li></ul><h2 id="生态系统"><a href="#生态系统" class="headerlink" title="生态系统"></a>生态系统</h2><ul><li><a href="https://twitter.com/ameensol/status/1699424914229321966">隐私池</a>的论文（作者包括 Vitalik 和 Ameen Soleimani）：用户可以证明符合监管要求，而不需要透露他们的全部交易历史</li><li><a href="https://mirror.xyz/erc4337official.eth/hRn_41cef8oKn44ZncN9pXvY3VID6LZOtpLlktXYtmA">ERC4337</a>（账户抽象）的拨款受益项目</li><li>黑客马拉松项目：<a href="https://ethwarsaw-2023.devpost.com/project-gallery">ETHWarsaw</a>和<a href="https://ethcon-korea.devfolio.co/projects">Ethcon Korea</a></li></ul><h2 id="链上统计"><a href="#链上统计" class="headerlink" title="链上统计"></a>链上统计</h2><ul><li>Gas手续费（通过<a href="https://ultrasound.money/#gas">ultrasound.money</a>）：7.8 至 88.9 gwei，平均为 15.7 gwei<ul><li>目前发行量通缩的gas为 20.4 gwei</li><li>本周净发行量为 3.6k ETH</li></ul></li><li><a href="https://www.coingecko.com/en/coins/ethereum">ETHUSD</a>：1615-1653 美元，当前为 1635 美元</li><li><a href="https://ratiogang.com/">ETHBTC</a>：0.0627-0.0636，当前为 0.0631，反转价格（ETH 超越 BTC 试纸）在约 0.16 左右</li></ul><h2 id="应用层的值得注意的事项"><a href="#应用层的值得注意的事项" class="headerlink" title="应用层的值得注意的事项"></a>应用层的值得注意的事项</h2><ul><li><a href="https://twitter.com/circle/status/1699045142429319321">USDC</a> 在 Optimism 和 Base 上原生发行</li><li>Kain 提议<a href="https://mirror.xyz/kain.eth/tAXGVKMTYM8K2gUOQq9JDQ1wyV_5Msdlrn_AtmiCGEI">Synthetix 尝试扩张</a>，在 Base 上使用 ETH 作为抵押品</li><li><a href="https://twitter.com/owocki/status/1699056199445221437">Kevin Owocki</a>回归 Gitcoin</li><li>Nouns DAO <a href="https://nouns.wtf/fork/0">fork #0</a>已开始（fork 的<a href="https://mirror.xyz/verbsteam.eth/iN0FKOn_oYVBzlJkwPwK2mhzaeL8K2-W80u82F7fHj8">解释</a>：使 20%以上的人可以一起退出他们在财政库中的份额）</li><li><a href="https://twitter.com/mailchain_xyz/status/1699052271022363079">TryENS</a>：创建一个临时的 ENS 子域名，48 小时后过期</li><li><a href="https://hashmarks.deafbeef.com/">Hashmarks</a>：需要使用物理雕刻刷新的逐渐消失的 SVG NFTs</li><li><a href="https://www.vaults.fyi/">Vaults.FYI</a>：为你的资产找到最佳收益（无论是否有农场激励）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1_数组</title>
      <link href="/2023/09/05/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/1_%E6%95%B0%E7%BB%84/"/>
      <url>/2023/09/05/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/1_%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1-删除排序数组中的重复项"><a href="#1-删除排序数组中的重复项" class="headerlink" title="1.删除排序数组中的重复项"></a>1.删除排序数组中的重复项</h1><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums &#x3D; [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>定义一个index变量，循环数组判断是否与临近的元素相同，若相同则赋值给下标为index的位置，并index+1，切片分割nums[:index]</p><h1 id="2-买卖股票的最佳时机"><a href="#2-买卖股票的最佳时机" class="headerlink" title="2.买卖股票的最佳时机"></a>2.买卖股票的最佳时机</h1><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。返回 你能获得的 最大 利润 。</p><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><p>输入：prices &#x3D; [7,1,5,3,6,4]<br>输出：7<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。<br>     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6 - 3 &#x3D; 3 。<br>     总利润为 4 + 3 &#x3D; 7 。</p><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>定义一个profit变量存储利润，循环数组判断是否比临近的元素大，若大则profit累加这个差值</p><h1 id="3-旋转数组"><a href="#3-旋转数组" class="headerlink" title="3.旋转数组"></a>3.旋转数组</h1><p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p><h4 id="示例-："><a href="#示例-：" class="headerlink" title="示例 ："></a>示例 ：</h4><p>输入: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右轮转 1 步: [7,1,2,3,4,5,6]<br>向右轮转 2 步: [6,7,1,2,3,4,5]<br>向右轮转 3 步: [5,6,7,1,2,3,4]</p><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>1.新建一个arr数组，循环原数组，将值赋值给new[(i+k)&amp;len(nums)],arr为结果</p><p>2.先反转全部数组，再反转前k个，最后在反转剩余的</p><h1 id="4-存在重复元素"><a href="#4-存在重复元素" class="headerlink" title="4.存在重复元素"></a>4.存在重复元素</h1><p>给你一个整数数组 <code>nums</code> 。如果任一值在数组中出现 <strong>至少两次</strong> ，返回 <code>true</code> ；如果数组中每个元素互不相同，返回 <code>false</code> 。</p><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><p>先排序，然后循环判断临近是否相等</p><h1 id="5-只出现一次的数字"><a href="#5-只出现一次的数字" class="headerlink" title="5.只出现一次的数字"></a>5.只出现一次的数字</h1><p>给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><p>我们只需要把所有的数字都异或一遍，最终的结果就是我们要求的那个数字  <strong>a⊕b⊕a&#x3D;b⊕a⊕a&#x3D;b⊕(a⊕a)&#x3D;b⊕0&#x3D;b。</strong></p><h1 id="6-两个数组的交集-II"><a href="#6-两个数组的交集-II" class="headerlink" title="6.两个数组的交集 II"></a>6.两个数组的交集 II</h1><p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><p>先对两个数组排序，定义两个指针一个index变量&#x3D;0，for i &lt; len(nums1) &amp;&amp; j &lt; len(nums2)，判断哪个数小，则那个指针++，若相等则nums[index]&#x3D;nums[i],然后三个变量++，最后返回nums[:index]</p><h1 id="7-加一"><a href="#7-加一" class="headerlink" title="7.加一"></a>7.加一</h1><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><p>digits &#x3D; [1,2,3]<br>输出：[1,2,4]</p><h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><p>从数组最后一个元素循环，如果!&#x3D;9，dig[i]+&#x3D;1并返回dig，否则dig[i]&#x3D;0，如果退出循环说明全是9，则append([]int{1}, digits…)</p><h1 id="8-移动零"><a href="#8-移动零" class="headerlink" title="8.移动零"></a>8.移动零</h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><p>nums &#x3D; [0,1,0,3,12]<br>输出: [1,3,12,0,0]</p><h4 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h4><p>1.把非零往前移，然后index++，然后循环index到数组长度设为零</p><p>2.定义i表示前面为零的个数，循环数组，如果为零，i++,否则nums[j-i] &#x3D; nums[j]，nums[j] &#x3D; 0</p><h1 id="9-两数之和"><a href="#9-两数之和" class="headerlink" title="9.两数之和"></a>9.两数之和</h1><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h3><p>新建一个map[int]int,遍历nums数组，判断map中是否存在target-v，若存在，返回k和target-v在map中的位置，若不存在则将这个值为键存入map中值为在nums数组的位置</p><h1 id="10-有效数独"><a href="#10-有效数独" class="headerlink" title="10.有效数独"></a>10.有效数独</h1><p>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p><p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p><h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h3><p>board &#x3D;<br>[[“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”]<br>,[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”]<br>,[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”]<br>,[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”]<br>,[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”]<br>,[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”]<br>,[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”]<br>,[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”]<br>,[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]<br>输出：false</p><h3 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h3><p>创建三个row,col,bax:&#x3D;make([] []bool,9)，循环到9，三个的第i为make([]bool,9),双层循环r，c到9，判断board[r] [c]!&#x3D;’.’，</p><p>赋值num:&#x3D;board[r] [c]-‘0’-byte(1)，判断 rowbuf[r] [num] || colbuf[r] [num] || boxbuf[r&#x2F;3*3+c&#x2F;3] [num]，返回false，</p><p>继续，赋值rowbuf[r] [num] &#x3D; true，colbuf[c] [num] &#x3D; true，boxbuf[r&#x2F;3*3+c&#x2F;3] [num] &#x3D; true，最后返回true</p><h2 id="11-旋转图像"><a href="#11-旋转图像" class="headerlink" title="11.旋转图像"></a>11.旋转图像</h2><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><p><img src="/noteimg/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/img/image-20230517103825323.png" alt="image-20230517103825323"> </p><h3 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h3><p>先对角线旋转，在根据竖直轴对称翻转</p>]]></content>
      
      
      <categories>
          
          <category> 初级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法练习笔记 </tag>
            
            <tag> 初级算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-9-30</title>
      <link href="/2023/08/30/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-9-30/"/>
      <url>/2023/08/30/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-9-30/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun（Cancun-Deneb）升级"><a href="#Dencun（Cancun-Deneb）升级" class="headerlink" title="Dencun（Cancun + Deneb）升级"></a><strong>Dencun（Cancun + Deneb）升级</strong></h2><ul><li>最新的所有核心开发人员 - 执行 (ACDE)视频会议。Tim Beiko的总结。Tim Beiko和Christine Kim的记录：<ul><li>Devnet-9 使用 EIP4788 主网地址和手动部署，并计划测试 MEV-Boost；KZG 仪式可信设置预计下周进行</li><li>EIP7514（限制质押增长）将在短暂的 Devnet-10 上进行测试，使用大量验证者</li><li>从 3 个审计中修复了 EIP4788（信标根）的问题：0 时间戳和环形缓冲区大小</li><li>对提案<a href="https://docs.google.com/presentation/d/1omnj-y2L59wERsOBQRKjoIKHm5VQ1A6Sdmc2_Oa75IM/edit?pli=1#slide=id.p">EIP7503</a>（通过重新铸造烧毁的 ETH 实现链上隐私）进行讨论</li></ul></li><li><a href="https://dencun-devnet-9.ethpandaops.io/">Devnet-9</a> 已上线</li></ul><h2 id="中心化观察：威胁你的-ETH-价值"><a href="#中心化观察：威胁你的-ETH-价值" class="headerlink" title="中心化观察：威胁你的 ETH 价值"></a><strong>中心化观察：威胁你的 ETH 价值</strong></h2><ul><li><p><strong>🚨</strong> <a href="https://twitter.com/lidodominance/status/1707757122291646495"><strong>Lido 达到 32.23%</strong></a> <strong>非常接近危险的</strong> <a href="https://www.youtube.com/watch?v=Y0ddkSa1ZuI&t=1050s"><strong>33.3%阈值</strong></a></p></li><li><p>客户端多样性（通过clientdiversity.org）：</p><ul><li>执行层：Geth 占据约 80%的超级多数派，可能导致链分叉</li><li>共识层：Prysm 占据 45%，任何客户端的错误超过 33.3%可能导致链活力丧失</li></ul></li><li><p>需要更多的<a href="https://nodewatch.io/">地理多样性，包括验证者和节点</a>，特别是在美国&#x2F;加拿大&#x2F;欧盟之外</p></li></ul><h2 id="Layer1"><a href="#Layer1" class="headerlink" title="Layer1"></a>Layer1</h2><ul><li><a href="https://twitter.com/uriklarman/status/1706716871024615723">91%的区块</a>通过仅有四个实体控制的 MEV-Boost 中继进行</li><li><a href="https://twitter.com/nero_eth/status/1706594750155931953">审查仪表盘</a>：展示验证者、中继和构建者的 OFAC 合规性</li><li><a href="https://twitter.com/metachris/status/1706274142071488649">内存池垃圾箱</a>（Parquet 和 CSV 中的交易）：添加包含状态和包含延迟</li></ul><h2 id="Holesky-测试网的客户端发布"><a href="#Holesky-测试网的客户端发布" class="headerlink" title="Holešky 测试网的客户端发布"></a><strong>Holešky 测试网的客户端发布</strong></h2><ul><li>共识层：<ul><li>Lighthouse <a href="https://github.com/sigp/lighthouse/releases/tag/v4.5.0">v4.5.0</a>：实验性 QUIC 支持</li><li>Lodestar <a href="https://github.com/ChainSafe/lodestar/releases/tag/v1.11.3">v1.11.3</a></li><li>Nimbus <a href="https://github.com/status-im/nimbus-eth2/releases/tag/v23.9.1">v23.9.1</a></li><li>Prysm <a href="https://github.com/prysmaticlabs/prysm/releases/tag/v4.1.0-alpha.1">v4.1.0-alpha.1</a></li><li>Teku <a href="https://github.com/Consensys/teku/releases/tag/23.9.1">v23.9.1</a>：Holešky 测试网在 Linux 上需要 GLIBC v2.34</li></ul></li><li>执行层：<ul><li>Besu <a href="https://github.com/hyperledger/besu/releases/tag/23.7.3">v23.7.3</a></li><li>Erigon <a href="https://github.com/ledgerwatch/erigon/releases/tag/v2.49.3">v2.49.3</a>：Holešky；<a href="https://github.com/ledgerwatch/erigon/releases/tag/v2.50.0">v2.50.0</a>：实现 Cancun EIPs</li><li>Geth <a href="https://github.com/ethereum/go-ethereum/releases/tag/v1.13.2">v1.13.2</a>：修复路径数据库存储模式的边缘情况</li><li>Nethermind <a href="https://github.com/NethermindEth/nethermind/releases/tag/1.21.0">v1.21.0</a>：可执行文件重命名，限制 RPC 调用，Trie 恢复和同步时间减少</li><li>Reth <a href="https://github.com/paradigmxyz/reth/releases/tag/v0.1.0-alpha.9">v0.1.0-alpha.9</a>：实现 Cancun EIPs，重新设计了 revm 状态处理 API 和状态修剪改进；<a href="https://github.com/paradigmxyz/reth/releases/tag/v0.1.0-alpha.10">v0.1.0-alpha.10</a>：Holešky支持</li></ul></li></ul><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a><strong>研究</strong></h2><ul><li>为 danksharding 做准备：<a href="https://blog.codex.storage/big-blocks-on-mainnet/">主网上大块传播时间的数据可视化</a></li><li><a href="https://ethresear.ch/t/resistance-is-not-futile-cr-in-mev-boost/16762">中继构建的包含列表</a>：提供 MEV-Boost 中的抗审查方案</li><li>用于多资源的<a href="https://arxiv.org/abs/2309.12735">动态费用优化设计框架</a></li></ul><h2 id="Layer2"><a href="#Layer2" class="headerlink" title="Layer2"></a>Layer2</h2><ul><li>OP Stack：<a href="https://blog.oplabs.co/fault-proof-vm/">社交去中心化和欺诈证明虚拟机</a>和<a href="https://blog.oplabs.co/dispute-games/">争议博弈</a></li><li><a href="https://github.com/0xFableOrg/roll-op/#readme">Roll-op</a>：用于配置和部署 OP Stack 网络的脚本</li></ul><h2 id="EIPs-标准"><a href="#EIPs-标准" class="headerlink" title="EIPs&#x2F;标准"></a><strong>EIPs&#x2F;标准</strong></h2><ul><li>EIPs<ul><li><a href="https://github.com/ethereum/EIPs/pull/7776/files">EIP7525</a>: 不活跃账户的过期状态</li></ul></li><li>ERCs（应用层）：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7775/files">ERC7524</a>: 钱包中的 PLUME 签名</li><li><a href="https://github.com/ethereum/EIPs/pull/7781/files">ERC7526</a>: Onchain NFT 版税实施</li></ul></li></ul><h2 id="开发者相关"><a href="#开发者相关" class="headerlink" title="开发者相关"></a><strong>开发者相关</strong></h2><ul><li><p>Holešky 测试网</p><p>用于质押、基础设施和协议测试</p><ul><li>浏览器：<a href="https://holesky.etherscan.io/">Etherscan</a>、<a href="https://holesky.beaconcha.in/">beaconcha.in</a> 和 <a href="https://holesky.otterscan.io/">Otterscan</a></li><li>分发给合约部署者的 1000 holETH（主网和 Goerli 测试网）</li><li>水龙头：<a href="https://holesky-faucet.pk910.de/">pk910 PoW 水龙头</a> 和 Etherscan 的 <a href="https://twitter.com/etherscan/status/1707712285115056469">Blockscan 聊天</a></li><li>替代已弃用的 <a href="https://github.com/eth-clients/goerli#readme">Goerli</a></li><li>用于应用层测试的 <a href="https://github.com/eth-clients/sepolia#readme">Sepolia 测试网</a></li></ul></li><li><p>Remix <a href="https://medium.com/remix-ide/remix-release-v0-36-0-36bae12abb1f">v0.36.0</a>: 使用 ChatGPT 解释函数、生成文档和解释编译器错误，增加更多快速修复和对 Ephemery 测试网的支持</p></li><li><p>Hardhat <a href="https://github.com/NomicFoundation/hardhat/releases/tag/hardhat@2.17.4">v2.17.4</a>: 支持 debug_traceCall</p></li><li><p><a href="https://github.com/PaulRBerg/btt-examples#readme">Branching Tree Technique examples</a>: 用于编写结构化 Solidity 测试的规范框架</p></li><li><p><a href="https://github.com/transmissions11/solmate/#readme">Solmate</a>（合约库）添加了 ERC6909（最小多代币接口）的实现</p></li><li><p>SSTORE gas：</p><ul><li><a href="https://forum.openzeppelin.com/t/understanding-the-refund-logic-in-reentrancyguard/37948/2">OpenZeppelin ReentrancyGuard 避免重置为零</a> 以最大化 gas 退款</li><li><a href="https://medium.com/eulerfinance/have-you-heard-about-this-sstore-quirk-anon-6a1ae870e57c">EVM 使用 SSTORE 的当前值而非中间值</a> 以降低 gas 成本</li></ul></li><li><p><a href="https://hackernoon.com/borrowing-on-ethereum-comparing-architecture-evolution-of-makerdao-yield-aave-compound-and-euler">借贷协议架构比较</a>: MakerDAO、Compound、Aave、Euler 和 Yield</p></li><li><p>Huffathon 挑战：<a href="https://github.com/devtooligan/huffathon-2023-challenge-0-1#readme">1</a>，<a href="https://github.com/devtooligan/huffathon-2023-challenge-0-2#readme">2</a>，<a href="https://github.com/PraneshASP/huffathon-challenge-2#readme">3</a>和<a href="https://github.com/RareSkills/rareskills-huffathon-challenge#readme">4</a></p></li><li><p>wagmi <a href="https://github.com/wagmi-dev/wagmi/discussions/3068">v2 alpha</a>：TanStack Query 支持，连接多个连接器，断开连接时切换链和 EIP6963 支持</p></li><li><p>ERC4337（账户抽象）：</p><ul><li><a href="https://github.com/pimlicolabs/permissionless.js#readme">Permissionless.js</a>：与 bundler （打包者）和 paymaster 进行交互的 TypeScript 库，构建在 viem 上</li><li>Alchemy的<a href="https://github.com/alchemyplatform/rundler#readme">Rundler</a>：用 Rust 编写的 ERC4337 bundler （打包者）</li></ul></li><li><p><a href="https://github.com/tomhirst/solidity-nextjs-starter#readme">Solidity Next.js starter v2</a>：使用Hardhat，viem，wagmi，Tailwind CSS 和 RainbowKit</p></li><li><p><a href="https://github.com/m8b-dev/ether-binder#readme">Ether binder</a> beta：用于与以太坊交互的 PHP 实用工具，使用 PHP 8.2</p></li><li><p>Curta CTF <a href="https://twitter.com/eth_call/status/1706029458275119205">Philosopher’s Stone writeup</a></p></li><li><p><a href="https://mteam88.github.io/posts/analyzing-ethereum-with-cryo/">使用 Cryo 和 Polars 进行数据分析的指南</a></p></li><li><p>Banteg：创建 ERC20 转账的<a href="https://banteg.xyz/posts/heatmap/">热力图</a></p></li><li><p>RareSkills：<a href="https://www.rareskills.io/post/circom-tutorial">Circom 教程</a></p></li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a><strong>安全</strong></h2><ul><li><a href="https://twitter.com/frankresearcher/status/1706740009997369775">SEAL 911 成员从 Dice9win 中的漏洞中挽回了 20 万美元</a></li><li>GMX（Arbitrum 上的 DEX）<a href="https://www.collider.vc/post/gmx-granted-million-dollar-bug-bounty-to-collider-the-bug-aftermath">披露了价格扭曲漏洞</a>，并支付了 100 万美元的赏金来修复</li></ul><h2 id="生态"><a href="#生态" class="headerlink" title="生态"></a><strong>生态</strong></h2><ul><li>Dankrad：<a href="https://twitter.com/dankrad/status/1707014810565566962">以太坊的价值需要社区保护</a>，它们不会自动受到经济激励的保证</li><li>EF <a href="https://esp.ethereum.foundation/data-collection-grants">数据收集赠款</a>，申请截止日期为 10 月 23 日，心愿单包括<a href="https://twitter.com/samcmau/status/1707604513086189869">XATU</a>（网络监控），测试网和数据收集项目</li><li><a href="https://sixdegree.xyz/research/Half-Year-Data-Report-of-ERC4337-by-Sixdegree.pdf">ERC4337（账户抽象）采用分析报告</a>：687,000 个钱包，2,000,000 个用户操作，大多数钱包使用不超过 5 次</li><li>ETHGlobal <a href="https://twitter.com/ETHGlobal/status/1706049363464569232">纽约黑客马拉松决赛列表</a></li></ul><h2 id="企业应用"><a href="#企业应用" class="headerlink" title="企业应用"></a><strong>企业应用</strong></h2><ul><li><a href="https://www.bis.org/publ/othp75.pdf">国际清算银行</a> <a href="https://www.bis.org/publ/othp75.pdf">Mariana 项目</a>：在 Sepolia 测试网上使用 AMM 进行跨境大规模兑换 CBDC 的概念验证</li><li><a href="https://zksync.mirror.xyz/w4_Dyhbx1X2BEGpYNCn8rEAS_2uC1hV0qPQl_m5AChk">布宜诺斯艾利斯数字身份</a>：QuarkID 钱包可用于申领出生证明和结婚证书，使用 zkSync Era</li></ul><h2 id="链上统计"><a href="#链上统计" class="headerlink" title="链上统计"></a><strong>链上统计</strong></h2><ul><li><p>Gas 费用（通过ultrasound.money）：5.5 至 74.1 gwei，平均为 10.7 gwei</p><ul><li>目前通缩 gas 为 20.9 gwei</li><li>本周净新发行量为 7.9k ETH</li></ul></li><li><p><a href="https://www.coingecko.com/en/coins/ethereum">ETHUSD</a>：1,569–1,569–1,684，当前为 $1668</p></li><li><p><a href="https://ratiogang.com/">ETHBTC</a>：当前为 0.062（Flippening 在约 0.16）</p></li></ul><h2 id="应用层的值得注意的事项"><a href="#应用层的值得注意的事项" class="headerlink" title="应用层的值得注意的事项"></a><strong>应用层的值得注意的事项</strong></h2><ul><li>Arbitrum <a href="https://arbitrumfoundation.medium.com/arbitrum-odyssey-reignited-a98f627d42ef">Odyssey</a> 重新启动，为用户提供为期 7 周的活动，试用应用并收集徽章</li><li><a href="https://www.prnewswire.com/news-releases/pudgy-penguins-debuts-toyline-in-major-retail-stores-across-us-301939099.html">Pudgy Toys</a>：Pudgy Penguin 的实体玩具，将在沃尔玛销售，许可费将与 NFT 持有者共享，购买者可以在 zkSync 上申领一个永久的 Pudgy</li><li>Nouns DAO <a href="https://w.mirror.xyz/AmHOzH-FQZVO3IhGXHSvCRxRSf2MO6VCZdmMwNEIyKE">燃烧提案</a>：激励使用财库资金，否则多余的 ETH 可以被燃烧</li><li><a href="https://twitter.com/ParisHilton/status/1707410178969137532">Paris Hilton 推广 MareBear NFT</a>：Tamagotchis 宠物</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>VanEck 宣布即将推出的 <a href="https://www.vaneck.com/us/en/press-releases/vaneck-prepares-to-launch-ethereum-futures-etf-efut.pdf">ETH 期货 ETF</a>（EFUT）</li><li><a href="https://www.coinbase.com/blog/coinbase-receives-regulatory-approval-to-enable-retail-perpetual-futures?__cf_chl_f_tk=NQFPKqxhWtw.O7q1bDHMnWlVb7p7j5_Tu2v3l0Qp2Hk-1695944027-0-gaNycGzNDHs">Coinbase</a> 获得百慕大货币管理局批准，提供永续期货交易，非美国用户可用</li><li>纽约和波士顿联邦储备银行：<a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=4580392">稳定币的安全飞行动态</a> 类似于货币市场基金</li><li><a href="https://www.coindesk.com/policy/2023/09/26/chase-uk-to-block-crypto-payments-citing-fraud-scams/">Chase UK</a> 将拒绝加密货币相关支付</li><li>交易所黑客事件：<a href="https://rekt.news/mixin-rekt/">Mixin Network 损失 2 亿美元</a>，<a href="https://twitter.com/justinsuntron/status/1706311251024822748">HTX（原名火币）损失 800 万美元</a></li><li><a href="https://eprint.iacr.org/2023/1406">Sigmabus</a>：在通用 SNARK 电路中高效计算椭圆曲线群操作</li><li><a href="https://eprint.iacr.org/2023/1472">Naysayer 证明</a>：乐观地接受证明，并在必要时进行检查</li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-9-23</title>
      <link href="/2023/08/27/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-9-23/"/>
      <url>/2023/08/27/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-9-23/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun（Cancun-Deneb）升级"><a href="#Dencun（Cancun-Deneb）升级" class="headerlink" title="Dencun（Cancun + Deneb）升级"></a>Dencun（Cancun + Deneb）升级</h2><ul><li><p>最新的所有核心开发人员 - 执行 (ACDE)视频会议。Christine Kim的记录：</p><ul><li>Devnet-9 计划于 9 月 27 日启动，以太坊基金会研究员卡尔-比克（Carl Beek）正在努力将 KZG 仪式的结果转换成标准化格式，如果准备就绪，Devnet-9 将包含 KZG 仪式生成的值</li><li>公共测试网升级顺序已更改：首先是 Goerli ，因为它已被弃用，EIP4844 允许测试 3&#x2F;6（目标&#x2F;最大） blob，最好是在 DevConnect 之前</li></ul></li><li><p>Dencun 测试<a href="https://www.youtube.com/watch?v=DRkAEbE-V4g&t=137s">视频会议</a>。参考<a href="https://hackmd.io/@oiYljOkuS1KY6mgjjbfQww/BJwFNsc1a">Terence</a>的记录</p></li><li><p>Consensus-specs <a href="https://github.com/ethereum/consensus-specs/releases/tag/v1.4.0-beta.2">v1.4.0-beta.2</a>：添加 EIP7514（限制质押增长），分叉选择规则的提议者奖励调整</p></li></ul><h2 id="Prague-Electra-升级"><a href="#Prague-Electra-升级" class="headerlink" title="Prague + Electra 升级"></a>Prague + Electra 升级</h2><ul><li>Terence：<a href="https://terencechain.substack.com/p/navigating-ethereums-2024-consensus">Electra 的重点应该是提高共识层的稳定性</a>，包括列表，增加最大有效余额（EIP7251）和改进分叉选择</li></ul><h2 id="中心化观察：威胁你的-ETH-价值"><a href="#中心化观察：威胁你的-ETH-价值" class="headerlink" title="中心化观察：威胁你的 ETH 价值"></a>中心化观察：威胁你的 ETH 价值</h2><ul><li><p><a href="https://dune.com/hildobby/eth2-staking"><strong>Lido 达到 32.23%</strong></a> <strong>仍然离 <a href="https://notes.ethereum.org/@djrtwo/risks-of-lsd">阈值33.3%</a> 太近</strong></p></li><li><p>客户端多样性（通过clientdiversity.org）：</p><ul><li>执行层：Geth 超过半数，可能导致分叉</li><li>共识层：Prysm 超过 33%，一个错误可能导致丧失活跃性</li></ul></li><li><p>需要更多的<a href="https://nodewatch.io/">质押者和节点地理多样性</a>，特别是在美国&#x2F;加拿大&#x2F;欧盟之外</p></li></ul><h2 id="Layer-1"><a href="#Layer-1" class="headerlink" title="Layer 1"></a>Layer 1</h2><ul><li>ERC4337（账户抽象）会议<a href="https://twitter.com/johnrising_/status/1704883350408950189">记录</a></li><li><a href="https://hackmd.io/@1ofB8klpQky-YoR5pmPXFQ/SJ0nuzD1T">在链上验证 p256 曲线的状态</a></li><li><a href="https://alessandromazza.notion.site/P256VERIFY-Precompile-in-Revm-ca2f782a91214b7d99f130cba8ceaed5">指南：将预编译添加到 Revm</a>（和 Reth），示例添加P256VERIFY</li><li>由于潜在的优势，<a href="https://twitter.com/MaxResnick1/status/1705320727162077235">集成 MEV-Boost 构建者</a>在 CEX&#x2F;DEX 套利中占绝对优势。</li></ul><h2 id="给质押者"><a href="#给质押者" class="headerlink" title="给质押者"></a>给质押者</h2><ul><li><a href="https://www.yamlike.com/archive/fund-solo-ethereum-validator-node-with-ira">用退休基金</a>（美国的 IRA）来资助独立质押</li></ul><h2 id="客户版本"><a href="#客户版本" class="headerlink" title="客户版本"></a>客户版本</h2><ul><li>执行层：<ul><li>Geth <a href="https://github.com/ethereum/go-ethereum/releases/tag/v1.13.1">v1.13.1</a>：修复了 v1.13.0 区块生产的问题，添加了环境变量用于配置和有颜色的帮助界面</li><li>Nethermind <a href="https://github.com/NethermindEth/nethermind/releases/tag/1.20.4">v1.20.4</a>：Holešky 测试网新的创世区块</li></ul></li></ul><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><ul><li><a href="https://ethresear.ch/t/statement-regarding-the-public-report-on-the-analysis-of-minroot/16670">EF 密码学</a>：VDF （可验证延迟函数）现在 死了么？</li><li>单一秘密领导选举（SSLE）：探讨了用目标组、XTR 和 CEILIDH 解决 Whisk 的<a href="https://ethresear.ch/t/the-return-of-torus-based-cryptography-whisk-and-curdleproof-in-the-target-group/16678">引导问题</a></li><li>Mike Neuder：<a href="https://notes.ethereum.org/@mikeneuder/infinite-buffet">ePBS</a>讨论 - 协议内设计、协议外提案和开放问题</li><li>用 BLS 多重盲签将<a href="https://ethresear.ch/t/making-pepc-dvt-private-with-bls-blinded-multi-signatures/16692"> PEPC-DVT</a> 设为私有</li></ul><h2 id="Layer-2"><a href="#Layer-2" class="headerlink" title="Layer 2"></a>Layer 2</h2><ul><li><a href="https://base.mirror.xyz/qQAChAdkfZDG_8Ik7FgrMIpjE-si3TdF1E5W6c8ruFQ">Pessimism</a>：Base 构建的开源监控系统</li><li><a href="https://polygon.technology/blog/canto-to-migrate-to-a-zk-l2-powered-by-polygon-chain-development-kit">Canto</a>和<a href="https://www.infura.io/blog/post/palm-network-scales-up-for-enhanced-operations-and-broader-use-cases">Palm</a>计划用 Polygon Chain Development Kit (CDK) 迁移到 zk rollups</li><li>Optimism <a href="https://optimism.mirror.xyz/wiHMKqsbAQnK51Se3MraSnvf0blwRzS9jguojEmKKVc">RetroPGF 第三轮申请</a>正在进行中，将分配 3000 万 OP</li></ul><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><ul><li>EIP<ul><li><a href="https://eips.ethereum.org/EIPS/eip-7519">EIP7519</a>：原子存储操作 SCREDIT 和 SDEBIT</li><li><a href="https://eips.ethereum.org/EIPS/eip-7523">EIP7523</a>：空账户弃用（禁止在合并后的网络上使用空账户）</li></ul></li><li>ERCs（应用层）：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7733/files">ERC7520</a>：zk-SNARK 公共输入溢出保护</li><li><a href="https://github.com/ethereum/EIPs/pull/7739/files">ERC7521</a>：合约钱包的通用意图</li><li><a href="https://github.com/ethereum/EIPs/pull/7743/files">ERC7522</a>：用于账户抽象（ERC4337）的 OIDC（OpenID Connect）zk 验证器</li></ul></li></ul><h2 id="开发者资料"><a href="#开发者资料" class="headerlink" title="开发者资料"></a>开发者资料</h2><ul><li><a href="https://github.com/eth-clients/holesky#readme">Holešky 测试网</a> 创世计划改为 9 月 28 日</li><li><a href="https://consensys.io/blog/consensys-announces-the-sunset-of-truffle-and-ganache-and-new-hardhat">Truffle 和 Ganache 即将停用</a>，开发者可以迁移到 Hardhat</li><li>Foundry:<ul><li><a href="https://twitter.com/_jxom/status/1704004731415511079">Rivet</a>（开发者钱包）增加了日志和 calldata 解码功能</li><li><a href="https://github.com/hrkrshnn/tstore-template#readme">Tstore-template</a>：带有自定义 solc 二进制文件的 Foundry 模板，支持内联汇编中的瞬态存储操作码</li></ul></li><li><a href="https://github.com/0xfuturistic/emily#readme">Emily</a>：Solidity 可信承诺库</li><li><a href="https://twitter.com/austingriffith/status/1703828935346454924">Speed Run Ethereum</a> 更新为 Scaffold-ETH-2，可以使用 Hardhat 或 Foundry</li><li>Alchemy 大学 <a href="https://www.alchemy.com/university/courses/solidity">学习 Solidity</a> ，11 节课程</li><li><a href="https://github.com/base-org/op-viem#readme">OP Viem</a>：OP Stack 网络的 viem 扩展</li><li><a href="https://mirror.xyz/privacy-scaling-explorations.eth/T4MR2PgBzBmN2I3dhDJpILXkQsqZp1Bp8GSm_Oo3Vnw">TLSNotary</a>（Alpha 版本）实现隐私保护的数据溯源和可移植性</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li><a href="https://twitter.com/balancer/status/1704552285395894422">Balancer 受到攻击</a>，本次攻击是对 EuroDNS（.fi TLD 使用的域名注册商）的社交工程攻击。</li><li><a href="https://mirror.xyz/anichohan.eth/QoLKhNHUqkycVPV8Ku2KnjbcBlG-Wwj5Sz_bfmemgbg">审计在链上展示的标准</a>（ERC7512）提案</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li><a href="https://twitter.com/wearecacti/status/1704605245353918541">Cacti-chat</a>（web3 聊天机器人）已上线，当前是测试版</li><li><a href="https://mirror.xyz/privacy-scaling-explorations.eth/6R8kACTYp9mF3eIpLZMXs8JAQmTyb6Uy8KnZqzmDFZI">Anon Aadhaar</a>：匿名证明 Aadhaar（印度）身份</li><li><a href="https://twitter.com/DeFiSaver/status/1703773252936708340">DeFiSaver</a> 为 Liquity 提供新的自动化选项：Savings protection (Supply) 和 Savings protection (Payback)</li><li><a href="https://medium.com/gammaswap-labs/gammaswap-is-officially-live-on-arbitrum-mainnet-e8a89e43ddb8">GammaSwap</a>：在 Arbitrum 上提供 Sushi 池的链上期权。做市商可以对冲 AMM LP 头寸</li><li>Vampire 攻击中心化交易所：<a href="https://mirror.xyz/infinex.eth/YA3Z3PTktUEwKPZjrrwi86urUWHqYd86zlq0dzry5n8">Infinex 允许交易者</a>从中心化交易历史中获得空投</li><li><a href="https://community.optimism.io/docs/governance/airdrop-3/#">Optimism Aridrop3</a>直接分发给委托用户</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://twitter.com/nansen_ai/status/1705137387838574904">Nansen 因为供应商数据泄露</a> ，一些电子邮件地址、密码哈希值和区块链地址被暴露</li><li><a href="https://www.bleepingcomputer.com/news/apple/apple-emergency-updates-fix-3-new-zero-days-exploited-in-attacks/">更多 Apple 零日漏洞</a>，更新你的设备</li><li>重新审视 <a href="https://medium.com/@omershlomovits/revisiting-paradigm-hardware-acceleration-for-zero-knowledge-proofs-16f717a49555">zk 证明的硬件加速</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-9-2</title>
      <link href="/2023/08/22/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-9-2/"/>
      <url>/2023/08/22/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-9-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun-Cancun-Deneb-升级"><a href="#Dencun-Cancun-Deneb-升级" class="headerlink" title="Dencun (Cancun + Deneb) 升级"></a>Dencun (Cancun + Deneb) 升级</h2><ul><li><p>最新的所有核心开发人员 - 执行 (ACDE)视频会议。Tim Beiko的总结。Tim Beiko和Christine Kim的记录：</p><ul><li>Devnet 8 将用于大多份 Dencun 测试，devnet 9 将包括最终的规范更改并希望成为最后一个 devnet</li><li>公共测试网升级顺序：Holešky（新测试网，节点运营商数量较少），Goerli（已弃用，拥有最多数量的 app&#x2F;L2&#x2F;质押者），然后是上主网之前的 Sepolia</li><li>Holešky 将测试 3&#x2F;6（目标数&#x2F;最大数）blob，并可选择将其他测试网&#x2F;主网减少到 2&#x2F;4</li><li>关于 Verkle trie 实时迁移与状态到期和地址空间扩展&#x2F;压缩相结合的讨论</li></ul></li><li><p><a href="https://domothy.com/blobspace/">blobspace 简介</a>：Dencun 升级中的 EIP4844（原 danksharding）和完整 danksharding</p></li></ul><h2 id="中心化观察：你的-ETH-价值正受到威胁"><a href="#中心化观察：你的-ETH-价值正受到威胁" class="headerlink" title="中心化观察：你的 ETH 价值正受到威胁"></a>中心化观察：你的 ETH 价值正受到威胁</h2><ul><li><p><a href="https://dune.com/hildobby/eth2-staking">Lido </a>即将突破 <a href="https://notes.ethereum.org/@djrtwo/risks-of-lsd"><strong>33% 的门槛</strong></a></p></li><li><p>客户端多样性（clientdiversity.org）：</p><ul><li>执行层：Geth 绝对多数，可能导致分叉</li><li>共识层：两个客户端超过 33%，一个bug可能让链不活跃</li></ul></li><li><p>需要：<a href="https://nodewatch.io/">质押者和节点在地理上更分散</a>，特别是在美国&#x2F;加拿大&#x2F;欧盟之外</p></li></ul><h2 id="Layer-1"><a href="#Layer-1" class="headerlink" title="Layer 1"></a>Layer 1</h2><ul><li><p>以太坊执行层规范</p><p>（EELS）：Python 参考实现（类似于共识层 Python 规范）</p><ul><li><a href="https://github.com/ethereum/yellowpaper#repository-currently-outdated">拨款可用于更新黄皮书</a>，缺少合并前分叉逻辑</li></ul></li><li><p>Erigon <a href="https://erigon.substack.com/p/update-on-caplin-and-roadmap-building">Caplin</a>（共识层客户端）路线图</p></li><li><p>Dapplion：<a href="https://hackmd.io/@dapplion/whisk_bootstrapping">Whisk: bootstrapping 问题</a>，bootstrapping 策略权衡</p></li><li><p>Otterscan <a href="https://github.com/otterscan/otterscan/releases/tag/v1.32.0">v1.32.0</a>：添加合约交互（针对 Sourcify 验证合约）</p></li></ul><h2 id="客户端版本"><a href="#客户端版本" class="headerlink" title="客户端版本"></a>客户端版本</h2><ul><li>共识层：<ul><li>Lodestar <a href="https://github.com/ChainSafe/lodestar/releases/tag/v1.11.0">v1.11.0</a>：添加 Holešky 测试网</li></ul></li><li>执行层：<ul><li>Nethermind <a href="https://github.com/NethermindEth/nethermind/releases/tag/1.20.2">v1.20.2</a> &#x2F; <a href="https://github.com/NethermindEth/nethermind/releases/tag/1.20.3">v1.20.3</a>：添加 Holešky 测试网</li><li>Reth <a href="https://github.com/paradigmxyz/reth/releases/tag/v0.1.0-alpha.8">v0.1.0-alpha.8</a>： 全节点低于 1TB，每个表可配置修剪，交易池和 RPC 改进</li></ul></li></ul><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><ul><li><a href="https://ethresear.ch/t/reducing-lst-dominance-risk-by-decoupling-attestation-weight-from-attestation-rewards/16523">将见证权重</a>与见证奖励分离，提案降低流动性质押风险</li><li><a href="https://ethresear.ch/t/cumulative-non-expiring-inclusion-lists/16520">累积的、未过期包含列表</a>，附加包含列表的设计</li><li><a href="https://ethresear.ch/t/slashing-penalty-analysis-eip-7251/16509">如果最大有效余额增加</a>（EIP7251），则削减惩罚，建议初始惩罚为常数或次线性缩小，并将相关惩罚修改为二次方缩小</li><li><a href="https://ethresear.ch/t/pepc-dvt-pepc-with-no-changes-to-the-consensus-protocol/16514">PEPC-DVT</a>：在不改变共识的前提下的协议强制提案者承诺</li></ul><h2 id="Layer-2"><a href="#Layer-2" class="headerlink" title="Layer 2"></a>Layer 2</h2><ul><li>Arbitrum <a href="https://medium.com/offchainlabs/stylus-now-live-one-chain-many-languages-eee56ad7266d">Stylus</a>：用 Rust、C 和 C++ 为 Nitro 链构建应用程序，在测试网上运行</li><li>Polygon <a href="https://polygon.technology/blog/introducing-polygon-chain-development-kit-launch-zk-l2s-on-demand-to-unlock-unified-liquidity">Chain 开发套件</a>(CDK)：可用于按需启动 rollup 或 validium 链</li><li>StarkWare <a href="https://github.com/starkware-libs/stone-prover#readme">Stone 证明器</a>开源</li></ul><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><ul><li>ERC（应用层）：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7528/files">ERC7505</a>：NFT 作者注册表</li><li><a href="https://github.com/ethereum/EIPs/pull/7547/files">ERC7506</a>：可信提示注册表</li></ul></li></ul><h2 id="开发者资料"><a href="#开发者资料" class="headerlink" title="开发者资料"></a>开发者资料</h2><ul><li>Foundry:<ul><li><a href="https://www.paradigm.xyz/2023/08/rivet">Rivet</a>：开发者钱包（浏览器扩展），与 Anvil、alpha 集成</li><li><a href="https://github.com/devtooligan/Huffpoint#readme">Huffpoint</a>：用 Huff 实现的 vm.breakpoint ， Foundry 调试器一起使用</li></ul></li><li>OpenSea<a href="https://docs.opensea.io/changelog/define-the-standard-for-nft-redeemables">可兑换 NFT</a>草案标准，概念证明销毁，以在主网上赎回</li><li><a href="https://blog.smlxl.io/ethereum-apocrypha-46e155e21a26">独特的合约设计</a>：BIG、多对一和一对多代理、重叠布局和深度嵌套变量</li><li><a href="https://twitter.com/ArbitrumDevs/status/1696525956834619856">Arbitrum Sepolia 测试网</a>已上线，Arbitrum Goerli 将于今年晚些时候弃用</li><li><a href="https://www.zksecurity.xyz/blog/posts/circomscribe/">Circcomscribe</a> 工具：分析 Circcom 代码</li><li>Trail of Bits 为<a href="https://github.com/crytic/slither/pull/2099">Slither</a>和<a href="https://github.com/crytic/echidna/pull/1108">Echidna 添加了 Vyper 支持</a></li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>Ajna 协议<a href="https://blog.summer.fi/ajna-possible-attack-vector/">潜在的恶意矢量攻击披露（可能影响借款人的使用）</a>，建议立刻偿还债务并退出</li><li>Balancer 披露漏洞，<a href="https://twitter.com/BeosinAlert/status/1696362629818908758">210 万美元</a><a href="https://twitter.com/Balancer/status/1696930832760635566">被利用</a></li><li>SharedStake（流动质押）<a href="https://medium.com/@chimera_defi/sharedstake-exploit-postmortem-sep-1-2023-50a85061d58c">105 ETH 被利用</a>，通过无效所有权检查无限 mint</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li><a href="https://twitter.com/gitcoin/status/1696516357876043826">Gitcoin Grant 18 已结束</a>，4.7 万名捐赠者捐赠了 68 万美元</li><li>Gitcoin Passport<a href="https://www.gitcoin.co/blog/gitcoin-passport-onchain-stamps">链上邮票</a>：在 Optimism 铸造 passport</li><li><a href="https://hats.mirror.xyz/NXJI4Rkk4TafwLvVZLfdlz-sLWdrNlKFmvJq9cKDkiw">Hats Protocol v2</a>：分配链上角色地址并选择每个角色获得的权力</li><li>Brian Armstrong：发布对Builder 支持计划， <a href="https://www.coinbase.com/blog/request-for-builders-startups-i-would-build-today">我今天要启动公司</a></li><li>Base 应用：<ul><li><a href="https://twitter.com/OpenCoverDeFi/status/1697232657481183252">OpenCover</a>：封面聚合器</li><li><a href="https://www.nfta.pl/">NFTA</a>：通过绘制价格图表进行每日价格预测游戏，测试版</li></ul></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://twitter.com/haydenzadams/status/1696991910370411003">Class action against Uniswap dismissed</a>, not liable for third-party misuse</li><li>Binance： <a href="https://www.binance.com/en/support/announcement/binance-encourages-users-to-convert-busd-to-other-stablecoins-prior-to-february-2024-d392843e81fd4bc3a5f7e219aa01f34d">BUSD用户应在2024年2月前转换为其他稳定币</a></li><li><a href="https://forum.makerdao.com/t/explore-a-fork-of-the-solana-codebase-for-newchain/21822">Rune 提案 Maker 链</a> , 可以利用硬分叉从治理攻击或技术故障中恢复过来</li><li>Ittai Abraham: <a href="https://decentralizedthoughts.github.io/2023-09-01-FFT/">有限域上的快速傅立叶变换</a></li><li><a href="https://eprint.iacr.org/2023/1284">使用 GKR 改进日志查找</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-9-16</title>
      <link href="/2023/08/21/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-9-16/"/>
      <url>/2023/08/21/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-9-16/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun（Cancun-Deneb）升级"><a href="#Dencun（Cancun-Deneb）升级" class="headerlink" title="Dencun（Cancun + Deneb）升级"></a>Dencun（Cancun + Deneb）升级</h2><ul><li><p>最新的所有核心开发人员 - 执行 (ACDE)视频会议。Tim Beiko的总结。Tim Beiko和Christine Kim的记录：</p><ul><li>在 kurtosis 上继续对 devnet-8 和 MEV-Boost 工作流进行测试</li><li>在 Dencun 中添加了最大 epoch 流失限制（EIP7514），每个 epoch 的最大新质押者将被设置为 8；<br>Dankrad：EIP7514 <a href="https://notes.ethereum.org/@dankrad/churn-limit">给时间处理 Lido 攻击的经济&#x2F;技术影响</a></li><li>在 Dencun 中添加了用于 L2 费用计算的 BLOBBASEFEE 操作码（EIP7516）</li><li>EIP4788（EVM 中的信标块根）正在更新审计提出的调整</li><li>Devnet-9 将包括 EIP7514、EIP7516 和 EIP4788 的更改，ACDC 将确定启动日期</li><li><a href="https://docs.google.com/presentation/d/1alcw5tbqQ4NRkjoGE5YfBWKy3qFc_55CabbeyPI6IP0">Reth 介绍</a>：用 Rust 实现的执行层客户端，希望加入 devnet-9</li></ul></li></ul><h2 id="中心化观察：威胁你-ETH-的价值"><a href="#中心化观察：威胁你-ETH-的价值" class="headerlink" title="中心化观察：威胁你 ETH 的价值"></a>中心化观察：威胁你 ETH 的价值</h2><ul><li><p><a href="https://dune.com/hildobby/eth2-staking"><strong>Lido 达到 32.3%</strong></a><strong>，虽然有所减少，但仍非常接近</strong><a href="https://notes.ethereum.org/@djrtwo/risks-of-lsd"><strong>33%阈值</strong></a></p></li><li><p>客户端多样性（通过clientdiversity.org）：</p><ul><li>执行层：Geth 占据绝对多数，可能导致链分叉</li><li>共识层：Prysm 超过 33%，可能导致活跃性丧失漏洞</li></ul></li><li><p>需要更多的<a href="https://nodewatch.io/">质押者和节点地理多样性</a>，尤其是在美国&#x2F;加拿大&#x2F;欧盟以外的地区</p></li></ul><h2 id="Layer-1"><a href="#Layer-1" class="headerlink" title="Layer 1"></a>Layer 1</h2><ul><li><a href="https://twitter.com/christine_dkim/status/1701302000107782559">epoch 流失限制</a>从 11 增加到 12（Dencun 中的 EIP7514 将存款设置为 8）</li><li>MEV-build-rs <a href="https://mev-rs.pbs.dev/mev-build-rs.html">alpha</a>：用 Rust 实现的 MEV-Boost 构建器，扩展了 Reth（执行层客户端）</li></ul><h2 id="给质押者"><a href="#给质押者" class="headerlink" title="给质押者"></a>给质押者</h2><ul><li><a href="https://blog.chainsafe.io/the-lodestar-user-incentive-program-list-of-winners-dispute-period-9a3d66d98b7d">Lodestar 激励计划</a> 结果，86 个验证者瓜分 25,000 美元</li><li><a href="https://twitter.com/ethereumonarm/status/1701891496645956028">Geth 节点</a> 在 NanoPC-T6（价值 129 美元的板）上运行，13 小时同步完成</li><li><a href="https://mirror.xyz/ladislaus.eth/joTqwZ1sBLxlJayV4pIYxCkwl4RWheM_xipU_OCp9MM">Secure-signer</a>（alpha 版）：硬件隔离的远程签名</li><li><a href="https://twitter.com/vacp2p/status/1702289509252026467">Tor Push</a>：验证者隐私的概念验证，通过 Tor 将消息推送到 gossipsub</li></ul><h2 id="客户端版本"><a href="#客户端版本" class="headerlink" title="客户端版本"></a>客户端版本</h2><ul><li>共识层：<ul><li>Nimbus <a href="https://github.com/status-im/nimbus-eth2/releases/tag/v23.9.0">v23.9.0</a>：Holešky 测试网支持和简化的远程签名配置</li></ul></li><li>执行层：<ul><li>Geth <a href="https://blog.ethereum.org/2023/09/12/geth-v1-13-0">v1.13.0</a>：用基于路径的存储重新实现修剪（需要重新同步）</li></ul></li></ul><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><ul><li><a href="https://ethresear.ch/t/streamlining-fast-finality/16591">简化的快速最终性</a>：每个 slot 只有一个提案和投票阶段的强确认</li><li><a href="https://notes.ethereum.org/@mikeneuder/goldilocks">两层质押</a>：本地流动质押设计</li></ul><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><ul><li>EIPs<ul><li><a href="https://eips.ethereum.org/EIPS/eip-7516">EIP7516</a>：BLOBBASEFEE 操作码</li></ul></li><li>ERCs（应用层）：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7678/files">ERC7515</a>：元数据中的 NFT 替代文本</li><li><a href="https://github.com/ethereum/EIPs/pull/7682/files">ERC7517</a>：AI&#x2F;ML 数据挖掘的内容许可</li><li><a href="https://github.com/ethereum/EIPs/pull/7719/files">ERC7518</a>：全球合规的 STO 和可互操作的资产生命周期（ERC1155 扩展）</li></ul></li></ul><h2 id="开发者资料"><a href="#开发者资料" class="headerlink" title="开发者资料"></a>开发者资料</h2><ul><li><a href="https://twitter.com/parithosh_j/status/1702816780542984504">Holešky 测试网未能启动</a>，因为配置错误，预计两周后重新启动</li><li>Hardhat <a href="https://github.com/NomicFoundation/hardhat/releases/tag/hardhat%402.17.3">v2.17.3</a>：默认<code>evmVersion</code>修改为<code>paris</code>以适用于 solc v0.8.20 以上的版本（适用不支持上海升级的 L2）</li><li>如果直接从汇编块返回，就会<a href="https://twitter.com/zachobront/status/1699954240058277928">跳过修饰符中的不变式检查</a></li><li><a href="https://banteg.xyz/posts/minimal-proxies/">最小代理概述</a>：不可变参数的 ERC1167 变体和克隆</li><li><a href="https://medium.com/@vikram.arun/multichain-erc-4626-conformance-f34b682b273b">ERC4626 一致性</a>：20% 的资金库不符合规范</li><li><a href="https://github.com/kopy-kat/MinimalAccount#readme">MinimalAccount</a>（ERC4337）：用 Huff 实现的 gas 优化，用于基准测试</li><li><a href="https://dune.com/ilemi/erc-and-eip-starter-kit">ERC 部署</a>：Dune 仪表板显示常见 ERC 的部署数量</li><li><a href="https://github.com/shafu0x/huff-stack-generator#readme">Huff-stack-generator</a>：生成堆栈注释</li><li><a href="https://github.com/fjl/geas#readme">Geas</a>（优秀的以太坊汇编）：EVM 的宏汇编器</li><li>Slitherin（自定义 Slither 检测器）<a href="https://github.com/pessimistic-io/slitherin/releases/tag/v0.3.0">v0.3</a>：添加任意调用检测器</li><li><a href="https://x.com/CodeHawks/status/1702200846941823371">Vyper 编译器</a>审计竞赛</li><li>CTF：<ul><li><a href="https://onlypwner.xyz/documentation">ONLYPWNER</a>：CTF 平台，有9个挑战</li><li>Curta CTF <a href="https://github.com/hrkrshnn/notes/blob/main/2023/curta.md">谋杀之谜</a>和<a href="https://twitter.com/zigtur/status/1700945573166149830">解决方案</a></li><li>Secureum RACE #21：<a href="https://ventral.digital/posts/2023/9/5/race-21-of-the-secureum-bootcamp-epoch-infinity">8 个问题的 Solidity 测验和答案</a></li></ul></li><li>Paradigm 的<a href="https://twitter.com/gakonst/status/1701631039008084126">Rust x Ethereum 幻灯片和视频</a>：Reth、Foundry、Alloy、Ruint 和 wagmi&#x2F;viem &amp; Rivet</li><li><a href="https://hackmd.io/@knownothing/zk-face-id">ZK Face ID 钱包</a>（ERC4337）演示，用 WebAuthn 和 Halo2 证明</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>Balancer <a href="https://medium.com/balancer-protocol/rate-manipulation-in-balancer-boosted-pools-technical-postmortem-53db4b642492">两个 Linear Pools 漏洞的事后分析</a>：第一个漏洞悬赏了 100 万美元，第二个漏洞在主网和 Optimism 被利用，造成 120 万美元损失</li><li><a href="https://www.zellic.io/blog/browsing-for-bugs-3m-bug-in-premia-finance">寻找漏洞</a>：发现了一个 Premia 漏洞，300 万美元存在风险，已悬赏并修复</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li>MetaMask <a href="https://metamask.io/news/latest/snaps-in-metamask-stable-and-where-we-go-from-here/">Snaps beta</a>：用于交易安全、聊天和非 EVM 网络的钱包插件</li><li><a href="https://x.com/Uniswap/status/1701229817411342396">Uniswap UI</a>：自动检测转账代币的费用</li><li><a href="https://drop.gaslite.org/">Gaslite</a>：空投 ETH、ERC20 和 ERC721 代币，包括 ETH 给 Friend Tech 的密钥持有者</li><li><a href="https://twitter.com/optimismgov/status/1702748223847170261">Optimism</a>：直接分发未领取的 Airdrop 1 的 OP 代币</li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-8-5</title>
      <link href="/2023/08/19/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-8-5/"/>
      <url>/2023/08/19/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-8-5/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun-Cancun-Deneb-升级"><a href="#Dencun-Cancun-Deneb-升级" class="headerlink" title="Dencun (Cancun + Deneb) 升级"></a>Dencun (Cancun + Deneb) 升级</h2><ul><li><p>最新的所有核心开发者 - 共识（ACDC）<a href="https://www.youtube.com/watch?v=X46mbG8N5XM&t=350s">视频会议</a>。<a href="https://www.galaxy.com/insights/research/ethereum-all-core-developers-execution-call-167/">克里斯汀·金 (Christine Kim)</a>的注释：</p><ul><li><p>EIP4788（在 EVM 中记录信标块根）：同意使用合约而不是预编译，需要审计&#x2F;形式化验证，devnet 8 将等待实现它</p></li><li><p>EF devops 推出了 210 万个验证器测试网，为 Holešky 测试网做准备</p></li><li><p>EIP5806（委托交易）和 EIP7377（迁移交易）的介绍以及关于帐户抽象的更广泛讨论</p></li><li><p><a href="https://docs.google.com/presentation/d/1Hgke4EHtjHBaYrIA6WbToGip6eho6INBgvwG76BIw1M">Verkle Trie 更新</a>: 性能改进、通过覆盖方法进行迁移以及还有一些剩余问题。</p></li></ul></li><li><p>共识规范 <a href="https://github.com/ethereum/consensus-specs/releases/tag/v1.4.0-beta.1">v1.4.0-beta.1</a>: 数据 gas 更名为 blob gas 以及包含附加测试</p></li><li><p>EIP4844:</p><ul><li>Terence: <a href="https://twitter.com/terencechain/status/1686737819581202432">EIP4844 经济学</a></li><li><a href="https://ceremony.ethereum.org/">KZG 仪式</a> 有133k捐款, <a href="https://twitter.com/CarlBeek/status/1686723570234187776">贡献大厅空了</a>; <a href="https://blog.ethereum.org/2023/08/02/kzg-special-contributions">特别贡献清单</a> (从卫星到猫)</li><li><a href="https://twitter.com/jcksie/status/1687434139035750401">GossipSub 优化</a> (IDontWant &amp; 限制 flood 发布) 应会减少 Nimbus CL 客户端带宽消耗</li></ul></li></ul><h2 id="Layer-1"><a href="#Layer-1" class="headerlink" title="Layer 1"></a>Layer 1</h2><ul><li><p><a href="https://twitter.com/nero_eth/status/1686347380159926272">Reorg.pics</a>: 主网重组的仪表板</p></li><li><p>Goerli 测试网上的长访问的 Epoch 发生了重组</p><p>, 不太可能在主网上发生</p><ul><li>Ben Edgington在《升级以太坊》一书中的<a href="https://eth2book.info/capella/part2/consensus/issues/#casper-ffgs-fork-choice-can-cause-long-reorgs">解释</a></li></ul></li><li><p><a href="https://github.com/OffchainLabs/sszpp#readme">SSZ++</a>: 快速 SSZ 库，27 毫秒反序列化和 23 毫秒完整信标状态哈希，无需缓存</p></li><li><p>evmone 中的 <a href="https://twitter.com/teamipsilon/status/1687091771648671744">EVMMAX API 原型</a> : 允许实现大多数预编译</p></li></ul><h2 id="给质押者"><a href="#给质押者" class="headerlink" title="给质押者"></a>给质押者</h2><ul><li><a href="https://relay.wenmerge.com/">Wenmerge</a> 非过滤 MEV-Boost 中继</li></ul><h2 id="客户端更新"><a href="#客户端更新" class="headerlink" title="客户端更新"></a>客户端更新</h2><ul><li>共识层：<ul><li>Lodestar <a href="https://github.com/ChainSafe/lodestar/releases/tag/v1.10.0">v1.10.0</a>: 性能改进、NodeJS v20、IPv6 支持、带宽优化和 DVT 用户的 builderOnly 选项</li><li>Teku <a href="https://github.com/Consensys/teku/releases/tag/23.8.0">v23.8.0</a>: 状态缓存改进和最低 Java 版本更新至 Java 17</li></ul></li></ul><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a><strong>研究</strong></h2><ul><li>Vitalik: <a href="https://ethresear.ch/t/nuances-of-data-recoverability-in-data-availability-sampling/16256">数据可用性采样中数据可恢复性的细微差别</a></li><li><a href="https://efdn.notion.site/PEPC-FAQ-0787ba2f77e14efba771ff2d903d67e4">协议强制提议者承诺 </a>(PEPC) 常见问题解答</li><li><a href="https://ethresear.ch/t/relays-in-a-post-epbs-world/16278">中继后 ePBS</a> &amp; 提案最顶区块(ToB)支付</li><li>Potuz: <a href="https://ethresear.ch/t/three-dichotomies-in-epbs/16267">ePBS 中的三个二分法</a></li></ul><h2 id="Layer-2"><a href="#Layer-2" class="headerlink" title="Layer 2"></a><strong>Layer 2</strong></h2><ul><li>Offchain Labs <a href="https://offchain.medium.com/bold-permissionless-validation-for-arbitrum-chains-9934eb5328cc">BOLD</a> (有限流动性延迟): 提出了用于 Arbitrum 链无许可验证的争议协议，消除了<a href="https://twitter.com/DZack23/status/1687209094015504389">延迟攻击向量</a></li><li>Popcorn: <a href="https://twitter.com/gluk64/status/1687263207860166656">zkEVM 互相批评归因</a> 和营销主张</li></ul><h2 id="EIPs-标准"><a href="#EIPs-标准" class="headerlink" title="EIPs&#x2F;标准"></a>EIPs&#x2F;<strong>标准</strong></h2><ul><li>EIPs:<ul><li><a href="https://github.com/ethereum/EIPs/pull/7441/files">EIP7441</a>: 将区块提议者选举升级为 Whisk</li></ul></li><li>ERCs (应用层):<ul><li><a href="https://github.com/ethereum/EIPs/pull/7427/files">ERC7425</a>: 代币化储备</li><li><a href="https://github.com/ethereum/EIPs/pull/7432/files">ERC7432</a>: NFT 角色</li><li><a href="https://github.com/ethereum/EIPs/pull/7443/files">ERC7439</a>: 防止票务兜售（ERC721扩展）</li><li><a href="https://github.com/ethereum/EIPs/pull/7444/files">ERC7444</a>: 时间锁到期</li></ul></li></ul><h2 id="给开发者"><a href="#给开发者" class="headerlink" title="给开发者"></a>给开发者</h2><ul><li><p>Hardhat <a href="https://github.com/NomicFoundation/hardhat/releases/tag/hardhat@2.17.1">v2.17.1</a>: Solidity v0.8.21 支持、纯函数中的 console.log 和改进代码扁平化</p></li><li><p>Foundry:</p><ul><li>提示: 使用 lcov <a href="https://twitter.com/paulrberg/status/1686829173585649667">生成本地覆盖率报告</a> using lcov</li></ul></li><li><p>Dan Finlay’ Foundry 的 <a href="https://github.com/danfinlay/foundry-matt#readme">MATT 拍卖</a> (最大化 NFT 收入)， 使用 ERC20 授权来出价</p></li><li><p>web3.py <a href="https://snakecharmers.ethereum.org/websockets-v2/">WebSocketProviderV2</a>: 重写WebsocketProvider, beta版</p></li><li><p>CryptoZombies <a href="https://cryptozombies.io/en/optimism">Optimism NFT 课程</a>: 创建、测试和部署</p></li><li><p><a href="https://www.bunzz.dev/decipher">DeCipher</a>: 使用区块浏览器 URL 的合约文档生成器</p></li><li><p>Secureum RACE #20: <a href="https://ventral.digital/posts/2023/7/30/race-20-of-the-secureum-bootcamp-epoch-infinity">8 个问题 Solidity 测验和答案</a></p></li><li><p>安全</p><ul><li><p>Vyper 在 v0.2.15&#x2F;16 和 v0.3.0 中重入锁故障,Curve 价值 7000 万美元的漏洞影响了 Alchemix, JPEG’d &amp; Metronome, 返回了一些Alchemix&amp;JPEG’d的资金</p><ul><li>潜在 <a href="https://github.com/banteg/vyper-reentrancy/#readme">脆弱的 Vyper 合约</a></li></ul></li><li><p>Base 上的LeetSwap (Solidly 分叉) <a href="https://twitter.com/blocksecteam/status/1686217464051539968">被利用</a>, 池通过内部函数被作为公开函数，而被操纵</p></li><li><p>2000 万美元发送到 <a href="https://twitter.com/tayvano_/status/1686418992599273472">垃圾投毒地址</a>, USDT 随后被冻结</p></li><li><p><a href="https://github.com/emilianobonassi/whitehacks-kit#readme">Whitehacks 套件</a>: 使用 Flashbots 在单个交易中执行操作的 Foundry 模板</p></li><li><p>使用注释的 <a href="https://github.com/aviggiano/solidity-audit-report-generator#readme">Solidity 审计报告生成器</a> (VSCode 插件)</p></li></ul></li></ul><h2 id="生态相关"><a href="#生态相关" class="headerlink" title="生态相关"></a><strong>生态相关</strong></h2><ul><li><a href="https://blog.ethereum.org/2015/07/30/ethereum-launches">以太坊主网推出</a> 八周年</li><li>Ethereum.org <a href="https://twitter.com/ethdotorg/status/1686377458529075200">翻译马拉松</a>: 翻译网站即可赢取奖品</li><li>Tx <a href="https://www.tx.cool/chat">聊天对话</a>: 类似聊天的界面，用于浏览链上消息的地址</li><li>Golem <a href="https://golem.foundation/2023/07/28/epoch-zero-results.html">Octant Epoch Zero</a>: 100 万美元分配给 10 个公共产品项目</li><li><a href="https://thedefiant.io/large-crv-backed-loans-threaten-to-destabilize-defi">Curve 联合创始人 Michael Egorov </a>在 Curve 漏洞利用后去杠杆化</li><li>用于预防垃圾攻击同时保持匿名的 <a href="https://mirror.xyz/privacy-scaling-explorations.eth/iCLmH1JVb7fDqp6Mms2NR001m2_n5OOSHsLF2QrxDnQ">Rate-limiting nullifier</a> (RLN)， 为可信仪式做贡献</li><li><a href="https://twitter.com/gitcoin/status/1686291853446926336">Gitcoin Grants 18</a> 申请开放</li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-8-26</title>
      <link href="/2023/08/13/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-8-26/"/>
      <url>/2023/08/13/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-8-26/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun-Cancun-Deneb-升级"><a href="#Dencun-Cancun-Deneb-升级" class="headerlink" title="Dencun (Cancun + Deneb) 升级"></a>Dencun (Cancun + Deneb) 升级</h2><ul><li><p>最新的所有核心开发人员 - 执行 (ACDE)视频会议。Christine Kim的记录：</p><ul><li>Dencun<a href="https://notes.ethereum.org/@ethpandaops/dencun-testing-overview">测试概述</a></li><li>devnet 9 和升级公共测试网的时间表将在下次 ACDE 电话会议上讨论</li></ul></li><li><p><a href="https://twitter.com/CarlBeek/status/1694566774375698789">KZG 仪式</a>圆满结束，共 141,416 贡献者，这是有史以来规模最大的仪式</p></li></ul><h2 id="Layer-1"><a href="#Layer-1" class="headerlink" title="Layer 1"></a>Layer 1</h2><ul><li>Holešky 测试网（替代Goerli）<ul><li><a href="https://twitter.com/parithosh_j/status/1694041437300535399">创世文件已生成</a>，于 9 月 15 日启动，拥有 146 万个验证者</li><li>ACDC 同意将 Shapella 升级的 epoch 时间从 10 调整为256，验证者踢出余额调整为 28 hETH ，并支持压缩创世状态.</li></ul></li><li>Dapplion：<a href="https://hackmd.io/@dapplion/expensive_duty_discovery">Whisk (SSLE) 昂贵的职责发现（duty discovery）</a>可以用验证者的公钥来解决</li></ul><h2 id="给质押者"><a href="#给质押者" class="headerlink" title="给质押者"></a>给质押者</h2><ul><li>基于来自大型质押池和实体的自我报告数据，<a href="https://twitter.com/hanni_abu/status/1694300131598680292">绝大多数执行层客户端仍然是Geth</a></li><li><a href="https://lighthouse-blog.sigmaprime.io/Siren.html">Siren v1</a>（Lighthouse 的验证器管理 UI）：监控节点和验证器健康状况</li></ul><h2 id="客户端版本"><a href="#客户端版本" class="headerlink" title="客户端版本"></a>客户端版本</h2><ul><li>共识层：<ul><li>Nimbus <a href="https://github.com/status-im/nimbus-eth2/releases/tag/v23.8.0">v23.8.0</a>：性能和稳定性改进</li><li>Prysm <a href="https://github.com/prysmaticlabs/prysm/releases/tag/v4.0.8">v4.0.8</a>：减少内存使用</li></ul></li><li>执行层：<ul><li>Besu <a href="https://github.com/hyperledger/besu/releases/tag/23.7.1">v23.7.1</a>：EVM 工具和 RPC 跟踪模块的性能和稳定性改进、更新依赖项和扩展功能</li><li>Reth <a href="https://github.com/paradigmxyz/reth/releases/tag/v0.1.0-alpha.7">v0.1.0-alpha.7</a>：修复爬虫到达节点问题、RPC 和 txpool 以及帐户的 eth_getProof 初步支持</li></ul></li></ul><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><ul><li><a href="https://ethresear.ch/t/super-finality-high-safety-confirmation-for-casper/16429">Casper的超级确定性</a> 确认规则，可以使用Beacon API 在客户端&#x2F;钱包中实现</li><li><a href="https://ethresear.ch/t/proof-of-validator-a-simple-anonymous-credential-scheme-for-ethereums-dht/16454">验证器证明</a>：分布式哈希表参与者的匿名凭证方案</li></ul><h2 id="Layer-2"><a href="#Layer-2" class="headerlink" title="Layer 2"></a>Layer 2</h2><ul><li><p>RISC Zero <a href="https://www.risczero.com/news/zeth-release">Zeth</a>：基于 revm 的 zk 区块生成证明器（zkEVM）</p></li><li><p>Base</p><p>使用升级多重签名 2&#x2F;2 （Optimism Foundation &amp; Base）</p><ul><li>Coinbase 将向 Optimism Collective 贡献至少 2.5% 的 Base 排序器收入，用于 RetroPGF 和生态系统项目 </li><li><a href="https://optimism.mirror.xyz/Luegue9qIbTO_NZlNVOsj25O1k4NBNKkNadp2d0MsTI?a">Optimism</a> 在 6 年内向 Coinbase 授予约 1.18 亿个 OP 代币（占供应量的 2.7%）</li></ul></li></ul><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><ul><li>更新了<a href="https://eips.ethereum.org/EIPS/eip-5069">EIP 编辑手册</a>(EIP5069)</li><li>ERC（应用层）：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7502/files">ERC7502</a>：可自交易的NFT</li><li><a href="https://github.com/ethereum/EIPs/pull/7522/files">ERC7503</a>：零知识虫洞</li><li><a href="https://github.com/ethereum/EIPs/pull/7523/files">ERC7504</a>：动态合约（一对多代理合约）</li></ul></li></ul><h2 id="开发者资料"><a href="#开发者资料" class="headerlink" title="开发者资料"></a>开发者资料</h2><ul><li>Foundry:<ul><li>Vulcan <a href="https://twitter.com/nomoixyz/status/1694421244798460067">v0.2.0</a>（开发框架）：添加gas估算和部署地址计算</li><li><a href="https://twitter.com/rjected/status/1694072110971248666">使用 jwt 秘密的 Cast rpc</a>允许Engine API 调用执行层</li></ul></li><li>使用 ScaffoldETH-2 和 The Graph 的<a href="https://github.com/kmjones1979/full-stack-dapp-workshop#readme">全栈 dapp workshop</a></li><li>Ape 框架<a href="https://mirror.xyz/apeworx.eth/gCGyXvzzwbTOLnr7rUzXPWFWkCVDjMs1haOcIj0Q2Hc">代码覆盖测试</a>指南</li><li><a href="https://github.com/wolovim/ape-hackathon-kit#readme">Ape-hackathon-kit</a>：在 Ape 框架中开发合约，在 Next.js、Tailwind、RainbowKit 和 wagmi 中开发 Web 应用程序</li><li>WhatsABI <a href="https://github.com/shazow/whatsabi/releases/tag/v0.8.0">v0.8.0</a>（字节码推测 ABI）：使用 ethers.js v5&#x2F;6 和 viem 进行测试，包大小减少到 12KB</li><li>区块索引公共物品 TrueBlocks <a href="https://github.com/TrueBlocks/trueblocks-core/releases/tag/v1.0.0-release">v1</a> 发布和<a href="https://tjayrush.medium.com/trueblocks-final-report-for-ef-grant-d784653c830d">给以太坊基金会的Grant报告</a></li><li>tx2uml <a href="https://twitter.com/naddison/status/1693512699249086702">v1.1.23</a>：添加选项方便隐藏参数名称&#x2F;值；<a href="https://github.com/naddison36/tx2uml/releases/tag/v1.1.24">v1.1.24</a>支持 Base 链</li><li>wagmi <a href="https://github.com/wagmi-dev/mipd#readme">mipd</a>：用于 ERC6963 （多注入 Provider 发现）的 TypeScript 实用程序</li><li>CTF：<ul><li>Curta CTF：<a href="https://twitter.com/devtooligan/status/1694746398326128777">devtooligan 的 Elohim 解决方案</a></li><li><a href="https://ctf.paradigm.xyz/">Paradigm CTF</a> 10 月 28-30 日</li></ul></li><li><a href="https://github.com/banteg/cryogen#readme">Cryogen</a>：实现更小的数据集和更快的查询</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li><a href="https://twitter.com/balancer/status/1694014645378724280">Balancer v2 池漏洞曝光</a>，受影响的 LP 赎回</li></ul><h2 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h2><ul><li><a href="https://twitter.com/dannyryan/status/1694709761412087989">Danny Ryan</a>反驳了<a href="https://hackmd.io/@sacha/on-the-risks-of-lsd">Lido 的说法：即随着 Lido 持股比例接近 33%，双重治理</a>可以减轻以太坊的风险</li><li>黑客马拉松项目：<a href="https://dorahacks.io/hackathon/ethtoronto2023/buidl">ETHToronto</a>、<a href="https://dorahacks.io/hackathon/ethwomen/buidl">ETHWomen</a>和<a href="https://taikai.network/ethargentina/hackathons/buildathon-2023/projects">以太坊阿根廷</a></li><li>Etherscan 添加 <a href="https://twitter.com/etherscan/status/1695031093043626181">搜索栏快捷方式</a>：按 “&#x2F;” 键快捷进入搜索栏</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li>隐私和扩展探索<a href="https://mirror.xyz/privacy-scaling-explorations.eth/p3Mtft28FG1ctgeUARVEKLTK_KexnWC6T4CUHaQark4">Bandada v1</a>：创建&#x2F;管理隐私保护匿名组</li><li>ScopeLift：<a href="https://www.scopelift.co/blog/dao-voting-from-layer-2-with-flexible-voting">利用 Layer 2 进行 DAO 投票，使用灵活投票</a>、概念证明</li><li>Base 应用：<ul><li><a href="https://twitter.com/friendtech/status/1694880415318954358">Friend Tech</a>增加了与 Key 持有者的照片共享功能</li><li><a href="https://www.storybase.xyz/">StoryBase</a>：按角色付费协作写作，以 NFT 形式铸造的片段</li><li><a href="https://citibike.xyz/frequently-asked-questions.html">自行车比赛</a>模仿：在 10 天的比赛中铸造&#x2F;窃取 NYC Citi Bikes 的 NFT</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-8-19</title>
      <link href="/2023/08/07/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-8-19/"/>
      <url>/2023/08/07/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-8-19/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun-Cancun-Deneb-升级"><a href="#Dencun-Cancun-Deneb-升级" class="headerlink" title="Dencun (Cancun + Deneb)升级"></a>Dencun (Cancun + Deneb)升级</h2><ul><li><p>最新的所有核心开发人员 - 执行 (ACDE)视频会议。Tim Beiko的总结。Tim Beiko和Christine Kim的记录：</p><ul><li><a href="https://twitter.com/parithosh_j/status/1691927807230677133">Devnet-8 启动</a>，所有 Dencun EIP、Besu 和 Erigon EL 客户端仍待加入</li></ul></li><li><p>EIP4788（EVM信标块根）合约将以单独的交易部署</p><ul><li>Holešky 测试网将支持 16亿 ETH 供应量</li></ul></li><li><p>ERC 从 EIP 库中分离出来，EIP 编辑团队仍是同一个组织</p><ul><li>提出 EIP7212（用于 secp256r1 椭圆曲线中签名验证的预编译）</li></ul></li><li><p><a href="https://ceremony.ethereum.org/">KZG 仪式</a>已有 138k 贡献者，将于 8 月 23 日停止接收贡献</p></li></ul><h2 id="Layer-1"><a href="#Layer-1" class="headerlink" title="Layer 1"></a>Layer 1</h2><ul><li>集成 builder-searcher 比率提升 ，<a href="https://twitter.com/specialmech/status/1691178038640492544">动画图表</a>显示自合并以来各类构建者每月构造区块份额的变化过程</li><li>Dapplion：<a href="https://hackmd.io/@dapplion/whisk_induced_missed_slots">Whisk（SSLE）导致错过初始 slot</a>，提案修复边缘情况</li></ul><h2 id="给质押者"><a href="#给质押者" class="headerlink" title="给质押者"></a>给质押者</h2><ul><li><a href="https://x.com/lodestar_eth/status/1691495095948980224">出现内存不足错误的 Lodestar v1.10 节点</a>，建议将 NodeJS 版本升级到 nodeJS v20</li><li><a href="https://blog.obol.tech/performance-testing-distributed-validators/">Obol DVT 性能测试</a>：与传统验证者差异小于 1%</li></ul><h2 id="客户端版本"><a href="#客户端版本" class="headerlink" title="客户端版本"></a>客户端版本</h2><ul><li>执行层：<ul><li>Geth <a href="https://github.com/ethereum/go-ethereum/releases/tag/v1.12.2">v1.12.2</a>：修复了一些社区报告的回归测试发现的问题</li></ul></li></ul><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><ul><li>提案<a href="https://ethresear.ch/t/no-free-lunch-a-new-inclusion-list-design/16389">包含列表设计</a>，分为提议者签名摘要和未签名的交易列表，解决免费数据可用性问题</li></ul><h2 id="Layer-2"><a href="#Layer-2" class="headerlink" title="Layer 2"></a>Layer 2</h2><ul><li>Arbitrum One <a href="https://twitter.com/hkalodner/status/1692586523919532348">批量发布者在 Gas 价格飙升期间短暂停止工作</a>，用户仍然可以进行交易</li><li><a href="https://davidecrapis.notion.site/Rollups-are-Real-Rollup-Economics-2-0-2516079f62a745b598133a101ba5a3de">Rollup 经济学 v2</a>：运作一个有盈余、福利社、联盟和layer 3</li></ul><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><ul><li><a href="https://github.com/ethereum/EIPs/issues/6990#issuecomment-1648535814">EIP&#x2F;ERC 编号</a>从 7500开始改为连续编号， 而不是使用 PR 编号</li><li>EIP：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7495/files">EIP7495</a>：SSZ PartialContainer： 引入一个新的 Simple Serialize ( SSZ )类型来表示<code>PartialContainer [ T , N ]</code>值。 <code>PartialContainer [T, N] </code>是一个 SSZ <code>Container</code>，即使单个字段成为可选字段或将来引入新字段，也具有稳定的序列化和默克尔化。</li></ul></li><li>ERC（应用层）：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7484/files">ERC7484</a>：智能合约帐户的注册表适配器</li><li><a href="https://github.com/ethereum/EIPs/pull/7492/files">ERC7492</a>：ERC20Spendable（ERC20扩展）</li><li><a href="https://github.com/ethereum/EIPs/pull/7500/files">ERC7500</a>：NFT动态特征</li><li><a href="https://github.com/ethereum/EIPs/pull/7501/files">ERC7501</a>：可赎回 NFT</li></ul></li></ul><h2 id="开发者资料"><a href="#开发者资料" class="headerlink" title="开发者资料"></a>开发者资料</h2><ul><li>Remix <a href="https://medium.com/remix-ide/remix-release-v0-35-0-9d955a9c853d">v0.35.0</a>：添加了许可证、可见性和可变性的快速修复功能</li><li>Foundry:<ul><li><a href="https://github.com/Will-Smith11/sks#readme">SKS</a>：代替子模块（Git Submodules），用于安装依赖项的包管理器脚本</li><li>提示：<a href="https://x.com/paulrberg/status/1692245880584142978">在合约导入路径中使用 src</a>以兼容 Hardhat</li></ul></li><li>OpenZeppelin Contracts 低严重性问题：<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-g4vp-m682-qqmp"><code>ERC2771Context</code>与自定义转发器一起使用</a>可能导致<code>_msgSender</code>返回<code>address(0)</code>，已在 v4.9.3 中修复</li><li>RareSkills：<a href="https://www.rareskills.io/post/solidity-style-guide">Solidity 风格指南</a></li><li><a href="https://github.com/banteg/vyper-cwia#readme">具有 immutable 参数的 Vyper 克隆</a>：与 CWIA 代理工厂兼容的示例合约</li><li><a href="https://twitter.com/bantg/status/1692239278158352778">用 Vyper 实现的 ERC6909</a>（最小多代币接口）</li><li><a href="https://twitter.com/naddison/status/1692178021061738706">Sol2uml diff</a>可以将 Etherscan 验证的合约与本地文件进行对比</li><li>WhatsABI <a href="https://github.com/shazow/whatsabi/releases/tag/v0.7.0">v0.7</a>（从字节码猜测 ABI）：支持代理合约</li><li>heimdall-rs <a href="https://twitter.com/BeckerrJon/status/1690453110265892865">v0.5.0</a>添加合约快照模块</li><li>Nethereum <a href="https://github.com/Nethereum/Nethereum/releases/tag/4.16.0">v4.16</a> (.NET)：添加数据服务包以便与 Etherscan&#x2F;Sourcify&#x2F;4Bytes 交互、使用 RPC 批处理的多重查询， ABI 解码和 ABI 存储的额外扩展</li><li><a href="https://wtf.allwallet.dev/week-19/">钱包测试框架</a>测试：当前需要 window.ethereum（不包括移动钱包）和自定义网络支持</li><li>Cryo <a href="https://github.com/paradigmxyz/cryo/releases/tag/0.2.0">v0.2</a>（提取区块链数据）：添加 python 适配器，合约和 <code>native_transfers</code> 数据集、交易选择器、命令链和摘要报告</li><li>Dune SQL 和以太坊数据分析<a href="https://web3datadegens.substack.com/p/advanced-wizard-guide-to-dune-sql">高级指南</a></li><li><a href="https://github.com/rymnc/erc-5564-bn254#readme">ERC5564（隐形地址）bn254</a>：使用 <code>arkworks-rs</code> 和 RLN 为属于其他成员集的用户生成可衍生的承诺并将其添加到其他成员中</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>ExactlyProtocol 通过未经验证的输入漏洞被<a href="https://twitter.com/BlockSecTeam/status/1692533280971936059">利用 700 万美元</a></li><li>Zunami 协议通过捐赠操纵价格<a href="https://twitter.com/BlockSecTeam/status/1690931111776358400">200 万美元漏洞被利用</a></li><li>RocketSwap 部署者私钥泄露<a href="https://twitter.com/rocketswap_labs/status/1691229656593371136">87 万美元被利用</a>，</li><li><a href="https://hackmd.io/@Deivitto/The-Auditor-Toolbox">审计工具箱</a>：带有 Foundry、Halmos、Heimdall、Slither、Echidna 和 Mythril 等的 docker</li><li><a href="https://www.auditwizard.io/blog/audit-wizard-beta-launch">审计向导</a>：使用合约地址或 GitHub，使用 Slither 扫描，查看 AST 并生成图表，测试版</li><li>Trail of Bits：<a href="https://blog.trailofbits.com/2023/08/14/can-you-pass-the-rekt-test/">Rekt Test</a> 12 个用于评估安全性的是&#x2F;否问题（以 Joel Test 为模型）</li></ul><h2 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h2><ul><li><p><a href="https://www.gitcoin.co/blog/announcing-gitcoin-grants-18">Gitcoin Grants 18</a>已开放</p><blockquote><p>欢迎大家为 <a href="https://explorer.gitcoin.co/#/round/10/0x30c381033aa2830ceb0aa372c2e4d28f004b3db9/0x30c381033aa2830ceb0aa372c2e4d28f004b3db9-27">登链社区</a> 和 <a href="https://explorer.gitcoin.co/#/round/10/0x30c381033aa2830ceb0aa372c2e4d28f004b3db9/0x30c381033aa2830ceb0aa372c2e4d28f004b3db9-29">Decert.me</a> 捐赠</p></blockquote></li><li><p><a href="https://blog.ethereum.org/2023/08/15/allocation-update-q2-23">EF 第二季度受资助者</a>将分享 900 万美元资金</p></li><li><p>ETHGlobal <a href="https://twitter.com/ETHGlobal/status/1692603548180132114">Superhack（OP Stack）决赛入围者</a></p></li><li><p>ETH慕尼黑<a href="https://twitter.com/ethmunich/status/1692603827550122004">黑客马拉松获奖者</a></p></li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li>OpenSea <a href="https://opensea.io/blog/articles/creator-fees-update">创建者版税</a>变为可选，包括使用市场过滤器的 L2 和 NFT</li><li>CoW Swap <a href="https://blog.cow.fi/cow-swap-launches-twap-orders-d5583135b472">时间加权平均价格 (TWAP) 订单</a></li><li><a href="https://blog.connext.network/announcing-the-next-airdrop-be764b1c548">Connext 治理代币</a>，使用 xERC20 跨链空投</li><li>Anish 的<a href="https://twitter.com/_anishagnihotri/status/1690455865382318081">FriendMEX</a>，Friend Tech 的专业风格界面，无需邀请码</li><li><a href="https://twitter.com/brian_armstrong/status/1690790384757321728">Brian Armstrong</a>：Coinbase 需要改进 NFT、Dapp 和 L2 的应用程序用户体验</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>Vitalik：发表 <a href="https://vitalik.eth.limo/general/2023/08/16/communitynotes.html">X（Twitter）社区笔记</a>，具有“加密价值”的机制设计</li><li>Patrick McCorry：发表 <a href="https://www.cryptofrens.info/p/understanding-crypto-in-africa">非洲的加密货币</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-8-12</title>
      <link href="/2023/08/04/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-8-12/"/>
      <url>/2023/08/04/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-8-12/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun-Cancun-Deneb-升级"><a href="#Dencun-Cancun-Deneb-升级" class="headerlink" title="Dencun (Cancun + Deneb) 升级"></a>Dencun (Cancun + Deneb) 升级</h2><ul><li><p>最新的所有核心开发人员 - 执行 (ACDE)视频会议。Tim Beiko的总结。Tim Beiko和Christine Kim的记录：</p><ul><li>Devnet 8 计划于下周初启动 </li><li>共识层分叉选择过滤逻辑的更改将与 Deneb 版本捆绑在一起</li></ul></li><li><p>EIP4788（EVM 信标块根）<a href="https://github.com/lightclient/4788asm#readme">合约草案</a>，欢迎来 gas 优化</p></li><li><p>最新 Dencun 测试<a href="https://www.youtube.com/watch?v=fQ6ugSRi3DA&t=160s">视频会议</a>（之前的 EIP4844 会议）</p></li><li><p><a href="https://ceremony.ethereum.org/">KZG 仪式</a>已有 136k 贡献者，将于 8 月 23 日停止接收贡献</p></li></ul><h2 id="Layer-1"><a href="#Layer-1" class="headerlink" title="Layer 1"></a>Layer 1</h2><ul><li>EthereumJS <a href="https://twitter.com/efjavascript/status/1689653616079208449">v7</a>：支持 ESM ，删除缓冲区，降低依赖性，减小构建大小，现在默认支持上海升级和 Cancun 升级</li><li>EF devops 启动了 3 倍主网规模（210 万验证者）的大型测试网来测试目前的客户端状态能处理多大的网络，三次尝试仍有问题，改为2倍主网规模(140万验证者)后出块速度接近主网，<a href="https://twitter.com/parithosh_j/status/1689753694487646208">Holešky 测试网会将140万验证者的规模视为稳定起点</a></li><li><a href="https://ethereum-magicians.org/t/introducing-eth2-package-a-tool-for-spinning-up-private-testnets-in-a-single-command/15390">Kurtosis eth2-package</a>，支持云中多节点执行层&#x2F;共识层测试网和任何客户端组合（包括 Reth），与 Grafana 和 Prometheus 一起开箱即用</li><li>Verkle Tries：<ul><li><a href="https://hackmd.io/@jsign/vkt-preimage-generation-and-distribution">Verkle 原像</a>生成和分发策略</li><li><a href="https://notes.ethereum.org/@rudolf/migration">Verkle Trie 迁移选项</a>：只读与可写 Merkle 树</li></ul></li><li><a href="https://twitter.com/EigenPhi/status/1689887764077273088">Flashbots 构建器故障</a>，在恢复捆绑交易的过程中处理不当</li></ul><h2 id="给质押者"><a href="#给质押者" class="headerlink" title="给质押者"></a>给质押者</h2><ul><li>信标链的<a href="https://twitter.com/superphiz/status/1689918550050291713">churn 限制已增加到每个 epoch 11 个验证者</a></li><li>目前运行以太坊节点最便宜的配置-<a href="https://twitter.com/EthereumOnARM/status/1689327953052577804">NanoPC-T6</a>，约 300 美元，可运行完整节点</li><li><a href="https://twitter.com/bloxroutelabs/status/1690065892778926080">bloXroute Ethical 中继</a>正在逐步废止（过滤广义抢跑交易和夹子交易）</li></ul><h2 id="客户端版本"><a href="#客户端版本" class="headerlink" title="客户端版本"></a>客户端版本</h2><ul><li>执行层：<ul><li>Geth <a href="https://github.com/ethereum/go-ethereum/releases/tag/v1.12.1">v1.12.1</a>：维护版本，包括 Dencun 的开发</li><li>Reth <a href="https://github.com/paradigmxyz/reth/releases/tag/v0.1.0-alpha.6">v0.1.0-alpha.6</a>：跟进修复 alpha.5 中处理重组的问题</li></ul></li></ul><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><ul><li><a href="https://ethresear.ch/t/the-second-slot-itch-statistical-analysis-of-reorgs/16333">第二个 slot 重组</a>：slot 指数影响重组的可能性</li><li><a href="https://ethresear.ch/t/empirical-analysis-of-builders-behavioral-profiles-bbps/16327">Builder 行为概况</a>(BBP)：涵盖 MEV-Boost 拍卖期间构建区块和投标时的功能和策略的指标</li><li><a href="https://mirror.xyz/ohotties.eth/lBEXiiU7yK91OuSn8QyJPM9Db8GuyDFzCEUAj60BWyI">强制协议提案者承诺</a>(PEPC) 介绍</li><li><a href="https://eprint.iacr.org/2023/1197">抗量子弱可验证延迟函数</a>，一种基于纯代数构造的新的抗量子弱可验证延迟函数。它的延迟取决于计算椭圆曲线之间的高度同源性，而其验证则依赖于两条椭圆曲线乘积的同源性计算。</li></ul><h2 id="Layer-2"><a href="#Layer-2" class="headerlink" title="Layer 2"></a>Layer 2</h2><ul><li>Coinbase <a href="https://base.mirror.xyz/KPrKIukePtM2Iz945_3GpQJ-tgMf1hoato5isStLXJI">Base</a>（OP Stack rollup）向公众开放（<a href="https://onchainsummer.xyz/">链上夏季</a>促销活动）</li></ul><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><ul><li>EIP：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7480/files">EIP7480</a>：EOF – 数据指令</li></ul></li></ul><h2 id="开发者资料"><a href="#开发者资料" class="headerlink" title="开发者资料"></a>开发者资料</h2><ul><li>Solmate <a href="https://github.com/transmissions11/solmate/pull/380">v6.2.0</a>：修复 SignedWadMath:wadMul 中的静默溢出问题；这个问题是用 Trail of Bits Medusa<a href="https://twitter.com/Montyly/status/1688603604062482433">发现</a>的</li><li><a href="https://github.com/jtriley-eth/iter-sol#readme">Iter</a>：用 Solidity 实现的惰性评估迭代器 </li><li><a href="https://twitter.com/msolomon44/status/1688656321053425664">Cove</a>：合约验证，alpha 版， 为 Solidity Foundry 项目准备，使用部署 tx 哈希进行合约验证</li><li>EVM Diff <a href="https://twitter.com/msolomon44/status/1689656505652690945">更新</a></li><li><a href="https://github.com/alexfertel/bulloak#readme">Bulloak</a>：基于分支树技术的 Solidity 测试生成器</li><li>深入研究 <a href="https://jtriley.substack.com/p/the-vyper-compiler">Vyper 编译器</a></li><li>Fe <a href="https://github.com/ethereum/fe/releases/tag/v0.24.0">v0.24.0</a>：增加支持用户定义库</li><li>Halmos <a href="https://github.com/a16z/halmos/releases/tag/v0.1.2">v0.1.2</a>（符号测试）：添加支持 DELEGATECALL、CALLCODE、CREATE2、结构类型作为测试参数和库链接</li><li><a href="https://github.com/Cozy-Finance/agent-buttercup#readme">Agent Buttercup</a>：面向 DeFi 研究人员&#x2F;工程师的基于代理的模拟引擎，使用 revm</li><li>yAcademy <a href="https://twitter.com/yAcademyDAO/status/1687891681423634432">zk 审计奖学金模块</a>：zk、Rate-limiting Nullifier 和 Spartan-ECDSA</li><li>CTF：<ul><li>Flashbots <a href="https://github.com/minaminao/ctf-blockchain/tree/main/src/MEVShareCTF#readme">MEV-Share CTF 解决方案</a></li><li>Curta CTF <a href="https://twitter.com/zachobront/status/1688247687613743105">公牛比利解决方案</a></li></ul></li><li><a href="https://mirror.xyz/privacy-scaling-explorations.eth/TuLZRdgCQsydC8JJgCNH4F7GzifRBQ6fr31DHGLFVWM">p0tion v1</a>：Groth16 zk 应用程序开发工具包</li><li><a href="https://blog.phylum.io/typosquat-of-popular-ethereum-package-steals-private-keys/">Noble curvetyposquat</a>：恶意 npm包将私钥发送到远程服务器</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>Steadefi 在 Arbitrum 和 alt-L1 上通过被入侵的协议部署者钱包<a href="https://twitter.com/steadefi/status/1688638572608552960">被盗 110 万美元</a></li><li><a href="https://kebabsec.xyz/posts/critical_vulnerability_in_uniswapx/">UniswapX 订单漏洞披露</a>，已修复并支付 20 万美元赏金</li><li><a href="https://hackmd.io/@vyperlang/HJUgNMhs2">Vyper</a> v0.2.15&#x2F;16 和 v0.3.0 中不可重入锁漏洞的事后分析</li><li><a href="https://twitter.com/samczsun/status/1688613385565528064">SEAL 911</a>：紧急情况下通过 Telegram 机器人联系安全社区</li></ul><h2 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h2><ul><li><a href="https://twitter.com/dannyryan/status/1688644951230267392">Danny 回应那些试图让中心化变化变常规的人</a>：Lido 超过 33% 的 ETH 质押对以太坊构成威胁</li><li>EF 下一个十亿奖学金：第 3 组的五个<a href="https://blog.ethereum.org/2023/08/07/nb-fellows-cohort-3">人物故事</a></li><li>Etherscan<a href="https://twitter.com/etherscan/status/1689984336274284544">相似合约搜索</a>更新，可以跨 Etherscan 链搜索</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li>Rune 的<a href="https://twitter.com/runekek/status/1688571159367823360">Maker 终极之战</a>和<a href="http://forum.makerdao.com/t/sparkdao-spk-pre-farming-airdrop-general-subdao-farming-overview/21595">SubDAO 挖矿概述</a></li><li>Maker<a href="https://twitter.com/runekek/status/1688991177843019778">增强型 DSR</a>（Dai 储蓄率）从 8% 开始，降至 5.8%</li><li><a href="https://nexusmutual.io/blog/nexus-mutual-expands-cover-capacity-in-the-uk-with-on-chain-capital">Nexus Mutual</a>通过 Retail Mutual 为英国小型零售商提供覆盖</li><li>安全<a href="https://twitter.com/safe/status/1689313162817093633">社交登录</a>：在 iOS 上使用 Google 或 Apple ID 注册，实验性</li><li><a href="https://twitter.com/smoldapp/status/1689998191289139200">MultiSafe</a>：将 Safe 克隆或部署到具有相同地址的多个链</li><li><a href="https://twitter.com/y00tsNFT/status/1689404417072889867">Y00ts</a> NFT 在之前从 Solana 迁移到 Polygon 后迁移到以太坊</li><li>DAO 关闭并分发 Arbitrum 空投：<a href="https://www.saddle.community/t/sip-x-protocol-operations-and-treasury-management/632">Saddle</a>（Curve fork）和<a href="https://twitter.com/hundredfinance/status/1689358397898887168">Hundred Finance</a></li><li>Base 应用：<ul><li><a href="https://basepaint.xyz/">BasePaint</a>：共享像素画布，每24小时开放版NFT</li><li><a href="https://twitter.com/0xsmallbrain/status/1689404151166570496">Words3</a>：价格波动的字母拼字游戏，游戏本周末结束</li><li><a href="https://twitter.com/phabcd/status/1690061905468010496">Friend Tech</a>：在移动设备上通过 DM、PWA 购买人员股份，仅限受邀者</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-7-8</title>
      <link href="/2023/08/02/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-7-8/"/>
      <url>/2023/08/02/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-7-8/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun-Cancun-Deneb-升级"><a href="#Dencun-Cancun-Deneb-升级" class="headerlink" title="Dencun (Cancun + Deneb) 升级"></a>Dencun (Cancun + Deneb) 升级</h2><ul><li>最新的所有核心开发者会议 – 执行（ACDE）<a href="https://www.youtube.com/watch?v=Voavkk8Es5E&t=78s">视频会议</a>。来自<a href="https://www.galaxy.com/research/insights/ethereum-all-core-developers-execution-call-165/">Christine Kim</a>的说明：</li><li><a href="https://docs.google.com/document/d/1p-1VvOGwI5GHkwaGMzJYDL7Affofm6rVLa6cvnmoqGI/edit">EIP6404&#x2F;6466 SSZ 过渡的影响</a>对使用RLP的现有合约的影响：EIP6404 的影响较小，而EIP6466 由于 3个项目受影响，依旧是可以管理 【提醒：SSZ EIPs已经从 Dencun 升级中删除】</li><li>Dencun更新：<a href="https://notes.ethereum.org/@parithosh/dencun-issue-tracker">devnet 问题跟踪</a>，计划在devnet 7上对EIP4844进行压力测试，同时并行为 devnet 8 开发全部的 Dencun EIPs。</li><li>讨论 EL 的引擎 API 标志，该标志用于建议 CL 使用本地块构建</li><li>EIP4844：<ul><li><a href="https://ceremony.ethereum.org/">为 KZG 仪式做贡献的最后机会</a>，7月23日截止，使用至少有8个交易的账户</li></ul></li></ul><h2 id="客户端发布"><a href="#客户端发布" class="headerlink" title="客户端发布"></a>客户端发布</h2><ul><li>共识层：<ul><li>Lighthouse <a href="https://github.com/sigp/lighthouse/releases/tag/v4.3.0">v4.3.0</a>：减少带宽，并对slasher进行了修改：默认启用广播，后端恢复为LMDB。</li></ul></li><li>执行层：<ul><li>Reth <a href="https://github.com/paradigmxyz/reth/releases/tag/v0.1.0-alpha.2">v0.1.0-alpha.2</a>：引擎API的稳定性得到改善，修复了内存不足的问题，修复了RPC 边缘情况，包括tracing和增加了新的指标。</li></ul></li></ul><h2 id="给质押者"><a href="#给质押者" class="headerlink" title="给质押者"></a>给质押者</h2><ul><li><a href="https://twitter.com/nero_eth/status/1675777429904797696">MEV-Boost dashboard</a> 增加了乐观中继的图表，显示了增加的胜率</li></ul><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a><strong>研究</strong></h2><ul><li>纳入PBS的建议：<a href="https://ethresear.ch/t/payload-timeliness-committee-ptc-an-epbs-design/16054">payload-timeliness committee</a> (PTC)，证明委员会的子集对构建者是否及时发布其执行 payload 进行投票。</li><li><a href="https://twitter.com/tim_roughgarden/status/1676980165316886530">交易费用机制设计</a>，证明了 MEV 使得用户体验不可能简单，验证者也不可能被激励去做正确的行为</li><li><a href="https://collective.flashbots.net/t/distributed-blockbuilding-networks-via-secure-knapsack-auctions/1955">分布式区块构建</a>：使用MPC进行保护隐私的knapsack拍卖</li></ul><h2 id="Layer2"><a href="#Layer2" class="headerlink" title="Layer2"></a>Layer2</h2><ul><li>Patrick McCorry: <a href="https://www.cryptofrens.info/p/bridging-databases-part-2">跨链桥的概述</a></li></ul><h2 id="EIP-标准"><a href="#EIP-标准" class="headerlink" title="EIP 标准"></a>EIP 标准</h2><ul><li>EIPs：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7266/files">EIP7266</a>：移除blake2f (0x09)预编译</li></ul></li><li>ERCs（应用层）：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7265/files">ERC7265</a>：断路器，用于当超过阈值时暂停 Token 留出。</li><li><a href="https://github.com/ethereum/EIPs/pull/7272/files">ERC7272</a>：以太坊访问代币（授权来自链外服务的函数调用）</li><li><a href="https://github.com/ethereum/EIPs/pull/7280/files">ERC7280</a>：NFT元数据扩展，如JSON-LD</li><li><a href="https://github.com/ethereum/EIPs/pull/7281/files">ERC7281</a>：主权桥接代币(xERC20)</li><li><a href="https://github.com/ethereum/EIPs/pull/7292/files">ERC7291</a>：目的绑定货币（ERC1155 扩展）</li></ul></li></ul><h2 id="开发者资料"><a href="#开发者资料" class="headerlink" title="开发者资料"></a>开发者资料</h2><ul><li>使用 <a href="https://blog.theredguild.org/how-to-diff-smart-contracts-etherscan/">Diffyscan 对 GitHub 合约和 Etherscan 验证的代码进行比较</a></li><li><a href="https://github.com/scaffold-eth/scaffold-eth-2#readme">Scaffold-ETH 2</a> 更新至Wagmi v1 &amp; viem</li><li><a href="https://github.com/softwarecurator/svelte-wagmi#readme">Svelte Wagmi</a>：Svelte stores and functions 使用wagmi进行连接和签名</li><li><a href="https://twitter.com/wighawag/status/1675803846147178497">Vitest-solidity-coverage</a>：用于 Vitest 的solidity-coverage的Hardhat插件。</li><li>Ape <a href="https://github.com/ApeWorX/ape/releases/tag/v0.6.12">v0.6.12</a>（合约开发框架）：增加了<a href="https://twitter.com/fubuloubu/status/1677436142679994369">EIP5202 蓝图支持</a>，覆盖和安装与编译的依赖性。</li><li>Huff <a href="https://github.com/jtriley-eth/huff-style-guide#readme">代码风格指南</a></li><li>RareSkills：<a href="https://www.rareskills.io/post/smart-contract-audit-tools">合约安全工具概述</a></li><li>CTF（挑战）：<ul><li>Curta CTF: <a href="https://www.curta.wtf/puzzle/13">乒乓球</a></li><li>Secureum RACE #19: <a href="https://ventral.digital/posts/2023/7/3/race-19-of-the-secureum-bootcamp-epoch-infinity">8个问题的Solidity测验和答案</a></li></ul></li><li><a href="https://learnblockchain.cn/article/6128">创建自定义Uniswap v4 Hook 的指南</a></li><li><a href="https://github.com/joshstevens19/reth-indexer#readme">Reth-indexer</a>：从Reth（EL客户端）数据库中读取，索引到Postgres并生成API。</li><li><a href="https://github.com/erhant/circomkit#readme">Circomkit</a>：简单接口和测试工具， 用于开发Circom电路。</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a><strong>安全</strong></h2><ul><li>Azuki DAO（不满的Azuki持有者）由于缺失的签名重放检查漏洞导致 <a href="https://twitter.com/MetaSleuth/status/1675783739174166528">35 ETH 被利用</a>。</li><li>Tincho: <a href="https://blog.theredguild.org/question-until-it-crashes/">问题驱动的方法</a>来审查代码</li><li>Multichain (即Anyswap)跨链桥<a href="https://twitter.com/peckshieldalert/status/1677124413274353664">1.26亿美元的漏洞</a></li><li>Poly Network 跨链桥<a href="https://rekt.news/poly-network-rekt2/">400万美元的漏洞</a>，4个私钥中的3个明显被滥用</li></ul><h2 id="生态系统"><a href="#生态系统" class="headerlink" title="生态系统"></a>生态系统</h2><ul><li><a href="https://twitter.com/etherscan/status/1675856302013284352">Etherscan 添加 ENS</a>到搜索栏自动查询。</li></ul><h2 id="可关注的应用层动态"><a href="#可关注的应用层动态" class="headerlink" title="可关注的应用层动态"></a>可关注的应用层动态</h2><ul><li><a href="https://twitter.com/ourzora/status/1677346773281669121">Zora network</a> (OP Stack L2) 由OpenSea支持。</li><li><a href="https://submint.io/">SUBMINT</a> (ENS子名铸币)在主网上线，设置定价和代币门铸币</li><li>本周的Gas guzzler ：VMPX ERC20代币<a href="https://twitter.com/0xCygaar/status/1676699126682075136">需要工作证明才能铸币</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-7-29</title>
      <link href="/2023/08/02/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-7-29/"/>
      <url>/2023/08/02/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-7-29/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun-Cancun-Deneb-升级"><a href="#Dencun-Cancun-Deneb-升级" class="headerlink" title="Dencun (Cancun + Deneb) 升级"></a>Dencun (Cancun + Deneb) 升级</h2><ul><li><p>最新的所有核心开发者 - 共识（ACDC）视频会议。克里斯汀·金 (Christine Kim)的记录：</p><ul><li>Dencun 升级讨论：正在开发专门针对 MEV-Boost 的各种蜂巢测试；将<code>parent_beacon_block_root</code>添加到执行层负载中的提议被拒绝，还有一个关于共识层出块确认规则待确认。</li><li>关于 Electra 升级包含哪些EIP的讨论将推迟，但EIP的更新可以提前纳入 ACDC 会议。</li><li>讨论了 EIP6914（重用已退出的验证者索引）的更新和 EIP6110（在链上提供验证者存款）原型</li><li>讨论提高共识层客户端<a href="https://docs.google.com/document/d/1HMSxMNY3nZR4NKohIQAhzRTzYnKEJEU9ro8Z8kcnH2c/edit#heading=h.jhia3qtraquu">符合规范重要性</a></li></ul></li><li><p>EIP4844：</p><ul><li>最新的 EIP4844 实施者电话会议。<a href="https://twitter.com/terencechain/status/1683519689601994753">Terence</a>的记录：devnet 8 需求讨论；<a href="https://hackmd.io/aVek93y-QmSv1mz2Agc9iQ">blob 交易内存池设计</a>；没有激励 MEV-Boost 构建者包含 blob 交易</li><li>KZG仪式<a href="https://twitter.com/carlbeek/status/1683034067435147265">延长至8月23日</a></li></ul></li></ul><h2 id="Layer-1"><a href="#Layer-1" class="headerlink" title="Layer 1"></a>Layer 1</h2><ul><li><a href="https://twitter.com/jasoriatanishq/status/1683454125042995200">Nethermind 实现了无状态验证</a>，可以作为无状态客户端参与网络</li><li><a href="https://mirror.xyz/rolfy.eth/9rT9Ia_VpbksURo8Bt8GSHaepM0mj0fo3styV-czBUE">Teku 计划修改缓存</a>以减少内存</li><li>Lighthouse 最新的 <a href="https://lighthouse-blog.sigmaprime.io/update-42.html">v4.3.0 版本</a>：子网主干改进和支持 IPv6</li><li>所有<a href="https://twitter.com/pcaversaccio/status/1683799790633582592">共识层主网 bootnodes</a>的IP和位置信息都可用</li><li><a href="https://github.com/paradigmxyz/jitevm#readme">JIT EVM</a>：将 EVM 热合约编译成机器码，使用 LLVM&#x2F;inkwell，用 Rust 实现，概念证明阶段</li></ul><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><ul><li><a href="https://ethresear.ch/t/game-theoretic-model-for-mev-boost-auctions-mma/16206">MEV-Boost 拍卖</a>博弈论模型：builder 赢得拍卖的策略</li></ul><h2 id="Layer-2"><a href="#Layer-2" class="headerlink" title="Layer 2"></a>Layer 2</h2><ul><li><a href="https://twitter.com/pgn_eth/status/1683843118284812290">公共物品网络</a>（OP Stack rollup）上线，旨在为公共物品筹集资金</li><li>Optimism 治理的<a href="https://gov.optimism.io/t/law-of-chains-v0-1-full-draft/6514">链法则</a>是一个开放的中立框架，为超级链生态系统（OP Stack）参与者建立一定的保护措施。其目的是促进用户保护、去中心化和经济自主等核心原则，为发展中的超级链奠定基础。</li></ul><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><ul><li>EIP：<ul><li><a href="https://eips.ethereum.org/EIPS/eip-7377">EIP7377</a>：迁移交易（EOA 将代码部署到其地址的一次性交易）</li><li><a href="https://github.com/ethereum/EIPs/pull/7378/files">EIP7378</a>：将时间加权平均添加到基本费用中</li></ul></li><li>ERC（应用层）：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7390/files">ERC7390</a>：通用选项</li><li><a href="https://github.com/ethereum/EIPs/pull/7400/files">ERC7399</a>：闪电贷</li><li><a href="https://eips.ethereum.org/EIPS/eip-7401">ERC7401</a>：NFT嵌套接口，强调父代币对关系的控制。</li><li><a href="https://github.com/ethereum/EIPs/pull/7405/files">ERC7405</a>：便携式合约账户</li><li><a href="https://github.com/ethereum/EIPs/pull/7406/files">ERC7406</a>：多命名空间链上注册表</li><li><a href="https://github.com/ethereum/EIPs/pull/7409/files">ERC7409</a>：公共 NFT 表情存储库</li><li><a href="https://github.com/ethereum/EIPs/pull/7410/files">ERC7410</a>：ERC20 更新花费者授权额度</li><li><a href="https://github.com/ethereum/EIPs/pull/7412/files">ERC7412</a>：按需链下数据检索</li><li><a href="https://github.com/ethereum/EIPs/pull/7418/files">ERC7417</a>：代币转换器（ERC20 和 ERC223 之间转换）</li></ul></li></ul><h2 id="开发者资料"><a href="#开发者资料" class="headerlink" title="开发者资料"></a>开发者资料</h2><ul><li><a href="https://twitter.com/openzeppelin/status/1684300974402449408">OpenZeppelin Contracts Wizard</a>添加了 Foundry 项目下载</li><li>深入研究<a href="https://www.gmhacker.com/solady-erc1967factory-deep-dive/">Solady ERC1967Factory</a> 部署和管理 ERC1967 代理</li><li><a href="https://banteg.mirror.xyz/xMsPLpgsv88NFspah0v1SyJHBk0Yp3vSyzCSznr6ZaM">EIP4626 合约</a>（代币化金库）并不都在 mint、deposit、burn 和 redeem 时发出 Transfer 事件</li><li>Halmos <a href="https://a16zcrypto.com/posts/article/release-notes-halmos-v0-1-0/">v0.1.0</a>（符号测试）：性能改进，扩展了 EVM ，支持作弊码</li><li>WhatsABI <a href="https://github.com/shazow/whatsabi/releases/tag/v0.6.0">v0.6.0</a>（从字节码猜测 ABI）：自动加载改进，修复错误 </li><li>CTF：<ul><li>Curta CTF <a href="https://twitter.com/jtriley_eth/status/1683203592344473601">神圣几何解法</a></li><li><a href="https://ctf.flashbots.net/">Flashbots CTF</a> 8 月 5 日至 7 日</li></ul></li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>zkSync Era 上的 EraLend 因只读重入漏洞<a href="https://rekt.news/eralend-rekt/"> 340 万美元</a>被利用</li><li>Conic Finance 针对 ETH omnipool（只读重入）和 crvUSD omnipool（三明治）漏洞的<a href="https://medium.com/@ConicFinance/post-mortem-eth-and-crvusd-omnipool-exploits-c9c7fa213a3d">事后分析</a></li></ul><h2 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h2><ul><li>ETHGlobal 巴黎<a href="https://twitter.com/ethglobal/status/1683156559847739394">黑客马拉松决赛入围者</a></li><li>Etherscan <a href="https://twitter.com/etherscan/status/1684920660550926336">IDM（Input Data Messages（输入数据消息）</a>，所有检测到消息的交易都会展示在单个页面中。</li></ul><h2 id="在应用层"><a href="#在应用层" class="headerlink" title="在应用层"></a>在应用层</h2><ul><li><p><a href="https://twitter.com/ryskfinance/status/1684202975001030658">Rysk Finance</a>（LP 回报不相关的期权 AMM）在 Arbitrum 上上线 [披露：Starbloom 投资组合]</p></li><li><p>Worldcoin</p><p>（通过虹膜扫描的 UBI）上线 Optimism</p><ul><li>Vitalik 谈<a href="https://vitalik.eth.limo/general/2023/07/24/biometric.html">生物识别证明</a></li></ul></li><li><p><a href="https://twitter.com/dwr/status/1684218017486438403">Farcaster</a> 添加 ENS 用户名</p></li><li><p><a href="https://medium.com/@Obstropolos/party-on-tcr-party-af0035199b9">TCR Party</a>回顾</p></li><li><p>Gas guzzler：Pond0x memecoin<a href="https://twitter.com/0xQuit/status/1684982136724733952">允许任何人转移代币</a>，基于 Solady 模拟 ERC20</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-7-22</title>
      <link href="/2023/07/30/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-7-22/"/>
      <url>/2023/07/30/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-7-22/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun-Cancun-Deneb-升级"><a href="#Dencun-Cancun-Deneb-升级" class="headerlink" title="Dencun (Cancun + Deneb) 升级"></a>Dencun (Cancun + Deneb) 升级</h2><ul><li><p>最新的所有核心开发人员 - 执行 (ACDE)视频会议。Tim Beiko的总结。Tim Beiko和Christine Kim的记录：</p><ul><li>Dencun 测试继续与 devnet 7 和<a href="https://twitter.com/parithosh_j/status/1682386409494138886">Sepolia 影子分叉</a>一起进行。</li></ul></li><li><p>实施 Dencun EIP 的客户团队已为 <a href="https://notes.ethereum.org/@ethpandaops/dencun-devnet-8">devnet 8</a> 做好准备</p><ul><li>EIP6780（仅在同一 tx 中自毁）边缘情况澄清，某些 L2 使用了 burn 功能</li></ul></li><li><p>讨论给执行层有效载荷中添加父信标块根、从执行 API 中添加 getBlockReceipts 和移除 minting ，以及标准化 JWT 存储位置</p><ul><li>EIP&#x2F;ERC repo 拆分（<a href="https://eips.ethereum.org/EIPS/eip-7329">EIP7329</a>）：核心开发人员赞成，Greg Colvin（EIP 编辑）仍反对</li></ul></li><li><p><a href="https://ceremony.ethereum.org/">KZG 仪式</a> 122k 贡献者，截止日期为 7 月 23 日。</p></li></ul><h2 id="Prague-Electra-升级"><a href="#Prague-Electra-升级" class="headerlink" title="Prague + Electra 升级"></a>Prague + Electra 升级</h2><ul><li><a href="https://notes.ethereum.org/@mikeneuder/eip-7251-faq">EIP7251 FAQ</a>：将允许超过 32 个 ETH 质押</li><li>为Prague + Electra 升级版提交 <a href="https://ethereum-magicians.org/t/name-needed-for-combined-el-cl-prague-electra-upgrade/15122">建议名称</a></li></ul><h2 id="Layer1"><a href="#Layer1" class="headerlink" title="Layer1"></a>Layer1</h2><ul><li>Ben Edgington：<a href="https://eth2book.info/capella/part2/consensus/">升级以太坊书</a> 加新章节：关于 LMD GHOST 和 Casper FFG</li></ul><h2 id="客户端发布"><a href="#客户端发布" class="headerlink" title="客户端发布"></a>客户端发布</h2><ul><li>共识层：<ul><li>Lodestar <a href="https://github.com/ChainSafe/lodestar/releases/tag/v1.9.2">v1.9.2</a>：针对出现未知区块父错误的传播区块的热修复，并更改了区块生产等待截止时间</li><li>Nimbus <a href="https://github.com/status-im/nimbus-eth2/releases/tag/v23.7.0">v23.7.0</a>：优化验证器客户端并提高验证器性能</li><li>Teku <a href="https://github.com/Consensys/teku/releases/tag/23.6.2">v23.6.2</a>：小错误修复和依赖关系更新</li></ul></li><li>执行层：<ul><li>Nethermind <a href="https://github.com/NethermindEth/nethermind/releases/tag/1.20.1">v1.20.1</a>：修复了 v1.20.0 导致的 Prysm 错误</li><li>Reth <a href="https://github.com/paradigmxyz/reth/releases/tag/v0.1.0-alpha.4">v0.1.0-alpha.4</a>：删除了阻止同步的下载器探索、UNIX 上的 jemallocator 默认值，并添加了交易池维护指标</li></ul></li></ul><h2 id="给质押者"><a href="#给质押者" class="headerlink" title="给质押者"></a>给质押者</h2><ul><li><a href="https://www.staking.directory/">质押目录网站</a>：质押参考大全</li></ul><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><ul><li><a href="https://eprint.iacr.org/2023/1079">数据可用性抽样（DAS）电子版</a>：证明现有结构的安全性，提出具有基准（benchmark）和权衡的新结构</li><li><a href="https://arxiv.org/abs/2307.10878">阈值加密交易池</a>：使用阈值加密交易池缓解 MEV 的交易问题</li></ul><h2 id="layer2"><a href="#layer2" class="headerlink" title="layer2"></a>layer2</h2><ul><li><a href="https://forum.celo.org/t/clabs-proposal-for-celo-to-transition-to-an-ethereum-l2/6109">Celo 提出向 Rollup 迁移</a>，最初为 OP Stack，使用 Celo 验证器集的去中心化定序器，通过 Eigen 层和 1 个区块最终性实现链外数据可用性</li><li><a href="https://zksync.mirror.xyz/HJ2Pj45EJkRdt5Pau-ZXwkV2ctPx8qFL19STM5jdYhc">zkSync Era</a> 覆盖测试Boojum（基于STARK的证明系统）</li><li><a href="https://www.mantle.xyz/blog/announcements/mantle-network-mainnet-alpha">Mantle</a>（乐观 Rollup ）alpha 已上线</li><li>Consensys <a href="https://twitter.com/LineaBuild/status/1681283676791873536">Linea</a> (zk rollup) alpha 已上线</li><li>L2BEAT: <a href="https://drive.google.com/file/d/182ycEW8C2wk5tGd3X1tG8oQfUy9WmSJk/view">Layer2 的升级过程</a> [PDF]</li></ul><h2 id="EIPs-Standards"><a href="#EIPs-Standards" class="headerlink" title="EIPs&#x2F;Standards"></a>EIPs&#x2F;Standards</h2><ul><li>ERC（应用层）：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7336/files">ERC7336</a>：跨多个注册器的交互</li><li><a href="https://github.com/ethereum/EIPs/pull/7361/files">ERC7361</a>：具有分布式验证功能的元数据Hash（ERC721 扩展）</li></ul></li></ul><h2 id="给开发者"><a href="#给开发者" class="headerlink" title="给开发者"></a>给开发者</h2><ul><li>Solidity <a href="https://soliditylang.org/blog/2023/07/19/solidity-0.8.21-release-announcement/">v0.8.21</a>：<ul><li>语言特性：放宽从其他合约访问事件和 immutable 变量初始化的限制</li><li>解决基于 IR 代码生成的未优化代码的 “堆栈过深 “错误</li><li>错误修正：传统代码生成 <a href="https://soliditylang.org/blog/2023/07/19/missing-side-effects-on-selector-access-bug/">始终为 .selector 中的表达式生成代码</a> 和 Yul 优化器 <a href="https://soliditylang.org/blog/2023/07/19/full-inliner-non-expression-split-argument-evaluation-order-bug/">FullInliner 评估顺序</a></li><li>网站 <a href="https://twitter.com/solidity_lang/status/1681658620935647232">改版</a></li></ul></li><li>创建 <a href="https://hackernoon.com/how-to-implement-a-stake-and-reward-contract-in-solidity">质押与奖励合约</a></li><li>使用 Hardhat 或 Foundry 在 Solidity 中<a href="https://medium.com/immunefi/how-to-reproduce-a-simple-mev-attack-b38151616cb4">重现简单的 MEV 攻击</a></li><li>使用<a href="https://blog.trailofbits.com/2023/07/21/fuzzing-on-chain-contracts-with-echidna/">Echidna模糊测试链上合约</a>指南</li><li>Sothis <a href="https://github.com/rainshowerLabs/sothis/releases/tag/0.4.0">v0.4.0</a>: 在本地 Anvil&#x2F;Hardhat 节点上重放历史状态</li><li>TheGaph：<a href="https://thegraph.com/blog/substreams-powered-subgraphs/">基于 SubStream 的 subgraph</a></li><li>Secureum <a href="https://ventral.digital/posts/2023/7/16/secureum-a-maze-x-ctf-2023-at-defi-security-summit">A-MAZE-X CTF 解决方案</a></li><li>Celer <a href="https://blog.celer.network/2023/07/18/brevis-alpha-now-live-introducing-zk-co-processing-and-data-attestation-sdks-for-developers/">Brevis</a>：zk 协同处理和数据认证 SDK，alpha版</li></ul><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><ul><li>Conic Finance 因只读重入 <a href="https://twitter.com/ConicFinance/status/1682385596700844032">$300百万 被利用</a></li><li>Immunefi：<a href="https://medium.com/immunefi/the-top-10-most-common-vulnerabilities-in-web3-bf7a921d489f">十大常见漏洞</a></li></ul><h2 id="生态系统"><a href="#生态系统" class="headerlink" title="生态系统"></a>生态系统</h2><ul><li>EthCC：<ul><li>各阶段视频： <a href="https://www.youtube.com/playlist?list=PLM-Xjhvin-uURP4lmYyP0iys2mxq-rCKU">main</a>, <a href="https://www.youtube.com/playlist?list=PLm6V2qdPAeaUBG-qBewmpopLdgVtpqaXM">Eiffel</a>, <a href="https://www.youtube.com/playlist?list=PLUt355rCCNrTliK_38XZpLzt1JGrKr2Dq">Versailles</a>, <a href="https://www.youtube.com/playlist?list=PLSJ8gU1sECuzy2pLKFvyPjFn6jaIx_p1C">Bastille</a>, <a href="https://www.youtube.com/playlist?list=PLhM7rBgpVV-KN8mM17IRSFIGsL0EaGA_m">Notre Dame</a>, <a href="https://www.youtube.com/playlist?list=PL-owlDp9BBasiGOoq5sK3gg0zKS_2WXLP">Louvre</a> &amp; <a href="https://www.youtube.com/playlist?list=PLqL60kqgLPBAM-gy8Dop9tTREOuq1q2QV">Saint Victor</a></li><li><a href="https://twitter.com/EthCC/status/1682040349857050627">EthCC 2024</a>将在布鲁塞尔举行</li></ul></li><li>Etherscan <a href="https://twitter.com/etherscan/status/1682351432543113218">高级过滤器更新</a></li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li><a href="https://aave.mirror.xyz/t7qcU668gSp9teT_SBhJb9_AVcbv8kpzvd0IpP39lBw">Aave GHO</a>（超额抵押稳定币）在主网上上线，Aave v3 提供的资产被用作抵押品</li><li><a href="https://blog.uniswap.org/uniswapx-protocol">UniswapX</a>(聚合器)发布：无Gas SWap，有 MEV 保护，交易失败无费用，测试版</li><li><a href="https://www.ajna.finance/">Ajna</a>（借贷）在主网上线，无治理，无外部价格预言机</li><li>OpenSea <a href="https://twitter.com/opensea/status/1682077991029932032">Deals</a>：创建用 NFT 和 WETH 交换 NFT 的出价</li><li><a href="https://twitter.com/mintdotfun/status/1681696385555648514">Mint.fun</a>（NFT 铸币）增加了对 Optimism 和 Zora 上 NFT 的支持</li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-7-15</title>
      <link href="/2023/07/24/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-7-15/"/>
      <url>/2023/07/24/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-7-15/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun-Cancun-Deneb-升级"><a href="#Dencun-Cancun-Deneb-升级" class="headerlink" title="Dencun (Cancun + Deneb) 升级"></a>Dencun (Cancun + Deneb) 升级</h2><ul><li><p>最新的所有核心开发人员 - 执行 (ACDE)视频会议 Christine Kim的记录：</p><ul><li>Dencun 更新：devnet 7 有 <a href="https://blobscan.com/">9k blob</a>，除了 Erigon 几乎所有EL和CL客户端组合都已经过测试；客户端版本通过 Hive 测试后，开发人员需在启动<a href="https://notes.ethereum.org/@ethpandaops/dencun-devnet-8">devnet 8</a>前先启动本地测试网</li></ul></li><li><p>下一次 CL 升级被命名为 Electra；目前为止提议包含在 <a href="https://github.com/ethereum/consensus-specs/issues/3449">Electra EIP</a>的有：EIP7002（EL 可触发退出）、EIP6110（在链上提供验证者存款）和 EIP7251（增加验证者最大有效余额）</p><ul><li>讨论活跃验证器集增长和设置验证器流失上限提案</li></ul></li><li><p>EIP4844：</p><ul><li>最新的 EIP4844 实施者电话会议。<a href="https://twitter.com/terencechain/status/1678447832217395203">Terence</a>的记录：devnet 7 垃圾 blob 信息测试；devnet 8 规范已公布；讨论 Beacon API 端点对 L2 的实用性；关于修改 blob gossip 参数的报告</li><li><a href="https://ceremony.ethereum.org/">KZG 仪式</a>120k 贡献，7 月 23 日结束</li></ul></li></ul><h2 id="Layer-1"><a href="#Layer-1" class="headerlink" title="Layer 1"></a>Layer 1</h2><ul><li>Erigon<a href="https://twitter.com/erigoneth/status/1677731373262446597">更新了 2023 年路线图</a>：执行层1次重大升级 Erigon3，共识层 Caplin，作为 Erigon3 的单一进程或独立进程运行</li><li><a href="https://github.com/jsign/go-curdleproofs#readme">Curdleproofs</a>：一个受 BG12 启发的 秘密单一领导人选举 go 实现 （零知识洗牌算法）。</li></ul><h2 id="客户端版本"><a href="#客户端版本" class="headerlink" title="客户端版本"></a>客户端版本</h2><ul><li>共识层：<ul><li>Prysm <a href="https://github.com/prysmaticlabs/prysm/releases/tag/v4.0.7">v4.0.7</a>比v4.0.6优化了：slot 0的验证者提案时间减少了800ms、减少分叉选择锁的使用，显著减少区块处理时间。</li></ul></li><li>执行层：<ul><li>Nethermind <a href="https://github.com/NethermindEth/nethermind/releases/tag/1.20.0">v1.20.0</a>：改进了日志颜色、快照同步更快了，改进了完全修剪</li><li>Reth <a href="https://github.com/paradigmxyz/reth/releases/tag/v0.1.0-alpha.3">v0.1.0-alpha.3</a>：热修复 Grafana 指标</li></ul></li></ul><h2 id="给质押者"><a href="#给质押者" class="headerlink" title="给质押者"></a>给质押者</h2><ul><li><a href="https://ethstakers.club/">Ethstakers.club</a>信标浏览器，测试版，使用 PostgreSQL 和 Charts.js ，开源 MIT 许可证</li><li><a href="https://www.servethehome.com/intel-exiting-the-pc-business-as-it-stops-investment-in-the-intel-nuc/">英特尔</a>退出 NUC 业务</li></ul><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><ul><li><a href="https://www.reddit.com/r/ethereum/comments/14vpyb3/ama_we_are_ef_research_pt_10_12_july_2023/">EF 研究团队 AMA</a>，讨论：EIP7002（EL 可触发退出）、RANDAO 操纵、DVT、EIP7251（增加最大有效余额）、SSLE、重新质押、技术路线图、<a href="https://www.reddit.com/r/ethereum/comments/14vpyb3/comment/jrny7o2">MEV 作为已解决的研究问题</a>、更容易质押、升级、<a href="https://www.reddit.com/r/ethereum/comments/14vpyb3/comment/jrnyxa8/">一次性签名</a>、zk、EF、EIP4844、执行分片和rollup</li><li><a href="https://ethresear.ch/t/selfish-mixing-and-randao-manipulation/16081">RANDAO操纵分析</a>：未检测到大规模操纵，操纵者可能面临社交削减</li><li><a href="https://rakita.github.io/blog/blog/parallel-evm-claim/">并行 EVM 研究</a>：确保并行运行交易时不会出现不一致</li><li>EF Robust Incentives Group<a href="https://efdn.notion.site/Robust-Incentives-Group-homepage-802339956f2745a5964d8461c5ccef02">帖子、论文和演讲</a></li></ul><h2 id="Layer-2"><a href="#Layer-2" class="headerlink" title="Layer 2"></a>Layer 2</h2><ul><li><a href="https://taiko.mirror.xyz/ryYEi4gAeOWwyERqYTs7CPbNEOYXaEeiMEui6gdlnyg">跨链通信</a>：L2 的不同方法</li><li><a href="https://twitter.com/SpearbitDAO/status/1679189382907953180">Polygon zkEVM 漏洞已披露</a>（已修复），除法余数验证不充分</li></ul><h2 id="EIP-标准"><a href="#EIP-标准" class="headerlink" title="EIP&#x2F;标准"></a>EIP&#x2F;标准</h2><ul><li>EIPs：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7329/files">Meta EIP7329</a>：ERC&#x2F;EIP 存储库拆分</li></ul></li><li>ERC（应用层）：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7303/files">ERC7303</a>：被代币控制的代币流通</li><li><a href="https://github.com/ethereum/EIPs/pull/7322/files">ERC7322</a>：具有可社交恢复的灵魂绑定</li><li><a href="https://github.com/ethereum/EIPs/pull/7331/files">ERC7331</a>：私募股权</li></ul></li></ul><h2 id="开发人员的东西"><a href="#开发人员的东西" class="headerlink" title="开发人员的东西"></a>开发人员的东西</h2><ul><li>Foundry：<ul><li>Forge-std <a href="https://github.com/foundry-rs/forge-std/releases/tag/v1.6.0">v1.6.0</a>：添加作弊代码 readCallers、deployCodeTo、skip(bool) 和 ShouldAddressIsNot 并将 check_write_int 添加到 StdStorage</li><li>用于测试 Solidity 的<a href="https://twitter.com/PaulRBerg/status/1679914755014942720">分支树技术</a></li><li><a href="https://twitter.com/paulrberg/status/1679184862928830479">ABI 使用强制类型转换</a>对构造函数参数进行编码</li></ul></li><li>Hardhat <a href="https://github.com/NomicFoundation/hardhat/releases/tag/hardhat%402.17.0">v2.17.0</a>：添加了对 solc v0.8.19&#x2F;20 和 Node v20 的支持</li><li><a href="https://github.com/philogy/sstore3#readme">SSTORE3</a>：代码即存储（CaS）模式的库，指针可以与其他变量一起打包</li><li><a href="https://blog.trailofbits.com/2023/07/07/differential-fuzz-testing-upgradeable-smart-contracts-with-diffusc/">Diffusc</a>：使用静态分析和差异模糊测试来比较可升级的合约实现</li><li><a href="https://github.com/wolovim/temo#readme">Temo</a>：一个在控制台终端 UI ，用来获取区块&#x2F;账户&#x2F;调用合约功能；使用 Ape、Anvil 和 Textual</li><li>Curta CTF <a href="https://twitter.com/exp_table/status/1678260264893026305">乒乓球解决方案</a></li><li><a href="https://github.com/dmpierre/eth-private-market#readme">私钥市场</a>：使用 zk-snarks 出售私钥、签名和 groth16 证明的演示</li><li>RareSkills：<a href="https://www.rareskills.io/post/rank-1-constraint-system">将代数电路转换为 R1CS</a></li><li><a href="https://github.com/aviggiano/circom-mutator#readme">Circcom-mutator</a> : Circcom 突变测试工具</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li><a href="https://medium.com/@Rodeo_Finance/rodeo-post-mortem-overview-f35635c14101">Rodeo Finance</a>通过 TWAP 预言机操纵 Arbitrum获得价值 88 万美元的漏洞</li><li><a href="https://arcadiafinance.medium.com/post-mortem-72e9d24a79b0">Arcadia Finance</a> 在主网和Optimism上被重入攻击， 46 万美元被利用</li><li><a href="https://twitter.com/peckshield/status/1678688731908411393">Libertify</a> 在主网和 Polygon POS 被重入， 利用价值 45 万美元</li><li><a href="https://twitter.com/dumbnamenumbers/status/1679259067833786374">Ethscriptions marketplace 被利用</a>，存款所有权无法验证</li><li>Trail of Bits：<a href="https://blog.trailofbits.com/2023/07/14/evaluating-blockchain-security-maturity/">评估代码库安全成熟度</a></li><li>PRBMath<a href="https://medium.com/certora/problems-in-solidity-fixed-point-libraries-certora-bug-disclosure-987f504daca4">签名乘法和除法漏洞</a>已披露</li></ul><h2 id="生态系统"><a href="#生态系统" class="headerlink" title="生态系统"></a>生态系统</h2><ul><li><a href="https://twitter.com/nanexcool/status/1678055882708463616">活跃验证器达到 655k</a>，限制增加到每个 epoch 10 次 激活&#x2F;退出</li><li>Ethereum.org <a href="https://github.com/ethereum/ethereum-org-website/issues/10666">第三季度网站路线图</a></li><li>Etherscan <a href="https://twitter.com/etherscan/status/1678387777254346754">类似合约搜索</a>已更新</li><li>ETH巴塞罗那<a href="https://ethbarcelona.devfolio.co/projects?show_winners=true">黑客松获奖者</a></li><li>巴西中央银行<a href="https://twitter.com/0xCygaar/status/1678818653305819136">CBDC 试点 GitHub 存储库</a></li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li><a href="https://medium.com/sablier/introducing-sablier-v2-b72f1aa7e458">Sablier v2</a>（代币流）：流表示为可转让的 NFT，添加非线性流、cliff支持、批量创建，第三方可以收取经纪人费用</li><li><a href="https://safe.mirror.xyz/rjWPvQjH9XEC2bADp-9Q1ZEW675pMu41hWsoX5v0Ros">Safe</a> (multisig) 增加了对账户抽象的 ERC4337 支持</li><li><a href="https://blog.cow.fi/cow-hooks-you-are-in-control-480ccb40044a">CoW Hooks</a>：可以在单个交易中实现兑换前和兑换后意图</li><li>0age <a href="https://twitter.com/z0age/status/1678775028270370822">Ret↵rn</a>：链上生成视听（SVG 和网络音频）NFT [Evan 和 Andrew 铸造]</li><li><a href="https://sound.mirror.xyz/W5F4DasupahnF_AyT5TwXSzKWJcOqHLuxf9nI0piPOE">Sound</a>（音乐 NFT）向所有艺术家开放</li><li>Justin Thaler: <a href="https://a16zcrypto.com/posts/article/17-misconceptions-about-snarks/">17 个 SNARK 误解</a></li><li><a href="https://eprint.iacr.org/2023/1071">Fiat-Shamir security</a> FRI 的 Fiat-Shamir 安全性以及基于 FRI 的协议系列（包括 Plonky2 和 ethSTARK）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-7-1</title>
      <link href="/2023/07/22/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-7-1/"/>
      <url>/2023/07/22/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-7-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun-Cancun-Deneb-升级"><a href="#Dencun-Cancun-Deneb-升级" class="headerlink" title="Dencun (Cancun + Deneb) 升级"></a>Dencun (Cancun + Deneb) 升级</h2><ul><li><p>最新的所有核心开发者 - 共识（ACDC）视频会议。克里斯汀·金 (Christine Kim)的记录：</p><ul><li>Deneb 升级引擎 API 更改的两个提案：提案1: 分阶段逐步弃用<code>engine_exchangeTransitionConfiguration</code>方法; 提案2: 增加一个构建控制标志(the builder override flag) ，该标记让验证者在区块构建上有更多的控制。</li></ul></li><li><p>EIP7251（增加最大有效余额）讨论</p><ul><li>EIP7002（执行层可触发退出）不在 Deneb 升级中考虑，之后可能会进行硬分叉，以E开头的恒星名称命名</li></ul></li><li><p>EIP4844：</p><ul><li><a href="https://4844-devnet-7.ethpandaops.io/">EIP4844 devnet 7</a>启动（与 devnet 6 规范相同）</li><li>最新 EIP4844 实施者<a href="https://www.youtube.com/watch?v=WFwXitiwv-Q">视频会议</a>。<a href="https://twitter.com/terencechain/status/1673366026313162752">Terence</a>的记录。Devnet 8 应包含 Dencun EIP</li></ul></li><li><p>Execution-spec-tests <a href="https://github.com/ethereum/execution-spec-tests/releases/tag/v1.0.0">v1.0.0</a>：升级到 PyTest，EIP4844 测试</p></li></ul><h2 id="Layer-1"><a href="#Layer-1" class="headerlink" title="Layer 1"></a>Layer 1</h2><ul><li>Holešky 测试网（Goerli 的继承者）<a href="https://github.com/ethereum/pm/issues/814#issuecomment-1613224057">协调会议记录</a>：目前 170 万验证者，其中 80 万为客户端团队，计划于 9 月 15 日（合并日）创世</li><li>MEV-Boost <a href="https://github.com/flashbots/mev-boost/releases/tag/v1.6">v1.6</a>：请求额外的数据可用性，改进日志记录</li><li><a href="https://ethereum-magicians.org/t/discussion-removal-of-ripemd-160-and-blake2f-precompiles/14857">移除 RIPEMD-160 和 blake2f 预编译</a>的提案</li><li><a href="https://mirror.xyz/0x55a0c204c6fDd0DCf238430cb4BF79D45e8D9Bc3/kw_7qbkOl4NV1pmpRgVwtsS-7TZff_zTmmNEOm2BbmU">了解 PBS(Proposer-Builder Separation提案构建分离)</a></li></ul><h2 id="客户端版本"><a href="#客户端版本" class="headerlink" title="客户端版本"></a>客户端版本</h2><ul><li>共识层：<ul><li>Lodestar <a href="https://github.com/ChainSafe/lodestar/releases/tag/v1.9.1">v1.9.1</a>：补丁——修复点对点网络或证明问题，解决V1.9.0版本中发现的一些日志的用户体验问题</li><li>Nimbus <a href="https://github.com/status-im/nimbus-eth2/releases/tag/v23.6.1">v23.6.1</a>：对 2021 年 4 月之前的历史记录的数据库修剪的性能改进</li></ul></li><li>执行层：<ul><li>Besu <a href="https://github.com/hyperledger/besu/releases/tag/23.4.4">v23.4.4</a>：新的 flat 数据库提高了区块处理时间和证明性能，BlobDB 提高了同步时间和磁盘 IO</li></ul></li></ul><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><ul><li><a href="https://arxiv.org/abs/2306.14272">BaseSAP</a>：隐形地址协议，可扩展用于特定的加密方案</li></ul><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><ul><li>EIP：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7251/files">EIP7251</a>：增加 <code>MAX_EFFECTIVE_BALANCE</code></li></ul></li><li>ERC（应用层）：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7229/files">ERC7229</a>：最小可升级代理合约</li><li><a href="https://github.com/ethereum/EIPs/pull/7231/files">ERC7231</a>：身份聚合NFT</li><li><a href="https://github.com/ethereum/EIPs/pull/7246/files">ERC7246</a>：Encumber（ERC20 扩展），允许质押代币而不转移所有权</li><li><a href="https://github.com/ethereum/EIPs/pull/7253/files">ERC7253</a>：通用钱包Uplink(又名 UwU Link)，一种用于接口和移动钱包签名请求的数据格式</li><li><a href="https://github.com/ethereum/EIPs/pull/7254/files">ERC7254</a>：分享代币收益</li></ul></li></ul><h2 id="开发者资料"><a href="#开发者资料" class="headerlink" title="开发者资料"></a>开发者资料</h2><ul><li>Remix <a href="https://medium.com/remix-ide/remix-release-v0-34-0-f40d90c197e2">v0.34.0</a>：EVM 版本标签， Solidity 分析器添加 SolHint linter，Etherscan 合约验证支持 L2 、支持构造函数参数和验证代理合约</li><li>Foundry：<ul><li><a href="https://forgept.apoorv.xyz/">ForGePT</a>：用 Foundry 电子书和 Telegram 支持频道训练过，需要 OpenAI API 密钥</li></ul></li><li><a href="https://mirror.xyz/spacesailor.eth/LEe2yoLoqy97BWHyO6J65XhnG8t33Nmvz_Vsa3ve7rY">Solidity 事件</a>指南：日志和用 web3.js 检索&#x2F;监听</li><li>编程模式 <a href="https://www.nascent.xyz/idea/youre-writing-require-statements-wrong"><code>Function 要求（Requirements）-影响（Effects）- 交互（Interactions） + 协议不变性检查（Protocol Invariants）</code></a>(FREI-PI) 模式</li><li>Viem <a href="https://twitter.com/wagmi_sh/status/1673832563931238400">v1.2</a>：用自定义操作扩展客户端</li><li>用 ethers.js 的 <a href="https://github.com/pcaversaccio/raw-tx/tree/main#readme">原始交易签名脚本</a></li><li><a href="https://snakecharmers.ethereum.org/python-ecosystem/">Python 生态系统</a> 概述：web3.py、py-evm、eth-tester、Ape、Woke、Vyper 和 Titanoboa</li><li><a href="https://github.com/paulmillr/noble-ciphers#readme">Noble-ciphers</a>：JavaScript 写的 Salsa20、ChaCha、Poly1305 和 AES-SIV，没有依赖项</li><li>Slither <a href="https://github.com/crytic/slither/releases/tag/0.9.4">v0.9.4</a>和<a href="https://github.com/crytic/slither/releases/tag/0.9.5">v0.9.5</a>补丁：新检测器：缓存数组长度、编码打包冲突、错误使用-using-for；新 printer：代码行；添加接口生成器并支持自定义存储布局</li><li>RareSkills：<a href="https://www.rareskills.io/post/how-does-tornado-cash-work">Tornado Cash 代码库解释</a></li><li>CTF：<a href="https://decentlysafedefi.xyz/me/">相当安全的 DeFi</a>，4 个挑战，用 Foundry</li><li><a href="https://github.com/orgs/indexsupply/discussions/122">E2PG</a>：以太坊到 Postgres 的索引器</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>Arbitrum 上的 Themis 协议被攻击，通过预言机操纵<a href="https://twitter.com/BlockSecTeam/status/1673897088617426946">利用了 37 万美元</a></li></ul><p><strong>生态系统</strong></p><ul><li>EF <a href="https://blog.ethereum.org/2023/06/28/academic-grants-round-23">学术资助获得者</a>：43 个项目分享 200 万美元资金</li><li>ETHGlobal Waterloo<a href="https://twitter.com/ethglobal/status/1673069276805099520">黑客马拉松决赛入围者</a>和<a href="https://www.youtube.com/playlist?list=PLXzKMXK2aHh7ZShjCVqztXMbdm9xTSqIR">视频</a></li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li>USDC<a href="https://www.circle.com/en/cross-chain-transfer-protocol">跨链传输协议</a>（CCTP）在主网和 Arbitrum 上线</li><li><a href="https://twitter.com/graphprotocol/status/1674143754725277697">Graph</a>服务了 1 万亿次查询</li><li>Mirror<a href="https://dev.mirror.xyz/8MThiFhn391cfgffQtiRoSpS-Op93IR71rYgf6YEzBc"> Writing NFT v2</a>：通过 NFT 阅读文章、开放编辑</li><li>Diva（DVT 流动质押）<a href="https://divastaking.medium.com/announcing-the-diva-dao-270bb0d188e8">DAO 空投</a>可由质押者索取，不可转让，因此大概不会产生税费，美国和加拿大国民被排除在早期分配之外</li><li><a href="https://blog.clr.fund/round-9-is-underway/">CLRFund第9轮</a>在Arbitrum上线，为公共物品做出贡献</li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-6-3</title>
      <link href="/2023/07/21/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-6-3/"/>
      <url>/2023/07/21/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-6-3/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun-Cancun-Deneb-升级"><a href="#Dencun-Cancun-Deneb-升级" class="headerlink" title="Dencun (Cancun + Deneb)升级"></a>Dencun (Cancun + Deneb)升级</h2><ul><li><p>最新的所有核心开发人员 - 执行 (ACDE)视频会议。Tim Beiko的总结。Tim Beiko和Christine Kim的记录：</p><ul><li><a href="https://docs.google.com/document/d/1HDbym5YOoYj63xswMAwvt5Psh4JaI0biY06b6ZvYV2s/edit">SELFDESTRUCT 弃用的影响分析</a>：EIP6780（SELFDESTRUCT 将仅在与部署合约同一笔交易中有用）影响较小，将包含在 Cancun 升级中；EIP6913 SETCODE 暂时不包含在 Cancun 升级中</li><li>EIP4844 讨论：excess_data_gas，使用 big endian 进行预编译，删除 SSZ EIP，起草测试网 Devnet #6 规范（Dencun devnet之前的最后一个 EIP4844 特定devnet）</li><li>提议将 Cancun 和 Prague 操作码排序添加到执行层规范中</li><li>Cancun 的最终候选EIP ：EIP4788（EVM 中的添加信标区块根）、EIP2537（BLS 预编译）、EIP5656（MCOPY 操作码）、EIP5920（PAY 操作码）和 EIP7069（改进的 CALL 指令）；Cancun 不再考虑新 EIP</li></ul></li><li><p>共识规范<a href="https://github.com/ethereum/consensus-specs/releases/tag/v1.4.0-alpha.0">v1.4.0-alpha.0</a>：Deneb 更新和 attnets 改造</p></li><li><p><a href="https://ceremony.ethereum.org/">KZG 仪式</a>接近 10 贡献者，现在拥有<a href="https://twitter.com/carlbeek/status/1661795909875924992">16 笔主网交易的账户</a>可用</p></li></ul><h2 id="Layer-1"><a href="#Layer-1" class="headerlink" title="Layer 1"></a>Layer 1</h2><ul><li>Ben Edgington：《以太坊升级电子书》添加新章节: <a href="https://eth2book.info/capella/part2/deposits-withdrawals/">存款和取款</a></li><li>Geth 团队：<a href="https://gist.github.com/holiman/4f6601018a8f559d7ce4cfe4e861cf73">如果绝大多数 EL 客户端出现错误会怎样</a>？</li><li><a href="https://twitter.com/gballet/status/1662046913259085824">Verkle 覆盖树转换方法</a>实现</li></ul><h2 id="客户端版本"><a href="#客户端版本" class="headerlink" title="客户端版本"></a>客户端版本</h2><ul><li>共识层：<ul><li>Lighthouse <a href="https://github.com/sigp/lighthouse/releases/tag/v4.2.0">v4.2.0</a>：验证器客户端更快地检测和避免执行层信标节点与离线执行层一起工作。</li><li>Prysm <a href="https://github.com/prysmaticlabs/prysm/releases/tag/v4.0.5">v4.0.5</a>：改进了见证聚合</li></ul></li><li>执行层：<ul><li>Geth <a href="https://github.com/ethereum/go-ethereum/releases/tag/v1.12.0">v1.12.0</a>：移除 PoW，GraphQL 数值编码为十六进制字符串</li><li>Nethermind <a href="https://github.com/NethermindEth/nethermind/releases/tag/1.18.2">v1.18.2</a>：同步过程加速</li></ul></li></ul><h2 id="给质押者"><a href="#给质押者" class="headerlink" title="给质押者"></a>给质押者</h2><ul><li>Eth-wizard <a href="https://github.com/stake-house/eth-wizard/releases/tag/v0.9.7">v0.9.7</a>：验证者在 Ubuntu&#x2F;Windows 上使用 MEV-Boost</li></ul><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><ul><li><a href="https://ethresear.ch/t/why-enshrine-proposer-builder-separation-a-viable-path-to-epbs/15710">实现 Proposer-Builder 分离的路径</a>：通过 Two-Block （两个 slot ）HeadLock 自上而下实现，通过 optimistic relay 自下而上实现</li><li><a href="https://arxiv.org/abs/2305.09032">计时博弈</a>：为了优化 MEV 捕获，提案者可能会延迟区块提案，但仍确保提案及时包含进去。</li></ul><h2 id="Layer-2"><a href="#Layer-2" class="headerlink" title="Layer 2"></a>Layer 2</h2><ul><li><a href="https://figmentcapital.medium.com/distributed-sequencer-technology-a-path-to-decentralized-sequencing-549662cc9912">去中心化定序技术</a>：使用分布式验证器技术对 L2 定序器进行渐进式去中心化的提议</li><li>Layer N <a href="https://www.layern.com/blog/zkfp">零知识欺诈证明</a>：混合方法只需要在存在欺诈可能性时生成证明</li></ul><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><ul><li>EIP：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7069/files">EIP7069</a>：改进的 CALL 指令</li></ul></li><li>ERC：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7050/files">ERC7050</a>：标记 NFT 创作者</li><li><a href="https://github.com/ethereum/EIPs/pull/7053/files">ERC7053</a>：可互操作的数字媒体索引</li><li><a href="https://github.com/ethereum/EIPs/pull/7066/files">ERC7066</a> : ERC721 可锁定</li></ul></li></ul><h2 id="开发者资料"><a href="#开发者资料" class="headerlink" title="开发者资料"></a>开发者资料</h2><ul><li>OpenZeppelin Contracts <a href="https://blog.openzeppelin.com/introducing-openzeppelin-contracts-v4.9">v4.9.0</a>：为 Optimism 、 Base 带来有时间戳支持的治理，针对 ERC-4626 通膨攻击提供保护，改进了默认AccessControl 以更好地处理默认管理员角色，兼容 EIP5267， 使用eip712Domain()增强了 Web3 应用程序中签名的互操作性。</li><li><a href="https://learnblockchain.cn/article/5879">Solc 合约元数据</a>解释：IPFS哈希值和solidity编译器版本</li><li>Foundry：<ul><li>Foundry <a href="https://twitter.com/hievalir/status/1662171773973204993">pre v1 更新亮点</a></li><li>Forge-std <a href="https://github.com/foundry-rs/forge-std/releases/tag/v1.5.6">v1.5.6</a>：新作弊码和纯控制台日志</li><li>提示：<a href="https://twitter.com/paulrberg/status/1660598958454865926">控制台日志记录支持格式说明符，</a>例如 %s 和 %d</li></ul></li><li>abi-to-sol <a href="https://github.com/gnidan/abi-to-sol/releases/tag/v0.7.0">v0.7</a>：生成可嵌入的输出（例如，无 pragma，无license identifier）</li><li>使用模糊测试<a href="https://dacian.me/exploiting-precision-loss-via-fuzz-testing">查找精度损失漏洞</a>的指南</li><li><a href="https://github.com/a16z/cicada#readme">Cicada</a>：使用同态时间锁难题的隐私链上投票</li><li>Vyper <a href="https://github.com/vyperlang/vyper/releases/tag/v0.3.8">v0.3.8</a>：瞬态存储关键字、三元运算符、内置 raw_revert 函数、移位运算符、可配置的 send() gas 和使用 PUSH0</li><li>Ape <a href="https://github.com/ApeWorX/ape/releases/tag/v0.6.9">v0.6.9</a>：通过 Pytest fixtures、Python v3.11 支持和 use_network 标记更容易测试</li><li><a href="https://twitter.com/uniswap/status/1661362297632088066">Uniswap</a>在 Sepolia 测试网上上线</li><li><a href="https://github.com/v3xlabs/enstate#readme">enstate.rs</a>：在 Rust 中使用缓存同时进行 ENS 查询</li><li><a href="https://github.com/morpho-labs/safer#readme">Safer</a>：使用 Foundry 脚本将交易签署并提交到的 <a href="https://app.safe.global/welcome">Safe</a> 多重签名</li><li>Curta CTF <a href="https://twitter.com/popular_12345/status/1662174518696366080">Baby it’s me 解决方案</a></li><li><a href="https://twitter.com/SpearbitDAO/status/1661786772072804361">代码规范概述</a>：关注简单的英语、状态机、图表、接口、占位符测试和可选的形式化定义</li><li>Echidna <a href="https://github.com/crytic/echidna/releases/tag/v2.2.0">v2.2.0</a>：多核模糊测试，优化覆盖收集，模糊测试速度提高 20 倍</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>Tornado Cash治理被攻击者使用 SELFDESTRUCT + CREATE2<a href="https://github.com/coinspect/learn-evm-attacks/tree/master/test/Business_Logic/TornadoCash_Governance">捕获</a></li></ul><h2 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h2><ul><li>Vitalik： <a href="https://vitalik.ca/general/2023/05/21/dont_overload.html">过载以太坊社会共识是高风险的</a>，应用开发者和二层网络需要找到替代方案来实现他们的安全目标，不会有救助。</li><li>Nick Fett: <a href="https://medium.com/@nfett/eigenlayer-crypto-rehypothecation-and-the-infinite-trust-machine4e8164845b59">restaking 被过度炒作</a></li><li>Optimism 的<a href="https://optimism.mirror.xyz/7v1DehEY3dpRcYFhqWrVNc9Qj94H2L976LKlWH1FX-8">RetroPGF第二轮学到的东西</a></li><li>ETHDam <a href="https://taikai.network/cryptocanal/hackathons/ethdam/projects?filter_by=finalists">黑客马拉松项目</a></li><li>ETHGlobal <a href="https://twitter.com/ethglobal/status/1662142905048350724">匿名世界黑客马拉松决赛选手</a></li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li>Maker 投票将<a href="https://forum.makerdao.com/t/stability-scope-parameter-changes-2-non-scope-defined-parameter-changes-may-2023/20981">DSR 提高到 3.33%</a></li><li><a href="https://medium.com/block-analitica/introducing-project-levon-e1444bd888d1">Levon</a>：获得 Maker 金库的信用评分，测试版</li><li>Kain：<a href="https://mirror.xyz/kain.eth/EB9DQldVEb0F74-LmrVau6YbjEtr8dsj1qVn6muYuXw">Synthetix 的状态</a></li><li><a href="https://mirror.xyz/0x01393d9b6dFFce134b6765e9bdd626b258357C37/7tghsnpqiCRKxS-5xbwPC7CPs2drbxWCR4GEZFhNWBY">TAI</a>（受控锚定稳定币）在主网上线</li><li><a href="https://astaria.xyz/">Astaria</a>（NFT 支持的借贷）在主网上线，测试版</li><li><a href="https://twitter.com/safe/status/1660677975669633024">Safe multisig</a> 支持 ERC1271 消息签名（用于 OpenSea 签名）</li><li><a href="https://twitter.com/utopialabs_/status/1661784971676381185">Utopia</a>：安全的多重签名无gas交换，测试版</li><li><a href="https://github.com/lcfr-eth/FlashbotsBundlerUI#readme">Flashbots Bundler</a>：用于从受感染地址中拯救代币</li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-6-24</title>
      <link href="/2023/07/16/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-6-24/"/>
      <url>/2023/07/16/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-6-24/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun-Cancun-Deneb-升级"><a href="#Dencun-Cancun-Deneb-升级" class="headerlink" title="Dencun (Cancun + Deneb) 升级"></a>Dencun (Cancun + Deneb) 升级</h2><ul><li><p>最新的所有核心开发人员 - 执行 (ACDE)视频会议。Christine Kim的记录：</p><ul><li>Deneb 范围：EIP7044（签名退出永久有效）和 EIP4788（EVM 中的信标链区块根）；考虑包含：EIP7045（扩大证明slot包含范围）和 EIP6988（防止被罚没的验证者被选为区块提议者）</li></ul></li><li><p>关于主网区块重组增加的讨论，提议更改区块生产、证明和聚合的<a href="https://github.com/ethereum/consensus-specs/pull/3433">sub-slot时间</a></p><ul><li>关于取消每个验证者最多质押 32 ETH 的讨论</li></ul></li><li><p>EIP4844：</p><ul><li>最新的 EIP4844 实施者<a href="https://www.youtube.com/watch?v=jQ86ItkOfm0">视频会议</a>。<a href="https://twitter.com/terencechain/status/1668332513645977612">Terence </a>的记录</li><li>Dankrad<a href="https://notes.ethereum.org/OZJ90ZlcQtyrtZa6INYixQ?view#Test-day-2-110623">对每个区块可以支持的 blob 大小进行测试</a></li><li><a href="https://4844-devnet-6.ethpandaops.io/">EIP4844 devnet 6</a> 测试网发布</li><li><a href="https://ceremony.ethereum.org/">KZG 仪式</a>有超过 11 万贡献者，没有人排队</li></ul></li><li><p>Consensus-specs <a href="https://github.com/ethereum/consensus-specs/releases/tag/v1.4.0-alpha.3">v1.4.0-alpha.3</a>：补丁将 BLOB_SIDECAR_SUBNET_COUNT 增加到 6</p></li></ul><h2 id="Layer-1"><a href="#Layer-1" class="headerlink" title="Layer 1"></a>Layer 1</h2><ul><li><a href="https://twitter.com/ethereumonarm/status/1669257232779825153">Erigon 存档节点</a>在小于 500 美元的 ARM 板上运行</li><li>Dedaub：<a href="https://docs.google.com/document/d/1p-1VvOGwI5GHkwaGMzJYDL7Affofm6rVLa6cvnmoqGI/edit#heading=h.kqxi3kc5lnoq">EIP6404&#x2F;6466</a> 研究用 RLP 的合约向 SSZ 过渡的影响[提醒：SSZ EIP 已从 Dencun 升级中移除]</li><li><a href="https://github.com/rauljordan/beacon-api-checker#readme">Beacon API 检查器</a>：使用 Rust 跨客户端检查 API 响应的 CLI</li></ul><h2 id="客户端版本"><a href="#客户端版本" class="headerlink" title="客户端版本"></a>客户端版本</h2><ul><li>共识层：<ul><li>Prysm <a href="https://github.com/prysmaticlabs/prysm/releases/tag/v4.0.6">v4.0.6</a>：修复错误，缩短边缘情况区块提议时间</li><li>Teku <a href="https://github.com/ConsenSys/teku/releases/tag/23.6.0">v23.6.0</a>：奖励 beacon-api 端点，<a href="https://mirror.xyz/rolfy.eth/w-hJGapBjnlOaMAjU4Bg8P2N7KyW4QOdaJN2FzBri-o">更新解决5月的最终性问题</a></li></ul></li><li>执行层：<ul><li>Erigon <a href="https://github.com/ledgerwatch/erigon/releases/tag/v2.45.2">v2.45.2</a>：分阶段同步修复</li></ul></li></ul><h2 id="给质押者"><a href="#给质押者" class="headerlink" title="给质押者"></a>给质押者</h2><ul><li>Payload 的<a href="https://payload.de/data/">区块分析仪表板</a>，测试版</li></ul><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><ul><li>关于 5 月的最终性问题事件的<a href="https://ethresear.ch/t/cascading-network-effects-on-ethereums-finality/15871">数据可视化</a></li></ul><h2 id="Layer-2"><a href="#Layer-2" class="headerlink" title="Layer 2"></a>Layer 2</h2><ul><li><a href="https://github.com/testinprod-io/op-erigon#readme">Optimistic Erigon 客户端</a>支持 Optimism 主网</li><li>Arbitrum<a href="https://arbitrumfoundation.notion.site/arbitrumfoundation/June-7-2023-Batch-Poster-Outage-d49c50df42864c7b83521fd7aa5897f2">定序器批量发布问题分析</a></li><li><a href="https://taiko.mirror.xyz/VjNjFws6OOVez5YCDMwjy4BUiDqZBHYDvcW4-JZGDkc">Layer 2 MEV</a>和去中心化排序</li><li>Frax Finance <a href="https://www.theblock.co/post/235110/frax-finance-to-launch-ethereum-layer-2-named-fraxchain">计划 Fraxchain rollup 用它的 LSD 作为 gas 费代币</a></li></ul><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><ul><li>ERC：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7169/files">ERC7169</a> : 分批排序</li><li><a href="https://github.com/ethereum/EIPs/pull/7182/files">ERC7182</a>：接口命名约定</li></ul></li></ul><h2 id="开发者资料"><a href="#开发者资料" class="headerlink" title="开发者资料"></a>开发者资料</h2><ul><li><p>Foundry：</p><ul><li><a href="https://twitter.com/hievalir/status/1669781947642695680">Pre-v1 更新</a>：fuzz-runs CLI 标志、0 basefee、Optimism 上的批量交易和 readCallers 作弊码</li><li><a href="https://github.com/0xNazgul/fuzzydefi#readme">Fuzzy DeFi</a>：Uniswap v2、Olympus DAO 和 Compound v2 分叉的代码属性</li><li><a href="https://github.com/ind-igo/forge-safe#readme">Forge-safe</a>：用 Forge 脚本构建安全的多签批量交易</li></ul></li><li><p>OpenZeppelin 合约<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/releases/tag/v4.9.2">v4.9.2</a>：MerkleProof 库补丁，修复<code>processMultiProof</code>和<code>processMultiProofCalldata</code>中的bug，即如果树在深度1处包含一个值为0的节点，则允许证明任意叶子。</p></li><li><p>Uniswapv4：使用钩子自定义流动性池，在 Dencun 升级中使用 ERC1153（瞬态存储）进行闪存记账，Uniswap v4 依旧正在开发中，源码使用：Business Source License ，4 年内限制其他产品使用。</p><ul><li><a href="https://github.com/saucepoint/v4-template#readme">V4-template</a>：用于创建 Uniswap v4 钩子的模板</li><li><a href="https://github.com/jtriley-eth/huff-hooks#readme">Huff 钩子</a>：Huff 中的 Uniswap v4 钩子库，正在进行中</li></ul></li><li><p><a href="https://github.com/merklejerk/bytecode-zip-fe/blob/main/docs/HELP.md">Bytecode.zip</a>：从浏览器部署压缩和包装合约</p></li><li><p>Titanoboa（Vyper 解释器）与<a href="https://twitter.com/big_tech_sux/status/1668305117605662720">jupyter notebooks 集成</a>：通过浏览器签名</p></li><li><p>Ethers.js <a href="https://github.com/ethers-io/ext-provider-plugin-multicoin#readme">ENS 多币 provider 插件</a> 扩展</p></li><li><p><a href="https://twitter.com/wagmi_sh/status/1668324730582224898">ABIType</a>：在运行时和类型级别添加从 JSON ABI 到人类可读 ABI 的转换</p></li><li><p>RainbowKit <a href="https://github.com/rainbow-me/rainbowkit/releases/tag/%40rainbow-me%2Frainbowkit%401.0.2">v1.0.2</a>：支持 WalletConnect v2 支持</p></li><li><p><a href="https://github.com/zobront/4byte-collider#readme">4byte collider</a>：用于查找有碰撞的4字节选择符的函数签名 </p></li><li><p><a href="https://wtf.allwallet.dev/week-09/">钱包测试框架</a>：切换到 viem 并添加了更多测试</p></li><li><p>用于合约钱包的<a href="https://ethresear.ch/t/passkey-based-account-abstraction-signer-for-smart-contract-wallets/15856">基于密钥的帐户抽象签名</a></p></li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>Sturdy Finance，<a href="https://rekt.news/sturdy-rekt/">80 万美元漏洞被利用</a>，通过只读重入进行价格操纵</li><li><a href="https://github.com/pcaversaccio/malleable-signatures#readme">签名延展性</a>：展示了如何执行使用紧凑签名的签名延展性攻击。</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li><a href="https://twitter.com/MakerDAO/status/1669710346003808256">Maker Dai 储蓄率 (DSR)</a>于 6 月 19 日升至 3.49%</li><li>Uniswap <a href="https://blog.uniswap.org/uniswap-v4">v4 愿景</a>：更通用的 v3 ，允许通过自定义池的挂钩进行不同的权衡</li><li>Uniswap 基金会<a href="https://uniswap.notion.site/Bridge-Assessment-Report-0c8477afadce425abac9c0bd175ca382">跨链桥评估</a>报告</li><li><a href="https://www.blog.eigenlayer.xyz/eigenlayer-stage-1-mainnet-launch/">EigenLayer 第 1 阶段</a>在主网上线，达到启动限制；<a href="https://restaking.nethermind.io/">restaking仪表板</a></li><li><a href="https://sound.mirror.xyz/eLJe_mQbJJf5_uNUu8AzJTP6VrfT7YIrSNFSeISE8Pc">Sound</a>（音乐 NFT）在 Optimism 上线</li><li><a href="https://twitter.com/Sothebysverse/status/1669478259489226752">Goose</a> NFT 以 540 万美元的价格从 3AC 系列中售出</li><li>NFT 基础设施项目最近艰难前行：<a href="https://twitter.com/______jpg______/status/1667818270672527363">JPG</a>暂停和<a href="https://twitter.com/backed_xyz/status/1668689845722423314">NFF（支持）</a>逐渐减少</li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-6-17</title>
      <link href="/2023/07/12/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-6-17/"/>
      <url>/2023/07/12/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-6-17/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun-Cancun-Deneb-升级"><a href="#Dencun-Cancun-Deneb-升级" class="headerlink" title="Dencun (Cancun + Deneb) 升级"></a>Dencun (Cancun + Deneb) 升级</h2><ul><li><p>最新的所有核心开发人员 - 执行 (ACDE)视频会议。Christine Kim的记录：</p><ul><li>Deneb 范围：EIP7044（签名退出永久有效）和 EIP4788（EVM 中的信标链区块根）；考虑包含：EIP7045（扩大证明slot包含范围）和 EIP6988（防止被罚没的验证者被选为区块提议者）</li></ul></li><li><p>关于主网区块重组增加的讨论，提议更改区块生产、证明和聚合的<a href="https://github.com/ethereum/consensus-specs/pull/3433">sub-slot时间</a></p><ul><li>关于取消每个验证者最多质押 32 ETH 的讨论</li></ul></li><li><p>EIP4844：</p><ul><li>最新的 EIP4844 实施者<a href="https://www.youtube.com/watch?v=jQ86ItkOfm0">视频会议</a>。<a href="https://twitter.com/terencechain/status/1668332513645977612">Terence </a>的记录</li><li>Dankrad<a href="https://notes.ethereum.org/OZJ90ZlcQtyrtZa6INYixQ?view#Test-day-2-110623">对每个区块可以支持的 blob 大小进行测试</a></li><li><a href="https://4844-devnet-6.ethpandaops.io/">EIP4844 devnet 6</a> 测试网发布</li><li><a href="https://ceremony.ethereum.org/">KZG 仪式</a>有超过 11 万贡献者，没有人排队</li></ul></li><li><p>Consensus-specs <a href="https://github.com/ethereum/consensus-specs/releases/tag/v1.4.0-alpha.3">v1.4.0-alpha.3</a>：补丁将 BLOB_SIDECAR_SUBNET_COUNT 增加到 6</p></li></ul><h2 id="Layer-1"><a href="#Layer-1" class="headerlink" title="Layer 1"></a>Layer 1</h2><ul><li><a href="https://twitter.com/ethereumonarm/status/1669257232779825153">Erigon 存档节点</a>在小于 500 美元的 ARM 板上运行</li><li>Dedaub：<a href="https://docs.google.com/document/d/1p-1VvOGwI5GHkwaGMzJYDL7Affofm6rVLa6cvnmoqGI/edit#heading=h.kqxi3kc5lnoq">EIP6404&#x2F;6466</a> 研究用 RLP 的合约向 SSZ 过渡的影响[提醒：SSZ EIP 已从 Dencun 升级中移除]</li><li><a href="https://github.com/rauljordan/beacon-api-checker#readme">Beacon API 检查器</a>：使用 Rust 跨客户端检查 API 响应的 CLI</li></ul><h2 id="客户端版本"><a href="#客户端版本" class="headerlink" title="客户端版本"></a>客户端版本</h2><ul><li>共识层：<ul><li>Prysm <a href="https://github.com/prysmaticlabs/prysm/releases/tag/v4.0.6">v4.0.6</a>：修复错误，缩短边缘情况区块提议时间</li><li>Teku <a href="https://github.com/ConsenSys/teku/releases/tag/23.6.0">v23.6.0</a>：奖励 beacon-api 端点，<a href="https://mirror.xyz/rolfy.eth/w-hJGapBjnlOaMAjU4Bg8P2N7KyW4QOdaJN2FzBri-o">更新解决5月的最终性问题</a></li></ul></li><li>执行层：<ul><li>Erigon <a href="https://github.com/ledgerwatch/erigon/releases/tag/v2.45.2">v2.45.2</a>：分阶段同步修复</li></ul></li></ul><h2 id="给质押者"><a href="#给质押者" class="headerlink" title="给质押者"></a>给质押者</h2><ul><li>Payload 的<a href="https://payload.de/data/">区块分析仪表板</a>，测试版</li></ul><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><ul><li>关于 5 月的最终性问题事件的<a href="https://ethresear.ch/t/cascading-network-effects-on-ethereums-finality/15871">数据可视化</a></li></ul><h2 id="Layer-2"><a href="#Layer-2" class="headerlink" title="Layer 2"></a>Layer 2</h2><ul><li><a href="https://github.com/testinprod-io/op-erigon#readme">Optimistic Erigon 客户端</a>支持 Optimism 主网</li><li>Arbitrum<a href="https://arbitrumfoundation.notion.site/arbitrumfoundation/June-7-2023-Batch-Poster-Outage-d49c50df42864c7b83521fd7aa5897f2">定序器批量发布问题分析</a></li><li><a href="https://taiko.mirror.xyz/VjNjFws6OOVez5YCDMwjy4BUiDqZBHYDvcW4-JZGDkc">Layer 2 MEV</a>和去中心化排序</li><li>Frax Finance <a href="https://www.theblock.co/post/235110/frax-finance-to-launch-ethereum-layer-2-named-fraxchain">计划 Fraxchain rollup 用它的 LSD 作为 gas 费代币</a></li></ul><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><ul><li>ERC：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7169/files">ERC7169</a> : 分批排序</li><li><a href="https://github.com/ethereum/EIPs/pull/7182/files">ERC7182</a>：接口命名约定</li></ul></li></ul><h2 id="开发者资料"><a href="#开发者资料" class="headerlink" title="开发者资料"></a>开发者资料</h2><ul><li><p>Foundry：</p><ul><li><a href="https://twitter.com/hievalir/status/1669781947642695680">Pre-v1 更新</a>：fuzz-runs CLI 标志、0 basefee、Optimism 上的批量交易和 readCallers 作弊码</li><li><a href="https://github.com/0xNazgul/fuzzydefi#readme">Fuzzy DeFi</a>：Uniswap v2、Olympus DAO 和 Compound v2 分叉的代码属性</li><li><a href="https://github.com/ind-igo/forge-safe#readme">Forge-safe</a>：用 Forge 脚本构建安全的多签批量交易</li></ul></li><li><p>OpenZeppelin 合约<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/releases/tag/v4.9.2">v4.9.2</a>：MerkleProof 库补丁，修复<code>processMultiProof</code>和<code>processMultiProofCalldata</code>中的bug，即如果树在深度1处包含一个值为0的节点，则允许证明任意叶子。</p></li><li><p>Uniswapv4：使用钩子自定义流动性池，在 Dencun 升级中使用 ERC1153（瞬态存储）进行闪存记账，Uniswap v4 依旧正在开发中，源码使用：Business Source License ，4 年内限制其他产品使用。</p><ul><li><a href="https://github.com/saucepoint/v4-template#readme">V4-template</a>：用于创建 Uniswap v4 钩子的模板</li><li><a href="https://github.com/jtriley-eth/huff-hooks#readme">Huff 钩子</a>：Huff 中的 Uniswap v4 钩子库，正在进行中</li></ul></li><li><p><a href="https://github.com/merklejerk/bytecode-zip-fe/blob/main/docs/HELP.md">Bytecode.zip</a>：从浏览器部署压缩和包装合约</p></li><li><p>Titanoboa（Vyper 解释器）与<a href="https://twitter.com/big_tech_sux/status/1668305117605662720">jupyter notebooks 集成</a>：通过浏览器签名</p></li><li><p>Ethers.js <a href="https://github.com/ethers-io/ext-provider-plugin-multicoin#readme">ENS 多币 provider 插件</a> 扩展</p></li><li><p><a href="https://twitter.com/wagmi_sh/status/1668324730582224898">ABIType</a>：在运行时和类型级别添加从 JSON ABI 到人类可读 ABI 的转换</p></li><li><p>RainbowKit <a href="https://github.com/rainbow-me/rainbowkit/releases/tag/%40rainbow-me%2Frainbowkit%401.0.2">v1.0.2</a>：支持 WalletConnect v2 支持</p></li><li><p><a href="https://github.com/zobront/4byte-collider#readme">4byte collider</a>：用于查找有碰撞的4字节选择符的函数签名 </p></li><li><p><a href="https://wtf.allwallet.dev/week-09/">钱包测试框架</a>：切换到 viem 并添加了更多测试</p></li><li><p>用于合约钱包的<a href="https://ethresear.ch/t/passkey-based-account-abstraction-signer-for-smart-contract-wallets/15856">基于密钥的帐户抽象签名</a></p></li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>Sturdy Finance，<a href="https://rekt.news/sturdy-rekt/">80 万美元漏洞被利用</a>，通过只读重入进行价格操纵</li><li><a href="https://github.com/pcaversaccio/malleable-signatures#readme">签名延展性</a>：展示了如何执行使用紧凑签名的签名延展性攻击。</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li><a href="https://twitter.com/MakerDAO/status/1669710346003808256">Maker Dai 储蓄率 (DSR)</a>于 6 月 19 日升至 3.49%</li><li>Uniswap <a href="https://blog.uniswap.org/uniswap-v4">v4 愿景</a>：更通用的 v3 ，允许通过自定义池的挂钩进行不同的权衡</li><li>Uniswap 基金会<a href="https://uniswap.notion.site/Bridge-Assessment-Report-0c8477afadce425abac9c0bd175ca382">跨链桥评估</a>报告</li><li><a href="https://www.blog.eigenlayer.xyz/eigenlayer-stage-1-mainnet-launch/">EigenLayer 第 1 阶段</a>在主网上线，达到启动限制；<a href="https://restaking.nethermind.io/">restaking仪表板</a></li><li><a href="https://sound.mirror.xyz/eLJe_mQbJJf5_uNUu8AzJTP6VrfT7YIrSNFSeISE8Pc">Sound</a>（音乐 NFT）在 Optimism 上线</li><li><a href="https://twitter.com/Sothebysverse/status/1669478259489226752">Goose</a> NFT 以 540 万美元的价格从 3AC 系列中售出</li><li>NFT 基础设施项目最近艰难前行：<a href="https://twitter.com/______jpg______/status/1667818270672527363">JPG</a>暂停和<a href="https://twitter.com/backed_xyz/status/1668689845722423314">NFF（支持）</a>逐渐减少</li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-6-10</title>
      <link href="/2023/07/10/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-6-10/"/>
      <url>/2023/07/10/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-6-10/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun-Cancun-Deneb-升级"><a href="#Dencun-Cancun-Deneb-升级" class="headerlink" title="Dencun (Cancun + Deneb)升级"></a>Dencun (Cancun + Deneb)升级</h2><ul><li><p>最新的所有核心开发人员 - 执行 (ACDE)视频会议。Tim Beiko的总结。Tim Beiko的记录：</p><ul><li>Cancun 升级范围最终确定：添加 EIP4788（EVM 信标链区块根），如果测试或者实现没问题的 会加入 EIP5656 （MCOPY），若发现有明显的瓶颈就会取消EIP5656</li></ul></li><li><p>Cancun 将不包括 EIP2537 (BLS)、EIP5920 (PAY) 和 EIP7069（修改后的 CALL 指令）</p><ul><li>在开发测试网，EIP4844 每个区块 blob 数设置为默认3个，最大6个，未来上主网仍可能会修改。</li></ul></li><li><p>EIP4844 的 Devnet 6（开发测试网） 将于下周发布</p><ul><li><a href="https://github.com/ethereum/pm/issues/803">Holešky 测试网</a>（Goerli 的继任） 6 月 15 日首次视频会议，议题是确定 9 月的创世配置和状态（对 Dencun 测试来说可能为时已晚）</li></ul></li><li><p>Consensus-specs <a href="https://github.com/ethereum/consensus-specs/releases/tag/v1.4.0-alpha.2">v1.4.0-alpha.2</a>：将 EIP4844 的 MAX_BLOBS_PER_BLOCK 增加到 6</p></li></ul><h2 id="Layer-1"><a href="#Layer-1" class="headerlink" title="Layer 1"></a>Layer 1</h2><ul><li><a href="https://github.com/paradigmxyz/flood/#readme">Flood</a>：EVM 的 RPC 端点基准测试</li><li>Terence：通过预先计算shuffling<a href="https://hackmd.io/lWq6jEVhThy72CnAkpTvig">减少 Prysm 验证者的 slot 0 提议时间</a></li></ul><h2 id="客户端版本"><a href="#客户端版本" class="headerlink" title="客户端版本"></a>客户端版本</h2><ul><li>执行层：<ul><li>Erigon <a href="https://github.com/ledgerwatch/erigon/releases/tag/v2.45.0">v2.45.0</a>：Caplin（嵌入式共识层）错误修复，区块体的数据库布局修改</li><li>Nethermind <a href="https://github.com/NethermindEth/nethermind/releases/tag/1.19.2">v1.19.2</a>：支持即将推出的 Teku v23.6</li></ul></li></ul><h2 id="给质押者"><a href="#给质押者" class="headerlink" title="给质押者"></a>给质押者</h2><ul><li><a href="https://github.com/tbenr/el-sync-driver#readme">执行层同步驱动程序</a>：使用现有的共识层客户端同步新的执行层客户端，无需更改共识层配置</li></ul><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><ul><li>提议<a href="https://ethresear.ch/t/increase-the-max-effective-balance-a-modest-proposal/15801">增加 MAX_EFFECTIVE_BALANCE</a>，允许验证者合并，减轻网络负载</li><li><a href="https://hackmd.io/@jsign/vkt-proofs-implementation-notes">Verkle Tree 证明生成和验证</a>实现优化</li></ul><h2 id="Layer-2"><a href="#Layer-2" class="headerlink" title="Layer 2"></a>Layer 2</h2><ul><li>Optimism <a href="https://twitter.com/optimismFND/status/1666850591669202965">Bedrock 升级，通过数据压缩和</a><a href="https://twitter.com/maurelian_/status/1667205092959830016">ETH 原生表示</a>降低 40% 以上的 gas 费用</li><li>Arbitrum <a href="https://twitter.com/ArbitrumDevs/status/1666549893001887744">batch-poster 错误</a>导致在链上发布交易暂停，从用户角度来看没有服务丢失</li><li>Arbitrum <a href="https://arxiv.org/abs/2306.02179">时间影响交易排序</a>经济学分析</li></ul><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><ul><li>ERC：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7144/files">ERC7144</a>：带有交易验证步骤的ERC20</li><li><a href="https://github.com/ethereum/EIPs/pull/7160/files">ERC7160</a> : ERC721 扩展，支持多个元数据</li></ul></li></ul><h2 id="开发者资料"><a href="#开发者资料" class="headerlink" title="开发者资料"></a>开发者资料</h2><ul><li>Web3 接口库：<ul><li>web3.js <a href="https://blog.chainsafe.io/announcing-the-full-release-of-web3-js-v4-e9e26275a3dc">v4</a>：用 TypeScript 重写，减少构建大小，模块化，可通过插件扩展</li><li>viem <a href="https://twitter.com/wagmi_sh/status/1666189876910501888">v1</a>：包括选择加入批处理 JSON-RPC</li></ul></li><li><a href="https://evm.storage/">evm.storage</a>：查看特定区块中已验证合约的存储和状态，alpha 版本</li><li>OpenZeppelin Contracts <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/releases/tag/v4.9.1">v4.9.1</a>：修复了 Governor 和 GovernorCompatibilityBravo 中的 DoS 漏洞，在该漏洞中，提案创建可能会被抢跑（ frontrunning） 阻止</li><li>Foundry：<ul><li>Patrick Collins：<a href="https://github.com/Cyfrin/foundry-full-course-f23#readme">Solidity 开发课程 – Foundry 版</a>，27 小时视频</li><li>提示：<a href="https://twitter.com/drakeevansv1/status/1666468515795140611">使用自定义配置文件调用foundry命令</a></li></ul></li><li>NatSpec<a href="https://twitter.com/spearbitdao/status/1665800702122250241">最佳实践</a></li><li>abi-to-sol <a href="https://github.com/gnidan/abi-to-sol/releases/tag/v0.8.0">v0.8.0</a>：支持用户定义的值类型</li><li><a href="https://twitter.com/big_tech_sux/status/1664856295474712579">Titanoboa</a>（Vyper 解释器）添加允许部署的节点交互</li><li>snekmate <a href="https://github.com/pcaversaccio/snekmate/releases/tag/v0.0.2">v0.0.2</a>（Vyper 合约）：支持 wad_ln 、wad_exp 和 EIP5267</li><li><a href="https://github.com/mds1/evm-diff#readme">EVM 差异</a>：EVM 兼容链的执行层规范差异</li><li>Tenderly ：单次运行中<a href="https://blog.tenderly.co/how-tenderly-enables-most-accurate-ethereum-gas-estimation/">精确的 gas 估算</a></li><li><a href="https://twitter.com/paulmillr/status/1664984693790457858">Noble 密码学更新</a>：标记 npm 源出处（用于透明构建），ed25519 和 ed448 提供不可抵赖性（强约束力的签名）</li><li><a href="https://github.com/martriay/merklefy#readme">Merklefy</a>：用于从 csv 生成默克尔树的web应用</li><li>用 Circom 和 Hardhat <a href="https://betterprogramming.pub/how-to-create-a-zk-smart-contract-cd948a673749">创建第一个零知识合约</a></li></ul><h2 id="生态系统"><a href="#生态系统" class="headerlink" title="生态系统"></a>生态系统</h2><ul><li>EF <a href="https://esp.ethereum.foundation/run-a-node-grants">运行节点Grant</a>，以鼓励多样化，接收 Dappnode 或 硬件形式的 Grant 。</li><li><a href="https://learnblockchain.cn/article/5966">Vitalik：以太坊要大众采用仍需三个转变</a>：Rollup、合约钱包、隐私</li><li>ETH首尔黑客马拉松<a href="https://ethseoul2023.devfolio.co/projects?show_winners=true">获奖者</a></li><li>ETH 贝尔格莱德黑客马拉松<a href="https://twitter.com/ethbelgrade/status/1667099119351914497">获奖者</a> &amp; <a href="https://taikai.network/ethbelgrade/hackathons/hackathon-2023/projects">项目列表</a></li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li><a href="https://twitter.com/MakerDAO/status/1665770361265459202">Maker DAO 通过 Coinbase 部署了 500M DAI</a> ，2.6% 的年回报率</li><li>评估 LP 在 AMM 中竞争力的<a href="https://blog.uniswap.org/metric-evaluate-lp-competitiveness-amm">FLAIR 指标</a></li><li><a href="https://ethresear.ch/t/forkable-stablecoin/15820">可分叉的稳定币设计</a>，用来管理有争议的链分叉</li><li>0xSplits <a href="https://0xsplits.mirror.xyz/eZ1uAL3bIOd75LGcBXQEzOYE51wTHtCjNGsAD70rocg">Swapper</a>：接收到的代币交换成输出代币，可叠加使用，例如创建税收钱包</li><li>sudoswap <a href="https://blog.sudoswap.xyz/introducing-sudoswap-v2.html">v2</a>（NFT 市场）：链上版税、创建者设置、支持 ERC1155 、条件订单和资金流水</li><li><a href="https://launch.mirror.xyz/oyJ1CLHinWc-NqJ5QYpNGgzsbQO5M-813apMWQcZhO0">Usernames.club</a>：UsernameNFT 社区命名空间，所有名称都可以通过CCIP Read 在usr.id 与 ENS 交互，通过 Nouns 拍卖获得</li><li><a href="https://github.com/summa-dev">Summa</a>：中心化交易所(cex)偿付能力解决方案的零知识证明，beta版。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-5-27</title>
      <link href="/2023/07/09/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-5-27/"/>
      <url>/2023/07/09/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-5-27/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun-Cancun-Deneb-升级"><a href="#Dencun-Cancun-Deneb-升级" class="headerlink" title="Dencun (Cancun + Deneb)升级"></a>Dencun (Cancun + Deneb)升级</h2><ul><li><p>最新的所有核心开发人员 - 执行 (ACDE)视频会议。Tim Beiko的总结。Tim Beiko和Christine Kim的记录：</p><ul><li><a href="https://docs.google.com/document/d/1HDbym5YOoYj63xswMAwvt5Psh4JaI0biY06b6ZvYV2s/edit">SELFDESTRUCT 弃用的影响分析</a>：EIP6780（SELFDESTRUCT 将仅在与部署合约同一笔交易中有用）影响较小，将包含在 Cancun 升级中；EIP6913 SETCODE 暂时不包含在 Cancun 升级中</li><li>EIP4844 讨论：excess_data_gas，使用 big endian 进行预编译，删除 SSZ EIP，起草测试网 Devnet #6 规范（Dencun devnet之前的最后一个 EIP4844 特定devnet）</li><li>提议将 Cancun 和 Prague 操作码排序添加到执行层规范中</li><li>Cancun 的最终候选EIP ：EIP4788（EVM 中的添加信标区块根）、EIP2537（BLS 预编译）、EIP5656（MCOPY 操作码）、EIP5920（PAY 操作码）和 EIP7069（改进的 CALL 指令）；Cancun 不再考虑新 EIP</li></ul></li><li><p>共识规范<a href="https://github.com/ethereum/consensus-specs/releases/tag/v1.4.0-alpha.0">v1.4.0-alpha.0</a>：Deneb 更新和 attnets 改造</p></li><li><p><a href="https://ceremony.ethereum.org/">KZG 仪式</a>接近 10 贡献者，现在拥有<a href="https://twitter.com/carlbeek/status/1661795909875924992">16 笔主网交易的账户</a>可用</p></li></ul><h2 id="Layer-1"><a href="#Layer-1" class="headerlink" title="Layer 1"></a>Layer 1</h2><ul><li>Ben Edgington：《以太坊升级电子书》添加新章节: <a href="https://eth2book.info/capella/part2/deposits-withdrawals/">存款和取款</a></li><li>Geth 团队：<a href="https://gist.github.com/holiman/4f6601018a8f559d7ce4cfe4e861cf73">如果绝大多数 EL 客户端出现错误会怎样</a>？</li><li><a href="https://twitter.com/gballet/status/1662046913259085824">Verkle 覆盖树转换方法</a>实现</li></ul><h2 id="客户端版本"><a href="#客户端版本" class="headerlink" title="客户端版本"></a>客户端版本</h2><ul><li>共识层：<ul><li>Lighthouse <a href="https://github.com/sigp/lighthouse/releases/tag/v4.2.0">v4.2.0</a>：验证器客户端更快地检测和避免执行层信标节点与离线执行层一起工作。</li><li>Prysm <a href="https://github.com/prysmaticlabs/prysm/releases/tag/v4.0.5">v4.0.5</a>：改进了见证聚合</li></ul></li><li>执行层：<ul><li>Geth <a href="https://github.com/ethereum/go-ethereum/releases/tag/v1.12.0">v1.12.0</a>：移除 PoW，GraphQL 数值编码为十六进制字符串</li><li>Nethermind <a href="https://github.com/NethermindEth/nethermind/releases/tag/1.18.2">v1.18.2</a>：同步过程加速</li></ul></li></ul><h2 id="给质押者"><a href="#给质押者" class="headerlink" title="给质押者"></a>给质押者</h2><ul><li>Eth-wizard <a href="https://github.com/stake-house/eth-wizard/releases/tag/v0.9.7">v0.9.7</a>：验证者在 Ubuntu&#x2F;Windows 上使用 MEV-Boost</li></ul><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><ul><li><a href="https://ethresear.ch/t/why-enshrine-proposer-builder-separation-a-viable-path-to-epbs/15710">实现 Proposer-Builder 分离的路径</a>：通过 Two-Block （两个 slot ）HeadLock 自上而下实现，通过 optimistic relay 自下而上实现</li><li><a href="https://arxiv.org/abs/2305.09032">计时博弈</a>：为了优化 MEV 捕获，提案者可能会延迟区块提案，但仍确保提案及时包含进去。</li></ul><h2 id="Layer-2"><a href="#Layer-2" class="headerlink" title="Layer 2"></a>Layer 2</h2><ul><li><a href="https://figmentcapital.medium.com/distributed-sequencer-technology-a-path-to-decentralized-sequencing-549662cc9912">去中心化定序技术</a>：使用分布式验证器技术对 L2 定序器进行渐进式去中心化的提议</li><li>Layer N <a href="https://www.layern.com/blog/zkfp">零知识欺诈证明</a>：混合方法只需要在存在欺诈可能性时生成证明</li></ul><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><ul><li>EIP：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7069/files">EIP7069</a>：改进的 CALL 指令</li></ul></li><li>ERC：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7050/files">ERC7050</a>：标记 NFT 创作者</li><li><a href="https://github.com/ethereum/EIPs/pull/7053/files">ERC7053</a>：可互操作的数字媒体索引</li><li><a href="https://github.com/ethereum/EIPs/pull/7066/files">ERC7066</a> : ERC721 可锁定</li></ul></li></ul><h2 id="开发者资料"><a href="#开发者资料" class="headerlink" title="开发者资料"></a>开发者资料</h2><ul><li>OpenZeppelin Contracts <a href="https://blog.openzeppelin.com/introducing-openzeppelin-contracts-v4.9">v4.9.0</a>：为 Optimism 、 Base 带来有时间戳支持的治理，针对 ERC-4626 通膨攻击提供保护，改进了默认AccessControl 以更好地处理默认管理员角色，兼容 EIP5267， 使用eip712Domain()增强了 Web3 应用程序中签名的互操作性。</li><li><a href="https://learnblockchain.cn/article/5879">Solc 合约元数据</a>解释：IPFS哈希值和solidity编译器版本</li><li>Foundry：<ul><li>Foundry <a href="https://twitter.com/hievalir/status/1662171773973204993">pre v1 更新亮点</a></li><li>Forge-std <a href="https://github.com/foundry-rs/forge-std/releases/tag/v1.5.6">v1.5.6</a>：新作弊码和纯控制台日志</li><li>提示：<a href="https://twitter.com/paulrberg/status/1660598958454865926">控制台日志记录支持格式说明符，</a>例如 %s 和 %d</li></ul></li><li>abi-to-sol <a href="https://github.com/gnidan/abi-to-sol/releases/tag/v0.7.0">v0.7</a>：生成可嵌入的输出（例如，无 pragma，无license identifier）</li><li>使用模糊测试<a href="https://dacian.me/exploiting-precision-loss-via-fuzz-testing">查找精度损失漏洞</a>的指南</li><li><a href="https://github.com/a16z/cicada#readme">Cicada</a>：使用同态时间锁难题的隐私链上投票</li><li>Vyper <a href="https://github.com/vyperlang/vyper/releases/tag/v0.3.8">v0.3.8</a>：瞬态存储关键字、三元运算符、内置 raw_revert 函数、移位运算符、可配置的 send() gas 和使用 PUSH0</li><li>Ape <a href="https://github.com/ApeWorX/ape/releases/tag/v0.6.9">v0.6.9</a>：通过 Pytest fixtures、Python v3.11 支持和 use_network 标记更容易测试</li><li><a href="https://twitter.com/uniswap/status/1661362297632088066">Uniswap</a>在 Sepolia 测试网上上线</li><li><a href="https://github.com/v3xlabs/enstate#readme">enstate.rs</a>：在 Rust 中使用缓存同时进行 ENS 查询</li><li><a href="https://github.com/morpho-labs/safer#readme">Safer</a>：使用 Foundry 脚本将交易签署并提交到的 <a href="https://app.safe.global/welcome">Safe</a> 多重签名</li><li>Curta CTF <a href="https://twitter.com/popular_12345/status/1662174518696366080">Baby it’s me 解决方案</a></li><li><a href="https://twitter.com/SpearbitDAO/status/1661786772072804361">代码规范概述</a>：关注简单的英语、状态机、图表、接口、占位符测试和可选的形式化定义</li><li>Echidna <a href="https://github.com/crytic/echidna/releases/tag/v2.2.0">v2.2.0</a>：多核模糊测试，优化覆盖收集，模糊测试速度提高 20 倍</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>Tornado Cash治理被攻击者使用 SELFDESTRUCT + CREATE2<a href="https://github.com/coinspect/learn-evm-attacks/tree/master/test/Business_Logic/TornadoCash_Governance">捕获</a></li></ul><h2 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h2><ul><li>Vitalik： <a href="https://vitalik.ca/general/2023/05/21/dont_overload.html">过载以太坊社会共识是高风险的</a>，应用开发者和二层网络需要找到替代方案来实现他们的安全目标，不会有救助。</li><li>Nick Fett: <a href="https://medium.com/@nfett/eigenlayer-crypto-rehypothecation-and-the-infinite-trust-machine4e8164845b59">restaking 被过度炒作</a></li><li>Optimism 的<a href="https://optimism.mirror.xyz/7v1DehEY3dpRcYFhqWrVNc9Qj94H2L976LKlWH1FX-8">RetroPGF第二轮学到的东西</a></li><li>ETHDam <a href="https://taikai.network/cryptocanal/hackathons/ethdam/projects?filter_by=finalists">黑客马拉松项目</a></li><li>ETHGlobal <a href="https://twitter.com/ethglobal/status/1662142905048350724">匿名世界黑客马拉松决赛选手</a></li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li>Maker 投票将<a href="https://forum.makerdao.com/t/stability-scope-parameter-changes-2-non-scope-defined-parameter-changes-may-2023/20981">DSR 提高到 3.33%</a></li><li><a href="https://medium.com/block-analitica/introducing-project-levon-e1444bd888d1">Levon</a>：获得 Maker 金库的信用评分，测试版</li><li>Kain：<a href="https://mirror.xyz/kain.eth/EB9DQldVEb0F74-LmrVau6YbjEtr8dsj1qVn6muYuXw">Synthetix 的状态</a></li><li><a href="https://mirror.xyz/0x01393d9b6dFFce134b6765e9bdd626b258357C37/7tghsnpqiCRKxS-5xbwPC7CPs2drbxWCR4GEZFhNWBY">TAI</a>（受控锚定稳定币）在主网上线</li><li><a href="https://astaria.xyz/">Astaria</a>（NFT 支持的借贷）在主网上线，测试版</li><li><a href="https://twitter.com/safe/status/1660677975669633024">Safe multisig</a> 支持 ERC1271 消息签名（用于 OpenSea 签名）</li><li><a href="https://twitter.com/utopialabs_/status/1661784971676381185">Utopia</a>：安全的多重签名无gas交换，测试版</li><li><a href="https://github.com/lcfr-eth/FlashbotsBundlerUI#readme">Flashbots Bundler</a>：用于从受感染地址中拯救代币</li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-10-7</title>
      <link href="/2023/07/06/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-10-7/"/>
      <url>/2023/07/06/%E6%AF%8F%E5%91%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BF%9B%E5%B1%95/2023-10-7/</url>
      
        <content type="html"><![CDATA[<h2 id="Dencun（Cancun-Deneb）升级"><a href="#Dencun（Cancun-Deneb）升级" class="headerlink" title="Dencun（Cancun + Deneb）升级"></a>Dencun（Cancun + Deneb）升级</h2><ul><li><p>最新的所有核心开发人员 - 执行 (ACDE)视频会议。Christine Kim的记录：</p><ul><li>Devnet-9：测试<a href="https://twitter.com/M25Marek/status/1709972302907978192">发现了一些错误</a>，MEV-Boost 测试已开始（网络上约 20% 验证者在运行 MEV-Boost 软件）</li></ul></li><li><p>Devnet-10：在 devnet-9 上没有问题后启动，短暂存在，包含 KZG 仪式的最终输出</p><ul><li>Goerli 测试网升级时间：现在确定日期还为时过早</li></ul></li><li><p>Dencun 互操作性测试<a href="https://www.youtube.com/watch?v=o1ET9AuEK9c&t=63s">视频会议</a></p></li></ul><h2 id="中心化观察：威胁你-ETH-价值"><a href="#中心化观察：威胁你-ETH-价值" class="headerlink" title="中心化观察：威胁你 ETH 价值"></a>中心化观察：威胁你 ETH 价值</h2><ul><li><p><a href="https://dune.com/hildobby/eth2-staking"><strong>Lido 占比 32.13%</strong></a> <strong>已略有减少，但仍然非常接近</strong><a href="https://www.youtube.com/watch?v=Y0ddkSa1ZuI&t=1050s"><strong>阀值 33.3%</strong></a></p></li><li><p>客户端多样性（通过clientdiversity.org）：</p><ul><li>执行层：Geth 约占 80% ，超级多数派，可能导致链分叉</li><li>共识层：Prysm 占 45%，任何客户端错误超过 33.3% 都可能导致活力丧失</li></ul></li><li><p><a href="https://nodewatch.io/">需要更多质押者和节点的地理多样性</a>，尤其是美国&#x2F;加拿大&#x2F;欧盟之外的其他地方</p></li></ul><h2 id="Layer-1"><a href="#Layer-1" class="headerlink" title="Layer 1"></a>Layer 1</h2><ul><li><a href="https://github.com/rainshowerLabs/blutgang#readme">Blutgang</a>：RPC 负载均衡器和缓存，用 Rust 编写</li><li>Revm <a href="https://github.com/bluealloy/revm/releases/tag/v26">v3.5.0</a>：过渡到 Alloy 类型</li><li><a href="https://twitter.com/gakonst/status/1709278476103283172">Geth 和 Reth</a>允许同步历史哈希</li><li>Besu（执行层客户端）<a href="https://consensys.io/blog/bonsai-tries-guide">Bonsai Tries</a> 存储解释</li><li>Verkle 实施者<a href="https://twitter.com/rudolf6_/status/1709672165573058673">视频会议记录</a></li></ul><h2 id="给质押者"><a href="#给质押者" class="headerlink" title="给质押者"></a>给质押者</h2><ul><li>Stakesaurus：<a href="https://stakesaurus.gitbook.io/eth-full-home-staking-setup-guide">家庭质押指南</a>，面向新手</li></ul><h2 id="客户端版本"><a href="#客户端版本" class="headerlink" title="客户端版本"></a>客户端版本</h2><ul><li>执行层：<ul><li>Erigon <a href="https://github.com/ledgerwatch/erigon/releases/tag/v2.51.0">v2.51.0</a>：修复一些错误</li></ul></li></ul><h2 id="Layer-2"><a href="#Layer-2" class="headerlink" title="Layer 2"></a>Layer 2</h2><ul><li><a href="https://blog.oplabs.co/op-stack-fault-proof-alpha/">OP Stack 欺诈证明系统</a> 在 OP Goerli 测试网上运行，alpha</li><li><a href="https://twitter.com/metisdao/status/1709965430591463763">Metis</a>（optimistic Rollup）回滚到在主网上存储交易数据</li><li><a href="https://arxiv.org/abs/2310.01155">EIP4844 经济学</a>：发布 blobs 和 blocks 的 Rollup 成本模型</li></ul><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><ul><li>EIP<ul><li><a href="https://github.com/ethereum/EIPs/pull/7809/files">EIP7530</a>：EVM 配置文件用于 zk rollup</li></ul></li><li>ERC（应用层）：<ul><li><a href="https://github.com/ethereum/EIPs/pull/7797/files">ERC7527</a>：基于内置函数 Oracle AMM 的标准接口系统</li><li><a href="https://github.com/ethereum/EIPs/pull/7808/files">ERC7528</a>：ETH（原生资产）地址约定（0xe）</li><li><a href="https://github.com/ethereum/EIPs/pull/7815/files">ERC7529</a>：利用 TXT 记录发现、验证智能合约并将其与 DNS 域名所有者关联的简单方法。</li><li><a href="https://github.com/ethereum/EIPs/pull/7817/files">ERC7531</a>：质押的 ERC721 所有权认证</li></ul></li></ul><h2 id="开发者资料"><a href="#开发者资料" class="headerlink" title="开发者资料"></a>开发者资料</h2><ul><li>OpenZeppelin Contracts <a href="https://blog.openzeppelin.com/introducing-openzeppelin-contracts-5.0">v5</a>：<ul><li>添加 AccessManager、GovernorStorage、ERC2771Forwarder、ERC1967Utils、Nonces、MessageHashUtils 和 Time</li><li>删除：Address.isContract、Counters、ERC777、SafeMath、TokenTimelock、托管（escrow）合约和所有预设（presets）</li><li>使用自定义错误、显式导入， Solidity 编译器最低版本为 v0.8.20</li></ul></li><li>Hardhat <a href="https://github.com/NomicFoundation/hardhat/releases/tag/hardhat%402.18.0">v2.18.0</a>：添加对作用域任务的支持</li><li>Foundry：<ul><li>Forge-std <a href="https://github.com/foundry-rs/forge-std/releases/tag/v1.7.0">v1.7.0</a>&#x2F;<a href="https://github.com/foundry-rs/forge-std/releases/tag/v1.7.1">v1.7.1</a>：添加 serializeJson cheat code、unixTime，将 parseJsonKeys 标记为 pure 并将 exit_code 重命名为 exitCode</li><li>Vulcan <a href="https://twitter.com/nomoixyz/status/1708965012511801575">v0.4.0</a>：添加 unwrap 以获取结果值，使用 expect 设置自定义回滚消息，使用 isOk 和 isError 改进错误处理和与外部 HTTP 服务器的交互</li><li><a href="https://github.com/g-01234/scope#readme">Scope</a>（VS Code 扩展）：Remix-like 和一些 Foundry 功能的可视化封装，alpha 版</li></ul></li><li>Huff：<ul><li><a href="https://github.com/horsefacts/huff-test#readme">Huff-test</a>：用于纯 Huff 测试断言的宏</li><li><a href="https://github.com/Philogy/py-huff#readme">Py-huff</a>：用 Python 实现的 Huff 编译器</li><li><a href="https://github.com/AmadiMichael/Zyclone#readme">Zyclone</a>：Huff 实现的混币器（类似于 Tornado Cash），gas优化，存款成本降低约 5 倍</li></ul></li><li>Vyper <a href="https://github.com/vyperlang/vyper/releases/tag/v0.3.10">v0.3.10</a>：添加 codesize 优化模式，pragma 指令，在生成的代码中使用 MCOPY，并生成具有 O(1)性能的选择器表</li><li>CTFs：<ul><li>Secureum RACE #22：<a href="https://ventral.digital/posts/2023/10/3/race-22-of-the-secureum-bootcamp-epoch-infinity">8 个问题的 Solidity 谜题和答案</a> 由 Tincho 提供</li></ul></li></ul><h2 id="生态"><a href="#生态" class="headerlink" title="生态"></a><strong>生态</strong></h2><ul><li>Vitalik 关于<a href="https://vitalik.eth.limo/general/2023/09/30/enshrinement.html">什么样特性应该在协议中加入和移除</a>：分析了账户抽象、zk-EVM、提议者-构建者分离、私有交易池、流动性质押和预编译</li><li><a href="https://ethereumwriterscohort.carrd.co/">Ethereum.org 撰稿人第二组</a> 10 月 20 日开始</li><li>Etherscan <a href="https://twitter.com/etherscan/status/1709917362613633489">事件日志高级过滤器</a></li></ul><h2 id="链上统计"><a href="#链上统计" class="headerlink" title="链上统计"></a><strong>链上统计</strong></h2><ul><li>Gas 费用（通过 ultrasound.money）：4.7 至 93.7 gwei，平均为 9.9 gwei<ul><li>目前通缩 gas 为 21.2 gwei</li><li>本周净新发行量为 8.6k ETH</li></ul></li><li><a href="https://www.coingecko.com/en/coins/ethereum">ETHUSD</a>：1,611–1,611–1,736，当前为 $1646</li><li><a href="https://ratiogang.com/">ETHBTC</a>：当前为 0.059（Flippening 在约 0.16）</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li>正在关闭：<a href="https://yield-protocol.medium.com/winding-down-yield-protocol-0974b38066cc">Yield Protocol</a>和<a href="https://utopia.beehiiv.com/p/winding-down">Utopia 产品</a>。</li><li>NFT 无代码创建：<ul><li><a href="https://opensea.io/blog/articles/introducing-opensea-studio">OpenSea Studio</a>（10%的铸造费用）。</li><li><a href="https://twitter.com/mintdotfun/status/1709252670274630114">mint.fun 创建</a>（0.0002 ETH 的铸造费用）。</li><li><a href="https://twitter.com/ourZORA/status/1709599808334499988">Zora</a>（在 Zora Network 上免费创建，0.000111 ETH 的铸造费用）。</li></ul></li><li><a href="https://twitter.com/RAC/status/1709629083578220615">RAC 的 Deadline NFT</a>在 Base 上上线，可以从主网或 Layer 2 购买[Andrew minted]。</li><li>Friend Tech 在 SIM 卡交换攻击后<a href="https://twitter.com/friendtech/status/1709661643028976110">添加&#x2F;删除登录方式</a>。</li><li>Nature：<a href="https://www.nature.com/articles/s41587-023-02005-1">科学社区 DAO</a>和替代性研究资金。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 每周以太坊进展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周以太坊进展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql知识点</title>
      <link href="/2023/07/02/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/07/02/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-关系型数据库"><a href="#MySQL-关系型数据库" class="headerlink" title="MySQL(关系型数据库)"></a>MySQL(关系型数据库)</h1><p>MySQL是目前最流行的<a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/696511">关系型数据库管理系统</a>之一，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，增加了速度并提高了灵活性，MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。</p><h2 id="SQL语句分类："><a href="#SQL语句分类：" class="headerlink" title="SQL语句分类："></a>SQL语句分类：</h2><ul><li>DQL（数据查询语言）: 查询语句，凡是select语句都是DQL。</li><li>DDL（数据定义语言）：create drop alter，对表结构的增删改。</li><li>DML（数据操作语言）：insert delete update，对表当中的数据进行增删改。</li><li>TCL（事务控制语言）：commit提交事务，rollback回滚事务。</li><li>DCL（数据控制语言）: grant授权、revoke撤销权限等。</li></ul><p>基本语句：</p><ul><li>查看有哪些数据库：show databases;</li><li>查看当前使用的数据库中有哪些表：show tables;</li><li>查看表结构：desc 表名;</li></ul><h2 id="DQL（数据查询语言）"><a href="#DQL（数据查询语言）" class="headerlink" title="DQL（数据查询语言）"></a>DQL（数据查询语言）</h2><p>select 字段名1 （’as‘） 别名,字段名2,字段名3,…. from 表名 where 条件;</p><p>——需要起别名时as可以省略</p><p>条件分类：等于大于小于、空值（is null）、和（and）、或者（or）、范围（bteween … and …）、集合（in）、模糊查询（like，%代表任意多个字符，_代表任意1个字符）、排序（order by 字段值 desc; 默认是升序，asc表示升序，desc表示降序）</p><p><strong>分组函数</strong>：count 计数、sum 求和、avg 平均值、max 最大值、min 最小值</p><p>例：查询某字段的数据总数量 ”select count (字段名) from 表名;“</p><p>注意：分组函数不可直接使用在where子句当中，因为分组函数是在where执行之后执行</p><p>注意：count（*）：统计总记录条数</p><p>​count（字段值）：统计字段中不为NULL的数据总数量</p><p><strong>group by 和 having</strong>：</p><p>group by ： 按照某个字段或者某些字段进行分组。<br>having : having是对分组之后的数据进行再次过滤。</p><p>例：找出每个部门的平均薪资，要求显示薪资大于5000的数据</p><p>​select deptno,avg(sal) from emp group by deptno having avg(sal) &gt; 5000;</p><p>**distinct:**关键字，只能出现在字段最前面，去重。</p><p><strong>执行顺序：</strong>select(5)  …   from(1)   …   where(2)…   group by(3)   …   having(4)…   order by(6)…</p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>——在表的连接查询中有一个笛卡尔积现象，就是查询条件没有要求时，查询出来的记录数量是两张表记录数量的乘积。</p><p><strong>分类</strong>：内连接：两张表是平等的，满足两张表之间条件的所有记录才能查询出来</p><p>​外连接：两张表有主次之分，主表的数据需要全部查询出来，当副表中的数据没有与主表相匹配，副表会将数据转化为Null与主表匹配</p><p>​自连接：自连接是一种特殊的内连接，它是指互相连接的两张表在物理上为同一张表，但在逻辑上可以分为两张表</p><p>例子：</p><p>内连接：查询每个员工的部门名称，显示员工名和部门名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">e.ename,d.dname</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">emp e</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">dept d</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure><p>外连接：查询员工的领导,显示员工名和领导名（右连接，即就算有些员工的bossno在领导表中不存在也显示出来，领导字段为null）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">a.ename <span class="string">&#x27;员工&#x27;</span>, b.ename <span class="string">&#x27;领导&#x27;</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">boss b</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span></span><br><span class="line">emp a</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">a.bossno <span class="operator">=</span> b.empno;</span><br></pre></td></tr></table></figure><h3 id="子查询：select语句中嵌套select语句"><a href="#子查询：select语句中嵌套select语句" class="headerlink" title="子查询：select语句中嵌套select语句"></a>子查询：select语句中嵌套select语句</h3><p>前面说过分组函数不可直接使用在where子句当中，此时就需要用到子查询</p><p>例：查询工资大于平均工资的员工</p><p>​select * from emp where sal &gt; (select avg(sal) from emp)</p><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>取出查询数据中的部分数据(limit是mysql特有的，其他数据库中没有，不通用)，重点用于分页查询</p><p>例：取出工资前5名的员工<br>        select ename,sal from emp order by sal desc limit 0, 5;</p><p>注意：limit是sql语句最后执行的的一个步骤</p><h2 id="DDL（数据定义语言）"><a href="#DDL（数据定义语言）" class="headerlink" title="DDL（数据定义语言）"></a>DDL（数据定义语言）</h2><p>新建表的语句：</p><p>create table 表名(<br>            字段名1 数据类型,<br>            字段名2 数据类型,<br>            字段名3 数据类型,<br>            ….<br>);</p><p>MySQL当中常见的字段的数据类型,( )中的类型相当于在Java中的类型：<br>    int 整数型(int)<br>    bigint   长整型(long)<br>    float 浮点型(float double)<br>    char 定长字符串(String)<br>    varchar可变长字符串(StringBuffer&#x2F;StringBuilder)<br>    date 日期类型 (java.sql.Date)<br>    BLOBBinary Large OBject (Object)，二进制大对象，存储图片、视频等流媒体信<br>    CLOBCharacter Large OBject(Object),字符大对象,存储较大文本，比如，可以存储4G的字符串</p><p>——<strong>char和varchar的区别：</strong>当某个字段中的数据长度不发生改变的时候，是定长的，例如：性别、生日等都是采用char；当一个字段的数据长度不确定，例如：姓名、地址等都是采用varchar。</p><p><strong>添加列：</strong>ALTER TABLE 表名 ADD 列名 数据类型;</p><p><strong>修改表的列名</strong>：ALTER TABLE 表名CHANGE 原列名 新列名 数据类型(xx);</p><p><strong>修改数据字段类型：</strong>ALTER TABLE 表名 MODIFY 列名 数据类型(xx);</p><p><strong>删除一列：</strong>ALTER TABLE 表名 DROP 列名;</p><p><strong>删除表：</strong>DROP TABLE 表名;</p><h2 id="约束（-）"><a href="#约束（-）" class="headerlink" title="约束（*）"></a>约束（*）</h2><p>在创建表的时候，可以给表的字段添加不同的约束，填写在字段名后面，添加约束可以保证表中数据的合法性、有效性、完整性。</p><p>常见的约束：</p><ul><li>非空约束(not null)：约束的字段不能为NULL</li><li>唯一约束(unique)：约束的字段不能重复</li><li>主键约束(primary key)：约束的字段既不能为NULL，也不能重复</li><li>外键约束(foreign key)</li></ul><p>——（primary key auto_increment）：主键自增，从1开始，以1递增。</p><p>示例：创建一张id为主键并且自增的用户表</p><p>​create table t_user(<br>​          id int primary key auto_increment,<br>​  username varchar(255)<br>​        );</p><p>注意：一张表只能有一个主键</p><h2 id="DML（数据操作语言）"><a href="#DML（数据操作语言）" class="headerlink" title="DML（数据操作语言）"></a>DML（数据操作语言）</h2><p>insert语句插入数据</p><p>​语法格式：</p><p>​insert into 表名(字段名1,字段名2,字段名3,….) values(值1,值2,值3,….)</p><p>​要求：字段的数量和值的数量相同，并且数据类型要对应相同。</p><p>注意：当一条insert语句执行成功之后，表格当中必然会多一行记录。即使多的这一行记录当中某些字段是NULL，后期也没有办法在执行insert语句插入数据了，只能使用update进行更新</p><p>update 表名 set 字段名1&#x3D;值1,字段名2&#x3D;值2… where 条件;</p><p>delete from 表名 where 条件;</p><h2 id="TCL（事务控制语言）"><a href="#TCL（事务控制语言）" class="headerlink" title="TCL（事务控制语言）"></a>TCL（事务控制语言）</h2><p><strong>事务</strong>：一个完整的业务逻辑单元，不可再分，比如：银行账户，从A账户向B账户转账100元，需要执行两条update语句，A账户-100，B账户+100。 以上两t条DML语句必须同时成功，或者同时失败，不允许出现一条成功，一条失败.想要保证以上的两条DML语句同时成功或者同时失败，那么就要使用数据库的”事务机制”。</p><p> 事务包括四大特性（ACID）：</p><ul><li>原子性：事务是最小的工作单元，不可再分。</li><li>一致性：必须保证多条DML语句同时成功或者同时失败。</li><li>隔离性：事务A与事务B之间具有隔离。</li><li>持久性：最后数据应该持久化到硬盘中，事务才能结束。</li></ul><p> 事务隔离性存在隔离级别，理论上隔离级别包括4个：</p><p>​       第一级别：读未提交(read uncommitted)<br>​       对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。<br>​       读未提交存在脏读现象：表示读到了脏数据（读到未提交的数据）。<br>​   第二级别：读已提交(read committed)<br>​       对方事务提交之后的数据我方可以读取到。<br>​       读已提交存在的问题是：不可重复读（在多次读取范围内读到数据不一致）。<br>​   第三级别：可重复读(repeatable read)<br>​       这种隔离级别解决了：不可重复读问题。<br>​       这种隔离级别存在的问题是：读取到的数据是幻读（在多次操作读取范围内发现数据不一致问题）。<br>​   第四级别：序列化读&#x2F;串行化读<br>​       解决了所有问题。<br>​       效率低，需要事务排队。</p><p>查看隔离级别：select @@tx_isolation;</p><p>设置隔离级别：set session|global transaction isolation level 隔离级别;</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 关闭事务自动提交</span></span><br><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启事务 </span></span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> bal <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">where</span> balno <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">update</span> bal <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">where</span> balno <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务 </span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务回滚</span></span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13-思考</title>
      <link href="/2023/07/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/13-%E6%80%9D%E8%80%83/"/>
      <url>/2023/07/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/13-%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="哈希指针"><a href="#哈希指针" class="headerlink" title="哈希指针"></a>哈希指针</h2><p>只是系统中一种形象化的方法。实际应用时候，只有哈希而没有指针</p><h2 id="区块“恋”"><a href="#区块“恋”" class="headerlink" title="区块“恋”"></a>区块“恋”</h2><p>有情侣一起买BTC，将私钥从中截断，每人保留其中一部分。如果未来两人依旧感情很好，就可以将钱取出；如果分手，这部分钱就会永久锁死，谁也无法取出，通过区块链的不可篡改性作为两人的爱情见证。这样做有什么问题？<br>如此下来，N个人怎么办？<br>如果按照这种方法，将私钥分为N份。但这样会有一系列问题：</p><p>一. 如果N个人中任意一个人忘记私钥，则无法将钱取出</p><p>二.截断私钥长度，会降低安全性，因为私钥长度会直接影响破解难度(2^256远远大于2^128)，之间难度差距远远不止一倍。可见，对于多个人账户，应该使用多重签名，而非截断私钥的方法</p><p>三.如果分手，该钱变成死钱，一直保存在UTXO集合中，对矿工不友好。</p><h2 id="分布式共识"><a href="#分布式共识" class="headerlink" title="分布式共识"></a>分布式共识</h2><p>理论上来说，分布式系统不可能达成共识。但实际中为何变成可能了？</p><p>严格来说，BTC系统共识随时可能被推翻，例如分叉攻击导致系统回滚。</p><p>此外，理论和实际存在差异。不可能结论针对特定模型，实际中对模型稍微修改或添加线下方法即可将不可能变为可能。</p><h2 id="BTC的稀缺性"><a href="#BTC的稀缺性" class="headerlink" title="BTC的稀缺性"></a>BTC的稀缺性</h2><p>为什么要挖矿？因为有收益，且收益大于开销。早期BTC难度低且出块奖励高，从而吸引矿工。<br>之前有提到，BTC总量固定，有人认为其是一个精妙的设计。但实际上，总量固定的东西并不适合作为货币，这也就决定了BTC并不能在未来完全颠覆现有货币体系。以太坊中便没有BTC中出块奖励定期减半的做法，此外，某些新型货币会自带通货膨胀的功能。<br>对个人来说，通货膨胀并非好事，因为钱不值钱了。但人类每年创造的价值，如果用总量固定的东西作为货币，则其只会越来越值钱，而这会导致拥有者不断看着其升值，其他没有的人无论如何奋斗都赶不上（房市也是如此，炒房使一部分人靠房租便可大赚特赚，个人奋斗却很难买房。这也是我国目前存在的较大的问题，社会财富的分配不公，最终引发各种社会矛盾，需要政府解决）。</p><h2 id="量子计算"><a href="#量子计算" class="headerlink" title="量子计算"></a>量子计算</h2><p>会不会BTC这种建立在密码学上的加密货币，在量子计算出来后会不会变得不安全。<br>一. 量子计算距离使用仍然有很长距离（人工智能也是，目前仍然处于弱人工智能阶段。其实很多技术都是如此，炒的情况很严重，但距离实用很远。但是不炒便不会有资本流入进行研究，这也是一个非常相悖的地方）。<br>二. 量子计算若真正使用到破坏现有加密算法，对传统金融业的破坏仍然是最大的。<br>三. 实际中使用的并非公钥，而是可以用公钥哈希。而哈希函数一般都是不可逆的，所以即使量子计算也无法反推私钥。<br>BTC中用的SHA-256，无论输入多大，最终结果都为256位，必然会导致信息丢失，无法反推原本数据。</p>]]></content>
      
      
      <categories>
          
          <category> 比特币 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12-零知识证明</title>
      <link href="/2023/06/26/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/12-%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/"/>
      <url>/2023/06/26/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/12-%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a>零知识证明</h1><p><strong>定义：一方（证明者）向另一方（验证者）证明某一个陈述是正确的，但不需要透露除该陈述是正确的之外的任何信息。</strong></p><blockquote><p>例如：A想要向B证明某一账户属于A，。但不可能通过A公布私钥的方法来证明，该账户确实属于A。因此，A可以产生一个账户签名，B通过公钥对签名进行验证。(实际上该证明是否属于零知识证明存在争议，因为泄露了用私钥产生的签名)</p></blockquote><h1 id="同态隐藏"><a href="#同态隐藏" class="headerlink" title="同态隐藏"></a>同态隐藏</h1><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/img/image-20230103104432576.png" alt="image-20230103104432576"> </p><p>零知识证明的数学基础便是同态隐藏。上图为同态隐藏的三个性质：</p><ul><li>第一个性质，说明如果有E(X)&#x3D;E(y)，则必然有x&#x3D;y。(无碰撞)</li><li>第二个性质，说明加密函数不可逆。知道加密值，无法反推出密码值。</li><li>第三个性质，最为重要，称为同态运算。说明对加密后的函数值进行某些代数运算，等价于对输入直接进行代数运算再加密。</li></ul><h4 id="例子：A想要向B证明他知道一组数X和Y使得X-Y-7，同时不想让B知道X和Y的具体数值。"><a href="#例子：A想要向B证明他知道一组数X和Y使得X-Y-7，同时不想让B知道X和Y的具体数值。" class="headerlink" title="例子：A想要向B证明他知道一组数X和Y使得X+Y&#x3D;7，同时不想让B知道X和Y的具体数值。"></a><strong>例子：A想要向B证明他知道一组数X和Y使得X+Y&#x3D;7，同时不想让B知道X和Y的具体数值。</strong></h4><p>最简单的证明版本如下：<br>1.Alice将E(x)、E(y)发给Bob。（性质2，不可逆）<br>2.Bob通过收到的E(x)、E(y)计算得到E(X+Y)。（性质3，同态加法）<br>3.Bob进行验证E(x+y)和E(7)是否相等。若相等则验证通过，否则验证失败。（性质1，无碰撞）</p><h1 id="盲签"><a href="#盲签" class="headerlink" title="盲签"></a>盲签</h1><p>盲签名是一种特殊的数字签名技术。盲签名因签名的人看不到所签署文件的具体内容而闻名，它有两个显著的特点：一是签名者对消息的内容是不可见的 ;二是签名被公开后，签名者不能追踪签名。</p><p>例如A向B转账：</p><p>用户A提供SerialNum银行在不知道SerialNum的情况下返回签名Token，减少A的存款<br>用户A把SerialNum和Token交给B完成交易<br>用户B拿SerialNum和Token给银行验证，银行验证通过，增加B的存款<br>银行无法把A和B联系起来。<br>中心化</p><h1 id="零币和零钞——专门为匿名性设计的货币"><a href="#零币和零钞——专门为匿名性设计的货币" class="headerlink" title="零币和零钞——专门为匿名性设计的货币"></a>零币和零钞——专门为匿名性设计的货币</h1><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/img/image-20230103105451546.png" alt="image-20230103105451546"> </p><p>零币在花费的时候，只需要用零知识证明来证明所花掉的币是系统中存在的某一个合法的币，但不用透露具体花掉的是系统中哪一个币。这样就破坏了关联性。</p><p>当然，这类货币并非主流加密货币，因为其为了设计匿名性，付出了一定代价，而且，需要强匿名性的用户并不多。</p><p>从数学上看，零币和零钞是安全的。但其并不是百分之百的匿名，其并未解决与系统外部实体发生交互时对匿名性的破坏。</p>]]></content>
      
      
      <categories>
          
          <category> 比特币 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11-匿名性</title>
      <link href="/2023/06/24/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/11-%E5%8C%BF%E5%90%8D%E6%80%A7/"/>
      <url>/2023/06/24/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/11-%E5%8C%BF%E5%90%8D%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="BTC系统并不是具有很好的匿名性"><a href="#BTC系统并不是具有很好的匿名性" class="headerlink" title="BTC系统并不是具有很好的匿名性"></a>BTC系统并不是具有很好的匿名性</h1><h2 id="BTC系统破坏其匿名性的情况"><a href="#BTC系统破坏其匿名性的情况" class="headerlink" title="BTC系统破坏其匿名性的情况"></a>BTC系统破坏其匿名性的情况</h2><p><strong>1.用户可以生成多个地址账户，但这些地址账户可以很容易被关联起来</strong><br>表面上看，每次交易可以更换公私钥对，从而每次都是新的账户，具有很强的匿名性。但实际上，这些账户在一定情况下，是可以被关联起来的。</p><blockquote><p>某个交易有2个输入和两个输出，所以addr1和addr2很可能是同一个人所持有的账户，因为该人同时拥有这两个私钥的地址。(一个账户中的钱可能不够)，而在输出中，很有可能有一个地址是属于找零钱的地址，即花掉之后剩余的钱。在某些情况下，也是可以分析出来的。</p></blockquote><p><strong>2.地址账户与个人在真实社会中的身份也可能会产生关联。</strong><br>任何使得BTC和实体世界中关联的操作都有可能泄露用户真实身份，其中最明显的就是资金的转入转出。要得到BTC，如果用钱买，就会与实体世界进行交互。想要将BTC转为现实中的货币，也同样需要与实体世界交互。</p><blockquote><p>在很多国家，都有防洗钱法。如何防范不法分子采用BTC进行洗钱呢？其实很简单，只需要盯住资金转入转出链即可。对于大额资金转入BTC或将大量BTC转为现实货币，很难逃避司法金融机构的监管。</p></blockquote><p><strong>3.BTC支付时候</strong><br>例如某些商家接受用BTC进行支付，例如可以用BTC购买咖啡、蛋糕等。(这种场景信用卡已经解决的很好了，用BTC交易延迟高，交易费贵，并非一个好的idea)，在进行支付时候，便和个人账户建立了联系，从而会泄露掉个人信息。</p><h2 id="BTC匿名性有多好？如何提高匿名性？"><a href="#BTC匿名性有多好？如何提高匿名性？" class="headerlink" title="BTC匿名性有多好？如何提高匿名性？"></a>BTC匿名性有多好？如何提高匿名性？</h2><p>匿名的本质是不想要暴露身份。而对于普通人来说，BTC的现有机制已经足够保持个人隐私了。但如果涉及违法，行政机关想要获得真实身份，其实很容易。<br><strong>那么可以采取哪些方法尽可能提高匿名性？</strong></p><blockquote><p>从应用层看，可以将各个不同用户的BTC混合在一起，使得追查变得混乱(Coin mixing)；从网络层看，可以采用多路径转发的方法，数据不直接发送出去，而是经过很多跳(洋葱路由的基本思想)。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 比特币 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-问题解答</title>
      <link href="/2023/06/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/10-%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
      <url>/2023/06/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/10-%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/</url>
      
        <content type="html"><![CDATA[<h1 id="一些问题及其解答"><a href="#一些问题及其解答" class="headerlink" title="一些问题及其解答"></a>一些问题及其解答</h1><ol><li><p><strong>转账交易时候，如果接收者不在线(没有连在比特币网络上)怎么办？</strong><br>转账交易只需要在区块链上记录，将某账户比特币转到另一账户，而接收方是否在线并无影响。</p></li><li><p><strong>假设某全节点收到某个转账交易，会不会有可能转账交易中收款人地址该全节点从未听过。</strong><br>可能，因为比特币账户只需要本地产生即可。只有该账户第一次收到钱时，其他节点才能知道该节点的存在。</p></li><li><p><strong>如果账户私钥丢失怎么办？</strong><br>没有办法。因为比特币是去中心化货币，没有第三方中心机构可以重置密码，所以账户上的钱也就变成了死钱。<br>通过加密货币交易所(中心化机构)，一般需要提供身份证明，如果忘记私钥可以找交易所申请追回私钥。但目前这类货币的交易所，尚且处于缺少监管的状态，并不一定具有可信力。而且，其本身仅起到“中介”作用，与该提问的回答“私钥丢失无法追回里面的比特币”并不冲突。<br>在历史上，有很多次交易所被黑客攻击偷走大量加密货币的事情，其中最著名的为Mt. GOX（中文译为：门头沟）事件。该交易所曾经为全球最大比特币交易所，交易量占到全球比特币交易量的70%左右，设于日本。后来由于被攻击丢失大量比特币，导致交易所破产，其CEO被判刑入狱。<br>此外，也有交易所监守自盗，工作人员卷款跑路(有点类似 rm -rf *&#x2F; 删库跑路)。</p></li><li><p><strong>私钥泄露怎么办？</strong><br>尽快将剩余BTC转到其他安全账户上，没有第三方中心机构重置密码或冻结账户，只能自己对自己负责。<br>BTC系统中账户便是公私钥对，密码就是私钥，无法更改。</p></li><li><p><strong>转账写错地址怎么办？</strong><br>没有办法，只能自认倒霉，无法取消已经发布的交易。如果转入不存在地址，则该部分比特币便成为了死钱。当然，比特币系统中UTXO会永久保存该交易，记录该并不存在的地址。因此，对全节点来说，这是不友好的。</p></li><li><p><strong>之前在BTC脚本中介绍了OP_RETURN指令，我们提到，这种方法为普通用户提供了一个向比特币网络中写入想要一直保存的内容。但OP_RETURN执行结果是无条件返回错误，而交易返回错误，区块又怎么会包含它？区块链又如何会接收这个区块？</strong></p><blockquote><p>思想1：特殊机制，该脚本即使返回错误，仍然写入区块链。（实际并不是）<br>思想2：即使返回失败，仍然写入区块链，只是具体处理时候不计算其即可。(恶意节点大量抛出失败交易，攻击区块链怎么办？上一篇中提到，每秒平均只能处理7笔交易)</p></blockquote><p>要想清楚，OP_RETURN是写在哪里的。OP_RETURN实际写在当前交易的输出脚本中，而验证交易合法性时，使用的当前交易的输入脚本和前一个交易(币来源的交易)的输出脚本进行验证。也就是说，验证当前交易合法性时，并不会执行该语句。（是不是感觉很妙呀？？？）只有在有人想花这笔钱时候，才会执行该语句。</p></li><li><p><strong>BTC系统挖矿，会不会有矿工“偷”答案？例如：某个矿工发现其他矿工发布了nonce，收到后验证该区块合法，将该nonce作为自己找到的nonce发布出去。</strong><br>实际上这是不可能的。发布的区块中包含铸币交易，其收款人地址为挖到矿的矿工地址，如果要偷答案，需要修改该收款地址，而地址改变，铸币交易内容也发生改变，从而引发Merkle Tree根哈希值改变。从而导致原本的nonce作废。也就是说，不可能会“偷”答案。</p></li><li><p><strong>交易费是交易者为了自己交易可以上链而给出的“小费”，那么如何得知哪个矿工可以挖到矿？</strong><br>事先无需知道谁会挖到矿，交易中总输入和总输出差额就是交易费。哪个矿工挖到矿，在打包交易时，可以将这些交易费收集起来作为自己获得的交易费。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 比特币 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09-分叉</title>
      <link href="/2023/06/15/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/09-%E5%88%86%E5%8F%89/"/>
      <url>/2023/06/15/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/09-%E5%88%86%E5%8F%89/</url>
      
        <content type="html"><![CDATA[<h1 id="分叉-fork-形成的原因"><a href="#分叉-fork-形成的原因" class="headerlink" title="分叉(fork)形成的原因"></a>分叉(fork)形成的原因</h1><ol><li>挖矿时两个节点差不多同时挖出矿，都会发布区块(对比特币系统当前状态产生分歧导致的分叉</li><li>分叉攻击，同样也会导致分叉(forking attack，人为故意造成)</li><li>比特币协议改变，在分布式系统中不能保证所有节点同时升级软件，假设存在少数节点未升级，导致出现分叉</li></ol><h1 id="硬分叉-hard-fork-：旧结点不认可新结点"><a href="#硬分叉-hard-fork-：旧结点不认可新结点" class="headerlink" title="硬分叉(hard fork)：旧结点不认可新结点"></a>硬分叉(hard fork)：旧结点不认可新结点</h1><blockquote><p>什么情况会出现硬分叉？<br>对比特币协议增加新协议，扩展新功能，未升级软件的旧节点会不认可这些修改，会认为这些特性是非法的。这也就是对比特币协议内容产生分歧，从而导致分叉。</p></blockquote><h4 id="典型例子，就是对比特币区块大小的修改"><a href="#典型例子，就是对比特币区块大小的修改" class="headerlink" title="典型例子，就是对比特币区块大小的修改"></a>典型例子，就是对比特币区块大小的修改</h4><p>假设将区块大小从1MB增大至4MB，系统中大多数节点更新了软件，少数节点仍然遵从1MB限制的协议(注意，这里大多数和少数是按照算力来区分的</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/img/image-20230102104357355.png" alt="image-20230102104357355"> </p><p>此时，就出现了新节点永远沿着上面的链挖矿，旧节点永远沿着下面的链挖矿，由于新节点算力足够强，所以形成两条永远都在延伸且平行的链。当然，上面的链，也有可能会挖出大小在1MB内的小区块，但对旧节点来说，该链上存在非法区块，不会认可该链。可见，这种分叉是持久性的。<br>只要这部分旧节点永远不更新软件，下面的链便永远不会消失。</p><h1 id="软分叉-soft-fork-：新结点不认可旧结点"><a href="#软分叉-soft-fork-：新结点不认可旧结点" class="headerlink" title="软分叉(soft fork)：新结点不认可旧结点"></a>软分叉(soft fork)：新结点不认可旧结点</h1><p>如果对BTC协议添加限制，使得原本合法交易在新交易中不合法，便会形成软分叉。</p><p>假设将区块大小从1MB减小至0.5MB(实际中，1MB已经足够小，不会调小了)，系统中大多数节点更新了软件，少数节点仍然遵从1MB限制的协议(注意，这里大多数和少数是按照算力来区分的</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/img/image-20230102105312754.png" alt="image-20230102105312754"> </p><p>新节点会认为该旧节点挖出区块超过0.5MB限制，为一个非法区块，不会认可该区块，会从其前一个小区块开始挖矿。而旧节点认可新区块，最终会造成5中的效果(绿色大节点为旧节点)，旧节点挖出的区块一直被抛弃，无法得到出块奖励(不在最长合法链上)。这就逼迫旧节点升级软件，最终会实现区块链上的所有矿工共同认可新协议，实现软件协议的升级。</p><blockquote><p>需要注意的是，旧节点如果不升级软件，挖出的区块可能就白挖了(大于0.5MB)，但对于系统来说，不会存在永久性分叉。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 比特币 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08-脚本</title>
      <link href="/2023/06/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/08-%E8%84%9A%E6%9C%AC/"/>
      <url>/2023/06/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/08-%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="输入输出脚本的几种形式"><a href="#输入输出脚本的几种形式" class="headerlink" title="输入输出脚本的几种形式"></a>输入输出脚本的几种形式</h1><h3 id="P2PK形式-Pay-to-public-key"><a href="#P2PK形式-Pay-to-public-key" class="headerlink" title="P2PK形式(Pay to public key)"></a>P2PK形式(Pay to public key)</h3><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/img/image-20230102100446562.png" alt="image-20230102100446562"> </p><h3 id="P2PKH形式-Pay-to-public-key-hash-——最常用"><a href="#P2PKH形式-Pay-to-public-key-hash-——最常用" class="headerlink" title="P2PKH形式(Pay to public key hash)——最常用"></a>P2PKH形式(Pay to public key hash)——最常用</h3><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/img/image-20230102101027264.png" alt="image-20230102101027264"> </p><h3 id="P2SH形式-Pay-to-script-hash）"><a href="#P2SH形式-Pay-to-script-hash）" class="headerlink" title="P2SH形式(Pay to script hash）"></a>P2SH形式(Pay to script hash）</h3><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/img/image-20230102102045092.png" alt="image-20230102102045092"> </p><blockquote><p>特点：输出脚本给出的不是收款人公钥的哈希，而是收款人提供的一个脚本的哈希。该脚本称为redeemScript,即赎回脚本。等未来花钱的时候，输入脚本要给出redeemScript的具体内容以及可以使之正确运行需要的签名。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 比特币 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07-挖矿</title>
      <link href="/2023/06/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/07-%E6%8C%96%E7%9F%BF/"/>
      <url>/2023/06/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/07-%E6%8C%96%E7%9F%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="全节点和轻节点"><a href="#全节点和轻节点" class="headerlink" title="全节点和轻节点"></a>全节点和轻节点</h1><table><thead><tr><th>全节点</th><th>轻节点</th></tr></thead><tbody><tr><td>一直在线</td><td>不是一直在线</td></tr><tr><td>在本地硬盘上维护完整区块链信息</td><td>不保存整个区块链，只需要保存每隔区块块头</td></tr><tr><td>在内存中维护UTXO集合，以便于快速检验交易合法性</td><td>不保存全部交易，只保存和自己有关的交易</td></tr><tr><td>监听比特币网络中交易内容，验证每个交易合法性</td><td>无法验证大多数交易合法性，只能检验和自己相关的交易合法性</td></tr><tr><td>决定哪些交易会打包到区块中</td><td>无法检测网上发布的区块正确性</td></tr><tr><td>监听其他矿工挖出的区块，验证其合法性</td><td>可以验证挖矿难度</td></tr><tr><td>挖矿： 1. 决定沿着哪条链挖下去。<br /> 2. 当出现等长分叉，选择哪一个分叉</td><td>只能检测哪个是最长链，不知道哪个是最长合法链</td></tr></tbody></table><h1 id="比特币安全性的保证？"><a href="#比特币安全性的保证？" class="headerlink" title="比特币安全性的保证？"></a>比特币安全性的保证？</h1><p>一是密码学的保证：别人没有自己的私钥，就无法伪造其合法签名，从而无法将其账户上BTC转走。（前提：系统中大多数算力掌握在好人手中）<br>二是共识机制：保证了恶意交易不被系统承认。</p><h2 id="挖矿设备演化"><a href="#挖矿设备演化" class="headerlink" title="挖矿设备演化"></a>挖矿设备演化</h2><p>普通CPU -&gt; GPU （主要用于并行计算）-&gt;ASIC芯片（挖矿专用矿机）</p><h2 id="大型矿池"><a href="#大型矿池" class="headerlink" title="大型矿池"></a>大型矿池</h2><p>矿池的架构如下图，通常是一个全节点驱动多台矿机。矿工只需要不停计算哈希值，而全节点其他职责由矿主来承担。ASIC芯片只能计算哈希值，不能实现全节点其他功能。此外，矿池出现解决了单个矿工收益不稳定的问题。当获得收益后，所有矿工对收益进行分配，从而保证了收益的稳定性。</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/img/image-20230101112225339.png" alt="image-20230101112225339"> </p><blockquote><p>矿池一般具有两种组织形式。1.类似大型数据中心（同一机构），集中成千上万矿机进行哈希计算。2.分布式，矿工与矿主不认识(不同机构)，矿工与矿主联系，自愿加入其矿池，矿主分配任务，矿工进行计算，获得收益后整个矿池中所有矿工进行利益分配</p></blockquote><h3 id="矿池利益分配方法"><a href="#矿池利益分配方法" class="headerlink" title="矿池利益分配方法"></a>矿池利益分配方法</h3><p>假设原本挖矿难度要求，计算所得126位的哈希值前70位都必须为0，现在降低要求，只需要前60位为0，这样挖矿会更容易挖到。当然，这个哈希是不会被区块链所承认的，我们将其称为一个share，或almost valid share。矿工每挖到一个share，将其提交给矿主，矿主对其进行记录，作为矿工工作量的证明。等到某个矿工真正挖到符合要求的的区块后，根据所有矿工提交的share数量进行分配。</p><h2 id="51-算力矿池可以发动哪些攻击"><a href="#51-算力矿池可以发动哪些攻击" class="headerlink" title="51%算力矿池可以发动哪些攻击"></a>51%算力矿池可以发动哪些攻击</h2><ol><li><p>分叉攻击<br>对已经经过6次确认的交易分叉，利用51%算力将交易记录回滚。</p><blockquote><p>矿工只能计算哈希值，并不知道区块包含哪些交易，区块链状况是什么。<br>此外，51%攻击只是一个概率问题，并非达到51%算力就能发动攻击，不能达到就无法发动攻击。此外，矿池本身算力也是在不断变化的。</p></blockquote></li><li><p>封锁交易<br>假如攻击者不喜欢某个账户A，不想让A的交易上区块链，在监听到有其他人将A的交易发布到区块链上时，立刻发动分叉攻击，使A所在链无法成为”最长合法链“。这样，便实现了对A账户的封锁。</p></li><li><p>盗币（将他人账户BTC转走）<br>这个是<strong>不可能</strong>的，因为其并没有他人账户私钥。如果依仗算力强，强行将没有签名的转账发布到区块链，正常节点不会认为其合法，这样，即使这条链再长，其他人也不会认为其是最长合法链。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 比特币 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06-挖矿难度调整</title>
      <link href="/2023/06/06/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/06-%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/"/>
      <url>/2023/06/06/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/06-%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要调整挖矿难度？"><a href="#为什么要调整挖矿难度？" class="headerlink" title="为什么要调整挖矿难度？"></a>为什么要调整挖矿难度？</h1><p>保持区块链的出块时间在平均10min左右，如果不调整挖矿难度，系统总算力越来越强，若挖矿难度保持不变，则出块时间会越来越短。</p><p><strong>出块时间越来越短是好事吗？</strong><br>出块时间缩短，那么交易可以很快便被写入区块链，并且提高了系统响应时间，增加了区块链系统效率。但是，出块时间并不是越短越好。出块时间太短，也会造成一定的问题。首先，区块在网络上传播具有时延，假如出块时间为1秒，但网络传播需要10秒，则会使得系统中节点经常性处于不一致的状态，增加了系统不稳定性，且系统经常性位于分叉状态（不仅二分叉，乃至多分叉）。分叉过多，则不利于系统达成共识，且会造成算力分散，使得黑客攻击成本大大降低(不再需要整个系统51%的算力)。</p><h1 id="如何调整挖矿难度？"><a href="#如何调整挖矿难度？" class="headerlink" title="如何调整挖矿难度？"></a>如何调整挖矿难度？</h1><p>在BTC协议中规定，每隔2016个区块需要调整一次难度，根据10min产生一个新区块可以得到，大概需要14天的时间。具体调整如下：</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/img/image-20230101110051568.png" alt="image-20230101110051568"> </p><p>如果实际时间比较长，target会比较大，相应的挖矿难度会降低；如果实际实际比较短，target会比较小，相应的挖矿难度会增大</p><blockquote><p>上调和下调都是有4倍的限制，例如：实际最近2016个区块出块时间超过8个星期(正常2个星期)，计算也只按照8个星期计算；实际最近2016个区块出块时间小于0.5个个星期(正常2个星期)，计算也只按照0.5个星期计算.这样是为了防止网络中出现黑天鹅事件。</p></blockquote><h1 id="如何让所有矿工都愿意调整这个挖矿难度呢？"><a href="#如何让所有矿工都愿意调整这个挖矿难度呢？" class="headerlink" title="如何让所有矿工都愿意调整这个挖矿难度呢？"></a>如何让所有矿工都愿意调整这个挖矿难度呢？</h1><p>这一调整算法在代码中已经写入，如果有恶意节点故意不调，其所产生的区块不会被大多数诚实的节点承认。<br>在block header中有一个nbits的域，它是对target的编码存储（target为256位，nbits为32位，也就是说block header并未直接存储target），其他节点在进行合法性验证时候会验证nbits域是否合法，不合法则对该区块不予以承认。</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/img/image-20230101110536938.png" alt="image-20230101110536938"> </p>]]></content>
      
      
      <categories>
          
          <category> 比特币 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05-网络工作原理</title>
      <link href="/2023/06/01/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/05-%E7%BD%91%E7%BB%9C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2023/06/01/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/05-%E7%BD%91%E7%BB%9C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="比特币网络的工作原理"><a href="#比特币网络的工作原理" class="headerlink" title="比特币网络的工作原理"></a>比特币网络的工作原理</h1><p>比特币工作于<strong>网络应用层</strong>，其底层（网络层）是一个<strong>P2P Overlay network</strong>（P2P覆盖网络）.比特币系统中所有节点完全平等，不像一些其他网络存在超级节点(super node)。要加入网络，至少需要知道一个种子节点，通过种子节点告知自己它所知道的节点。节点之间的通信采用了TCP协议，便于穿透防火墙。当节点离开时，只需要自行退出即可，其他节点在一定时间后仍然没有收到该节点消息，便会将其删掉.</p><blockquote><p>比特币网络设计原则：<strong>简单、鲁棒（最坏情况下能达到最优状况，即健壮性）而非高效</strong>。</p></blockquote><p>每个节点维护一个邻居节点集合，消息传播在网络中采用<strong>洪泛法</strong>，某个节点在收到一条消息会将其发送给所有邻居节点并标记，下次再收到便不会再发送该消息。邻居节点选取随机，未考虑网络底层拓扑结构，也与现实世界物理地址无关。该网络具有极强鲁棒性，但牺牲了网络效率.</p><p>比特币系统中，每个节点要维护一个等待上链的交易集合。第一次听到交易，若是合法交易，则将其加入该交易集合并转发给邻居节点，以后再收到该交易就不再转发（避免网络上交易无线传输）。假如网络中存在两个冲突交易，如交易1：A-&gt;B,交易2：A-&gt;C（假设花费的同一笔钱）.具体接收哪个取决于节点先接收到哪个交易，之后收到另一个交易会将其放弃。</p><blockquote><p>假如某个节点先听到A-&gt;B，但又听到A-&gt;C已经上链，则此时A-&gt;B为非法交易，所以要再等待上链交易集合中删除A-&gt;B</p></blockquote><p>新发布区块在网络中传播方式与新发布交易传播方式类似，每个节点除检查该区块内容是否合法，还要检查是否位于最长合法链上。区块越大，则网络上传输越慢。BTC协议对于区块大小限制为不大于1M大小.</p><blockquote><p>区块大小越大，网络上传播时延越长；区块大小越小，则可以包含的交易数目越少。</p></blockquote><p>此外，比特币网络传播属于<strong>Best effort（尽力而为）</strong>，不能保证一定传输成功。以一个交易发布到网络上，未必所有节点都能收到，也未必所有节点收到交易顺序都一致。</p>]]></content>
      
      
      <categories>
          
          <category> 比特币 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-具体实现</title>
      <link href="/2023/05/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/04-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/05/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/04-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="区块链：去中心化账"><a href="#区块链：去中心化账" class="headerlink" title="区块链：去中心化账"></a>区块链：去中心化账</h1><h2 id="比特币-BTC-：基于交易的账本模式"><a href="#比特币-BTC-：基于交易的账本模式" class="headerlink" title="比特币(BTC)：基于交易的账本模式"></a>比特币(BTC)：基于交易的账本模式</h2><h3 id="UTXO-Unspent-Transaction-Output-：尚未被花掉的交易输出的数据结构，在比特币系统中，由全节点维护，UTXO集合中每个元素要给出产生这个输出的交易的哈希值，以及其在交易中是第几个输出。通过这两个信息，便可以定位到UTXO中的输出，防范“双花攻击”"><a href="#UTXO-Unspent-Transaction-Output-：尚未被花掉的交易输出的数据结构，在比特币系统中，由全节点维护，UTXO集合中每个元素要给出产生这个输出的交易的哈希值，以及其在交易中是第几个输出。通过这两个信息，便可以定位到UTXO中的输出，防范“双花攻击”" class="headerlink" title="**UTXO(Unspent Transaction Output)**：尚未被花掉的交易输出的数据结构，在比特币系统中，由全节点维护，UTXO集合中每个元素要给出产生这个输出的交易的哈希值，以及其在交易中是第几个输出。通过这两个信息，便可以定位到UTXO中的输出，防范“双花攻击”"></a>**UTXO(Unspent Transaction Output)**：尚未被花掉的交易输出的数据结构，在比特币系统中，由全节点维护，UTXO集合中每个元素要给出产生这个输出的交易的哈希值，以及其在交易中是第几个输出。通过这两个信息，便可以定位到UTXO中的输出，防范“双花攻击”</h3><blockquote><p>每个交易会消耗输出，但也会产生新的输出</p><p>例如：A转给B5个BTC，之后B将其转给D，则UTXO中会删掉A-&gt;B这一交易记录，同时会添加B-&gt;D这一交易记录</p></blockquote><p>每个交易<strong>可以有多个输入</strong>，也可以<strong>有多个输出</strong>，但输入之和要等于输出之和（total inputs &#x3D; total outputs）,存在一些交易的total inputs 略大于 total outputs，这部分差额便作为交易费，给了获得记账权的节点</p><p>BTC系统中每21万个区块，BTC出块奖励减半。根据下图计算，基本上出块<strong>奖励每4年减半</strong></p><h2 id="以太坊-ETH-：基于账户的模式"><a href="#以太坊-ETH-：基于账户的模式" class="headerlink" title="以太坊(ETH)：基于账户的模式"></a>以太坊(ETH)：基于账户的模式</h2><p>系统中显示记录账户余额，可以看到，比特币这种模式，隐私性较好，但其也付出一定代价。在进行交易时，因为没有账户这一概念，无法知道账户剩余多少BTC,所以必须说明币的来源（防止双花攻击）。而基于账户的模式，则天然地避免了这种缺陷，转账交易就是对一个（多个）账户余额的数字减和另一个（多个）账户余额的数字加</p><h2 id="BTH的具体示例（blockchain-info）"><a href="#BTH的具体示例（blockchain-info）" class="headerlink" title="BTH的具体示例（blockchain.info）"></a>BTH的具体示例（blockchain.info）</h2><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/img/image-20221231215811539.png" alt="image-20221231215811539"> </p><h2 id="BTH交易示例"><a href="#BTH交易示例" class="headerlink" title="BTH交易示例"></a>BTH交易示例</h2><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/img/image-20221231213303050.png" alt="image-20221231213303050"></p><h2 id="什么是挖矿？"><a href="#什么是挖矿？" class="headerlink" title="什么是挖矿？"></a>什么是挖矿？</h2><p>可以看到，区块哈希与前一区块哈希都是以一长串0开头的，挖矿本身就是尝试各种nonce，使得产生的区块哈希值小于等于目标阈值，该目标阈值，表示成16进制，就是前面含有一长串的0，每次尝试nonce，可以视为一次伯努利试验，成功的概率极小，失败的概率极大，伯努利试验本身具有无记忆性。也就是说，无论之前做多少大量试验，对后续继续试验没有任何影响.</p><p>nonce是一个32位的无符号整型数据，在挖矿时候是通过不断调整nonce进行的，但可以看到，nonce的取值最多为2^32(2的32次方)种。但并非将这些nonce全部遍历一遍，就一定能找到符合要求的nonce。由于近年来，挖矿人员越来越多，挖矿难度已经调整的比较大了，而2^32这一搜索空间太小，所以仅调整nonce很大可能找不到正确的结果。区块中发布一个区块时会有一个铸币交易(coinbase交易)里有一CoinBase域，其中可以写入任何内容，在这里写什么都没有影响，所以，只要我们改变了写入内容，便可以改变Merkle Tree 的根哈希值。所以，在实际的挖矿中，包含两层循环。外层循环调整coinbase域（可以规定只将其中前x个字节作为另一个nonce），算出block header中根哈希值后，内层循环再调整nonce。</p><h2 id="比特币系统安全性分析"><a href="#比特币系统安全性分析" class="headerlink" title="比特币系统安全性分析"></a>比特币系统安全性分析</h2><blockquote><p>算力低的用户并非完全不能获得记账权，仅仅是概率上较低的问题</p></blockquote><blockquote><p>比特币协议中，缺省需要等6个确认区块，此时才认为该记录是不可篡改的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 比特币 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-数据结构</title>
      <link href="/2023/05/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/05/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希指针-Hash-pointer"><a href="#哈希指针-Hash-pointer" class="headerlink" title="哈希指针(Hash pointer)"></a>哈希指针(Hash pointer)</h1><p><strong>普通指针：</strong>存储某个结构体在内存中的地址</p><p><strong>哈希指针：</strong>除了存储内存地址，还要存储该结构体的哈希值</p><p><strong>普通链表：</strong>改变其中的某一个结点不影响其他结点</p><p><strong>区块链：</strong>就是一条使用哈希指针将各个结点串联起来的链表，结点称为区块，每一个区块包含上一个区块的哈希值</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/img/image-20221229114352812.png" alt="image-20221229114352812">     </p><blockquote><p>**篡改证明日志(tamper-evident log):**如果某个区块被篡改，后面的所有H()都将被修改，导致最后一个H()与本地的H()的不相等</p></blockquote><h1 id="Markle-Tree-默克尔树"><a href="#Markle-Tree-默克尔树" class="headerlink" title="Markle Tree(默克尔树)"></a>Markle Tree(默克尔树)</h1><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/img/image-20221229124613233.png" alt="image-20221229124613233"> </p><p>比特币系统中又一个重要的数据结构比特币中，每个数据块就是一个交易tx(Transation)，对每个交易取H()，再对相邻的两个H()一起取H()，最后可以得到一个根哈希</p><blockquote><p><strong>优点：</strong>只需要记住Root Hash（根哈希值)，便可以检测出对树中任何部位的修改</p></blockquote><h4 id="实际用途：提供Markle-proof"><a href="#实际用途：提供Markle-proof" class="headerlink" title="实际用途：提供Markle proof"></a>实际用途：提供Markle proof</h4><p>比特币中节点分为<strong>轻节点</strong>和<strong>全节点</strong>，全节点保存整个区块的所有内容，而轻节点仅仅保存区块的块头信息</p><p>&#x3D;&#x3D;如何向轻节点证明某个交易被写入区块链？&#x3D;&#x3D;</p><img src="/noteimg/区块链/比特币/img/image-20221229130553885.png" alt="image-20221229130553885" style="zoom:150%;" /> <p>便需要用到Markle proof，将交易到根节点这一条路径称为Markle proof，全节点将整个Markle proof发送给轻节点，轻节点即可根据其算出根哈希值，和自己保存的对比，从而验证该交易是否被写入区块链。只要沿着该路径，所有哈希值都正确，说明内容没有被修改过。</p>]]></content>
      
      
      <categories>
          
          <category> 比特币 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-共识协议</title>
      <link href="/2023/05/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/03-%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/05/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/03-%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="双花攻击-double-spending"><a href="#双花攻击-double-spending" class="headerlink" title="双花攻击(double spending)"></a>双花攻击(double spending)</h1><p>数字货币本身为带有签名的数据文件，可以进行复制,对用户来说，可以将同一货币花费两次.</p><blockquote><p>方案：添加唯一编号(不可篡改)，每次支付向货币发行单位查询真伪，这是典型的第三方中心化方案</p><p>所以去中心化的比特币便吸引了人们</p></blockquote><h1 id="去中心化需要解决的问题"><a href="#去中心化需要解决的问题" class="headerlink" title="去中心化需要解决的问题"></a>去中心化需要解决的问题</h1><p>数字货币的发行由谁执行？如何发行？发行多少？什么时候发行？</p><blockquote><p>在比特币系统中由挖矿来决定货币发行权和发行量。</p></blockquote><p>如何验证交易是否有效？如何防止双花攻击？</p><blockquote><p>该问题的解决，依赖于系统中维护的一个数据结构，记录货币的使用情况（是否被花过？被谁花过？）</p><p>该数据结构由系统中全体用户共同维护，保证了交易的有效性。该数据结构，便是区块链。</p></blockquote><h2 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h2><p>假定A获得<strong>铸币权</strong>，新新发布了10个比特币（该交易称为铸币交易）。A将10个比特币转给了B(5个)和C(5个)，A对该交易进行签名，同时该交易需要说明所花掉10个比特币来源（来自铸币交易）。之后，B将自己的5个比特币转给C(2个)和D(3个)，该交易需要B的签名，该交易需要说明所花掉的5个比特币来自于第二个交易中。然后，C将自己所拥有的全部7个比特币都转给E，并对该交易签名，可以发现该交易中C的比特币来源于两个交易中。这样，就构成了一个简单的区块链。<strong>【红色部分为比特币来源】</strong></p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/img/image-20221230210223964.png" alt="image-20221230210223964"></p><blockquote><p><strong>红色的链</strong>说明比特币的来源并非凭空捏造，可以防止双花攻击。</p><p>交易：收款地址为公钥的哈希，付款人的签名</p><p>交易中：收款方需要知道付款方的公钥，从而验证付款方签名是否有效（其他节点都需要知道付款方公钥，验证交易合法性）</p><p>实际中A转账时候提供的公钥需要和铸币交易中公钥对的上，这样就防止了恶意节点伪造A的公钥来“偷”走A的比特币。</p><p>在比特币系统中，通过执行脚本实现上述验证过程。将当前交易输入脚本与前一个交易输出脚本（说明币的来源的交易）拼接执行，如果可以正确执行，说明交易合法。</p><p>在该图中，一个区块仅含有一个交易，实际中一个区块中包含多个交易，交易通过Markle Tree组织起来，在区块中存储。</p></blockquote><h2 id="比特币区块信息"><a href="#比特币区块信息" class="headerlink" title="比特币区块信息"></a>比特币区块信息</h2><table><thead><tr><th>block Header（区块宏观信息）</th><th>block body</th></tr></thead><tbody><tr><td>Version(版本协议)</td><td>…</td></tr><tr><td>Hash of previous block header（指向前一个区块指针）</td><td>…</td></tr><tr><td>Merkle root hash（默克尔树根哈希值）</td><td>…</td></tr><tr><td>target（挖矿难度目标阈值）</td><td>…</td></tr><tr><td>nonce（随机数）</td><td>…</td></tr></tbody></table><blockquote><ol><li>挖矿求解问题：Hash（block header）&lt;&#x3D;target</li><li>Hash of previous block header只计算区块块头部分的哈希（ Merkle root hash保证了block body内容不被篡改，所以只需要计算block header即可保证整个区块内容不会被篡改）</li><li>区块链系统中，轻节点（只存储区块block header信息）只利用区块链，但并不参与区块链系统维护和构造。</li></ol></blockquote><h2 id="分布式共识"><a href="#分布式共识" class="headerlink" title="分布式共识"></a>分布式共识</h2><blockquote><p>可否各个节点独立完成区块链构建？<br>很明显不行，各个节点独立打包交易，形成区块链，必然无法避免区块链内容不一致。从分布式系统角度来说，<strong>账本内容需要取得分布式共识</strong>，从而保证区块链内容在不同节点上的一致性。</p></blockquote><p>FLP不可能结论：在一个异步系统中，网络时延无上限，即使只有一个成员是有问题的，也不可能达成共识。<br>CAP Theorem（Consistency一致性、Availability可靠性、Partition tolerance容错性）：任何一个分布式系统中，最多只能满足其中两个性质。<br>分布式共识中协议Paxos 可以保证Consistency（若达成共识必然一致），但在某些情况下，可能会一直无法达成共识。</p><h2 id="比特币共识协议"><a href="#比特币共识协议" class="headerlink" title="比特币共识协议"></a>比特币共识协议</h2><blockquote><p>背景：假设系统中存在部分节点有恶意，但存在比例较小。大多数节点为“好”的节点，在这种情况下进行共识协议设置。<br>想法1：直接投票<br>某个节点打包交易到区块，将其发给其他节点，其他节点检查该候选区块，检查若正确投赞成票，若票数过半数，加入区块链。<br>存在的问题1——恶意节点不断打包不合法区块，导致一直无法达成共识，时间全花费在投票上。<br>存在的问题2——无强迫投票手段，某些节点不投票（行政不作为）。<br>存在的问题3——网络延迟事先未知，投票需要等多久？效率上会产生问题。<br>更大的一个问题——membership。如果是联盟链，对加入成员有要求，可以基于投票。但比特币系统，任何人都可以加入，且创建账户及其简单，只需要本地产生公私钥对即可。只有转账（交易）时候,比特币系统才能知道该账户的存在。这样，黑客可以使用计算机专门生成大量公私钥对，当其产生大量公私钥对超过系统中一半数目，就可以获得支配地位（<strong>女巫攻击</strong>）。所以，这种简单的投票方案也是不可行的。</p></blockquote><p>比特币系统中采用了很巧妙的方案解决这个问题。虽然仍然是投票，但并非简单的根据账户数目，而是依据计算力进行投票。<br>在比特币系统中，每个节点都可以自行组装一个候选区块，而后，尝试各种nonce值，这就是挖矿。[H(block header)&lt;&#x3D;target]<br>当某个节点找到符合要求的nonce，便获得了<strong>记账权</strong>，从而可以将区块发布到系统中。其他节点受到区块后，验证区块合法性，如果系统中绝大多数节点验证通过，则接收该区块为最新的区块并加入到区块链中。</p><blockquote><ol><li>会不会合法区块被拒绝？<br>如图所示。发生分叉的情况下，暂时保存分叉情况，但区块链只承认最长合法链，随着时间推移，必然存在某一条链变成最长合法链。这样，也就会导致合法区块被拒绝<br><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/img/3388381_1581760307110_043471697E62271078507983EA89D352.png" alt="图片说明"></li><li>分叉攻击<br>如图所示，A用户对上面的A转账给B的记录回滚，从而非法获取利益。在两条链上，发现交易都合法。这是一个典型的双花攻击。A给B转账后，用分叉攻击将钱又转回来，覆盖掉原来的记录。<br>在比特币系统中，这种情况实际上很难发生。因为大多数矿工认可的是最长的合法链，会沿着上面的链继续挖下去。而A这个攻击者要想回退记录，就必须使得下面的链变得比上面的链还长。理论上来说，攻击者需要达到整个系统中51%的计算力，才能使得这种攻击成功。<br><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/img/3388381_1581760633059_47DAC7C8FB06138B83FFA215B3285151.png" alt="图片说明"><br>此外，区块链正常运行场景下，也可能会发生分叉。当两个节点同时获得记账权时，会有两个等长的合法链。在缺省情况下，节点接收最先听到的区块，该节点会沿着该区块继续延续。但随着时间延续，必然有一个链胜出，由此保证了区块链的一致性。（被扔掉的区块称为“孤儿区块”)</li></ol></blockquote><p>可见，依赖于算力竞争，有效的防止了“女巫攻击”。</p><h2 id="比特币激励机制"><a href="#比特币激励机制" class="headerlink" title="比特币激励机制"></a>比特币激励机制</h2><blockquote><p>为什么系统中节点要竞争记账权？需要提供算力和电力成本，节点为什么要去做？</p></blockquote><p>比特币系统设计之初便考虑到了这个问题，那就是引入激励机制。比特币通过设置<strong>出块奖励</strong>来解决该问题，一个获得合法区块的节点，可以在区块中加入一个特殊交易（铸币交易）。事实上，这种方式也是唯一一个产生新比特币的途径。</p><blockquote><p>比特币系统设计规定，起初每个区块可以获得50个比特币，但之后每隔21万个区块，奖励减半。</p></blockquote><p><strong>但是这样就可以了吗？？？</strong><br>区块中保存交易记录，那么，会不会存在节点只想发布区块而不想打包交易？中本聪在设计该系统时，引入了交易费。在一个区块中，其输入&gt;&#x3D;输出，差值便是给区块所属节点的手续费。这些会在后续文章中详细说明。</p>]]></content>
      
      
      <categories>
          
          <category> 比特币 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-密码学原理</title>
      <link href="/2023/05/22/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/01-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/"/>
      <url>/2023/05/22/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/01-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="密码学原理"><a href="#密码学原理" class="headerlink" title="密码学原理"></a>密码学原理</h1><h3 id="比特币了利用了密码学中两个功能：哈希（cryptographic-hash-function）、签名（非对称加密）"><a href="#比特币了利用了密码学中两个功能：哈希（cryptographic-hash-function）、签名（非对称加密）" class="headerlink" title="比特币了利用了密码学中两个功能：哈希（cryptographic hash function）、签名（非对称加密）"></a>比特币了利用了密码学中两个功能：哈希（cryptographic hash function）、签名（非对称加密）</h3><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p><strong>collision resistance(抗碰撞性)：</strong>给定x和y且x!&#x3D;y，给定一个哈希函数Hash()，可以使Hash(x)&#x3D;Hash(y)称为hash碰撞，它是不可避免的，因为输入空间总大于输出空间</p><p>&#x3D;&#x3D;很难!!!&#x3D;&#x3D;collision resistance保证给定x，找到一个y，能够在x!&#x3D;y的前提下，使得Hash(x)&#x3D;Hash(y)</p><blockquote><p>MD5一个很流行哈希函数目前已经知道如何制造碰撞</p></blockquote><p><strong>hiding(单向不可逆)：</strong>前提是<strong>输入空间足够大，分布比较均匀</strong>.</p><p>给定x和Hash(),可以很容易得到Hash(x),但在已知Hash(x)和Hash()的情况下，无法反推出x的具体取值（除非蛮力破解）</p><blockquote><p>collision resistance + hiding —-&gt;digital commitment(数据保证):把预测结果作为输入x，算出一个哈希值，将哈希值公布，hiding让人们知道哈希值而不知道预测值，最后再将x公布，因为有collision resistance的性质，预测结果是不可篡改的。</p></blockquote><p><strong>Puzzle friendly(不可预测)：</strong>哈希值计算事先不可预测，想要H(x)落入某个范围，没有什么好办法只能一个一个试</p><blockquote><p>在挖矿过程中保证了工作量证明(POW)机制，挖矿难验证易，比特币系统中采用SHA-256哈希函数</p></blockquote><h3 id="签名（非对称加密）"><a href="#签名（非对称加密）" class="headerlink" title="签名（非对称加密）"></a>签名（非对称加密）</h3><p>创建一个公私钥对，公钥是公开的，私钥只有自己知道，加密用公钥，解密用私钥</p><blockquote><p>交流：A用B公钥对信息加密，B用自己私钥解密</p><p>签名：A用自己私钥给信息加密，大家用A的公钥对这个信息进行验证，防止有人仿冒A</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 比特币 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合约安全工具</title>
      <link href="/2023/05/16/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/05/16/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<ol><li><p><strong>Mythril：</strong>Mythril是一款<strong>基于符号执行的工具</strong>，用于发现 Solidity 合约中的潜在漏洞和安全风险。它可以检测各种漏洞类型，如重入、整数溢出、未经授权的访问等，并提供相应的警告和建议。</p></li><li><p><strong>Slither：</strong>Slither是另一个针对Solidity智能合约的<strong>静态分析工具</strong>。它可以检测出合约中的安全漏洞、代码质量问题和潜在的优化机会。Slither<strong>提供了丰富的规则集和可自定义的插件系统</strong>，可以<strong>检测各种安全问题</strong>，包括代码注入、可重入性、未初始化变量等，并<strong>提供详细的分析报告和修复建议。</strong></p></li><li><p>Manticore：Manticore是一个<strong>符号执行工具</strong>，用于对以太坊智能合约进行深入分析。它可以<strong>生成各种输入和状态组合，以测试合约的边界条件和异常情况</strong>，并发现潜在的漏洞和安全问题。</p></li><li><p><strong>MythX：</strong>MythX是一个<strong>基于云的智能合约安全分析平台，整合了多种静态和动态分析工具。</strong>它可以<strong>自动扫描合约代码，检测潜在的漏洞，并提供详细的报告和修复建议。</strong></p></li><li><p><strong>Echidna：</strong>Echidna是一个<strong>基于模糊测试的智能合约分析工具</strong>。它可以<strong>生成各种随机、无效或异常的输入，以发现潜在的漏洞和安全问题</strong>。Echidna<strong>还支持属性驱动测试，用于验证合约是否满足特定的安全属性。</strong></p></li><li><p>Oyente：Oyente是一个用于<strong>静态分析以太坊智能合约的工具</strong>。它<strong>可以检测出多种类型的漏洞，如重入攻击、整数溢出等，并提供相应的警告和修复建议。</strong></p></li><li><p>solhint：solhint是一个Solidity合约的<strong>静态分析工具</strong>，用于<strong>强制实施 Solidity 编码规范和最佳实践</strong>。它可以<strong>检测合约中的潜在问题、命名约定、代码风格等，并提供相应的修复建议。</strong></p></li><li><p>Ethlint：Ethlint是另一个Solidity合约的<strong>静态分析工具</strong>，用于<strong>检查代码中的潜在问题和代码质量问题</strong>。它可以<strong>检测合约中的命名约定、错误的语法使用、代码风格等，并提供改进建议和修复建议。</strong></p></li><li><p><strong>Securify</strong>：Securify是一个由以太坊基金会支持的智能合约漏洞扫描器。这款流行的以太坊智能合约扫描器可以检测多达37个智能合约漏洞，并实现上下文特定的静态分析，以获得更准确的安全报告。</p></li></ol><h1 id="slither"><a href="#slither" class="headerlink" title="slither"></a>slither</h1><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/img/image-20230619161222942.png" alt="image-20230619161222942"> </p><img src="/noteimg/区块链/合约安全/img/image-20230619161238470.png" alt="image-20230619161238470" style="zoom:67%;" /> <p><code>slither [target] --checklist</code>.</p><h1 id="Mythril"><a href="#Mythril" class="headerlink" title="Mythril"></a>Mythril</h1><p>docker run -v &#x2F;root&#x2F;yaoqi&#x2F;contract_test:&#x2F;root mythril&#x2F;myth analyze  &#x2F;root&#x2F;file.sol –solv 0.8.17</p><h1 id="Manticore"><a href="#Manticore" class="headerlink" title="Manticore"></a>Manticore</h1><p>docker run -it trailofbits&#x2F;manticore</p><p>docker cp FiftyYearsChallenge.sol a303f6f670b7:&#x2F;manticore&#x2F;</p><p>manticore FiftyYearsChallenge.sol</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/img/image-20230620213546447.png" alt="image-20230620213546447"></p>]]></content>
      
      
      <categories>
          
          <category> 合约安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9-签名重放</title>
      <link href="/2023/05/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/9-%E7%AD%BE%E5%90%8D%E9%87%8D%E6%94%BE/"/>
      <url>/2023/05/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/9-%E7%AD%BE%E5%90%8D%E9%87%8D%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="签名重放"><a href="#签名重放" class="headerlink" title="签名重放"></a>签名重放</h1><p>签名重放发生在合约没有跟踪签名是否先前被使用。</p><p>我们可以添加以下几行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bytes memory signature = abi.encodePacked(v, r, s);</span><br><span class="line">require(!used[signature], &quot;signature already used&quot;); </span><br><span class="line">// mapping(bytes =&gt; bool);</span><br><span class="line">used[signature] = true;</span><br></pre></td></tr></table></figure><p>唉，这段代码还是不安全啊!</p><h2 id="签名的可塑性"><a href="#签名的可塑性" class="headerlink" title="签名的可塑性"></a>签名的可塑性</h2><p>给定一个有效的签名，攻击者可以做一些快速的算术来推导出一个不同的签名。然后，攻击者可以 “重放”这个修改过的签名。但首先，让我们提供一些代码，证明我们可以从一个有效的签名开始，修改它，并显示新的签名仍然通过。</p><h2 id="安全签名"><a href="#安全签名" class="headerlink" title="安全签名"></a>安全签名</h2><p>在这一点上，你可能想得到一些安全的签名代码，这里是检查清单：</p><ul><li>使用openzeppelin的库来防止可塑性攻击，并还原到零地址的问题</li><li>不要使用签名作为密码。信息需要包含攻击者不能轻易重复使用的信息（如msg.sender）。</li><li>在链上对你所签署的内容进行Hash</li><li>使用 <code>nonce</code> 来防止重放攻击。更好的是，遵循EIP712，这样用户可以看到他们正在签署的内容，并且可以防止签名在合约和不同链之间被重复使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 合约安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-不安全Delegatecall</title>
      <link href="/2023/05/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/8-%E4%B8%8D%E5%AE%89%E5%85%A8Delegatecall/"/>
      <url>/2023/05/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/8-%E4%B8%8D%E5%AE%89%E5%85%A8Delegatecall/</url>
      
        <content type="html"><![CDATA[<h1 id="不安全的代理调用"><a href="#不安全的代理调用" class="headerlink" title="不安全的代理调用"></a>不安全的代理调用</h1><p>委托调用（Delegatecall）不应该被用于不受信任的合约，因为它把所有的控制权都交给了委托接受者。在这个例子中，不受信任的合约偷走了合约中所有的以太币。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">contract UntrustedDelegateCall &#123;</span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function doDelegateCall(address _delegate, bytes calldata data) public &#123;</span><br><span class="line">        (bool ok, ) = _delegate.delegatecall(data);</span><br><span class="line">        require(ok, &quot;delegatecall failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract StealEther &#123;</span><br><span class="line">    function steal() public &#123;</span><br><span class="line">        (bool ok, ) = tx.origin.call&#123;value: address(this).balance&#125;(&quot;&quot;);</span><br><span class="line">        require(ok);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack(address victim) public &#123;</span><br><span class="line">        UntrustedDelegateCall(victim).doDelegateCall(</span><br><span class="line">            address(this),</span><br><span class="line">            abi.encodeWithSignature(&quot;steal()&quot;)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 合约安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-private私有变量</title>
      <link href="/2023/05/06/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/7-private%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F/"/>
      <url>/2023/05/06/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/7-private%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="private私有变量"><a href="#private私有变量" class="headerlink" title="private私有变量"></a>private私有变量</h1><p>私有变量在区块链上仍然是可见的，所以敏感信息不应该被存储在那里。如果它们不能被访问，验证者如何能够处理取决于其值的交易？私有变量不能从外部的Solidity 合约中读取，但它们可以使用以太坊客户端在链外读取</p><blockquote><p>标注为 <code>private</code> 区域的数据并不是不能访问，它们存储在一个又一个的 <code>slot</code>存储槽里</p></blockquote><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>要读取一个变量，你需要知道它的存储槽。在下面的例子中，myPrivateVar的存储槽是0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">contract PrivateVarExample &#123;</span><br><span class="line">    uint256 private myPrivateVar;</span><br><span class="line"></span><br><span class="line">    constructor(uint256 _initialValue) &#123;</span><br><span class="line">        myPrivateVar = _initialValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是读取已部署的智能合约的私有变量的javascript代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">readPrivateVar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> privateVarValue = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(</span><br><span class="line">    <span class="title class_">PrivateVarExample</span>_ADDRESS,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">  );</span><br><span class="line">  ...</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Value of private variable &#x27;myPrivateVar&#x27;:&quot;</span>,</span><br><span class="line">  web3.<span class="property">utils</span>.<span class="title function_">hexToNumberString</span>(privateVarValue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 合约安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-未检查底层调用结果</title>
      <link href="/2023/05/05/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/6-%E6%9C%AA%E6%A3%80%E6%9F%A5%E5%BA%95%E5%B1%82%E8%B0%83%E7%94%A8%E7%BB%93%E6%9E%9C/"/>
      <url>/2023/05/05/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/6-%E6%9C%AA%E6%A3%80%E6%9F%A5%E5%BA%95%E5%B1%82%E8%B0%83%E7%94%A8%E7%BB%93%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="未检查底层调用结果"><a href="#未检查底层调用结果" class="headerlink" title="未检查底层调用结果"></a>未检查底层调用结果</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    uint256 public x;</span><br><span class="line"></span><br><span class="line">    function setx(uint256 _x) external &#123;</span><br><span class="line">        require(_x &gt; 10, &quot;x must be bigger than 10&quot;);</span><br><span class="line">        x = _x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    function setXV1(address a, uint256 _x) external &#123;</span><br><span class="line">        (bool success, ) =</span><br><span class="line">            a.call(abi.encodeWithSignature(&quot;setx(uint256)&quot;, _x));</span><br><span class="line">        // success is not checked!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在合约 B 中，如果 _x 小于 10，setXV1 会默默地失败。当一个函数通过.call方法被调用时，被调用者可以回退，但父函数不会回退。必须检查返回成功的值，并且代码行为必须相应地分支。</p><p><code>call</code> 这类底层调用的方式失败并不会发生回滚。因此，攻击者可以精心设计 gas，让底层调用回滚，而其他语句继续运行。</p>]]></content>
      
      
      <categories>
          
          <category> 合约安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-整数运算</title>
      <link href="/2023/04/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/4-%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"/>
      <url>/2023/04/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/4-%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h1><p>而从 <code>Solidity 0.8.0</code> 开始，所有的算术运算默认就会进行溢出检查，额外引入库将不再必要。</p><p>0.8.0 开始，算术运算有两种计算模式：一种是<code>checked</code>（检查）模式，另一种是 <code>unchecked</code>（不检查）模式。</p><h2 id="Solidity-不会向上转型-uint-大小"><a href="#Solidity-不会向上转型-uint-大小" class="headerlink" title="Solidity 不会向上转型 uint 大小"></a>Solidity 不会向上转型 uint 大小</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function limitedMultiply(uint8 a, uint8 b) public pure returns (uint256 product) &#123;</span><br><span class="line">    product = a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管product是一个uint256变量，但乘法结果不会大于255，否则代码将被回退。</p><p>这个问题可以通过向上转型每个变量来解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function unlimitedMultiply(uint8 a, uint8 b) public pure returns (uint256 product) &#123;</span><br><span class="line">    product = uint256(a) * uint256(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solidity-溢出不会回退"><a href="#Solidity-溢出不会回退" class="headerlink" title="Solidity 溢出不会回退"></a>Solidity 溢出不会回退</h2><p>Solidity 并不检查将一个整数转换为一个较小的整数是否安全。除非某些业务逻辑能确保向下转型是安全的，否则应该使用 <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol">SafeCast</a> 这样的库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function test(int256 value) public pure returns (int8) &#123;</span><br><span class="line">return int8(value + 1); // overflows and does not revert</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 合约安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-数据操作</title>
      <link href="/2023/04/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/5-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/04/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/5-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h1><h2 id="对存储指针的写入不会保存新数据"><a href="#对存储指针的写入不会保存新数据" class="headerlink" title="对存储指针的写入不会保存新数据"></a>对存储指针的写入不会保存新数据</h2><p>这段代码看起来像是把myArray[1]中的数据复制到了myArray[0]中，但其实不是。如果你把函数的最后一行注释掉，编译器会说这个函数应该变成一个视图函数。对foo的写入并没有写到底层存储。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract DoesNotWrite &#123;</span><br><span class="line">    struct Foo &#123;</span><br><span class="line">        uint256 bar;</span><br><span class="line">    &#125;</span><br><span class="line">    Foo[] public myArray;</span><br><span class="line"></span><br><span class="line">    function moveToSlot0() external &#123;</span><br><span class="line">        Foo storage foo = myArray[0];</span><br><span class="line">        foo = myArray[1]; </span><br><span class="line">        myArray[1] = Foo(&#123;bar: 100&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以不要写到存储指针。</p><h2 id="删除包含动态数据类型的结构体并不会删除动态数据"><a href="#删除包含动态数据类型的结构体并不会删除动态数据" class="headerlink" title="删除包含动态数据类型的结构体并不会删除动态数据"></a>删除包含动态数据类型的结构体并不会删除动态数据</h2><p><strong>如果一个映射（或动态数组）在一个结构体内，并且该结构被删除，那么映射或数组将不会被删除。</strong></p><p>除了删除数组之外，删除关键字只能删除一个存储槽。<strong>如果该存储槽包含对其他存储槽的引用，这些存储槽不会被删除。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">contract NestedDelete &#123;</span><br><span class="line"></span><br><span class="line">    mapping(uint256 =&gt; Foo) buzz;</span><br><span class="line"></span><br><span class="line">    struct Foo &#123;</span><br><span class="line">        mapping(uint256 =&gt; uint256) bar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Foo foo;</span><br><span class="line"></span><br><span class="line">    function addToFoo(uint256 i) external &#123;</span><br><span class="line">        buzz[i].bar[5] = 6;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getFromFoo(uint256 i) external view returns (uint256) &#123;</span><br><span class="line">        return buzz[i].bar[5];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deleteFoo(uint256 i) external &#123;</span><br><span class="line">        delete buzz[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在让我们做以下交易序列</p><ol><li>addToFoo(1)</li><li>getFromFoo(1) 返回 6</li><li>deleteFoo(1)</li><li>getFromFoo(1) 仍然返回 6!</li></ol><p>记住，在Solidity中，map 永远不会是 “空”的。因此，如果有人访问一个已经被删除的项目，交易将不会回退，而是返回该数据类型的零值。</p>]]></content>
      
      
      <categories>
          
          <category> 合约安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-拒绝服务攻击</title>
      <link href="/2023/04/25/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/3-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/"/>
      <url>/2023/04/25/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/3-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h1><h2 id="Gas-导致拒绝服务"><a href="#Gas-导致拒绝服务" class="headerlink" title="Gas 导致拒绝服务"></a>Gas 导致拒绝服务</h2><h3 id="悲痛攻击（griefing-attack）"><a href="#悲痛攻击（griefing-attack）" class="headerlink" title="悲痛攻击（griefing attack）"></a>悲痛攻击（griefing attack）</h3><p>意味着黑客试图为其他人 “制造悲痛”，即使他们没有从这样做中获得经济利益。</p><p>一个智能合约可以通过进入一个无限循环，恶意地用完转发给它的所有Gas。考虑一下下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract Mal &#123;</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        // infinite loop uses up all the gas</span><br><span class="line">        while (true) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>尽管擦除存储是一个节省Gas的操作，但它仍然有一个成本。如果一个数组变得太长，它就不可能被删除。</p><p>如果一个智能合约转账到有转账hook的代币，攻击者可以设置一个不接受代币的合约（它要么没有onReceive函数，要么将该函数编程为回退）。这将使代币无法转账，并导致整个交易被回退。</p></blockquote><h2 id="依赖某些特定条件"><a href="#依赖某些特定条件" class="headerlink" title="依赖某些特定条件"></a>依赖某些特定条件</h2><p>依赖某些特定条件才能执行的逻辑，如果有人恶意破坏并且没有检查是否满足条件，就会造成服务中断。</p><p>例如下面的例子：依赖接收者可以接收以太币，但是如果接收以太币的合约无 <code>receive</code> 函数或者 <code>fallback</code> 函数，就会让逻辑无法进行下去。</p><p>多人竞拍，如果有出价更高的则退回上个一竞拍者的以太币，并且更新胜出者 <code>king</code> 和当前标价 <code>balance</code>，<code>Attack</code> 合约参与竞拍，但是无法退回以太币给它，导致 DOS(claimThrone无法访问)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">contract KingOfEther &#123;</span><br><span class="line">    address public king;</span><br><span class="line">    uint public balance;</span><br><span class="line"></span><br><span class="line">    function claimThrone() external payable &#123;</span><br><span class="line">        require(msg.value &gt; balance, &quot;Need to pay more to become the king&quot;);</span><br><span class="line"></span><br><span class="line">        (bool sent, ) = king.call&#123;value: balance&#125;(&quot;&quot;);</span><br><span class="line">        require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line"></span><br><span class="line">        balance = msg.value;</span><br><span class="line">        king = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    KingOfEther kingOfEther;</span><br><span class="line"></span><br><span class="line">    constructor(KingOfEther _kingOfEther) &#123;</span><br><span class="line">        kingOfEther = KingOfEther(_kingOfEther);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        kingOfEther.claimThrone&#123;value: msg.value&#125;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 合约安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-tx.origin</title>
      <link href="/2023/04/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/2-tx.origin/"/>
      <url>/2023/04/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/2-tx.origin/</url>
      
        <content type="html"><![CDATA[<h1 id="tx-origin"><a href="#tx-origin" class="headerlink" title="tx.origin"></a>tx.origin</h1><p>在合约中使用 <code>tx.origin</code> 可能容易受到伪造的交易攻击，因为它只提供了最初的发送者地址，而不是当前调用合约的地址。这种攻击称为 “跨合约伪造”（cross-contract calling attack）或 “Tx.origin漏洞”（Tx.origin vulnerability）。因此，尽量避免在合约中过于依赖 <code>tx.origin</code>。</p><p>使用tx.origin很少有好的理由。如果tx.origin被用来识别交易发起人，那么中间人攻击是可能的。<strong>如果用户被骗去调用一个恶意的智能合约，那么该智能合约就可以利用tx.origin所拥有的所有权限来进行破坏</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">contract phish &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    constructor () &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    receive() external payable&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable&#123;&#125;</span><br><span class="line"></span><br><span class="line">    function withdrawAll (address payable _recipient) public &#123;</span><br><span class="line">        require(tx.origin == msg.sender);</span><br><span class="line">        _recipient.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">    function getOwner() public view returns(address) &#123;</span><br><span class="line">        return owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TxOrigin &#123;</span><br><span class="line">    address  owner;</span><br><span class="line">    phish PH;</span><br><span class="line"></span><br><span class="line">    constructor(address phishAddr) &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        PH=phish(payable(phishAddr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() internal &#123;</span><br><span class="line">        address phOwner = PH.getOwner();</span><br><span class="line">        if (phOwner == msg. sender) &#123;</span><br><span class="line">            PH.withdrawAll(payable(owner));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            payable(owner).transfer(address(this). balance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fallback() external payable&#123;</span><br><span class="line">        attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 合约安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-重入攻击</title>
      <link href="/2023/04/16/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/1-%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB/"/>
      <url>/2023/04/16/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/1-%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="重入攻击"><a href="#重入攻击" class="headerlink" title="重入攻击"></a>重入攻击</h1><p>每当一个智能合约调用另一个智能合约的函数，向其发送以太币，或向其代币转账，那么就有可能出现重入。</p><p>重入攻击的类型可以分为：<br>（1）单函数重入<br>（2）跨函数重入<br>（3）跨合约重入</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="单函数重入"><a href="#单函数重入" class="headerlink" title="单函数重入"></a>单函数重入</h3><p>当一个易受攻击的函数是攻击者试图递归调用的同一个函数时，就会发生单函数重入攻击。<br><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/img/Z5jDNDcI63130b6cc6bb8.png" alt="image.png"><br>在此示例中，注释（1）部分进行资金转移之后，才对注释（2）账户余额状态进行修改。这时候，会让黑客可以在状态修改之前利用fallback()函数多次调用该函数，直至取走合约账户内的全部余额。</p><h3 id="跨函数重入"><a href="#跨函数重入" class="headerlink" title="跨函数重入"></a>跨函数重入</h3><p>当一个易受攻击的函数与一个可被攻击者利用的函数共享状态时，就会发生跨函数重入。<br><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/img/I2v9TxrD63130b7626179.png" alt="image.png"><br>在此示例中，黑客可以利用fallback()操作该合约，外部调用transfer()函数，在合约余额状态设置为0之前，进行转移资金。虽然该合约能接受到取款，但是也可以转移资金。<br>跨函数重入和单函数重入在同一个合约中，也有不在同一个合约，重入可以发生在跨多个合约，便是多个合约共享同一个状态。</p><h3 id="跨合约重入"><a href="#跨合约重入" class="headerlink" title="跨合约重入"></a>跨合约重入</h3><p>当一个合约中的一个状态在另一个合约中使用，但在被调用之前未完全更新时，可能会发生跨合约重入。<br>跨合约重入所需以下条件：<br>（1）一个合约中的状态在另一个合约中共享或者使用<br>（2）攻击者可以通过利用执行流来操纵合约的状态</p><h2 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h2><p>1）对于单函数重入、跨函数重入，可以在合约中实现互斥锁，用来防止重复调用同一个合约中的函数，从而防止重入<br><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/img/cfrZPT1N63130d45b197d.png" alt="image.png"><br>（2）在调用外部合约或所谓的“检查-生效-交互”模式之前检查并尝试更新所有状态。这样，即使重入，也不会产生任何影响，因为所有状态都已完成更新(先更新后交互)<br><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/img/ndIhRCb363130d4f90527.png" alt="image.png"><br>（3）防止攻击者利用合约的控制流。设置一组列入白名单的地址，可以防止攻击者将未知的恶意合约注入合约<br>（4）gas限制可以防止重入攻击，但这不应该被视为一种安全策略，因为gas成本取决于以太坊的操作码，这些操作码可能会发生变化。另一方面，智能合约代码是不可变的。无论如何，有必要了解这些函数之间的区别：send，transfer和call。send和transfer的函数本质上是相同的，但如果事务失败，transfer将恢复，而send则不会。关于重入，send和transfer都有2300个单位的gas限制。使用这些函数应该可以防止发生重入攻击，因为这不足以递归回调源函数来利用资金<br>（5)使用自动化的智能合约审计扫描工具或需求专业的第三方审计团队的帮助，也可以帮助检测重入错误。</p>]]></content>
      
      
      <categories>
          
          <category> 合约安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0-安全事件</title>
      <link href="/2023/04/10/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/0-%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6/"/>
      <url>/2023/04/10/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/0-%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><p>这似乎是一个简单的错误，但忘记对谁可以调用一个敏感函数（如提取以太币或改变所有权）进行限制，这种情况经常发生，令人惊讶</p><h1 id="输入验证"><a href="#输入验证" class="headerlink" title="输入验证"></a>输入验证</h1><p>如果访问控制是关于控制谁调用一个函数，那么输入验证就是控制他们用什么来调用合约。</p><p>这通常归结为忘记在适当的地方设置require语句。</p><h1 id="过多的函数限制"><a href="#过多的函数限制" class="headerlink" title="过多的函数限制"></a>过多的函数限制</h1><p>过多的验证可能意味着资金不会被盗，但它可能意味着资金被锁定在合约中。拥有多重的保障措施也不是一件好事。</p><p>最引人注目的事件之一是Akutars NFT，它最终导致价值3400万美元的Eth卡在智能合约内，无法提取。</p><h1 id="双重投票或msg-sender欺骗"><a href="#双重投票或msg-sender欺骗" class="headerlink" title="双重投票或msg.sender欺骗"></a>双重投票或msg.sender欺骗</h1><p>使用vanilla ERC20代币或NFT作为门票来计算投票权重是不安全的，因为攻击者可以用一个地址投票，将代币转账到另一个地址，并从该地址再次投票。为了防止这种攻击，应该使用<a href="https://www.rareskills.io/post/erc20-snapshot">ERC20 Snapshot</a>或<a href="https://www.rareskills.io/post/erc20-votes-erc5805-and-erc6372">ERC20 Votes</a>。通过对过去的一个时间点进行快照，当前的代币余额不能被操纵以获得非法投票权。</p><h1 id="闪电贷治理攻击"><a href="#闪电贷治理攻击" class="headerlink" title="闪电贷治理攻击"></a>闪电贷治理攻击</h1><p>然而，使用具有快照或投票函数的ERC20代币并不能完全解决这个问题，如果有人可以通过闪电贷来暂时增加他们的余额，然后在同一交易中对他们的余额进行快照。如果该快照被用于投票，他们将有一个不合理的大量投票权可供支配。</p><h1 id="闪电贷价格攻击"><a href="#闪电贷价格攻击" class="headerlink" title="闪电贷价格攻击"></a>闪电贷价格攻击</h1><p>区块链上的资产价格通常被计算为资产之间的当前汇率。例如，如果一个合约目前是1美元兑100个k9币，那么你可以说k9币的价格是0.01美元。然而，价格通常会随着买卖压力的变化而变化，而闪电贷会产生巨大的买卖压力。</p><p>当查询另一个智能合约的资产价格时，开发者需要非常小心，因为他们假设他们所调用的智能合约对闪电贷的操纵是免疫的。</p><h1 id="权力过大的管理员"><a href="#权力过大的管理员" class="headerlink" title="权力过大的管理员"></a>权力过大的管理员</h1><p>仅仅因为一个合约有一个所有者或管理员，这并不意味着他们需要无限权力。</p><blockquote><p>使用Ownable2Step而不是Ownable，这在技术上不是一个漏洞，但<a href="https://www.rareskills.io/post/openzeppelin-ownable2step">OpenZeppelin ownable</a>如果所有权被转移到一个不存在的地址，会导致合约所有权的丧失。Ownable2step要求接收者确认所有权。这可以防止意外地将所有权发送到一个错误的地址。</p></blockquote><h1 id="抢跑（Frontrunning）"><a href="#抢跑（Frontrunning）" class="headerlink" title="抢跑（Frontrunning）"></a>抢跑（Frontrunning）</h1><p>在 Etheruem（和类似的链）的背景下，Frontrunning 意味着观察一个待定的交易，并通过支付更高的 交易成本在它之前执行另一个交易。也就是说，攻击者已经 “跑到了 “交易的前面。如果该交易是一个有利可图的交易，那么除了支付更高的 交易成本，完全复制该交易是有意义的。</p><p>这种现象有时被称为MEV，意思是矿工可提取的价值，但有时在其他情况下是最大可提取的价值。区块生产者有无限的权力来重新排序交易和插入自己的交易，从历史上看，在以太坊进入股权证明之前，区块生产者就是矿工，因此而得名。</p><h1 id="payable-函数导致合约余额更新"><a href="#payable-函数导致合约余额更新" class="headerlink" title="payable 函数导致合约余额更新"></a>payable 函数导致合约余额更新</h1><p>因为当执行函数之前，合约首先是读取交易对象，因此合约的余额会先改变成 原来的余额+msg.value，某些合约可能会未注意合约余额已发生改变，导致漏洞。函数 <code>msg.value &gt;= address(this).balance</code> 永远不可能为真。</p><h1 id="挖矿属性依赖"><a href="#挖矿属性依赖" class="headerlink" title="挖矿属性依赖"></a>挖矿属性依赖</h1><p>合约中有部分内置变量，这些变量会受到矿工的影响，因此不应该把它们当作特定的判断条件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">contract Roulette &#123;</span><br><span class="line">    uint public pastBlockTime;</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        require(msg.value == 10 ether);</span><br><span class="line">        require(block.timestamp != pastBlockTime);</span><br><span class="line">        pastBlockTime = block.timestamp;</span><br><span class="line">        if(block.timestamp % 15 == 0)&#123;//依赖了区块时间戳</span><br><span class="line">        payable(msg.sender).transfer(address(this).balance);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 合约安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链拍</title>
      <link href="/2023/04/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8B%8D/"/>
      <url>/2023/04/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8B%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>该项目是通过truffle与webpack快速搭建的Dapp项目，利用solidity编写的智能合约实现该拍卖系统的逻辑部分，大概流程为上传拍品，进行出价，拍卖时间结束后会进行揭示报价等，结果会由买家卖家和仲裁人三方决定交易是否成功，进行出价未成功的用户通过托管合约退回之前出价金额，主要运用web3.js和ethers.js、truffle和solidity、IPFS其中主要的数据结构有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 商品结构体</span><br><span class="line">   struct Product &#123;</span><br><span class="line">       // 商品ID</span><br><span class="line">       uint256 id;</span><br><span class="line">       // 商品名字</span><br><span class="line">       string name;</span><br><span class="line">       // 商品类别</span><br><span class="line">       string category;</span><br><span class="line">       // 商品图片链接</span><br><span class="line">       string imageLink;</span><br><span class="line">       // 商品描述文本链接</span><br><span class="line">       string descLink;</span><br><span class="line">       // 开始拍卖时间</span><br><span class="line">       uint256 auctionStartTime;</span><br><span class="line">       // 结束拍卖时间</span><br><span class="line">       uint256 auctionEndTime;</span><br><span class="line">       // 起拍价</span><br><span class="line">       uint256 startPrice;</span><br><span class="line">       // 最高出价人地址</span><br><span class="line">       address highestBidder;</span><br><span class="line">       // 最高价</span><br><span class="line">       uint256 highestBid;</span><br><span class="line">       // 第二高出价人出价</span><br><span class="line">       uint256 secondHighestBid;</span><br><span class="line">       // 总共出价</span><br><span class="line">       uint256 totalBids;</span><br><span class="line">       // 商品状态</span><br><span class="line">       ProductStatus status;</span><br><span class="line">       ProductCondition condition;</span><br><span class="line">       // 竞拍人详情</span><br><span class="line">       mapping(address =&gt; mapping(bytes32 =&gt; Bid)) bids;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 竞拍人报价信息</span><br><span class="line">   struct Bid &#123;</span><br><span class="line">       address bidder;</span><br><span class="line">       uint256 productId;</span><br><span class="line">       uint256 value;</span><br><span class="line">       bool revealed;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="内部主要逻辑"><a href="#内部主要逻辑" class="headerlink" title="内部主要逻辑"></a>内部主要逻辑</h2><h3 id="上传拍品"><a href="#上传拍品" class="headerlink" title="上传拍品"></a>上传拍品</h3><p>传入相关参数进行拍品上链，其中利用了订阅监听拍品上链的事件，并将拍品信息保存到数据库中，前端页面显示的时候也是通过查询数据库，这样更高效方便，上传拍品还使用了IPFS进行保存拍品的图片和描述信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">EcommerceStore</span>.<span class="property">events</span>.<span class="title class_">NewProduct</span>(&#123;</span><br><span class="line">      <span class="attr">fromBlock</span>: <span class="string">&#x27;latest&#x27;</span></span><br><span class="line">    &#125;, <span class="keyword">function</span> (<span class="params">error, result</span>) &#123;</span><br><span class="line">      <span class="comment">// 结果包含 非索引参数 以及 主题 topic</span></span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> product = result.<span class="property">returnValues</span>;</span><br><span class="line">      that.<span class="property">fun</span>.<span class="title function_">saveProduct</span>(product);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="讲讲项目中的ipfs？"><a href="#讲讲项目中的ipfs？" class="headerlink" title="讲讲项目中的ipfs？"></a>讲讲项目中的ipfs？</h4><p>通过拍品图片和描述上传到IPFS后接受的返回值(唯一标识符CID)保存到拍品信息中并上链和保存到数据库，查询商品信息是也是通过查询IPFS返回数据来进行展示。</p><h4 id="为什么想到用ipfs（基于内容，gas贵）"><a href="#为什么想到用ipfs（基于内容，gas贵）" class="headerlink" title="为什么想到用ipfs（基于内容，gas贵）"></a>为什么想到用ipfs（基于内容，gas贵）</h4><p>首先在以太坊本身并不直接支持存储大型文件，包括图片的，IPFS也是去中心化的文件系统，防篡改的，它是基于内容寻址，拍品的照片和一些较长的描述信息保存在IPFS还能节省Gas，但目前由于IPFS的关系，可能导致文件丢失，付费购买稳定的IPFS存储</p><h4 id="IPFS"><a href="#IPFS" class="headerlink" title="IPFS"></a>IPFS</h4><p>IPFS的设计目标之一是提供高可用性和冗余性，以减少文件丢失的风险。由于IPFS使用分布式存储的方式，文件会被分散存储在全球网络的多个节点上。这意味着即使某个节点不可用或文件被删除，其他节点仍然可能拥有该文件的副本。</p><h4 id="丢失"><a href="#丢失" class="headerlink" title="丢失"></a>丢失</h4><ol><li>节点离线：如果<strong>存储文件的节点离线并且没有其他节点拥有该文件的副本</strong>，那么该文件将暂时无法访问，直到节点重新上线或其他节点重新存储该文件。</li><li>文件丢失：如果<strong>所有存储文件的节点都意外丢失了该文件</strong>，那么文件可能无法找回。</li><li>不活跃的文件：IPFS使用内容寻址，文件的标识是基于其内容的哈希值。如果<strong>某个文件在网络中不活跃（即没有被频繁访问或传输）</strong>，那么<strong>可能会存在较少的节点存储该文件，增加了文件丢失的风险。</strong></li></ol><h3 id="出价"><a href="#出价" class="headerlink" title="出价"></a>出价</h3><p>出价的时候会有一个输入出价价格和实际出价价格，如果出价&lt;实际出价则出价失败，在揭示报价时会回退出价，但可以迷惑别的竞拍选手，因为出价也是上链所有人可以查到，其中还需要输入一个密文，在揭示报价也需要这个密文</p><h3 id="揭示报价"><a href="#揭示报价" class="headerlink" title="揭示报价"></a>揭示报价</h3><p>输入密文进行揭示，到拍品结束结束都可以进行，其中未及时揭示报价的用户会退还之前的报价</p><h3 id="托管合约"><a href="#托管合约" class="headerlink" title="托管合约"></a>托管合约</h3><p>创建一个 Multisig Escrow（多重签名托管）合约，里面存放了了买方赢得拍卖的数量，买方，卖方和一个任意的第三方是参与者。托管的资金只能被释放给卖方，或是返回给买方，并且至少需要三个参与者中的两个同意才能执行。</p><p>在接下来的几节，我们将会实现托管合约，并当拍卖结束时，在运行时添加创建一个以太坊托管合约的功能。</p><h2 id="升级插件"><a href="#升级插件" class="headerlink" title="升级插件"></a>升级插件</h2><p>使用的是OpenZeppelin升级插件，在部署一个可升级的智能合约时实际上部署了三个合约： </p><ol><li>您编写的合约，称为包含逻辑的实施合约。</li><li>ProxyAdmin是代理的管理员。</li><li>执行合同的代理，这是您实际与之交互的合同。</li></ol><p>在这里 ，代理是一个简单的协定，它只是<strong>将所有调用委托给实现协定</strong>。 委托调用类似于常规调用，不同之处在于<strong>所有代码都在调用方的上下文中执行，而不是在被调用方的上下文中执行</strong>。正因为如此，一个  <code>transfer</code>在实现合约的代码中，实际上将传输代理的余额，对合约存储的任何读取或写入都将从代理自己的存储中读取或写入。 </p><p>这允许我们将 <strong>合约的状态和代码解耦</strong> ：代理保存状态，而实现合约提供代码。智能合约的任何用户始终与代理交互， <strong>代理永远不会更改其地址</strong> 。这允许您推出升级或修复错误，而无需要求用户更改任何内容 - 他们只是一如既往地与相同的地址进行交互。 </p>]]></content>
      
      
      <categories>
          
          <category> 区块链项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比特币简易版方法</title>
      <link href="/2023/04/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/%E6%AF%94%E7%89%B9%E5%B8%81%E7%AE%80%E6%98%93%E7%89%88%E6%96%B9%E6%B3%95/"/>
      <url>/2023/04/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/%E6%AF%94%E7%89%B9%E5%B8%81%E7%AE%80%E6%98%93%E7%89%88%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="基本原型"><a href="#基本原型" class="headerlink" title="基本原型"></a>基本原型</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区块</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">Timestamp     <span class="type">int64</span>          <span class="comment">//时间戳</span></span><br><span class="line">Transactions  []*Transaction <span class="comment">//存储交易</span></span><br><span class="line">PrevBlockHash []<span class="type">byte</span>         <span class="comment">//前面区块的哈希值</span></span><br><span class="line">Hash          []<span class="type">byte</span>         <span class="comment">//哈希值</span></span><br><span class="line">Nonce         <span class="type">int</span>            <span class="comment">//用于找到pow</span></span><br><span class="line">Height        <span class="type">int</span>            <span class="comment">//区块高度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(transactions []*Transaction, prevBlockHash []<span class="type">byte</span>, height <span class="type">int</span>)</span></span> *Block &#123;</span><br><span class="line">   <span class="comment">//新建一个区块</span></span><br><span class="line">   block := &amp;Block&#123;time.Now().Unix(), transactions, prevBlockHash, []<span class="type">byte</span>&#123;&#125;, <span class="number">0</span>, height&#125;</span><br><span class="line">   <span class="comment">//计算nonce来符合pow共识</span></span><br><span class="line">   pow := NewProofOfWork(block)</span><br><span class="line">   nonce, hash := pow.Run()</span><br><span class="line">   block.Hash = hash[:]</span><br><span class="line">   block.Nonce = nonce</span><br><span class="line">   <span class="keyword">return</span> block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区块链</span></span><br><span class="line"><span class="keyword">type</span> Blockchain <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//数据库中存储的最后一个块的哈希</span></span><br><span class="line">   tip []<span class="type">byte</span></span><br><span class="line">   db  *bolt.DB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *Blockchain)</span></span> MineBlock(transactions []*Transaction) *Block &#123;</span><br><span class="line"><span class="keyword">var</span> lastHash []<span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> lastHeight <span class="type">int</span></span><br><span class="line"><span class="comment">//在一笔交易被放入一个块之前进行验证</span></span><br><span class="line"><span class="keyword">for</span> _, tx := <span class="keyword">range</span> transactions &#123;</span><br><span class="line"><span class="keyword">if</span> bc.VerifyTransaction(tx) != <span class="literal">true</span> &#123;</span><br><span class="line">log.Panic(<span class="string">&quot;ERROR:Invalid transaction&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取最后一个块的哈希</span></span><br><span class="line">bc.db.View(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">b := tx.Bucket([]<span class="type">byte</span>(blocksBucket))</span><br><span class="line">lastHash = b.Get([]<span class="type">byte</span>(<span class="string">&quot;l&quot;</span>))</span><br><span class="line">blockData := b.Get(lastHash)</span><br><span class="line">block := DeserializeBlock(blockData)</span><br><span class="line">lastHeight = block.Height</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//挖出一个新的块</span></span><br><span class="line">newBlock := NewBlock(transactions, lastHash, lastHeight+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//修改区块链的数据</span></span><br><span class="line">bc.db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">b := tx.Bucket([]<span class="type">byte</span>(blocksBucket))</span><br><span class="line">b.Put(newBlock.Hash, newBlock.Serialize())</span><br><span class="line">b.Put([]<span class="type">byte</span>(<span class="string">&quot;l&quot;</span>), newBlock.Hash)</span><br><span class="line">bc.tip = newBlock.Hash</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> newBlock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环直到符合pow证明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pow *ProofOfWork)</span></span> Run() (<span class="type">int</span>, []<span class="type">byte</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> hashInt big.Int</span><br><span class="line"><span class="keyword">var</span> hash [<span class="number">32</span>]<span class="type">byte</span></span><br><span class="line">nonce := <span class="number">0</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Mining the block containing&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> nonce &lt; maxNonce &#123;</span><br><span class="line">data := pow.prepareData(nonce)</span><br><span class="line">hash = sha256.Sum256(data)</span><br><span class="line"><span class="keyword">if</span> math.Remainder(<span class="type">float64</span>(nonce), <span class="number">100000</span>) == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;\r%x&quot;</span>, hash)</span><br><span class="line">&#125;</span><br><span class="line">hashInt.SetBytes(hash[:])</span><br><span class="line">        <span class="comment">//符合要求</span></span><br><span class="line"><span class="keyword">if</span> hashInt.Cmp(pow.target) == <span class="number">-1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;\r%x&quot;</span>, hash)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">nonce++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;\n\n&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> nonce, hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="持久化和命令行接口"><a href="#持久化和命令行接口" class="headerlink" title="持久化和命令行接口"></a>持久化和命令行接口</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line"><span class="comment">//定义一个 buffer 存储序列化之后的数据。然后，我们初始化一个 gob encoder 并对 block 进行编码，结果作为一个字节数组返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> Serialize() []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="comment">//Buffer是一个实现了读写方法的可变大小的字节缓冲</span></span><br><span class="line"><span class="keyword">var</span> result bytes.Buffer</span><br><span class="line"><span class="comment">//NewEncoder返回一个将编码后数据写入result的*Encoder</span></span><br><span class="line">encoder := gob.NewEncoder(&amp;result)</span><br><span class="line"><span class="comment">//Encode方法将b编码后发送，并且会保证所有的类型信息都先发送</span></span><br><span class="line">encoder.Encode(b)</span><br><span class="line"><span class="comment">//返回未读取部分字节数据的切片</span></span><br><span class="line"><span class="keyword">return</span> result.Bytes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeserializeBlock</span><span class="params">(d []<span class="type">byte</span>)</span></span> *Block &#123;</span><br><span class="line"><span class="keyword">var</span> block Block</span><br><span class="line"><span class="comment">//函数返回一个从r读取数据的*Decoder，如果r不满足io.ByteReader接口，则会包装r为bufio.Reader。</span></span><br><span class="line">decoder := gob.NewDecoder(bytes.NewReader(d))</span><br><span class="line"><span class="comment">//Decode从输入流读取下一个之并将该值存入&amp;block</span></span><br><span class="line">decoder.Decode(&amp;block)</span><br><span class="line"><span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建区块链</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlockchain</span><span class="params">()</span></span> *Blockchain &#123;</span><br><span class="line"><span class="keyword">var</span> tip []<span class="type">byte</span></span><br><span class="line">    <span class="comment">//打开一个 BoltDB 文件</span></span><br><span class="line">db, err := bolt.Open(dbFile, <span class="number">0600</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">//先获取了存储区块的 bucket：如果存在，就从中读取 l 键</span></span><br><span class="line">err = db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">b := tx.Bucket([]<span class="type">byte</span>(blocksBucket))</span><br><span class="line">        <span class="comment">//如果不存在，就生成创世块，创建 bucket，并将区块保存到里面，然后更新 l 键以存储链中最后一个块的哈希。</span></span><br><span class="line"><span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">genesis := NewGenesisBlock()</span><br><span class="line">b, err := tx.CreateBucket([]<span class="type">byte</span>(blocksBucket))</span><br><span class="line">err = b.Put(genesis.Hash, genesis.Serialize())</span><br><span class="line">err = b.Put([]<span class="type">byte</span>(<span class="string">&quot;l&quot;</span>), genesis.Hash)</span><br><span class="line">tip = genesis.Hash</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tip = b.Get([]<span class="type">byte</span>(<span class="string">&quot;l&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">bc := Blockchain&#123;tip, db&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;bc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个新的、名为getbalance，采用flag.ExitOnError为错误处理策略的FlagSet。</span></span><br><span class="line">getBalanceCmd := flag.NewFlagSet(<span class="string">&quot;getbalance&quot;</span>, flag.ExitOnError)</span><br><span class="line"><span class="comment">//String用指定的名称、默认值、使用信息注册一个string类型flag。返回一个保存了该flag的值的指针。</span></span><br><span class="line">getBalanceAddress := getBalanceCmd.String(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;The address to get balance for&quot;</span>)</span><br><span class="line"><span class="comment">//通过switch os.Args[1] case --- 判断命令行以及参数是否错误</span></span><br><span class="line"><span class="comment">//通过传入*getBalanceAddress，以及nodeID进行方法调用</span></span><br><span class="line">cli.getBalance(*getBalanceAddress, nodeID)</span><br></pre></td></tr></table></figure><h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//账户</span></span><br><span class="line"><span class="keyword">type</span> Wallet <span class="keyword">struct</span> &#123;</span><br><span class="line">PrivateKey ecdsa.PrivateKey</span><br><span class="line">PublicKey  []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//q</span></span><br><span class="line"><span class="keyword">type</span> Wallets <span class="keyword">struct</span> &#123;</span><br><span class="line">Wallets <span class="keyword">map</span>[<span class="type">string</span>]*Wallet</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个账户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWallet</span><span class="params">()</span></span> *Wallet &#123;</span><br><span class="line">private, public := newKeyPair()</span><br><span class="line">wallet := Wallet&#123;private, public&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;wallet</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newKeyPair</span><span class="params">()</span></span> (ecdsa.PrivateKey, []<span class="type">byte</span>) &#123;</span><br><span class="line"><span class="comment">//返回一个实现了P-256的曲线</span></span><br><span class="line">    curve := elliptic.P256()</span><br><span class="line">    <span class="comment">//GenerateKey函数生成一对</span></span><br><span class="line">    private, _ := ecdsa.GenerateKey(curve, rand.Reader)</span><br><span class="line">    pubKey := <span class="built_in">append</span>(private.PublicKey.X.Bytes(), private.PublicKey.Y.Bytes()...)</span><br><span class="line">    <span class="keyword">return</span> *private, pubKey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取钱包地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Wallet)</span></span> GetAddress() []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="comment">//使用 RIPEMD160(SHA256(PubKey)) 哈希算法</span></span><br><span class="line">pubKeyHash := HashPubKey(w.PublicKey)</span><br><span class="line"><span class="comment">//给哈希加上地址生成算法版本的前缀</span></span><br><span class="line">versionedPayload := <span class="built_in">append</span>([]<span class="type">byte</span>&#123;version_w&#125;, pubKeyHash...)</span><br><span class="line"><span class="comment">//计算校验和</span></span><br><span class="line">checksum := checksum(versionedPayload)</span><br><span class="line">fullPayload := <span class="built_in">append</span>(versionedPayload, checksum...)</span><br><span class="line"><span class="comment">//使用 Base58 对组合进行编码</span></span><br><span class="line">address := Base58Encode(fullPayload)</span><br><span class="line"><span class="keyword">return</span> address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对公钥取哈希</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HashPubKey</span><span class="params">(pubKey []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">publicSHA256 := sha256.Sum256(pubKey)</span><br><span class="line">RIPEMD160Hasher := ripemd160.New()</span><br><span class="line">RIPEMD160Hasher.Write(publicSHA256[:])</span><br><span class="line">publicRIPEMD160 := RIPEMD160Hasher.Sum(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span> publicRIPEMD160</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算校验和(校验和是结果哈希的前四个字节)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checksum</span><span class="params">(payload []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">firstSHA := sha256.Sum256(payload)</span><br><span class="line">secondSHA := sha256.Sum256(firstSHA[:])</span><br><span class="line"><span class="keyword">return</span> secondSHA[:addressChecksumLen]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用私钥对任意长度的hash值（必须是较大信息的hash结果）进行签名，返回签名结果(一对大整数)</span></span><br><span class="line"><span class="comment">//Reader是一个全局、共享的密码用强随机数生成器---私钥---交易副本</span></span><br><span class="line">r, s, err := ecdsa.Sign(rand.Reader, &amp;privKey, []<span class="type">byte</span>(dataToSign))</span><br><span class="line">signature := <span class="built_in">append</span>(r.Bytes(), s.Bytes()...)</span><br><span class="line">tx.Vin[inID].Signature = signature</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用公钥验证hash值和两个大整数r、s构成的签名，并返回签名是否合法。</span></span><br><span class="line">rawPubKey := ecdsa.PublicKey&#123;curve, &amp;x, &amp;y&#125;</span><br><span class="line"><span class="comment">//交易副本</span></span><br><span class="line">ecdsa.Verify(&amp;rawPubKey, []<span class="type">byte</span>(dataToVerify), &amp;r, &amp;s)==<span class="literal">true</span>?</span><br></pre></td></tr></table></figure><h1 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交易</span></span><br><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">   ID   []<span class="type">byte</span><span class="comment">//交易ID</span></span><br><span class="line">   Vin  []TXInput<span class="comment">//输入脚本数组</span></span><br><span class="line">   Vout []TXOutput<span class="comment">//输出脚本数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TXInput <span class="keyword">struct</span> &#123;</span><br><span class="line">Txid      []<span class="type">byte</span><span class="comment">//一个交易输入引用了之前一笔交易的一个输出, ID表明是之前哪笔交易</span></span><br><span class="line">Vout      <span class="type">int</span><span class="comment">//对应哪个输出</span></span><br><span class="line">Signature []<span class="type">byte</span><span class="comment">//签名数据</span></span><br><span class="line">PubKey    []<span class="type">byte</span><span class="comment">//公钥</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TXOutput <span class="keyword">struct</span> &#123;</span><br><span class="line">Value      <span class="type">int</span>      <span class="comment">//有多少币</span></span><br><span class="line">PubKeyHash []<span class="type">byte</span><span class="comment">//锁定脚本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一笔新的交易</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUTXOTransaction</span><span class="params">(wallet *Wallet, to <span class="type">string</span>, amount <span class="type">int</span>, UTXOSet *UTXOSet)</span></span> *Transaction &#123;</span><br><span class="line"><span class="keyword">var</span> inputs []TXInput</span><br><span class="line"><span class="keyword">var</span> outputs []TXOutput</span><br><span class="line"><span class="comment">//获取from地址的公钥的hash</span></span><br><span class="line">pubKeyHash := HashPubKey(wallet.PublicKey)</span><br><span class="line"><span class="comment">//找到至少 amount 的 UTXO</span></span><br><span class="line">acc, vaildOutputs := UTXOSet.FindSpendableOutputs(pubKeyHash, amount)</span><br><span class="line"><span class="comment">//不足够支付</span></span><br><span class="line"><span class="keyword">if</span> acc &lt; amount &#123;</span><br><span class="line">log.Panic(<span class="string">&quot;ERROR:Not enough funds&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//足够支付(遍历含有from地址输出的交易)</span></span><br><span class="line"><span class="keyword">for</span> txid, outs := <span class="keyword">range</span> vaildOutputs &#123;</span><br><span class="line">txID, _ := hex.DecodeString(txid)</span><br><span class="line"><span class="keyword">for</span> _, out := <span class="keyword">range</span> outs &#123;</span><br><span class="line"><span class="comment">//存入到这笔交易的输入里</span></span><br><span class="line">input := TXInput&#123;txID, out, <span class="literal">nil</span>, wallet.PublicKey&#125;</span><br><span class="line">inputs = <span class="built_in">append</span>(inputs, input)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">from := fmt.Sprintf(<span class="string">&quot;%s&quot;</span>, wallet.GetAddress())</span><br><span class="line">outputs = <span class="built_in">append</span>(outputs, *NewTXOutput(amount, to))</span><br><span class="line">    <span class="comment">//余额大于转账金额</span></span><br><span class="line"><span class="keyword">if</span> acc &gt; amount &#123;</span><br><span class="line">outputs = <span class="built_in">append</span>(outputs, *NewTXOutput(acc-amount, from))</span><br><span class="line">&#125;</span><br><span class="line">tx := Transaction&#123;<span class="literal">nil</span>, inputs, outputs&#125;</span><br><span class="line">tx.ID = tx.Hash()</span><br><span class="line"><span class="comment">//签名交易</span></span><br><span class="line">UTXOSet.Blockchain.SignTransaction(&amp;tx, wallet.PrivateKey)</span><br><span class="line"><span class="keyword">return</span> &amp;tx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UTXO"><a href="#UTXO" class="headerlink" title="UTXO"></a>UTXO</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 address 中找到至少 amount 的 UTXO</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UTXOSet)</span></span> FindSpendableOutputs(pubkeyHash []<span class="type">byte</span>, amount <span class="type">int</span>) (<span class="type">int</span>, <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span>) &#123;</span><br><span class="line">unspentOutputs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span>)</span><br><span class="line">accumulated := <span class="number">0</span></span><br><span class="line">db := u.Blockchain.db</span><br><span class="line">db.View(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">b := tx.Bucket([]<span class="type">byte</span>(utxoBucket))</span><br><span class="line">c := b.Cursor()</span><br><span class="line"><span class="keyword">for</span> k, v := c.First(); k != <span class="literal">nil</span>; k, v = c.Next() &#123;</span><br><span class="line">txID := hex.EncodeToString(k)</span><br><span class="line">outs := DeserializeOutputs(v)</span><br><span class="line"><span class="keyword">for</span> outIdx, out := <span class="keyword">range</span> outs.Outputs &#123;</span><br><span class="line">                <span class="comment">//如果该交易输出可以被解锁，即可被花费</span></span><br><span class="line"><span class="keyword">if</span> out.IsLockedWithKey(pubkeyHash) &amp;&amp; accumulated &lt; amount &#123;</span><br><span class="line">accumulated += out.Value</span><br><span class="line">unspentOutputs[txID] = <span class="built_in">append</span>(unspentOutputs[txID], outIdx)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> accumulated, unspentOutputs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找并返回所有未使用的交易输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UTXOSet)</span></span> FindUTXO(pubKeyHash []<span class="type">byte</span>) []TXOutput &#123;</span><br><span class="line"><span class="keyword">var</span> UTXOs []TXOutput</span><br><span class="line">db := u.Blockchain.db</span><br><span class="line">db.View(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">b := tx.Bucket([]<span class="type">byte</span>(utxoBucket))</span><br><span class="line">c := b.Cursor()</span><br><span class="line"><span class="keyword">for</span> k, v := c.First(); k != <span class="literal">nil</span>; k, v = c.Next() &#123;</span><br><span class="line">outs := DeserializeOutputs(v)</span><br><span class="line"><span class="keyword">for</span> _, out := <span class="keyword">range</span> outs.Outputs &#123;</span><br><span class="line">                <span class="comment">//如果该交易输出可以被解锁，即可被花费</span></span><br><span class="line"><span class="keyword">if</span> out.IsLockedWithKey(pubKeyHash) &#123;</span><br><span class="line">UTXOs = <span class="built_in">append</span>(UTXOs, out)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> UTXOs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当有区块被挖出需要更新UTXO集</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UTXOSet)</span></span> Update(block *Block) &#123;</span><br><span class="line">db := u.Blockchain.db</span><br><span class="line">db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">b := tx.Bucket([]<span class="type">byte</span>(utxoBucket))</span><br><span class="line"><span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Transactions &#123;</span><br><span class="line"><span class="keyword">if</span> tx.IsCoinbase() == <span class="literal">false</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, vin := <span class="keyword">range</span> tx.Vin &#123;</span><br><span class="line">updateOuts := TXOutputs&#123;&#125;</span><br><span class="line">                    <span class="comment">//获取输入交易</span></span><br><span class="line">outsBytes := b.Get(vin.Txid)</span><br><span class="line">                    <span class="comment">//找到输入交易的输出交易数组</span></span><br><span class="line">outs := DeserializeOutputs(outsBytes)</span><br><span class="line"><span class="keyword">for</span> outIdx, out := <span class="keyword">range</span> outs.Outputs &#123;</span><br><span class="line"><span class="keyword">if</span> outIdx != vin.Vout &#123;</span><br><span class="line">updateOuts.Outputs = <span class="built_in">append</span>(updateOuts.Outputs, out)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">                    <span class="comment">//移除已花费输出(覆盖)</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(updateOuts.Outputs) == <span class="number">0</span> &#123;</span><br><span class="line">b.Delete(vin.Txid)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">b.Put(vin.Txid, updateOuts.Serialize())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">newOutputs := TXOutputs&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, out := <span class="keyword">range</span> tx.Vout &#123;</span><br><span class="line">newOutputs.Outputs = <span class="built_in">append</span>(newOutputs.Outputs, out)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从新挖出来的交易中加入未花费输出</span></span><br><span class="line">b.Put(tx.ID, newOutputs.Serialize())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Merkle-树"><a href="#Merkle-树" class="headerlink" title="Merkle 树"></a>Merkle 树</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Merkle树</span></span><br><span class="line"><span class="keyword">type</span> MerkleTree <span class="keyword">struct</span> &#123;</span><br><span class="line">RootNode *MerkleNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="keyword">type</span> MerkleNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Left  *MerkleNode</span><br><span class="line">Right *MerkleNode</span><br><span class="line">Data  []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个新的结点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMerkleNode</span><span class="params">(left, right *MerkleNode, data []<span class="type">byte</span>)</span></span> *MerkleNode &#123;</span><br><span class="line">mNode := MerkleNode&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> left == <span class="literal">nil</span> &amp;&amp; right == <span class="literal">nil</span> &#123;</span><br><span class="line">hash := sha256.Sum256(data)</span><br><span class="line">mNode.Data = hash[:]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">prevHashes := <span class="built_in">append</span>(left.Data, right.Data...)</span><br><span class="line">hash := sha256.Sum256(prevHashes)</span><br><span class="line">mNode.Data = hash[:]</span><br><span class="line">&#125;</span><br><span class="line">mNode.Left = left</span><br><span class="line">mNode.Right = right</span><br><span class="line"><span class="keyword">return</span> &amp;mNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMerkleTree</span><span class="params">(data [][]<span class="type">byte</span>)</span></span> *MerkleTree &#123;</span><br><span class="line"><span class="keyword">var</span> nodes []MerkleNode</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(data)%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">data = <span class="built_in">append</span>(data, data[<span class="built_in">len</span>(data)<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, datum := <span class="keyword">range</span> data &#123;</span><br><span class="line">node := NewMerkleNode(<span class="literal">nil</span>, <span class="literal">nil</span>, datum)</span><br><span class="line">nodes = <span class="built_in">append</span>(nodes, *node)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data)/<span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">var</span> newLevel []MerkleNode</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(nodes); j += <span class="number">2</span> &#123;</span><br><span class="line">node := NewMerkleNode(&amp;nodes[j], &amp;nodes[j+<span class="number">1</span>], <span class="literal">nil</span>)</span><br><span class="line">newLevel = <span class="built_in">append</span>(newLevel, *node)</span><br><span class="line">&#125;</span><br><span class="line">nodes = newLevel</span><br><span class="line">&#125;</span><br><span class="line">mTree := MerkleTree&#123;&amp;nodes[<span class="number">0</span>]&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;mTree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> version <span class="keyword">struct</span> &#123;</span><br><span class="line">    Version    <span class="type">int</span></span><br><span class="line">    BestHeight <span class="type">int</span><span class="comment">//区块链中节点的高度</span></span><br><span class="line">    AddrFrom   <span class="type">string</span><span class="comment">//发送者的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>version</code> 用于找到一个更长的区块链。当一个节点接收到 <code>version</code> 消息，它会检查本节点的区块链是否比 <code>BestHeight</code> 的值更大。<strong>如果不是，节点就会请求并下载缺失的块。</strong>为了接收消息，我们需要一个服务器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeAddress <span class="type">string</span></span><br><span class="line"><span class="comment">//对中心节点的地址进行硬编码</span></span><br><span class="line"><span class="keyword">var</span> knownNodes = []<span class="type">string</span>&#123;<span class="string">&quot;localhost:3000&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartServer</span><span class="params">(nodeID, minerAddress <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    nodeAddress = fmt.Sprintf(<span class="string">&quot;localhost:%s&quot;</span>, nodeID)</span><br><span class="line">    miningAddress = minerAddress</span><br><span class="line">    ln, err := net.Listen(protocol, nodeAddress)</span><br><span class="line">    <span class="keyword">defer</span> ln.Close()</span><br><span class="line">    bc := NewBlockchain(nodeID)</span><br><span class="line">    <span class="keyword">if</span> nodeAddress != knownNodes[<span class="number">0</span>] &#123;</span><br><span class="line">        <span class="comment">//向中心节点发送 version 消息来查询是否自己的区块链已过时。</span></span><br><span class="line">        sendVersion(knownNodes[<span class="number">0</span>], bc)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := ln.Accept()</span><br><span class="line">        <span class="keyword">go</span> handleConnection(conn, bc)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个节点接收到一个命令，它会运行 <code>bytesToCommand</code> 来提取命令名，并选择正确的处理器处理命令主体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConnection</span><span class="params">(conn net.Conn, bc *Blockchain)</span></span> &#123;</span><br><span class="line">    request, err := ioutil.ReadAll(conn)</span><br><span class="line">    command := bytesToCommand(request[:commandLength])</span><br><span class="line">    <span class="keyword">switch</span> command &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;version&quot;</span>:</span><br><span class="line">        handleVersion(request, bc)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Unknown command!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    conn.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 <code>version</code> 命令处理器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleVersion</span><span class="params">(request []<span class="type">byte</span>, bc *Blockchain)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buff bytes.Buffer</span><br><span class="line">    <span class="keyword">var</span> payload verzion</span><br><span class="line"></span><br><span class="line">    buff.Write(request[commandLength:])</span><br><span class="line">    dec := gob.NewDecoder(&amp;buff)</span><br><span class="line">    err := dec.Decode(&amp;payload)</span><br><span class="line"></span><br><span class="line">    myBestHeight := bc.GetBestHeight()</span><br><span class="line">    foreignerBestHeight := payload.BestHeight</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> myBestHeight &lt; foreignerBestHeight &#123;</span><br><span class="line">        sendGetBlocks(payload.AddrFrom)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> myBestHeight &gt; foreignerBestHeight &#123;</span><br><span class="line">        sendVersion(payload.AddrFrom, bc)</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们需要对请求进行解码，提取有效信息。所有的处理器在这部分都类似，所以我们会下面的代码片段中略去这部分。</p><p>然后节点将从消息中提取的 <code>BestHeight</code> 与自身进行比较。如果自身节点的区块链更长，它会回复 <code>version</code> 消息；否则，它会发送 <code>getblocks</code> 消息。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比特币简易版</title>
      <link href="/2023/04/03/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/%E6%AF%94%E7%89%B9%E5%B8%81%E7%AE%80%E6%98%93%E7%89%88/"/>
      <url>/2023/04/03/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/%E6%AF%94%E7%89%B9%E5%B8%81%E7%AE%80%E6%98%93%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//区块</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">   Timestamp     <span class="type">int64</span>          <span class="comment">//时间戳</span></span><br><span class="line">   Transactions  []*Transaction <span class="comment">//存储交易</span></span><br><span class="line">   PrevBlockHash []<span class="type">byte</span>         <span class="comment">//前面区块的哈希值</span></span><br><span class="line">   Hash          []<span class="type">byte</span>         <span class="comment">//哈希值</span></span><br><span class="line">   Nonce         <span class="type">int</span>            <span class="comment">//用于找到pow</span></span><br><span class="line">   Height        <span class="type">int</span>            <span class="comment">//区块高度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h1><p>定义了挖矿难度，在准备完除了区块哈希和nonce值时，将该区块所有数据与nonce值一起通过bytes.Join()方法返回的[]byte并进行SHA256哈希算法，循环nonce直到找到一个符合挖矿难度的nonce值，然后将哈希值和nonce值赋值给区块然后添加到链上</p><h1 id="持久化和命令行接口"><a href="#持久化和命令行接口" class="headerlink" title="持久化和命令行接口"></a>持久化和命令行接口</h1><h2 id="BoltDB"><a href="#BoltDB" class="headerlink" title="BoltDB"></a>BoltDB</h2><p>因为它：非常简洁、用 Go 实现、不需要运行一个服务器、能够允许我们构造想要的数据结构</p><p>Bolt 使用键值存储，键值对被存储在 bucket 中，为了获取一个值，你需要知道一个 bucket 和一个键（key）。</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>在 BoltDB 中，值只能是 <code>[]byte</code> 类型，但是我们想要存储 <code>Block</code> 结构。所以，我们需要使用 <a href="https://golang.org/pkg/encoding/gob/">encoding&#x2F;gob</a> 来对这些结构进行序列化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个 buffer 存储序列化之后的数据。然后，我们初始化一个 gob encoder 并对 block 进行编码，结果作为一个字节数组返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> Serialize() []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="comment">//Buffer是一个实现了读写方法的可变大小的字节缓冲</span></span><br><span class="line"><span class="keyword">var</span> result bytes.Buffer</span><br><span class="line"><span class="comment">//NewEncoder返回一个将编码后数据写入result的*Encoder</span></span><br><span class="line">encoder := gob.NewEncoder(&amp;result)</span><br><span class="line"><span class="comment">//Encode方法将b编码后发送，并且会保证所有的类型信息都先发送</span></span><br><span class="line">encoder.Encode(b)</span><br><span class="line"><span class="comment">//返回未读取部分字节数据的切片</span></span><br><span class="line"><span class="keyword">return</span> result.Bytes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeserializeBlock</span><span class="params">(d []<span class="type">byte</span>)</span></span> *Block &#123;</span><br><span class="line"><span class="keyword">var</span> block Block</span><br><span class="line"><span class="comment">//函数返回一个从r读取数据的*Decoder，如果r不满足io.ByteReader接口，则会包装r为bufio.Reader。</span></span><br><span class="line">decoder := gob.NewDecoder(bytes.NewReader(d))</span><br><span class="line"><span class="comment">//Decode从输入流读取下一个之并将该值存入&amp;block</span></span><br><span class="line">decoder.Decode(&amp;block)</span><br><span class="line"><span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>将所有的区块以键值对(区块哈希—序列化的区块数据)的形式保存到BoltDB中，以及一个最新区块的哈希保存到BoltDB中</p><h2 id="命令行接口"><a href="#命令行接口" class="headerlink" title="命令行接口"></a>命令行接口</h2><p>使用flag包实现命令行接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个新的、名为getbalance，采用flag.ExitOnError为错误处理策略的FlagSet。</span></span><br><span class="line">getBalanceCmd := flag.NewFlagSet(<span class="string">&quot;getbalance&quot;</span>, flag.ExitOnError)</span><br><span class="line"><span class="comment">//String用指定的名称、默认值、使用信息注册一个string类型flag。返回一个保存了该flag的值的指针。</span></span><br><span class="line">getBalanceAddress := getBalanceCmd.String(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;The address to get balance for&quot;</span>)</span><br><span class="line"><span class="comment">//通过switch os.Args[1] case --- 判断命令行以及参数是否错误</span></span><br><span class="line"><span class="comment">//通过传入*getBalanceAddress，以及nodeID进行方法调用</span></span><br><span class="line">cli.getBalance(*getBalanceAddress, nodeID)</span><br></pre></td></tr></table></figure><h1 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交易</span></span><br><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">   ID   []<span class="type">byte</span><span class="comment">//交易ID</span></span><br><span class="line">   Vin  []TXInput<span class="comment">//输入脚本数组</span></span><br><span class="line">   Vout []TXOutput<span class="comment">//输出脚本数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TXInput <span class="keyword">struct</span> &#123;</span><br><span class="line">Txid      []<span class="type">byte</span><span class="comment">//一个交易输入引用了之前一笔交易的一个输出, ID表明是之前哪笔交易</span></span><br><span class="line">Vout      <span class="type">int</span><span class="comment">//对应哪个输出</span></span><br><span class="line">Signature []<span class="type">byte</span><span class="comment">//签名数据</span></span><br><span class="line">PubKey    []<span class="type">byte</span><span class="comment">//公钥</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TXOutput <span class="keyword">struct</span> &#123;</span><br><span class="line">Value      <span class="type">int</span>      <span class="comment">//有多少币</span></span><br><span class="line">PubKeyHash []<span class="type">byte</span><span class="comment">//锁定脚本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 账户</span></span><br><span class="line"><span class="keyword">type</span> Wallet <span class="keyword">struct</span> &#123;</span><br><span class="line">PrivateKey ecdsa.PrivateKey  <span class="comment">//ecdsa.PrivateKey代表一个ECDSA私钥</span></span><br><span class="line">PublicKey  []<span class="type">byte</span> <span class="comment">//公钥</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用椭圆曲线加密生成公钥和私钥，利用ECDSA算法对交易签名，利用Base58转换公钥给地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个实现了P-256的曲线</span></span><br><span class="line">curve := elliptic.P256()</span><br><span class="line"><span class="comment">//GenerateKey函数生成一对</span></span><br><span class="line">private, _ := ecdsa.GenerateKey(curve, rand.Reader)</span><br><span class="line">pubKey := <span class="built_in">append</span>(private.PublicKey.X.Bytes(), private.PublicKey.Y.Bytes()...)</span><br><span class="line"><span class="keyword">return</span> *private, pubKey</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用私钥对任意长度的hash值（必须是较大信息的hash结果）进行签名，返回签名结果(一对大整数)</span></span><br><span class="line"><span class="comment">//Reader是一个全局、共享的密码用强随机数生成器---私钥---交易副本</span></span><br><span class="line">r, s, err := ecdsa.Sign(rand.Reader, &amp;privKey, []<span class="type">byte</span>(dataToSign))</span><br><span class="line">signature := <span class="built_in">append</span>(r.Bytes(), s.Bytes()...)</span><br><span class="line">tx.Vin[inID].Signature = signature</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用公钥验证hash值和两个大整数r、s构成的签名，并返回签名是否合法。</span></span><br><span class="line">rawPubKey := ecdsa.PublicKey&#123;curve, &amp;x, &amp;y&#125;</span><br><span class="line"><span class="comment">//交易副本</span></span><br><span class="line">ecdsa.Verify(&amp;rawPubKey, []<span class="type">byte</span>(dataToVerify), &amp;r, &amp;s)</span><br></pre></td></tr></table></figure><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>首先定位到某条区块链，启动服务时判断是否为中心节点，若不是则向中心节点发送同步区块消息，下载缺失的块进行同步，每个结点有自己的数据库文件，每次收到命令时</p>]]></content>
      
      
      <categories>
          
          <category> 区块链项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>掌上钱包</title>
      <link href="/2023/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/%E6%8E%8C%E4%B8%8A%E9%92%B1%E5%8C%85/"/>
      <url>/2023/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/%E6%8E%8C%E4%B8%8A%E9%92%B1%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="通过-助记词-path-私钥方式-加密的JSON钱包-绑定账号"><a href="#通过-助记词-path-私钥方式-加密的JSON钱包-绑定账号" class="headerlink" title="通过 **助记词+(path) &#x2F; 私钥方式 &#x2F; 加密的JSON钱包 **绑定账号"></a>通过 **助记词+(path) &#x2F; 私钥方式 &#x2F; 加密的JSON钱包 **绑定账号</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> privateKey = <span class="string">&#x27;YOUR_PRIVATE_KEY&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.<span class="property">providers</span>.<span class="title class_">JsonRpcProvider</span>(<span class="string">&#x27;https://polygon-rpc.com&#x27;</span>);</span><br><span class="line"><span class="comment">// 使用私钥创建钱包</span></span><br><span class="line"><span class="keyword">const</span> wallet = <span class="keyword">new</span> ethers.<span class="title class_">Wallet</span>(privateKey, provider);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mnemonic = <span class="string">&#x27;YOUR_MNEMONIC&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.<span class="property">providers</span>.<span class="title class_">JsonRpcProvider</span>(<span class="string">&#x27;https://polygon-rpc.com&#x27;</span>);</span><br><span class="line"><span class="comment">// 使用助记词创建钱包</span></span><br><span class="line"><span class="keyword">const</span> wallet = ethers.<span class="property">Wallet</span>.<span class="title function_">fromMnemonic</span>(mnemonic).<span class="title function_">connect</span>(provider);</span><br></pre></td></tr></table></figure><h3 id="privateKeyToAccount"><a href="#privateKeyToAccount" class="headerlink" title="privateKeyToAccount"></a>privateKeyToAccount</h3><p>通过私钥来创建账户对象</p><p><strong>参数 ：</strong><code>privateKey</code> - <code>String</code>: 用来创建账户的私钥。</p><h3 id="fromMnemonic"><a href="#fromMnemonic" class="headerlink" title="fromMnemonic"></a>fromMnemonic</h3><p><em>ethers</em>.<em>Wallet</em>.<strong>fromMnemonic</strong>( <em>mnemonic</em> [ , <em>path</em> , [ <em>wordlist</em> ] ] ) ⇒ <em><strong>Wallet</strong></em></p><p>从助记短语中创建实例如果没有指定path，则使用的默认path路径(<code>m/44&#39;/60&#39;/0&#39;/0/0</code>),如果不指定wordlist，则使用English Wordlist</p><h3 id="fromEncryptedJson"><a href="#fromEncryptedJson" class="headerlink" title="fromEncryptedJson"></a>fromEncryptedJson</h3><p><em>ethers</em>.<em>Wallet</em>.<strong>fromEncryptedJson</strong>( <em>json</em> , <em>password</em> [ , <em>progress</em> ] ) ⇒ <em>Promise&lt; **Wallet** &gt;</em></p><p>从加密的JSON钱包创建一个实例。</p><p>如果提供了<em>进度</em>，它将在解密期间被调用，其值介于0到1之间，表示一个完成进度。</p><h2 id="在主网上支持以太坊域名-ENS"><a href="#在主网上支持以太坊域名-ENS" class="headerlink" title="在主网上支持以太坊域名(ENS)"></a>在主网上支持以太坊域名(ENS)</h2><p>通过ethers.js的provider.resolveName(“ricmoo.eth”);返回账户实现转账</p><h2 id="对某笔交易进行签名或者执行签名交易"><a href="#对某笔交易进行签名或者执行签名交易" class="headerlink" title="对某笔交易进行签名或者执行签名交易"></a>对某笔交易进行签名或者执行签名交易</h2><h3 id="signTransaction"><a href="#signTransaction" class="headerlink" title="signTransaction"></a>signTransaction</h3><p>使用给定的私钥签名以太坊交易</p><p><strong>参数 ：</strong></p><ul><li><code>tx</code> <strong>-</strong> <code>Object</code>:交易对象，具有如下结构：<ul><li><code>nonce</code> - <code>String</code>: (可选) 签名交易时所用的 nonce 值。默认使用33. web3.eth.getTransactionCount().</li><li><code>chainId</code> - <code>String</code>: (可选) 签名交易时所用的 chain id。 默认使用 web3.eth.net.getId().</li><li><code>to</code> - <code>String</code>: (可选) 交易接受者，部署合约时其值为空。</li><li><code>data</code> - <code>String</code>: (可选) 交易调用数据，对简单转账交易来说其值为空。</li><li><code>value</code> - <code>String</code>: (可选) 以 wei 为单位的以太币转账数量。</li><li><code>gasPrice</code> - <code>String</code>: (可选) 交易所用的燃料价格，如果传入为空值则会使用 web3.eth.gasPrice()</li><li><code>gas</code> - <code>String</code>: 交易可用的燃料上限。</li><li><code>chain</code> - <code>String</code>: (可选) 默认值为 <code>mainnet</code>.</li><li><code>hardfork</code> - <code>String</code>: (可选) 默认值为 <code>petersburg</code>.</li><li><code>common</code> - <code>Object</code>: (可选) common 对象：<ul><li><code>customChain</code> - <code>Object</code>: 自定义链属性<ul><li><code>name</code> - <code>string</code>: (可选) 链名称</li><li><code>networkId</code> - <code>number</code>: 自定义链的网络 id</li><li><code>chainId</code> - <code>number</code>: 自定义链的 chain id</li></ul></li><li><code>baseChain</code> - <code>string</code>: (可选) <code>mainnet</code>, <code>goerli</code>, <code>kovan</code>, <code>rinkeby</code>, 或 <code>ropsten</code></li><li><code>hardfork</code> - <code>string</code>: (可选) <code>chainstart</code>, <code>homestead</code>, <code>dao</code>, <code>tangerineWhistle</code>, <code>spuriousDragon</code>, <code>byzantium</code>, <code>constantinople</code>, <code>petersburg</code>, 或 <code>istanbul</code></li></ul></li></ul></li><li><code>privateKey</code> - <code>String</code>: 签名交易所用的私钥。</li><li><code>callback</code> - <code>Function</code>: (可选) 可选的回调函数, 其第一个返回值为错误对象，第二个返回值为调用结果。</li></ul><p><strong>返回值(Promise)：</strong> <strong>Object</strong>，<strong>RLP 编码的交易对象：</strong></p><ul><li><code>messageHash</code> - <code>String</code>: 给定消息的哈希值。</li><li><code>r</code> - <code>String</code>: 签名的头 32 个字节。</li><li><code>s</code> - <code>String</code>: 签名接下来的 32 个字节。</li><li><code>v</code> - <code>String</code>: 恢复值 + 27。</li><li><code>rawTransaction</code> - <code>String</code>: RLP 编码的交易, 可使用 35.web3.eth.sendSignedTransaction 直接发送。</li><li><code>transactionHash</code> - <code>String</code>: RLP 编码交易的交易哈希。</li></ul><p>signTransaction方法返回的<code>rawTransaction</code> - <code>String</code>: RLP 编码的交易, 可使用 sendSignedTransaction 直接发送。</p><h2 id="显示当前网络下的一些重要参数"><a href="#显示当前网络下的一些重要参数" class="headerlink" title="显示当前网络下的一些重要参数"></a>显示当前网络下的一些重要参数</h2><p>如：当前 gas 价格、每秒交易数(api)、币种价格(api)</p><h2 id="通过输入合约地址输入合约地址和合约ABI显示-或者通过合约地址获取ABI，但需要合约已验证-出合约所具有的方法，用户可以选择方法和输入参数与之合约交互"><a href="#通过输入合约地址输入合约地址和合约ABI显示-或者通过合约地址获取ABI，但需要合约已验证-出合约所具有的方法，用户可以选择方法和输入参数与之合约交互" class="headerlink" title="通过输入合约地址输入合约地址和合约ABI显示(或者通过合约地址获取ABI，但需要合约已验证)出合约所具有的方法，用户可以选择方法和输入参数与之合约交互"></a>通过输入合约地址输入合约地址和合约ABI显示(或者通过合约地址获取ABI，但需要合约已验证)出合约所具有的方法，用户可以选择方法和输入参数与之合约交互</h2><p>前端弄，我只负责返回数据给搞前端的解析</p><h2 id="模拟消息调用的Gas使用量"><a href="#模拟消息调用的Gas使用量" class="headerlink" title="模拟消息调用的Gas使用量"></a>模拟消息调用的Gas使用量</h2><h3 id="estimateGas"><a href="#estimateGas" class="headerlink" title="estimateGas"></a>estimateGas</h3><p>通过执行一个消息调用来得到交易的 gas 用量。</p><p><strong>参数：</strong></p><ul><li><code>Object</code> - 交易对象，相关信息可以查看 web3.eth.sendTransaction, 消息调用交易和一般交易的区别是 <code>from</code> 属性也是可选的。</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</li></ul><p><strong>返回值(Promise)：</strong>String,模拟消息或交易调用的 gas 用量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">web3.<span class="property">eth</span>.<span class="title function_">estimateGas</span>(&#123;</span><br><span class="line">    <span class="attr">to</span>: <span class="string">&quot;0x11f4d0A3c12e86B4b5F39B213F7E19D048276DAe&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: <span class="string">&quot;0xc6888fa10000000000000000000000000000000000000000000000000000000000000003&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br></pre></td></tr></table></figure><h2 id="查询历史交易或者区块信息"><a href="#查询历史交易或者区块信息" class="headerlink" title="查询历史交易或者区块信息"></a>查询历史交易或者区块信息</h2><p>前端弄，我只负责返回数据给搞前端的解析</p>]]></content>
      
      
      <categories>
          
          <category> 区块链项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨链</title>
      <link href="/2023/03/28/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E6%89%A9%E5%AE%B9/%E8%B7%A8%E9%93%BE/"/>
      <url>/2023/03/28/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E6%89%A9%E5%AE%B9/%E8%B7%A8%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="链桥"><a href="#链桥" class="headerlink" title="链桥"></a>链桥</h1><p>随着一层网络区块链和二层网络扩容解决方案的激增，以及越来越多的去中心化应用程序跨链，跨链通信和资产转移需求已成为网络基础设施的重要组成部分。 存在不同类型的链桥就是为了帮助解决这种需求。</p><h2 id="对链桥的需求"><a href="#对链桥的需求" class="headerlink" title="对链桥的需求"></a>对链桥的需求</h2><p>链桥的存在是为了连接区块链网络。 它们实现了区块链之间的连通性和互操作性。</p><p>区块链存在于孤立的环境中，这意味着区块链之间本来就无法进行交易和通信。 因此，虽然某个生态系统内可能存在大量的活动和创新，但它会由于缺乏与其他生态系统的连通性和互操作性而受到限制。</p><p>链桥提供了一种让孤立的区块链环境相互连通的途径。 它们在区块链之间建立了一条传输路线，让代币、信息、任意数据甚至智能合约调用都可以从一条区块链转移到另一条。</p><h2 id="链桥是如何工作的？"><a href="#链桥是如何工作的？" class="headerlink" title="链桥是如何工作的？"></a>链桥是如何工作的？</h2><p>虽然链桥设计多种多样，但以下三种方便资产跨链转移的方法脱颖而出：</p><ul><li><strong>锁定并铸币 –</strong> 锁定源链上的资产并在目标链上铸币。</li><li><strong>销毁并铸币 –</strong> 销毁源链上的资产并在目标链上铸币。</li><li><strong>原子交换 –</strong> 通过第三方将源链上的资产与目标链上的资产交换。</li></ul><h2 id="链桥类型"><a href="#链桥类型" class="headerlink" title="链桥类型"></a>链桥类型</h2><p>链桥通常可以分为以下几类之一：</p><ul><li><strong>原生链桥 –</strong> 这些链桥通常用于加强特定区块链上的流动性，使用户更容易将资金转移到生态系统。 例如，<a href="https://bridge.arbitrum.io/">Arbitrum 链桥(opens in a new tab)↗</a>的目的就是为了方便用户从以太坊主网桥接到 Arbitrum。 其他此链类桥包括 Polygon PoS 链桥、<a href="https://app.optimism.io/bridge">Optimism 网关(opens in a new tab)↗</a>等。</li><li><strong>基于验证者或预言机的链桥 –</strong> 这些链桥依赖于外部验证者组或预言机来验证跨链转移。 例如：Multichain 与 Across。</li><li><strong>通用信息传递链桥 –</strong> 这些链桥可以跨链传输资产、信息和任意数据。 例如：Nomad 与 LayerZero。</li><li><strong>流动性网络 –</strong> 这些链桥主要是通过原子交换将资产从一条链转移到另一条链。 一般来讲，它们不支持跨链信息传递。 例如：Connext 与 Hop。</li></ul><h2 id="桥梁类型"><a href="#桥梁类型" class="headerlink" title="桥梁类型"></a>桥梁类型</h2><p>桥梁具有各种设计和复杂程度。 一般来说，桥梁分为两类：需信任桥梁和免信任桥梁。</p><table><thead><tr><th>需信任桥梁</th><th>免信任桥梁</th></tr></thead><tbody><tr><td>需信任桥梁依赖于中心实体或系统的运作。</td><td>免信任桥梁使用智能合约和算法运行。</td></tr><tr><td>他们对资金的保管和桥梁的安全性有信任假设。 用户大多依赖桥梁运营商的声誉。</td><td>这种桥梁免于信任，即桥梁的安全性与底层区块链的安全性相同。</td></tr><tr><td>用户需要放弃对其加密资产的控制。</td><td>通过智能合约，免信任桥梁使用户能够继续控制他们的资金。</td></tr></tbody></table><p>简而言之，我们可以说需信任桥梁具有信任假设，而免信任桥梁对信任的依赖非常小，因此不会在基础域之外出现新的信任假设。 上述术语的解释如下：</p><ul><li><strong>免信任</strong>：与底层域具有同等的安全性。 如 <a href="https://medium.com/connext/the-interoperability-trilemma-657c2cf69f17">Arjun Bhuptani 在本文中所述。(opens in a new tab)↗</a></li><li><strong>信任假设</strong>：通过在系统中添加外部验证者来摆脱底层域的安全性，从加密经济学的角度来说，这降低了安全性。</li></ul><p>为了更好地理解这两种方法之间的主要区别，我们来举个例子：</p><p>想象一下，你在机场安检站。 有两种检查站：</p><ol><li>手动检查站 — 由工作人员手动检查你的机票和身份证明的所有详细信息，然后再交出登机牌。</li><li>自助值机 — 由一台机器操作，你可以在其中输入航班的详细信息，如果一切检查完毕，你就会收到登机牌。</li></ol><p>手动检查站类似于需信任模式，因为它依赖于第三方（即工作人员）进行操作。 作为用户，你相信工作人员会做出正确的决定并正确使用你的私人信息。</p><p>自助值机类似于免信任模式，因为它不再需要操作员，而是利用技术进行操作。 用户始终可以控制他们的数据，并且不必信任第三方来处理他们的私人信息。</p><p>许多桥梁解决方案采用的模式介于这两个极端之间，具有不同的免信任度。</p><h2 id="权衡利弊"><a href="#权衡利弊" class="headerlink" title="权衡利弊"></a>权衡利弊</h2><p>没有完美的链桥解决方案。 有的只是为了实现目的而进行的权衡利弊。 开发者和用户可以根据以下因素评估链桥：</p><ul><li><strong>安全性 –</strong> <strong>谁来验证系统？</strong> 通常，由外部验证者保护的链桥不如由区块链验证者在本地保护的链桥安全。</li><li><strong>便利性 –</strong> <strong>完成一笔交易需要多长时间</strong>，用户需要签署多少笔交易? 对于开发者来说，集成一个链桥需要多长时间，这个过程有多复杂?</li><li><strong>连通性 –</strong> 一个链桥<strong>可以连接哪些不同的目标链</strong>（卷叠、侧链、其他一层网络区块链等），集成一条新区块链有多难?</li><li><strong>传递更复杂数据的能力 –</strong> <strong>链桥能够跨链传输信息和更复杂的任意数据，还是只支持跨链资产转移？</strong></li><li><strong>成本效益 –</strong> 通过链桥<strong>跨链转移资产的成本是多少？</strong> 通常情况下，链桥收取固定或变动的费用，具体取决于燃料成本和特定路线的流动性。 根据确保链桥安全所需的资本来评估链桥的成本效益也是至关重要的。</li></ul><h2 id="链桥相关风险"><a href="#链桥相关风险" class="headerlink" title="链桥相关风险"></a>链桥相关风险</h2><p>去中心化金融领域中最大的三次黑客攻击都是链桥造成的，而且链桥目前仍处于开发阶段早期。 使用任何链桥都有以下风险：</p><ul><li><strong>智能合约风险 –</strong> 虽然许多链桥已经成功通过了审计，但只需智能合约中的一个缺陷就会使资产暴露在黑客攻击中。</li><li><strong>系统性金融风险</strong> – 许多链桥使用包装资产在新的链上铸造规范化的原始资产。 这使生态系统面临系统性风险，正如我们所看到的那样，包装代币遭到利用。</li><li><strong>交易对手风险 –</strong> 一些链桥采用可信设计，这要求用户依靠一种假设，即验证者不会串通起来窃取用户的资金。 用户需要信任这些第三方参与者，这使他们面临一些风险，比如跑路、审查和其他恶意活动。</li><li><strong>未解决的问题 –</strong> 考虑到链桥处于发展阶段初期，还有许多关于链桥在不同市场条件下如何表现的问题都尚未解决，如网络拥塞期和在发生网络级攻击或状态回滚等不可预见的事件时。 这种不确定性带来了一定的风险，且风险程度目前仍然未知。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 扩容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 扩容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态通道</title>
      <link href="/2023/03/25/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E6%89%A9%E5%AE%B9/%E7%8A%B6%E6%80%81%E9%80%9A%E9%81%93/"/>
      <url>/2023/03/25/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E6%89%A9%E5%AE%B9/%E7%8A%B6%E6%80%81%E9%80%9A%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h1 id="状态通道"><a href="#状态通道" class="headerlink" title="状态通道"></a>状态通道</h1><p>状态通道让参与者可以安全地进行链下交易，同时最大限度地减少和以太坊主网的交互。 通道对等节点可以进行任意数量的链下交易，并且<strong>只需提交两个链上交易以打开和关闭通道</strong>。 这样便实现了极高的交易吞吐量，并为用户降低了成本。</p><h2 id="什么是通道？"><a href="#什么是通道？" class="headerlink" title="什么是通道？"></a>什么是通道？</h2><p>通道是简单的对等协议，允许双方进行多笔交易，然后只将最终结果发布到区块链。 渠道使用加密算法证明产生的摘要数据确实是一组有效中间交易的结果。 “多重签名”智能合约确保交易由正确的相关方签署。</p><p>每条通道都由以太坊上运行的多签智能合约管理。 <strong>要打开一条通道，参与者在链上部署通道合约并将资金存入其中</strong>。 双方<strong>共同签署一个状态</strong>更新来初始化通道的状态，之后他们就可以快速且自由地进行链下交易。</p><p><strong>要关闭通道，参与者需要将各方一致同意的通道最终状态提交到链上</strong>。 然后，智能合约根据通道最终状态下每个参与者的余额分配锁定资金。</p><p>对等通道在一些情况下非常有用，比如，某些预先确定的参与者希望频繁进行交易，并且不会产生明显的费用。 区块链通道分为两类：<strong>支付通道</strong>和<strong>状态通道</strong>。</p><h2 id="支付通道"><a href="#支付通道" class="headerlink" title="支付通道"></a>支付通道</h2><p>将支付通道描述成由<strong>两个用户共同维护的“双向账本”</strong>最为恰当。 账本的<strong>初始余额是通道打开期间锁定在链上合约中的存款总和</strong>。 支付通道转账可以立刻执行，并且除了最初建立一次性链上通道以及通道的最终关闭外，其余部分无需区块链实际参与。账本余额的更新需要渠道中所有各方的批准。 <strong>通道更新在所有通道参与者签署后被视为最终确定</strong>，这和以太坊上的交易非常相似。</p><h2 id="状态通道-1"><a href="#状态通道-1" class="headerlink" title="状态通道"></a>状态通道</h2><p>除了支持链下支付外，尚未证实支付通道可用于处理通用状态转换逻辑。 创建状态通道是为了解决这个问题，并使通道可用于扩展通用计算。</p><p><strong>状态通道与支付通道仍有很多共同点</strong>。 例如，当用户通过交换加密签名的信息（交易）进行互动时，另一些通道参与者也必须对信息签名。 如果提出的状态更新没有获得所有参与者的签名，则认为是无效的。</p><p>但是，除了保存用户的余额外，通道还跟踪合约存储的当前状态（即合约变量的值）。</p><p>这使得两个用户之间可以在链下执行智能合约。 在这种情况下，<strong>智能合约内部状态的更新只需由创建通道的另一方批准即可</strong>。</p><p>虽然这<strong>解决了前文描述的可扩展性问题，但它对安全性有影响</strong>。 在以太坊上，以太坊状态转换的有效性由网络的共识协议强制执行。 因此，不可能对智能合约的状态提出无效更新或者修改智能合约的执行。状态通道没有同样的安全保障。 在某种程度上，状态通道是主网的缩影。 <strong>由于执行规则的参与者有限，发生恶意行为（例如，提出无效状态更新）的可能性增加</strong>。 状态通道的安全性来自基于欺诈证明的争议仲裁系统。</p>]]></content>
      
      
      <categories>
          
          <category> 扩容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 扩容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分片</title>
      <link href="/2023/03/20/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E6%89%A9%E5%AE%B9/%E5%88%86%E7%89%87/"/>
      <url>/2023/03/20/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E6%89%A9%E5%AE%B9/%E5%88%86%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h1><p>以太坊分片（Ethereum sharding）是指以太坊区块链网络的一个扩容方案，旨在提高以太坊的吞吐量和可扩展性。在传统的以太坊区块链中，<strong>每个区块都需要被所有的节点验证和执行，这导致了处理速度较慢和高昂的交易费用。</strong></p><p>分片是通过<strong>将整个以太坊网络分割成多个小的子链（片段）</strong>来解决这个问题。<strong>每个分片将具有自己的交易历史和状态，并且可以独立地处理交易</strong>。这样一来，<strong>不同的分片可以并行地处理交易，从而提高整体的吞吐量和效率</strong>。</p><p><strong>每个分片都将由一组节点组成，这些节点负责验证和执行该分片中的交易。这些节点称为验证者（validators）</strong>。验证者通过参与共识算法来确定每个分片的交易顺序和状态更新。<strong>分片之间的通信和交互是通过主链（beacon chain）来实现的</strong>，主链维护了整个网络的状态和共识规则。</p><p>以太坊分片的实施是通过以太坊2.0（Ethereum 2.0）的升级来实现的。以太坊2.0是以太坊网络的下一代版本，它引入了分片和其他改进，旨在提高可扩展性、安全性和效率。</p><p><strong>Danksharding</strong>是以太坊成为真正可扩展区块链的方式，但要实现这一目标需要进行多项协议升级。<strong>Proto-Danksharding</strong>是这个过程中的一个中间步骤。两者都旨在使第 2 层上的交易对用户来说尽可能便宜，并且应该将以太坊扩展到每秒超过 100,000 笔交易。</p><h2 id="什么是-Proto-Danksharding？"><a href="#什么是-Proto-Danksharding？" class="headerlink" title="什么是 Proto-Danksharding？"></a>什么是 Proto-Danksharding？</h2><p>Proto-Danksharding，也称为<a href="https://eips.ethereum.org/EIPS/eip-4844">EIP-4844（在新标签页中打开）</a>，<a href="https://ethereum.org/zh/layer2/#rollups"> Rollups </a>将更便宜的数据添加到块的一种方式这个名字来自提出这个想法的两位研究人员：Protolambda 和 Dankrad Feist。目前，rollups 的用户交易成本受到限制，因为他们将交易发布在<code>CALLDATA</code>. 这是昂贵的，因为它由所有以太坊节点处理并永远存在于链上，即使汇总只需要很短的时间。Proto-Danksharding <strong>引入了可以发送并附加到块的数据块</strong>。EVM 无法访问这些 blob 中的数据，并且<strong>会在固定时间段（1-3 个月）后自动删除</strong>。这意味着汇总可以更便宜地发送数据，并以更便宜的交易形式将节省的费用转嫁给最终用户。</p><h3 id="为什么-blob-使汇总更便宜？"><a href="#为什么-blob-使汇总更便宜？" class="headerlink" title="为什么 blob 使汇总更便宜？"></a>为什么 blob 使汇总更便宜？</h3><p><strong>Rollups 是一种扩展以太坊的方法，它通过在链下批处理交易然后将结果发布到以太坊</strong>。汇总基本上由两部分组成：数据和执行检查。数据是由汇总处理的完整交易序列，以产生发布到以太坊的状态变化。执行检查是由一些诚实的参与者（“证明者”）重新执行这些交易，以确保提议的状态更改是正确的。为了执行检查，交易数据必须足够长的时间可供任何人下载和检查。这意味着 rollup sequencer 的任何不诚实行为都可以被证明者识别和挑战。但是，它不需要永远可用。</p><h3 id="为什么删除-blob-数据就可以了？"><a href="#为什么删除-blob-数据就可以了？" class="headerlink" title="为什么删除 blob 数据就可以了？"></a>为什么删除 blob 数据就可以了？</h3><p><strong>Rollups 在链上发布对其交易数据的承诺，并使实际数据在数据块中可用</strong>。这意味着证明者可以检查承诺是否有效或质疑他们认为错误的数据。在节点级别，数据块保存在共识客户端中。共识客户端证明他们已经看到了数据并且它已经在网络中传播。如果数据永久保存，这些客户端将膨胀并导致运行节点的大量硬件需求。相反，数据每 1-3 个月自动从节点中删除一次。共识客户证明表明，证明者有足够的机会验证数据。实际数据可以由汇总操作员、用户或其他人存储在链外。</p><h3 id="如何验证-blob-数据？"><a href="#如何验证-blob-数据？" class="headerlink" title="如何验证 blob 数据？"></a>如何验证 blob 数据？</h3><p>Rollups 在数据 blob 中发布它们执行的事务。他们还发布了对数据的“承诺”。他们通过对数据拟合多项式函数来做到这一点。然后可以在不同的点评估此功能。例如，如果我们定义一个非常简单的函数<code>f(x) = 2x-1</code>，那么我们可以评估这个函数的<code>x = 1</code>, <code>x = 2</code>，<code>x = 3</code>给出结果<code>1, 3, 5</code>。证明者将相同的函数应用于数据并在相同的点对其进行评估。如果更改了原始数据，则函数将不相同，因此在每个点计算的值也不会相同。实际上，承诺和证明更为复杂，因为它们包含在加密函数中。</p><h3 id="什么是KZG？"><a href="#什么是KZG？" class="headerlink" title="什么是KZG？"></a>什么是KZG？</h3><p>将数据块减少为小的<a href="https://dankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.html">加密“承诺”的方案</a>。必须验证汇总提交的数据块，以确保汇总没有行为不当。这涉及<strong>证明者重新执行 blob 中的交易以检查承诺是否有效</strong>。这在概念上与执行客户端使用 Merkle 证明在第 1 层检查以太坊交易有效性的方式相同。KZG 是将多项式方程拟合到数据的替代证明。承诺在一些秘密数据点评估多项式。<strong>证明者将在数据上拟合相同的多项式并以相同的值对其进行评估</strong>，检查结果是否相同。这是一种验证数据的方法，该数据与一些汇总使用的零知识技术兼容，并最终与以太坊协议的其他部分使用。</p><h3 id="什么是KZG仪式？"><a href="#什么是KZG仪式？" class="headerlink" title="什么是KZG仪式？"></a>什么是KZG仪式？</h3><p>KZG 仪式是以太坊社区中许多人共同生成秘密随机数字串的一种方式，可<strong>用于验证某些数据</strong>。非常重要的一点是，<strong>这串数字是未知的，任何人都无法重新创建。为确保这一点，参加仪式的每个人都会收到前一位参与者的字符串。然后他们创建一些新的随机值（例如，通过允许浏览器测量鼠标的移动）并将其与先前的值混合。</strong>然后他们将价值发送给下一个参与者并从他们的本地机器上销毁它。只要仪式中的一个人诚实地这样做，最终的价值对于攻击者来说是不可知的。EIP-4844 KZG 仪式向公众开放，数万人参加以增加自己的熵。要破坏仪式，100% 的参与者必须主动不诚实。从参与者的角度来看，如果他们知道自己是诚实的，就没有必要相信其他任何人，因为他们知道他们获得了仪式（他们个人满足了 N 选 1 的诚实参与者要求）。</p><h3 id="KZG仪式的随机数有什么用？"><a href="#KZG仪式的随机数有什么用？" class="headerlink" title="KZG仪式的随机数有什么用？"></a>KZG仪式的随机数有什么用？</h3><p>当 rollup 在 blob 中发布数据时，他们提供了他们在链上发布的“承诺”。这种<strong>承诺是在某些点评估多项式拟合数据的结果</strong>。这些点<strong>由 KZG 仪式中生成的随机数定义</strong>。然后，<strong>证明者可以在相同点评估多项式以验证数据——如果它们得出相同的值，则数据是正确的。</strong></p><h3 id="为什么-KZG-随机数据必须保密？"><a href="#为什么-KZG-随机数据必须保密？" class="headerlink" title="为什么 KZG 随机数据必须保密？"></a>为什么 KZG 随机数据必须保密？</h3><p>如果有人知道用于承诺的随机位置，他们很容易生成适合这些特定点的新多项式（即“碰撞”）。这意味着他们可以在 blob 中添加或删除数据，并且仍然提供有效的证据。为了防止这种情况发生，他们不是向证明者提供实际的秘密位置，而是使用椭圆曲线实际接收包裹在加密“黑匣子”中的位置。这些以原始值不能被逆向工程的方式有效地打乱了值，但是通过一些聪明的代数证明者和验证者仍然可以在它们代表的点上评估多项式。</p><p>Danksharding 和 Proto-Danksharding 都不遵循旨在将区块链分成多个部分的传统“分片”模型。分片链不再是路线图的一部分。相反，Danksharding 使用跨 blob 的分布式数据采样来扩展以太坊。这实现起来要简单得多。这种模型有时被称为“数据分片”。</p><h2 id="什么是-Danksharding？"><a href="#什么是-Danksharding？" class="headerlink" title="什么是 Danksharding？"></a>什么是 Danksharding？</h2><p>Danksharding 是从 Proto-Danksharding 开始的汇总扩展的完整实现。Danksharding 将在以太坊上带来大量空间用于汇总以转储其压缩的交易数据。这意味着以太坊将能够轻松支持数百个单独的汇总，并使每秒数百万笔交易成为现实。</p><p>其工作方式是将附加到块的 blob 从 Proto-Danksharding 中的 1 个扩展到完整 Danksharding 中的 64 个。其余所需的更改都是对共识客户端操作方式的更新，以使它们能够处理新的大 blob。其中一些更改已经在路线图上用于独立于 Danksharding 的其他目的。例如，Danksharding 要求实现提议者-构建者分离。这是一次升级，将不同验证者之间的构建块和提议块的任务分开。同样，Danksharding 需要数据可用性采样，但对于不存储太多历史数据的非常轻量级的客户端（“无状态客户端”）的开发也需要它。</p><h3 id="为什么Danksharding需要proposer-builder分离？"><a href="#为什么Danksharding需要proposer-builder分离？" class="headerlink" title="为什么Danksharding需要proposer-builder分离？"></a>为什么Danksharding需要proposer-builder分离？</h3><p>需要提议者-构建者分离，以<strong>防止各个验证者不得不为 32MB 的 blob 数据生成昂贵的承诺和证明</strong>。这会给家庭利益相关者带来太大压力，并要求他们投资更强大的硬件，这会损害权力下放。相反，专门的区块构建者负责这项昂贵的计算工作。然后，他们将他们的区块提供给区块提议者进行广播。区块提议者简单地选择最有利可图的区块。任何人都可以廉价且快速地验证 blob，这意味着任何普通验证者都可以检查区块构建者是否诚实行事。这允许在不牺牲去中心化的情况下处理大型 blob。</p><h3 id="为什么-Danksharding-需要数据可用性采样？"><a href="#为什么-Danksharding-需要数据可用性采样？" class="headerlink" title="为什么 Danksharding 需要数据可用性采样？"></a>为什么 Danksharding 需要数据可用性采样？</h3><p>验证器需要数据可用性采样才能快速有效地验证 blob 数据。使用数据可用性采样，验证器可以非常确定 blob 数据可用并正确提交。每个验证器都可以随机抽取几个数据点并创建证明，这意味着验证器不必检查整个 blob。如果有任何数据丢失，它会被快速识别并拒绝 blob。</p>]]></content>
      
      
      <categories>
          
          <category> 扩容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 扩容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>侧链</title>
      <link href="/2023/03/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E6%89%A9%E5%AE%B9/%E4%BE%A7%E9%93%BE/"/>
      <url>/2023/03/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E6%89%A9%E5%AE%B9/%E4%BE%A7%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="侧链"><a href="#侧链" class="headerlink" title="侧链"></a>侧链</h1><p>侧链是独立于以太坊运行的独立区块链，<strong>通过双向桥梁与以太坊主网连接</strong>。 <strong>侧链可以有单独的区块参数和共识算法</strong>，它们通常是为高效处理交易而设计的。 但是，使用侧链需要权衡取舍，因为它们未继承以太坊的安全属性。 与二层网络扩容解决方案不同，<strong>侧链不会将状态变化和交易数据发布到以太坊主网。</strong></p><p>侧链还在一定程度上牺牲了去中心化或安全性来实现高吞吐量。 </p><h2 id="侧链如何运作？"><a href="#侧链如何运作？" class="headerlink" title="侧链如何运作？"></a>侧链如何运作？</h2><p>侧链是独立的区块链，具有不同的历史记录、开发路线图和设计考虑。 虽然和以太坊在表面上可能有一些相似之处，但侧链有几个独特的特征。</p><h3 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h3><p>使侧链独一无二（即不同于以太坊）的特点之一是使用了共识算法。 <strong>侧链不依赖以太坊达成共识</strong>，并可以选择适合其需求的替代共识协议。 </p><p>与以太坊一样，侧链也有验证并处理交易、生成区块以及存储区块链状态的验证节点。 验证者还负责维护整个网络的共识，并保护网络免受恶意攻击。</p><h4 id="区块参数"><a href="#区块参数" class="headerlink" title="区块参数"></a>区块参数</h4><p>以太坊对出块时间（即产生新区块所需的时间）和区块大小（即以燃料为计量单位的每个区块包含的数据量）设置了限制。 相反，<strong>侧链通常采用不同的参数，例如更快的出块时间和更高的燃料限制，以实现高吞吐量、快速交易和低费用</strong>。</p><p>虽然这样做有一些好处，但会对网络去中心化和安全性产生严重影响。 较快的出区块时间和较大的区块大小这样的区块参数，增加了运行全节点的难度，让一些“超级节点”负责保护区块链的安全。 在这种情况下，验证者串通或恶意接管区块链的可能性增加。</p><h3 id="以太坊虚拟机兼容性"><a href="#以太坊虚拟机兼容性" class="headerlink" title="以太坊虚拟机兼容性"></a>以太坊虚拟机兼容性</h3><p>一些侧链与以太坊虚拟机兼容，并且能够执行为以太坊虚拟机 (EVM)开发的合约。 兼容以太坊虚拟机的侧链支持用 Solidity 编写的智能合约，也支持其他以太坊虚拟机智能合约语言，这意味着为以太坊主网编写的智能合约也将在兼容以太坊虚拟机的侧链上有效。</p><p>这意味着，如果想在侧链上使用你的去中心化应用程序，只需将你的智能合约部署到该侧链即可。 侧链的外观、给人的感受和行为与主链相似，你仍然用 Solidity 编写合约，并通过侧链远程过程调用与侧链交互。</p><p>由于侧链与以太坊虚拟机兼容，因而被视为对以太坊原生去中心化应用程序有效的扩容解决方案。 去中心化应用程序部署到侧链上后，用户可以获得更低的燃料费用和更快的交易速度，尤其是在主网拥塞的情况下。</p><p>然而，正如前文所述，使用侧链需认真权衡其利弊。 每个侧链负责其自身安全性，没有继承以太坊的安全属性。 这增加了发生恶意行为的可能性，可能会影响到你的用户或使他们的资金面临风险。</p><h3 id="资产转移"><a href="#资产转移" class="headerlink" title="资产转移"></a>资产转移</h3><p>为了使一条独立区块链成为以太坊主网的侧链，区块链必须能支持资产在它与以太坊主网之间转移。 这种与以太坊的互操作性是使用区块链桥梁实现的。 桥梁使用部署在以太坊主网和侧链上的智能合约控制两者之间的资金桥接。</p><p>虽然桥梁可以帮助用户在以太坊和侧链之间转移资金，但实体资产不会在两条链之间移动。 而是采用通常与铸币和销毁相关的机制跨链转移价值。 </p><h2 id="侧链的优缺点"><a href="#侧链的优缺点" class="headerlink" title="侧链的优缺点"></a>侧链的优缺点</h2><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>支撑侧链的技术是成熟的，并得益于广泛的研究和设计的改进。</td><td>侧链在一定程度上牺牲了去中心化和免信任以换取可扩展性。</td></tr><tr><td>侧链支持通用计算并提供以太坊虚拟机兼容性（它们可以运行以太坊原生去中心化应用程序）。</td><td>侧链使用单独的共识机制，并且没有从以太坊的安全保障中受益。</td></tr><tr><td>侧链使用不同的共识模型，为用户高效处理交易并降低交易费。</td><td>侧链需要更高的信任假设（例如，恶意侧链验证者达到一定人数可以进行欺诈）。</td></tr><tr><td>与以太坊虚拟机兼容的侧链允许去中心化应用程序扩展其生态系统。</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 扩容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 扩容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二层网络</title>
      <link href="/2023/03/11/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E6%89%A9%E5%AE%B9/%E4%BA%8C%E5%B1%82%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/03/11/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E6%89%A9%E5%AE%B9/%E4%BA%8C%E5%B1%82%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="二层扩容"><a href="#二层扩容" class="headerlink" title="二层扩容"></a>二层扩容</h1><p>此类链下解决方案的安全性来自以太坊主网。</p><p>第二层是解决方案的一个集体术语，用于通过处理以太坊主网（第一层）的交易，同时<strong>利用主网的强大分散安全模式，帮助扩展您的应用程序</strong>。 当网络繁忙时，交易速度会受到影响，这可能使某些类型的去中心化应用程序的用户体验变差。 而且，随着网络越来越繁忙，由于交易发送者的目标是超越对方的出价，燃料价格也随之上升。 这可能会让以太坊的使用成本非常高。</p><p>大多数第二层解决方案均<strong>围绕着一个服务器或服务器群集</strong>，可以将它们称之为节点、验证者、运营商、排序者、区块生产者或类似术语。 根据实施情况，这些第二层节点可由使用它们的个人、企业或实体运行，或者由第三方运营商或一大群个人（与主网相似）运行。 一般而言，<strong>交易会提交给第二层节点，而非直接提交给第一层（主网）</strong>。 对于部分解决方案，<strong>二层网络实例会将它们分组，然后锚定到一层网络</strong>，之后受一层网络保护且不能更改。 对于不同的第二层技术和实施而言，如何做到这一点的细节差异很大。</p><blockquote><p>二层网络的交易会在主网上产生一些元数据或验证数据。这些数据可以用来证明二层网络上的交易的有效性，并确保主网和二层网络之间的一致性。这些数据可能会被提交到主网上的特殊合约进行验证，但它们不会直接影响主网的状态根或智能合约的状态</p></blockquote><h2 id="为什么需要第二层？"><a href="#为什么需要第二层？" class="headerlink" title="为什么需要第二层？"></a>为什么需要第二层？</h2><ul><li>每秒增加交易量会大大提高用户体验，并减少以太坊主网上的网络拥塞情况。</li><li>卷叠就是将多个交易打包到一个交易中，然后发到以太坊主网上，这为用户减少了燃料费用。以太坊将更具包容性，任何人都可以用得起以太坊。</li><li>关于可扩容性的任何更新都不应以分散安全性为代价 - 第二层建立在以太坊的基础上。</li><li>有一些特定应用的第二层网络，在大规模处理资产时有它们自己的效率。</li></ul><h2 id="卷叠"><a href="#卷叠" class="headerlink" title="卷叠"></a>卷叠</h2><p>卷叠并不是把多个交易打包成一个交易在以太坊主网上执行，而是<strong>将多个交易在卷叠链上验证和执行</strong>，并通<strong>过特殊的交易将验证后的交易数据的摘要发送到以太坊主网，以更新主网的状态根。</strong></p><h3 id="乐观卷叠（Optimistic-Rollup）"><a href="#乐观卷叠（Optimistic-Rollup）" class="headerlink" title="乐观卷叠（Optimistic Rollup）"></a><strong>乐观卷叠（Optimistic Rollup）</strong></h3><p>乐观卷叠被认为是“乐观的”，因为它们假设链下交易是有效的，并且<strong>不发布推送到链上的交易批次的有效性证明</strong>。在以太坊上提交卷叠批次后，<strong>有一个时间窗口（称为挑战期）</strong>，在此期间任何人都可以通过计算<strong>欺诈证明</strong>来挑战卷叠交易的结果。</p><blockquote><p>欺诈证明：乐观卷叠<strong>允许任何人在不提供有效性证明的情况下发布区块</strong>。 然而，为了确保链保持安全，乐观卷叠<strong>指定了一个时间窗口</strong>，在此期间任何人都可以对状态转换提出异议。 因此，卷叠块被称为“断言”，因为任何人都可以挑战它们的有效性。如果有人对断言提出异议，则卷叠协议将启动欺诈证明计算。 每种类型的欺诈证明都是交互式的 — <strong>必须有人发布断言，然后其他人才能对其提出挑战。</strong> </p></blockquote><h4 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h4><ol><li>Optimism: Optimism 是一种快速、简单、安全乐观卷叠，与以太坊虚拟机相当。它扩展了以太坊技术，同时还通过可追溯公共物品融资来扩展其价值。</li><li>Arbitrum: Arbitrum 是一种乐观卷叠，目的是提供与以太坊完全一致的交互体验，但交易成本只是它们在一层网络上的很小比例。</li><li>Boba Network Boba 是最初从乐观卷叠分叉而来的乐观卷叠链，它是一种旨在降低铸币费用，提高交易吞吐量，并扩展智能合约能力的扩容解决方案。</li></ol><h3 id="零知识卷叠（Zero-Knowledge-Rollup）"><a href="#零知识卷叠（Zero-Knowledge-Rollup）" class="headerlink" title="零知识卷叠（Zero-Knowledge Rollup）"></a><strong>零知识卷叠（Zero-Knowledge Rollup）</strong></h3><p> 零知识卷叠运营商<strong>生成有效性证明来证明状态变化的正确性</strong>。 该<strong>有效性证明能以加密方式自证，确保提出的以太坊状态变化确实是该批次中所有交易执行后的最终结果。</strong>零知识卷叠的状态<strong>由部署在以太坊网络上的智能合约维护</strong>。 为了更新这个状态，零知识卷叠节点必须提交一个有效性证明进行验证。 如前所述，有效性证明是一种加密保证，即<strong>卷叠提出的状态变化确实是执行给定批次交易的结果</strong>。 这意味着零知识卷叠<strong>只需提供有效性证明</strong>即可在以太坊上最终确定交易，而不是像乐观卷叠那样将所有交易数据发布到链上。</p><blockquote><p> 有效性证明：有效性证明是一种简单的加密承诺，用于<strong>验证批量交易的正确性</strong>。有效性证明允许参与方在不透露陈述本身的情况下<strong>证明陈述的正确性</strong> — 因此，它们又称为零知识证明。 </p></blockquote><p>将资金<strong>从零知识卷叠转移到以太坊时不会出现延迟</strong>，因为一旦零知识卷叠合约<strong>验证了有效性证明后，就会执行退出交易</strong>。 相反，<strong>从乐观卷叠中提取资金会产生延迟，让任何人都可以使用欺诈证明来挑战退出交易。</strong></p><h4 id="项目-1"><a href="#项目-1" class="headerlink" title="项目"></a>项目</h4><ol><li>Loopring：Loopring 的零知识卷叠二层网络解决方案旨在提供与以太坊主链相同的安全保障，并大规模提升可扩展性：交易吞吐量增加 1000 倍，交易费用降至一层网络 0.1%。</li><li>zkSync：zkSync 是由 Matter Labs 推出的以用户为中心的零知识卷叠平台。它是以太坊的扩容解决方案，已经在以太坊主链上线，支持付款、代币交换和 NFT 挖矿。</li><li>ZKSpace：ZKSpace 平台由三个主要部分组成：利用零知识卷叠技术建立的二层自动化做市商，被称为 ZKSwap；还有被称为 ZKSquare 的支付服务，以及被称为 ZKSea 的非同质化代币市场。</li><li>Aztec：Aztec Network 是以太坊上的第一个私有零知识卷叠，使去中心化应用程序能够访问隐私并扩展。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 扩容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 扩容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PLASMA链</title>
      <link href="/2023/03/07/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E6%89%A9%E5%AE%B9/PLASMA%E9%93%BE/"/>
      <url>/2023/03/07/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E6%89%A9%E5%AE%B9/PLASMA%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="PLASMA链"><a href="#PLASMA链" class="headerlink" title="PLASMA链"></a>PLASMA链</h1><h2 id="什么是-PLASMA？"><a href="#什么是-PLASMA？" class="headerlink" title="什么是 PLASMA？"></a>什么是 PLASMA？</h2><p>Plasma 是一个用于改善以太坊这类公共区块链的可扩展性的框架。 正如原 <a href="http://plasma.io/plasma.pdf">Plasma 白皮书(opens in a new tab)↗</a>中所述，Plasma 链是在另一个区块链之上构建的，该区块链被称为“根链”。 每个“子链”都从根链延伸而来，通常由部署在母链上的智能合约进行管理。</p><p>Plasma 合约除了其他功能之外，还有一项功能是作为<a href="https://ethereum.org/zh/developers/docs/bridges/">链梁</a>，让用户可以在以太坊主网和 plasma 链之间转移资产。 虽然这使它们<strong>类似于<a href="https://ethereum.org/zh/developers/docs/scaling/sidechains/">侧链</a>，但 plasma 链至少在某种程度上受益于以太坊主网的安全性。 这一点不同于单独负责其安全性的侧链。</strong></p><h2 id="PLASMA-如何工作？"><a href="#PLASMA-如何工作？" class="headerlink" title="PLASMA 如何工作？"></a>PLASMA 如何工作？</h2><p>Plasma 框架的基本组成部分包括：</p><h3 id="链下计算"><a href="#链下计算" class="headerlink" title="链下计算"></a>链下计算</h3><p>Plasma 假设以太坊主网不需要验证所有交易。 相反，我们可以在主网外处理交易，使节点不必验证每笔交易。</p><p>链下计算是必要的，因为 Plasma 链可以优化速度和成本。 例如，一个 Plasma 链可能，而且大多数情况下都使用单个“运营商”来管理交易的排序和执行。 由于只有一个实体验证交易，plasma 链上的处理速度比以太坊主网更快。</p><h3 id="状态承诺"><a href="#状态承诺" class="headerlink" title="状态承诺"></a>状态承诺</h3><p><strong>虽然 Plasma 在链下执行交易，但它们是在以太坊主执行层上结算的，否则，Plasma 链无法从以太坊的安全保证中受益。</strong> <strong>但是在不知道 Plasma 链状态的情况下完成链下交易会破坏安全模型并让无效交易扩散。 这就是为什么运营商，即负责在 Plasma 链上生产区块的实体，需要定期在以太坊上发布“状态承诺”</strong>。</p><p><a href="https://en.wikipedia.org/wiki/Commitment_scheme">承诺方案(opens in a new tab)</a>是一种加密技术，用于承诺价值或声明而不向另一方透露。 承诺是“有约束力的”，因为一旦你承诺了，就不能改变价值或声明。 <strong>Plasma 中的状态承诺采用“Merkle 根”的形式</strong>，运营商每隔一段时间将其发送到以太坊链上的 Plasma 合约。</p><p>Merkle 根是能够压缩大量信息的密码原语。 Merkle 根（在此情况下也称为“区块根”）可以代表区块中的所有交易。 Merkle 根还可以更容易地验证一小部分数据是否是较大数据集的一部分。 </p><p>Merkle 根对于向以太坊提供有关链下状态的信息非常重要。 你可以将 Merkle 根视为“保存点”：运营商表示，“这是 Plasma 链在 x 时间点的状态，这是 Merkle 根作为证明。” 运营商使用 Merkle 根对 Plasma 链的<em>当前状态</em>进行承诺，这就是为什么它被称为“状态承诺”。</p><h3 id="入口和出口"><a href="#入口和出口" class="headerlink" title="入口和出口"></a>入口和出口</h3><p>为了让以太坊用户利用 Plasma，需要有一种机制在主网和 Plasma 链之间转移资金。 但是，我们不能随意将以太币发送到 Plasma 链上的地址 — 这些链是不兼容的，因此交易要么失败，要么导致资金损失。</p><p>Plasma 使用在以太坊上运行的主合约来处理用户的入口和出口。 该主合约还负责跟踪状态承诺（前面已解释）并通过欺诈证明惩罚不诚实行为（稍后将详细介绍）。</p><h4 id="进入-plasma-链"><a href="#进入-plasma-链" class="headerlink" title="进入 plasma 链"></a>进入 plasma 链</h4><p>要进入 Plasma 链，Alice（用户）必须在 Plasma 合约中存入以太币或任何 ERC-20 代币。 监视合约存款的 Plasma 运营商重新创建与 Alice 的初始存款相等的金额，并将其释放到她在 Plasma 链上的地址。 Alice 需要证明在子链上收到资金，然后才能使用这些资金进行交易。</p><h4 id="退出-plasma-链"><a href="#退出-plasma-链" class="headerlink" title="退出 plasma 链"></a>退出 plasma 链</h4><p>由于几个原因，退出 plasma 链比进入它更复杂。 最大的问题是，虽然以太坊有关于 Plasma 链状态的信息，但它无法验证信息是否真实。 恶意用户可能会做出不正确的断言（“我有 1000 个以太币”）并提供虚假证据来支持该声明而侥幸逃脱。</p><p>为防止恶意取款，引入了“挑战期”的概念。 在挑战期内（通常为一周），任何人都可以使用欺诈证明来挑战取款请求。 如果挑战成功，则取款请求被拒绝。</p><p>但是，通常情况下，用户是诚实的，并对他们拥有的资金做出正确的声明。 在这种情况下，Alice 将通过向 Plasma 合约提交交易，在根链（以太坊）上发起取款请求。</p><p>她还必须提供 Merkle 证明，验证在 Plasma 链上创建她的资金的交易是否包含在区块中。 这对于 Plasma 的迭代是必要的，例如<a href="https://www.learnplasma.org/en/learn/mvp.html">最小可行 Plasma(opens in a new tab)</a> 使用<a href="https://en.wikipedia.org/wiki/Unspent_transaction_output">未花费的交易输出 (UTXO)(opens in a new tab)</a> 模型。</p><p>其他的，如 <a href="https://www.learnplasma.org/en/learn/cash.html">Plasma Cash(opens in a new tab)↗</a>，将资金表示为<a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-721/">非同质化代币</a>，而不是未花费的交易输出。 在这种情况下，取款需要证明 Plasma 链上代币的所有权。 这是通过提交涉及代币的两个最新交易并提供 Merkle 证明来验证这些交易是否包含在区块中来完成的。</p><p>用户还必须在取款请求中添加保证金，作为诚实行为的保证。 如果挑战者证明 Alice 的取款请求无效，她的保证金将被罚没，其中一部分作为奖励交给挑战者。</p><p>如果在没有任何人提供欺诈证明的情况下经过挑战期，Alice 的取款请求被认为是有效的，允许她从以太坊上的 Plasma 合约中取回存款。</p>]]></content>
      
      
      <categories>
          
          <category> 扩容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 扩容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Validium</title>
      <link href="/2023/03/07/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E6%89%A9%E5%AE%B9/Validium/"/>
      <url>/2023/03/07/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E6%89%A9%E5%AE%B9/Validium/</url>
      
        <content type="html"><![CDATA[<h1 id="VALIDIUM"><a href="#VALIDIUM" class="headerlink" title="VALIDIUM"></a>VALIDIUM</h1><h2 id="什么是-VALIDIUM？"><a href="#什么是-VALIDIUM？" class="headerlink" title="什么是 VALIDIUM？"></a>什么是 VALIDIUM？</h2><p>Validium 是使用链下数据可用性和计算的扩展解决方案，旨在通过在以太坊主网外处理交易来提高吞吐量。 与零知识卷叠（ZK 卷叠）一样，Validium 发布<a href="https://ethereum.org/zh/glossary/#zk-proof">零知识证明</a>以便在以太坊上验证链下交易。 这样可以防止无效的状态转换并增强 Validium 链的安全保障。</p><p>属于 Validium 用户的资金由以太坊上的智能合约控制。 恰如零知识卷叠一样，Validium 几乎可以提供即时提款；在主网上验证提款请求的有效性证明后，用户可以通过提供<a href="https://ethereum.org/zh/developers/tutorials/merkle-proofs-for-offline-data-integrity/">默克尔证明</a>提取资金。 默克尔证明验证用户的提款交易是否包含在经过验证的交易批次中，从而允许链上合约处理提款。</p><p>但是，Validium 用户可以冻结他们的资金并限制提款。 如果 Validium 链上的数据可用性管理器不给用户提供链下状态数据，就会发生这种情况。 如果无法访问交易数据，用户将无法计算证明资金所有权和执行提款所需的默克尔证明。</p><p>这<strong>是 Validium 和零知识卷叠之间的主要区别，它们在数据可用性范围内的位置不同</strong>。 两种解决方案处理数据存储的方式不同，这会对安全性和去信任产生影响。</p>]]></content>
      
      
      <categories>
          
          <category> 扩容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 扩容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Truffle</title>
      <link href="/2023/03/03/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Truffle/"/>
      <url>/2023/03/03/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Truffle/</url>
      
        <content type="html"><![CDATA[<h1 id="Truffle-命令"><a href="#Truffle-命令" class="headerlink" title="Truffle 命令"></a>Truffle 命令</h1><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><ul><li><code>truffle init</code>：在当前目录下创建新的 Truffle 项目。</li><li><code>truffle unbox &lt;box-name&gt;</code>：下载指定的 Truffle box 模板，以快速创建一个新项目。</li></ul><h3 id="编译和部署智能合约"><a href="#编译和部署智能合约" class="headerlink" title="编译和部署智能合约"></a>编译和部署智能合约</h3><ul><li><code>truffle compile</code>：编译智能合约。</li><li><code>truffle migrate</code>：部署智能合约。</li><li><code>truffle migrate --reset</code>：重新部署智能合约。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyContract</span> = artifacts.<span class="built_in">require</span>(<span class="string">&quot;XlbContract&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">deployer</span>) &#123;</span><br><span class="line">  <span class="comment">// 部署步骤</span></span><br><span class="line">  deployer.<span class="title function_">deploy</span>(<span class="title class_">MyContract</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="交互式控制台"><a href="#交互式控制台" class="headerlink" title="交互式控制台"></a>交互式控制台</h3><ul><li><code>truffle console</code>：启动交互式控制台，可在其中与智能合约进行交互。</li><li><code>truffle console --network &lt;network-name&gt;</code>：在指定的网络上启动交互式控制台。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">truffle</span>(develop)&gt; <span class="keyword">let</span> instance = <span class="keyword">await</span> <span class="title class_">MetaCoin</span>.<span class="title function_">deployed</span>()</span><br><span class="line"><span class="title function_">truffle</span>(develop)&gt; <span class="keyword">let</span> accounts = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getAccounts</span>()</span><br><span class="line"><span class="title function_">truffle</span>(develop)&gt; <span class="keyword">let</span> result = instance.<span class="title function_">sendCoin</span>(accounts[<span class="number">1</span>], <span class="number">10</span>, &#123;<span class="attr">from</span>: accounts[<span class="number">0</span>]&#125;)</span><br><span class="line"><span class="comment">//result.tx (string) - 交易哈希 hash</span></span><br><span class="line"><span class="comment">//result.logs (array) - 解码过的事件 (日志)</span></span><br><span class="line"><span class="comment">//result.receipt (object) - 交易收据 receipt（包括使用的gas）</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li><code>truffle test</code>：运行测试脚本。</li></ul><h3 id="编写外部脚本"><a href="#编写外部脚本" class="headerlink" title="编写外部脚本"></a>编写外部脚本</h3><ul><li><code>truffle exec &lt;path/to/file.js&gt;</code>：运行外部脚本</li></ul><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><ul><li><code>truffle version</code>：查看 Truffle 版本号。</li><li><code>truffle networks</code>：查看已配置的网络列表。</li><li><code>truffle help</code>：查看 Truffle 帮助文档。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 合约框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 合约框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hardhat</title>
      <link href="/2023/03/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Hardhat/"/>
      <url>/2023/03/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Hardhat/</url>
      
        <content type="html"><![CDATA[<h1 id="Hardhat-命令"><a href="#Hardhat-命令" class="headerlink" title="Hardhat 命令"></a>Hardhat 命令</h1><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><ul><li><code>npx hardhat</code>：在当前目录下创建新的 Hardhat 项目。</li><li><code>npx hardhat example</code>：在当前目录下创建新的 Hardhat 示例项目。</li><li><code>npx hardhat upgrade --network &lt;network-name&gt;</code>：升级当前项目到 Hardhat 最新版本。</li></ul><h3 id="编译和部署智能合约"><a href="#编译和部署智能合约" class="headerlink" title="编译和部署智能合约"></a>编译和部署智能合约</h3><ul><li><code>npx hardhat compile</code>：编译智能合约。</li><li><code>npx hardhat run scripts/&lt;script-name&gt;.js --network &lt;network-name&gt;</code>：部署智能合约。</li><li><code>npx hardhat node</code>：在本地启动一个节点，可用于本地测试。</li></ul><h3 id="交互式控制台"><a href="#交互式控制台" class="headerlink" title="交互式控制台"></a>交互式控制台</h3><ul><li><code>npx hardhat console</code>：启动交互式控制台，可在其中与智能合约进行交互。</li><li><code>npx hardhat console --network &lt;network-name&gt;</code>：在指定的网络上启动交互式控制台。</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li><code>npx hardhat test</code>：运行测试脚本。</li></ul><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><ul><li><code>npx hardhat clean</code>：删除构建文件和缓存文件。</li><li><code>npx hardhat accounts</code>：列出钱包地址。</li><li><code>npx hardhat config</code>：查看 Hardhat 配置信息。</li><li><code>npx hardhat help</code>：查看 Hardhat 帮助文档。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 合约框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 合约框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9-Forge标准库参考</title>
      <link href="/2023/02/26/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Foundry/9-Forge%E6%A0%87%E5%87%86%E5%BA%93%E5%8F%82%E8%80%83/"/>
      <url>/2023/02/26/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Foundry/9-Forge%E6%A0%87%E5%87%86%E5%BA%93%E5%8F%82%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="Forge-标准库"><a href="#Forge-标准库" class="headerlink" title="Forge 标准库"></a>Forge 标准库</h1><p>包含的内容：</p><ul><li><p>标准库</p><ul><li>Std Logs: 在 DSTest 库的日志事件的基础上进行扩展。</li><li>Std Assertions: 在 DSTest 库的断言功能的基础上进行扩展。</li><li>Std Cheats: 围绕 Forge 作弊代码的包装，以提高安全性和开发人员体验。</li><li>Std Errors: 围绕常见的内部 Solidity 错误和 reverts 的包装。</li><li>Std Storage: 用于存储操作的工具类。</li><li>Std Math: 实用的数学函数。</li><li>Script Utils: 可以在测试和脚本中访问的工具类。</li><li>Console Logging: 控制台日志功能。</li></ul></li><li><p>一个作弊代码实例 vm，你可以通过它调用 Forge 作弊代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.startPrank(alice);</span><br></pre></td></tr></table></figure></li><li><p>所有 Hardhat console 功能的记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(alice.balance); // or `console2`</span><br></pre></td></tr></table></figure></li><li><p>所有用于断言和日志的 Dappsys 测试函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEq(dai.balanceOf(alice), 10000e18);</span><br></pre></td></tr></table></figure></li><li><p>工具类函数也包括在 Script.sol 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 对于给定的部署者地址和 nonce，计算合约将被部署到的地址</span><br><span class="line">address futureContract = computeCreateAddress(alice, 1);</span><br></pre></td></tr></table></figure></li></ul><h2 id="Std-Logs"><a href="#Std-Logs" class="headerlink" title="Std Logs"></a>Std Logs</h2><p>Std Logs 在 DSTest 库的日志事件基础上进行扩展。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">event log_array(uint256[] val);</span><br><span class="line">event log_array(int256[] val);</span><br><span class="line">event log_array(address[] val);</span><br><span class="line">event log_named_array(string key, uint256[] val);</span><br><span class="line">event log_named_array(string key, int256[] val);</span><br><span class="line">event log_named_array(string key, address[] val);</span><br></pre></td></tr></table></figure><h2 id="Std-Assertions"><a href="#Std-Assertions" class="headerlink" title="Std Assertions"></a>Std Assertions</h2><ol><li><strong>fail</strong>(string memory err)：如果命中某个分支或执行点，则测试失败，并发出消息。</li><li><strong>assertFalse</strong>(bool data)、<strong>assertFalse</strong>(bool data, string memory err)：断言条件为假。</li><li><strong>assertEq</strong>：断言 <code>a</code> 等于 <code>b</code>，对 <code>bool</code>、<code>bytes</code>、<code>int256</code> 和 <code>uint256</code> 数组起作用。</li><li><strong>assertApproxEqAbs</strong>：uint256，断言 <code>a</code> 近似等于 <code>b</code>，delta 为百分比</li><li><strong>assertApproxEqRel</strong>：uint256，断言 <code>a</code> 近似等于 <code>b</code>，delta 为百分比，其中 <code>1e18</code> 为100%。</li></ol><h2 id="Std-Cheats"><a href="#Std-Cheats" class="headerlink" title="Std Cheats"></a>Std Cheats</h2><ol><li><p><strong>skip</strong>(uint256 time)：将 <code>block.timestamp</code> 向前跳过指定的秒数</p></li><li><p><strong>rewind</strong>(uint256 time)：将 <code>block.timestamp</code> 重新调整为指定的秒数</p></li><li><p><strong>hoax</strong>(address who,(uint256 give),(address origin)):从一个有一些 ether 的地址设置一个 prank，如果没有指定余额，它将被设置为 2^128 wei</p></li><li><p><strong>startHoax</strong>(address who,(uint256 give),(address origin)):从一个有一些 ether 的地址开始一个永久的prank，如果没有指定余额，它将被设置为 2^128 wei</p></li><li><p><strong>deal</strong>((address token,)address to, uint256 give(, bool adjust))：围绕 deal 作弊码的包装，也适用于大多数 ERC-20 代币,如果使用 <code>deal</code> 的替代签名，在设置余额后调整代币的总供应量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deal(address(dai), alice, 10000e18);</span><br><span class="line">assertEq(dai.balanceOf(alice), 10000e18);</span><br></pre></td></tr></table></figure></li><li><p><strong>deployCode</strong>(string memory what(,bytes memory args)(,uint256 val)) returns (address):通过从 artifacts 目录中获取合约字节码来部署合约,calldata 参数可以是 <code>ContractFile.sol</code>（如果文件名和合约名称相同），<code>ContractFile.sol:ContractName</code>，或者是相对于项目根目录的 artifact 路径。值也可以通过使用 <code>val</code> 参数来传递。如果你需要在构造函数上发送 ETH，这是必要的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address deployment = deployCode(&quot;MyContract.sol&quot;, abi.encode(arg1, arg2));</span><br></pre></td></tr></table></figure></li><li><p><strong>bound</strong>(uint256 x, uint256 min, uint256 max) returns (uint256 result)：一个数学函数，用于将模糊测试的输入包裹在一定范围内</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input = bound(input, 99, 101);</span><br><span class="line">返回99输入0。</span><br><span class="line">返回100输入1。</span><br><span class="line">返回101输入2。</span><br><span class="line">返回99输入3。</span><br></pre></td></tr></table></figure></li><li><p><strong>changePrank</strong>(address who)：</p></li><li><p><strong>makeAddr</strong>(string memory name) returns(address addr)：创建一个由所提供的 <code>name</code> 衍生的地址</p></li><li><p><strong>makeAddrAndKey</strong>(string memory name) returns(address addr, uint256 privateKey)：创建一个由提供的 <code>name</code> 衍生的地址和私钥。</p></li><li><p><strong>noGasMetering</strong>：一个函数修改器，在函数的生命周期内关闭 Gas 计量</p></li></ol><h2 id="Std-Errors"><a href="#Std-Errors" class="headerlink" title="Std Errors"></a>Std Errors</h2><ol><li><strong>assertionError</strong>：当断言失败时，Solidity 内部的错误</li><li><strong>arithmeticError</strong>：当算术运算失败时，Solidity 内部的错误，例如下溢和溢出</li><li><strong>divisionError</strong>：当除法失败时的 Solidity 内部错误，例如除以零</li><li><strong>enumConversionError</strong>：当试图将一个数字转换为一个枚举的变体时，如果该数字大于该枚举的变体数量（从0开始计算），则 Solidity 内部会出现错误</li><li><strong>encodeStorageError</strong>：当试图访问存储中被破坏的数据时的 Solidity 内部错误，除非使用了程序集，否则数据不会损坏。</li><li><strong>popError</strong>：当试图从一个空数组上弹出一个元素时，Solidity 内部的错误</li><li><strong>indexOOBError</strong>：当试图访问一个超出边界的数组元素时，Solidity 内部的错误</li><li><strong>memOverflowError</strong>：当试图分配一个超过 2^64-1 项的动态内存数组，Solidity 内部出现的错误</li><li><strong>zeroVarError</strong>：当试图通过一个尚未初始化的函数指针调用一个函数时，Solidity 的内部错误</li></ol><blockquote><p>为了捕捉的错误，我们在预计会导致下溢的函数调用之前插入<code>vm.expectRevert(stdError.arithmeticError)</code>。</p></blockquote><h2 id="Std-Storage"><a href="#Std-Storage" class="headerlink" title="Std Storage"></a>Std Storage</h2><p>Std Storage 是一个库，使操纵存储变得容易，要使用 Std Storage，在你的测试合约中添加以下一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using stdStorage for StdStorage;</span><br></pre></td></tr></table></figure><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>查询功能：</p><ul><li>target: 设置目标合约的地址</li><li>sig: 将函数的 4 字节选择器设置为静态调用</li><li>with_key: 传递一个参数给函数，可以多次使用以传递多个参数。顺序很重要。</li><li>depth: 设置值在 tuple 中的位置（例如，在 struct 中）。</li></ul><p>终端功能：</p><ul><li>find: 在给定的 target、sig、with_key(s) 和 depth 中找到一个任意的储存槽</li><li>checked_write: 设置要写到存储槽的数据</li><li>read_<type>:从存储槽中读取 <code>bytes32</code>，<code>bool</code>，<code>address</code>，<code>uint256</code>，或<code>int256</code> 的值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// MetaRPG.sol</span><br><span class="line">struct Character &#123;</span><br><span class="line">    string name;</span><br><span class="line">    uint256 level;</span><br><span class="line">&#125;</span><br><span class="line">// playerToCharacter跟踪玩家的角色信息。</span><br><span class="line">mapping (address =&gt; Character) public playerToCharacter;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// MetaRPG.t.sol</span><br><span class="line">// 比方说，我们想把我们的角色的等级设置为 120。</span><br><span class="line">stdstore</span><br><span class="line">    .target(address(metaRpg))</span><br><span class="line">    .sig(&quot;playerToCharacter(address)&quot;)</span><br><span class="line">    .with_key(address(this))</span><br><span class="line">    .depth(1)</span><br><span class="line">    .checked_write(120);</span><br></pre></td></tr></table></figure><h2 id="Std-Math"><a href="#Std-Math" class="headerlink" title="Std Math"></a>Std Math</h2><ol><li><strong>abs</strong>(int256 a) returns (uint256):返回一个数字的绝对值。</li><li><strong>delta</strong>(uint256 a, uint256 b) returns (uint256):返回两个数字的绝对值之差</li><li><strong>percentDelta</strong>(uint256 a, uint256 b) returns (uint256)：返回两个数字之间的差值，以百分比表示，其中 <code>1e18</code> 是 100%</li></ol><h2 id="Script-Utils"><a href="#Script-Utils" class="headerlink" title="Script Utils"></a><strong>Script Utils</strong></h2><ol><li><strong>computeCreateAddress</strong>(address deployer, uint256 nonce) returns (address)：对于给定的部署者地址和 nonce，计算合约将被部署到的地址。对预先计算合约将被部署的地址很有用</li><li><strong>deriveRememberKey</strong>(string memory mnemonic, uint32 index) returns (address who, uint256 privateKey)：从助记符中导出私钥，同时将其存储在 forge 的本地钱包中。返回地址和私钥。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Foundry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 合约框架 </tag>
            
            <tag> Foundry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-作弊码总结</title>
      <link href="/2023/02/26/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Foundry/8-%E4%BD%9C%E5%BC%8A%E7%A0%81%E6%80%BB%E7%BB%93/"/>
      <url>/2023/02/26/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Foundry/8-%E4%BD%9C%E5%BC%8A%E7%A0%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Environment-环境"><a href="#Environment-环境" class="headerlink" title="Environment  环境"></a>Environment  环境</h1><ol><li><p><strong>warp</strong>(uint256)：设置block.timestamp</p></li><li><p><strong>roll</strong>(uint256)：设置block.number</p></li><li><p><strong>fee</strong>(uint256)：设置block.basefee</p></li><li><p><strong>difficult</strong>(uint256)：设置block.difficulty</p></li><li><p><strong>chainId</strong>(uint256)：设置block.chainId</p></li><li><p><strong>store</strong>(address account, bytes32 slot, bytes32 value)：将 value 值存储在账户 account 的存储槽 slot 中</p></li><li><p><strong>load</strong>(address account, bytes32 slot) returns (bytes32)：从帐户上的存储槽位加载值</p></li><li><p><strong>etch</strong>(address who, bytes calldata code)：设置要编码的地址的字节码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bytes memory code = address(awesomeContract).code;</span><br><span class="line">address targetAddr = address(1);</span><br><span class="line">vm.etch(targetAddr, code);</span><br><span class="line">log_bytes(address(targetAddr).code); // 0x6080604052348015610010...</span><br></pre></td></tr></table></figure></li><li><p><strong>deal</strong>(address who, uint256 newBalance)：将地址余额设置为<code>newBalance</code></p></li><li><p><strong>prank</strong>(address)：将msg.sender设置为下次调用的指定地址,“下一个call”也包括静态调用，但不包括对作弊码地址的调用。<br><strong>prank</strong>(address sender, address origin)：如果使用了prank的替代签名，那么在下一次调用时也要设置tx.origin。</p></li><li><p><strong>startPrank</strong>：参数与prank一样，对于所有后续调用有效，直到 stopPrank 出现</p></li><li><p><strong>stopPrank</strong>：停止startPrank</p></li><li><p><strong>record</strong>：告诉VM开始记录所有存储读取和写入，要访问读取和写入，请使用access。</p></li><li><p><strong>accesses</strong>：获取某个地址上已被读取或写入的所有存储槽，需先调用record()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/// contract NumsContract &#123;</span><br><span class="line">///     uint256 public num1 = 100; // slot 0</span><br><span class="line">///     uint256 public num2 = 200; // slot 1</span><br><span class="line">/// &#125;</span><br><span class="line"></span><br><span class="line">vm.record();</span><br><span class="line">numsContract.num2();</span><br><span class="line">(bytes32[] memory reads, bytes32[] memory writes) = vm.accesses(</span><br><span class="line">  address(numsContract)</span><br><span class="line">);</span><br><span class="line">emit log_uint(uint256(reads[0])); // 1</span><br></pre></td></tr></table></figure></li><li><p><strong>recoedLogs</strong>：通知VM开始记录所有发出的事件，要访问它们，请使用getRecordedLogs。</p></li><li><p><strong>getRecordLogs</strong>：获取recordLogs记录的已发出事件，这个函数在被调用时将消耗记录的日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/// event LogCompleted(</span><br><span class="line">///   uint256 indexed topic1,</span><br><span class="line">///   bytes data</span><br><span class="line">/// );</span><br><span class="line"></span><br><span class="line">vm.recordLogs();</span><br><span class="line"></span><br><span class="line">emit LogCompleted(10, &quot;operation completed&quot;);</span><br><span class="line"></span><br><span class="line">Vm.Log[] memory entries = vm.getRecordedLogs();</span><br><span class="line"></span><br><span class="line">assertEq(entries.length, 1);</span><br><span class="line">assertEq(entries[0].topics[0], keccak256(&quot;LogCompleted(uint256,bytes)&quot;));</span><br><span class="line">assertEq(entries[0].topics[1], bytes32(uint256(10)));</span><br><span class="line">assertEq(abi.decode(entries[0].data, (string)), &quot;operation completed&quot;);</span><br></pre></td></tr></table></figure></li><li><p><strong>setNonce</strong>(address account, uint64 nonce)：设置给定Account的nonce，新的nonce必须大于帐户的当前nonce。</p></li><li><p><strong>getNonce</strong>(address account) returns (uint64)：获取给定Account的nonce</p></li><li><p><strong>mockCall</strong>(address where, bytes calldata data, bytes calldata retdata)：模拟对一个地址的所有调用，如果调用数据严格或松散地匹配数据，则返回retdata。<br>当一个呼叫被发出时，首先检查呼叫数据是否与数据完全匹配。如果不是，则检查调用数据以查看是否有部分匹配，匹配从调用数据的第一个字节开始。<br>如果找到匹配，则调用返回retdata。</p><p>mockCall(address where,uint256 value,bytes calldata data,bytes calldata retdata)：使用第二个签名，我们可以使用特定的msg.value来模拟调用。如果有歧义，则Calldata match优先于msg.value。</p></li><li><p><strong>clearMockedCalls</strong>：清除所有模拟call。</p></li><li><p><strong>coinbase</strong>(address)：设置block.coinbase</p></li><li><p><strong>broadcast</strong>( )、<strong>broadcast</strong>(address who)、<strong>broadcast</strong>(uint256 privateKey)：使用调用测试合约的地址或作为发送者提供的地址&#x2F;私钥，让下一个调用（仅在此调用深度）创建一个稍后可以在链上签名和发送的交易。</p></li><li><p><strong>startBroadcast</strong>：参数与broadcast一样，使用调用测试合约的地址或作为发送者提供的地址&#x2F;私钥，让所有后续调用（仅在此调用深度）创建稍后可以在链上签名和发送的交易。</p></li><li><p><strong>stopBroadcast</strong>：停止收集交易以供以后的链上广播。</p></li><li><p><strong>pauseGasMetering</strong>：暂停气体计量（即<code>gasleft()</code>不随着操作的执行而减少），通过关闭不必要的代码以及长时间运行的脚本（否则会耗尽 Gas）的 Gas 计量，这对于更好地了解 Gas 成本非常有用。</p></li><li><p><strong>resumeGasMetering</strong>：恢复燃气计量（即<code>gasleft()</code>随着操作的执行而减少）。天然气使用量将恢复到暂停时的相同量。</p></li></ol><h1 id="Assertions-断言"><a href="#Assertions-断言" class="headerlink" title="Assertions 断言"></a>Assertions 断言</h1><ol><li><p><strong>expectRevert</strong>( )、<strong>expectRevert</strong>(bytes4 msg)、<strong>expectRevert</strong>(bytes calldata msg)：如果下一个调用没有返回预期的消息msg，那么expectRevert将返回，在调用expectRevert之后，在恢复调用之前对其他作弊码的调用将被忽略，有3个签名：</p><ul><li><strong>不带参数</strong>：断言下一次call reverts，无论消息如何。</li><li>**With<code>bytes4</code>**：断言下一次call reverts为指定的 bytes4。</li><li>**With<code>bytes</code>**：断言下一次call reverts为指定的bytes。</li></ul></li><li><p><strong>expectEmit</strong>(bool checkTopic1,bool checkTopic2,bool checkTopic3,bool checkData)：断言主题匹配而不检查发射器地址</p><p><strong>expectEmit</strong>(bool checkTopic1,bool checkTopic2,bool checkTopic3,bool checkData,address emitter)：断言主题匹配并且发出地址匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">event Transfer(address indexed from, address indexed to, uint256 amount);</span><br><span class="line"></span><br><span class="line">function testERC20EmitsTransfer() public &#123;</span><br><span class="line">    vm.expectEmit(true, true, false, true, address(myToken));</span><br><span class="line">    emit MyToken.Transfer(address(this), address(1), 10);</span><br><span class="line">    // 执行调用</span><br><span class="line">    myToken.transfer(address(1), 10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>expectCall</strong>(address where, bytes calldata data)、<strong>expectCall</strong>(address where, uint256 value,bytes calldata data)：期望至少有一个对指定地址的调用，其中调用数据严格或松散匹配数据，第二个还可以检查调用是否使用预期的msg.value进行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Contract target = new Contract();</span><br><span class="line">vm.expectCall(address(target),1,abi.encodeWithSelector(target.pay.selector, 2));</span><br><span class="line">target.pay&#123;value: 1&#125;(2);</span><br></pre></td></tr></table></figure></li></ol><h1 id="Fuzzer-模糊"><a href="#Fuzzer-模糊" class="headerlink" title="Fuzzer 模糊"></a>Fuzzer 模糊</h1><ol><li><p><strong>assume</strong>(bool)：false，模糊器将丢弃当前的模糊输入并开始新的模糊运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function testSomething(uint256 a) public &#123;</span><br><span class="line">    vm.assume(a != 1);</span><br><span class="line">    require(a != 1);</span><br><span class="line">    // [PASS]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Forking-分叉"><a href="#Forking-分叉" class="headerlink" title="Forking 分叉"></a>Forking 分叉</h1><ol><li><p><strong>createFork</strong>(string calldata urlOrAlias)、<strong>createFork</strong>(string calldata urlOrAlias，uint256 block)、<strong>createFork</strong>(string calldata urlOrAlias，bytes32 transaction) returns (uint256)：从给定端点创建新的分叉，并返回该分叉的标识符，如果将块号作为参数传递，则分叉将从该块开始，否则它将从最新的块开始  <em>latest</em> ，如果提供了交易哈希，它将把分叉滚动到交易被挖掘的区块，并重播所有以前执行的交易。 </p></li><li><p><strong>selectFork</strong>(uint256 forkId)：接受由createFork创建的fork标识符，并将相应的fork状态设置为活动状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uint256 forkId = vm.createFork(MAINNET_RPC_URL, 1_337_000);</span><br><span class="line">vm.selectFork(forkId);</span><br><span class="line"></span><br><span class="line">assertEq(block.number, 1_337_000);</span><br></pre></td></tr></table></figure></li><li><p><strong>createSelectFork</strong>(string calldata urlOrAlias)、<strong>createSelectFork</strong>(string calldata urlOrAlias，uint256 block) returns (uint256)：<br>createFork + selectFork</p></li><li><p><strong>activeFork</strong>() returns (uint256)：返回当前活动分叉的标识符，如果当前没有分叉处于活动状态，则还原。 </p></li><li><p><strong>rollFork</strong>(uint256 blockNumber)、<strong>rollFork</strong>(bytes32 transaction)、<strong>rollFork</strong>(uint256 forkId, uint256 blockNumber)、<strong>rollFork</strong>(uint256 forkId, bytes32 transaction)：更新分叉，如果没传forkId表示更新当前活动分叉</p></li><li><p><strong>makePersistent</strong>(address)、<strong>makePersistent</strong>(address，address)、<strong>makePersistent</strong>(address，address，address)、<strong>makePersistent</strong>(address[] calldata)：将指定帐户标记为持久帐户，每个叉子createFork有自己独立的存储，只有测试合约账户和调用者在分叉之间是持久的</p></li><li><p><strong>revokePersistent</strong>(address)、<strong>revokePersistent</strong>(address[] calldata)：将指定帐户撤销标记为持久帐户</p></li><li><p><strong>isPersistent</strong>(address) returns (bool)：判断指定帐户标记是否为持久帐户</p></li><li><p><strong>allowCheatcodes</strong>(address)：在分叉模式下，显式授予给定地址作弊码访问权限</p></li><li><p><strong>transact</strong>(bytes32 txHash)、<strong>transact</strong>(uint256 forkId, bytes32 txHash)：在分叉模式下，获取交易并在当前状态下执行交易</p></li></ol><h1 id="External-外部"><a href="#External-外部" class="headerlink" title="External 外部"></a>External 外部</h1><ol><li><p><strong>ffi</strong>(string[] calldata) returns (bytes memory)：如果启用了ffi，则可以调用任意命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string[] memory inputs = new string[](3);</span><br><span class="line">inputs[0] = &quot;echo&quot;;</span><br><span class="line">inputs[1] = &quot;-n&quot;;</span><br><span class="line">inputs[2] = &quot;gm&quot;;</span><br><span class="line"></span><br><span class="line">bytes memory res = vm.ffi(inputs);</span><br><span class="line">assertEq(string(res), &quot;gm&quot;);</span><br></pre></td></tr></table></figure></li><li><p><strong>projectRoot</strong>() returns (string memory)：返回当前项目的根目录</p></li><li><p><strong>getCode</strong>(string calldata) returns (bytes memory)：返回给定合约路径的创建字节码。调用数据参数可以是以下形式  <code>ContractFile.sol</code> （如果文件名和合约名称相同），  <code>ContractFile.sol:ContractName</code>或相对于项目根目录的项目路径。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyContract myContract = new MyContract(arg1, arg2);</span><br><span class="line">bytes memory args = abi.encode(arg1, arg2);</span><br><span class="line">bytes memory bytecode = abi.encodePacked(vm.getCode(&quot;MyContract.sol:MyContract&quot;), args);</span><br><span class="line">address anotherAddress;</span><br><span class="line">assembly &#123;</span><br><span class="line">    anotherAddress := create(0, add(bytecode, 0x20), mload(bytecode))</span><br><span class="line">&#125;</span><br><span class="line">assertEq0(address(myContract).code, anotherAddress.code); // [PASS]</span><br></pre></td></tr></table></figure></li><li><p><strong>getDeployedCode</strong>(string calldata) returns (bytes memory)：只返回部署的字节码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract Override &#123;</span><br><span class="line">    event Payload(address sender, address target, bytes data);</span><br><span class="line">    function emitPayload(address target, bytes calldata message) external payable returns (uint256) &#123;</span><br><span class="line">        emit Payload(msg.sender, target, message);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bytes memory code = vm.getDeployedCode(&quot;Override.sol:Override&quot;);</span><br><span class="line">address overrideAddress = address(64);</span><br><span class="line">vm.etch(overrideAddress, code);</span><br><span class="line">assertEq(overrideAddress.code,code)</span><br></pre></td></tr></table></figure></li><li><p><strong>setEnv</strong>(string calldata key, string calldata value)：设置环境变量 <code>key=value</code></p></li><li><p><strong>envOr</strong>：读取任何类型的环境变量的无失败方法：如果请求的环境键不存在，<code>envOr()</code>将返回默认值而不是revert（也适用于数组）,<br>返回的类型由传递的参数<code>defaultValue</code>类型决定，delimiter为分割符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function envOr(string calldata key, bool defaultValue) external returns (bool value);</span><br><span class="line">function envOr(string calldata key, uint256 defaultValue) external returns (uint256 value);</span><br><span class="line">function envOr(string calldata key, int256 defaultValue) external returns (int256 value);</span><br><span class="line">function envOr(string calldata key, address defaultValue) external returns (address value);</span><br><span class="line">function envOr(string calldata key, bytes32 defaultValue) external returns (bytes32 value);</span><br><span class="line">function envOr(string calldata key, string calldata defaultValue) external returns (string memory value);</span><br><span class="line">function envOr(string calldata key, bytes calldata defaultValue) external returns (bytes memory value);</span><br><span class="line"></span><br><span class="line">function envOr(string calldata key, string calldata delimiter, bool[] calldata defaultValue) external returns (bool[] memory value);</span><br><span class="line">function envOr(string calldata key, string calldata delimiter, uint256[] calldata defaultValue) external returns (uint256[] memory value);</span><br><span class="line">function envOr(string calldata key, string calldata delimiter, int256[] calldata defaultValue) external returns (int256[] memory value);</span><br><span class="line">function envOr(string calldata key, string calldata delimiter, address[] calldata defaultValue) external returns (address[] memory value);</span><br><span class="line">function envOr(string calldata key, string calldata delimiter, bytes32[] calldata defaultValue) external returns (bytes32[] memory value);</span><br><span class="line">function envOr(string calldata key, string calldata delimiter, string[] calldata defaultValue) external returns (string[] memory value);</span><br><span class="line">function envOr(string calldata key, string calldata delimiter, bytes[] calldata defaultValue) external returns (bytes[] memory value);</span><br></pre></td></tr></table></figure></li><li><p><strong>envBool</strong>(string calldata key) returns (bool value)、<strong>envBool</strong>(string calldata key, string calldata delimiter) returns (bool[] memory values);：将环境变量读取为 <code>bool</code>或者 <code>bool[]</code></p></li><li><p><strong>envUint</strong>：将环境变量读取为 <code>uint256</code>或者 <code>uint256[]</code>. </p></li><li><p><strong>envInt</strong>：将环境变量读取为 <code>int256</code>或者 <code>int256[]</code></p></li><li><p><strong>envAddress</strong>：将环境变量读取为 <code>address</code>或者 <code>address[]</code></p></li><li><p><strong>envBytes32</strong>：将环境变量读取为 <code>bytes32</code>或者 <code>address[]</code>. </p></li><li><p><strong>envString</strong>：将环境变量读取为 <code>string</code>或者 <code>string[]</code></p></li><li><p><strong>envBytes</strong>：将环境变量读取为 <code>bytes</code>或者 <code>bytes[]</code>. </p></li><li><p><strong>parseJson</strong>：解析字符串形式的 JSON 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string memory root = vm.projectRoot();</span><br><span class="line">string memory path = string.concat(root, &quot;/src/test/fixtures/broadcast.log.json&quot;);</span><br><span class="line">string memory json = vm.readFile(path);</span><br><span class="line">bytes memory transactionDetails = json.parseRaw(&quot;.transactions[0].tx&quot;);</span><br><span class="line">RawTx1559Detail memory rawTxDetail = abi.decode(transactionDetails, (RawTx1559Detail));</span><br><span class="line"></span><br><span class="line">// 返回与“key”对应的值</span><br><span class="line">vm.parseJson(string memory json, string memory key)</span><br><span class="line">// 返回整个json文件</span><br><span class="line">vm.parseJson(string memory json);</span><br></pre></td></tr></table></figure></li></ol><h1 id="Utilities-实用程序"><a href="#Utilities-实用程序" class="headerlink" title="Utilities 实用程序"></a>Utilities 实用程序</h1><ol><li><p><strong>addr</strong>(uint256 privateKey) returns (address)：计算给定私钥的地址。</p></li><li><p><strong>sign</strong>(uint256 privateKey, bytes32 digest) returns (uint8 v, bytes32 r, bytes32 s)：使用私钥 privateKey 签署摘要摘要，返回 (v, r, s)。 这对于测试获取签名数据并执行 ecrecover 来验证签名者的函数非常有用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">address alice = vm.addr(1);</span><br><span class="line">bytes32 hash = keccak256(&quot;Signed by Alice&quot;);</span><br><span class="line">(uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);</span><br><span class="line">address signer = ecrecover(hash, v, r, s);</span><br><span class="line">assertEq(alice, signer); // [PASS]</span><br></pre></td></tr></table></figure></li><li><p><strong>label</strong>(address addr, string calldata label)：为测试跟踪中的 addr 设置标签 label， 如果地址被标记，则测试跟踪中将显示标签而不是地址。</p></li><li><p><strong>deriveKey</strong>(string calldata mnemonic, uint32 index) returns (uint256)：在导出路径m&#x2F;44’&#x2F;60’&#x2F;0’&#x2F;0&#x2F;{index}处导出。</p><p><strong>deriveKey</strong>(string calldata mnemonic, string calldata path,uint32 index) returns (uint256)：允许您指定派生路径作为第二个参数。</p><p>从给定的助记词或助记词文件路径派生私钥。 </p></li><li><p><strong>rememberKey</strong>(uint256 privateKey) returns (address)：将私钥存储在forge的本地钱包中并返回相应的地址，该地址稍后可用于广播。</p></li><li><p><strong>toString</strong>：将任何类型转换为其字符串版本。</p></li></ol><h1 id="Snapshots-快照"><a href="#Snapshots-快照" class="headerlink" title="Snapshots 快照"></a>Snapshots 快照</h1><p>1.<strong>snapshot</strong>() returns(uint256)：拍摄区块链状态的快照并返回创建的快照的标识符</p><p>2.<strong>revertTo</strong>(uint256) returns(bool)：将区块链的状态恢复到给定的快照。 这将删除给定的快照以及此后拍摄的任何快照（例如：恢复到 id 1 将删除 id 2、3 等的快照）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct Storage &#123;</span><br><span class="line">    uint slot0;</span><br><span class="line">    uint slot1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SnapshotTest is Test &#123;</span><br><span class="line">    Cheats constant cheats = Cheats(HEVM_ADDRESS);</span><br><span class="line"></span><br><span class="line">    Storage store;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        store.slot0 = 10;</span><br><span class="line">        store.slot1 = 20;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testSnapshot() public &#123;</span><br><span class="line">        uint256 snapshot = cheats.snapshot();</span><br><span class="line">        store.slot0 = 300;</span><br><span class="line">        store.slot1 = 400;</span><br><span class="line"></span><br><span class="line">        assertEq(store.slot0, 300);</span><br><span class="line">        assertEq(store.slot1, 400);</span><br><span class="line"></span><br><span class="line">        // after resetting to a snapshot all changes are discarded</span><br><span class="line">        cheats.revertTo(snapshot);</span><br><span class="line">        assertEq(store.slot0, 10, &quot;snapshot revert for slot 0 unsuccessful&quot;);</span><br><span class="line">        assertEq(store.slot1, 20, &quot;snapshot revert for slot 1 unsuccessful&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="RPC-远程过程调用"><a href="#RPC-远程过程调用" class="headerlink" title="RPC 远程过程调用"></a>RPC 远程过程调用</h1><p><strong>rpcUrl</strong>(string calldata alias) returns(string memory)：返回已配置别名的 URL</p><p><strong>rpcUrls</strong>() returns(string[2] [] memory)：返回所有配置的（别名、URL）对</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --snip--</span></span><br><span class="line"><span class="section">[rpc_endpoints]</span></span><br><span class="line"><span class="attr">optimism</span> = <span class="string">&quot;https://optimism.alchemyapi.io/v2/...&quot;</span></span><br><span class="line"><span class="attr">mainnet</span> = <span class="string">&quot;$&#123;RPC_MAINNET&#125;&quot;</span> </span><br><span class="line"></span><br><span class="line">string memory <span class="attr">url</span> = vm.rpcUrl(<span class="string">&quot;optimism&quot;</span>)<span class="comment">;</span></span><br><span class="line">assertEq(url, &quot;https://optimism.alchemyapi.io/v2/...&quot;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h1 id="Files-文件"><a href="#Files-文件" class="headerlink" title="Files 文件"></a>Files 文件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 读取文件的全部内容到字符串，(path) =&gt; (data)</span><br><span class="line">function readFile(string calldata) external returns (string memory);</span><br><span class="line">// 读取文件的下一行为字符串，(path) =&gt; (line)</span><br><span class="line">function readLine(string calldata) external returns (string memory);</span><br><span class="line">// 将数据写入文件，如果不存在则创建一个文件，如果存在则完全替换其内容,(path, data) =&gt; ()</span><br><span class="line">function writeFile(string calldata, string calldata) external;</span><br><span class="line">// 将行写入文件，如果不存在则创建一个文件,(path, data) =&gt; ()</span><br><span class="line">function writeLine(string calldata, string calldata) external;</span><br><span class="line">// 关闭文件读取，重置偏移量并允许从readLine开始读取,(path) =&gt; ()</span><br><span class="line">function closeFile(string calldata) external;</span><br><span class="line">// 删除文件。该作弊代码将在以下情况下恢复，但不限于这些情况:Path指向一个目录、文件不存在、用户没有权限删除文件,(path) =&gt; ()</span><br><span class="line">function removeFile(string calldata) external;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Foundry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 合约框架 </tag>
            
            <tag> Foundry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-DSTest</title>
      <link href="/2023/02/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Foundry/7-DSTest/"/>
      <url>/2023/02/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Foundry/7-DSTest/</url>
      
        <content type="html"><![CDATA[<h1 id="DSTest-Reference"><a href="#DSTest-Reference" class="headerlink" title="DSTest Reference"></a>DSTest Reference</h1><p>Dappsys Test（简称DSTest）提供基本的日志和断言功能</p><h2 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h2><p>这是对所有可用的日志事件的完整概述。关于详细的描述和使用实例，见下文。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">event log                    (string);</span><br><span class="line">event logs                   (bytes);</span><br><span class="line"></span><br><span class="line">event log_address            (address);</span><br><span class="line">event log_bytes32            (bytes32);</span><br><span class="line">event log_int                (int);</span><br><span class="line">event log_uint               (uint);</span><br><span class="line">event log_bytes              (bytes);</span><br><span class="line">event log_string             (string);</span><br><span class="line"></span><br><span class="line">event log_named_address      (string key, address val);</span><br><span class="line">event log_named_bytes32      (string key, bytes32 val);</span><br><span class="line">event log_named_decimal_int  (string key, int val, uint decimals);</span><br><span class="line">event log_named_decimal_uint (string key, uint val, uint decimals);</span><br><span class="line">event log_named_int          (string key, int val);</span><br><span class="line">event log_named_uint         (string key, uint val);</span><br><span class="line">event log_named_bytes        (string key, bytes val);</span><br><span class="line">event log_named_string       (string key, string val);</span><br></pre></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>这是对所有可用断言功能的完整概述。关于详细的描述和使用实例，见下文。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// 断言 `条件` 为真</span><br><span class="line">function assertTrue(bool condition) internal;</span><br><span class="line">function assertTrue(bool condition, string memory err) internal;</span><br><span class="line"></span><br><span class="line">// 断言 `a` 等于 `b`</span><br><span class="line">function assertEq(address a, address b) internal;</span><br><span class="line">function assertEq(address a, address b, string memory err) internal;</span><br><span class="line">function assertEq(bytes32 a, bytes32 b) internal;</span><br><span class="line">function assertEq(bytes32 a, bytes32 b, string memory err) internal;</span><br><span class="line">function assertEq(int a, int b) internal;</span><br><span class="line">function assertEq(int a, int b, string memory err) internal;</span><br><span class="line">function assertEq(uint a, uint b) internal;</span><br><span class="line">function assertEq(uint a, uint b, string memory err) internal;</span><br><span class="line">function assertEqDecimal(int a, int b, uint decimals) internal;</span><br><span class="line">function assertEqDecimal(int a, int b, uint decimals, string memory err) internal;</span><br><span class="line">function assertEqDecimal(uint a, uint b, uint decimals) internal;</span><br><span class="line">function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal;</span><br><span class="line">function assertEq(string memory a, string memory b) internal;</span><br><span class="line">function assertEq(string memory a, string memory b, string memory err) internal;</span><br><span class="line">function assertEq32(bytes32 a, bytes32 b) internal;</span><br><span class="line">function assertEq32(bytes32 a, bytes32 b, string memory err) internal;</span><br><span class="line">function assertEq0(bytes memory a, bytes memory b) internal;</span><br><span class="line">function assertEq0(bytes memory a, bytes memory b, string memory err) internal;</span><br><span class="line"></span><br><span class="line">// 断言  `a` 大于 `b`</span><br><span class="line">function assertGt(uint a, uint b) internal;</span><br><span class="line">function assertGt(uint a, uint b, string memory err) internal;</span><br><span class="line">function assertGt(int a, int b) internal;</span><br><span class="line">function assertGt(int a, int b, string memory err) internal;</span><br><span class="line">function assertGtDecimal(int a, int b, uint decimals) internal;</span><br><span class="line">function assertGtDecimal(int a, int b, uint decimals, string memory err) internal;</span><br><span class="line">function assertGtDecimal(uint a, uint b, uint decimals) internal;</span><br><span class="line">function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal;</span><br><span class="line"></span><br><span class="line">// 断言  `a` 大于等于 `b`</span><br><span class="line">function assertGe(uint a, uint b) internal;</span><br><span class="line">function assertGe(uint a, uint b, string memory err) internal;</span><br><span class="line">function assertGe(int a, int b) internal;</span><br><span class="line">function assertGe(int a, int b, string memory err) internal;</span><br><span class="line">function assertGeDecimal(int a, int b, uint decimals) internal;</span><br><span class="line">function assertGeDecimal(int a, int b, uint decimals, string memory err) internal;</span><br><span class="line">function assertGeDecimal(uint a, uint b, uint decimals) internal;</span><br><span class="line">function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal;</span><br><span class="line"></span><br><span class="line">// 断言  `a` 小于 `b`</span><br><span class="line">function assertLt(uint a, uint b) internal;</span><br><span class="line">function assertLt(uint a, uint b, string memory err) internal;</span><br><span class="line">function assertLt(int a, int b) internal;</span><br><span class="line">function assertLt(int a, int b, string memory err) internal;</span><br><span class="line">function assertLtDecimal(int a, int b, uint decimals) internal;</span><br><span class="line">function assertLtDecimal(int a, int b, uint decimals, string memory err) internal;</span><br><span class="line">function assertLtDecimal(uint a, uint b, uint decimals) internal;</span><br><span class="line">function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal;</span><br><span class="line"></span><br><span class="line">// 断言  `a` 小于等于 `b`</span><br><span class="line">function assertLe(uint a, uint b) internal;</span><br><span class="line">function assertLe(uint a, uint b, string memory err) internal;</span><br><span class="line">function assertLe(int a, int b) internal;</span><br><span class="line">function assertLe(int a, int b, string memory err) internal;</span><br><span class="line">function assertLeDecimal(int a, int b, uint decimals) internal;</span><br><span class="line">function assertLeDecimal(int a, int b, uint decimals, string memory err) internal;</span><br><span class="line">function assertLeDecimal(uint a, uint b, uint decimals) internal;</span><br><span class="line">function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Foundry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 合约框架 </tag>
            
            <tag> Foundry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-配置</title>
      <link href="/2023/02/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Foundry/6-%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/02/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Foundry/6-%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-foundry-toml-配置"><a href="#使用-foundry-toml-配置" class="headerlink" title="使用 foundry.toml 配置"></a>使用 foundry.toml 配置</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>配置可以由配置文件命名空间。默认配置文件名为 default，所有其他配置文件都继承自该配置文件。</p><p> 您可以自由自定义 default 配置文件，并根据需要添加任意数量的新配置文件。</p><p>让我们看一下包含两个配置文件的配置文件：始终启用优化器的默认配置文件，以及始终显示跟踪的 CI 配置文件：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.default]</span></span><br><span class="line"><span class="attr">optimizer</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">optimizer_runs</span> = <span class="number">20_000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[profile.ci]</span></span><br><span class="line"><span class="attr">verbosity</span> = <span class="number">4</span></span><br></pre></td></tr></table></figure><p>运行 forge 时，您可以使用 FOUNDRY_PROFILE 环境变量指定要使用的配置文件。</p><p>除了配置文件部分，配置文件还可以包含独立部分（[fmt]、[fuzz]、[invariant] 等）。 </p><p>默认情况下，每个独立部分都属于 default 配置文件。 即 [fmt] 等同于 [profile.default.fmt]。</p><p>要为 default 以外的不同配置文件配置独立部分，请使用语法 [profile.<profile name>.<standalone>]。 即 [profile.ci.fuzz]。</p><h2 id="Project：通常与项目相关的配置"><a href="#Project：通常与项目相关的配置" class="headerlink" title="Project：通常与项目相关的配置"></a>Project：通常与项目相关的配置</h2><ol><li>src：类型: string，默认值: src，环境变量: FOUNDRY_SRC 或 DAPP_SRC，相对于项目根目录的合约源代码的路径。</li><li>test：类型: string，默认值: test，环境变量: FOUNDRY_TEST 或 DAPP_TEST，相对于项目根目录的合约测试源代码的路径。</li><li>out：类型: string，默认值: out，环境变量: FOUNDRY_OUT 或 DAPP_OUT放置合约输出的路径，相对于项目根目录。</li><li>libs：类型: 字符串数组 (路径)，默认值: lib，环境变量: FOUNDRY_LIBS 或 DAPP_LIBS一个包含库的路径数组，相对于项目根目录。</li><li>cache：类型: boolean，默认值: true，环境变量: FOUNDRY_CACHE 或 DAPP_CACHE是否启用缓存，如果启用，编译源代码、测试和依赖关系的结果将缓存在 cache 中。</li><li>cache_path：类型: string，默认值: cache，环境变量: FOUNDRY_CACHE_PATH 或 DAPP_CACHE_PATH缓存的路径，相对于项目根目录。</li><li>broadcast：类型: string，默认值: broadcast，广播交易日志的路径，相对于项目根目录。</li><li>force：类型: boolean，默认值: false，环境变量: FOUNDRY_FORCE 或 DAPP_FORCE是否执行干净构建，丢弃缓存。</li></ol><h2 id="Solidity编译器：与-Solidity-编译器的行为有关的配置"><a href="#Solidity编译器：与-Solidity-编译器的行为有关的配置" class="headerlink" title="Solidity编译器：与 Solidity 编译器的行为有关的配置"></a>Solidity编译器：与 Solidity 编译器的行为有关的配置</h2><ol><li><p>remappings：类型: 字符串数组 (remappings)，默认值: none，环境变量: FOUNDRY_REMAPPINGS 或 DAPP_REMAPPINGS</p><p>一个格式如下的重映射数组: <name>&#x3D;<target>，一个重映射 让 Solidity 从不同的目录导入。例如，下面的重映射：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@openzeppelin/=node_modules/@openzeppelin/openzeppelin-contracts/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &quot;@openzeppelin/contracts/utils/Context.sol&quot;;</span><br><span class="line">// 相当于</span><br><span class="line">import &quot;node_modules/@openzeppelin/openzeppelin-contracts/contracts/utils/Context.sol&quot;;</span><br></pre></td></tr></table></figure></li><li><p>auto_detect_remappings：类型: boolean，默认值: true，环境变量: FOUNDRY_AUTO_DETECT_REMAPPINGS 或 DAPP_AUTO_DETECT_REMAPPINGS</p><p>如果启用，Foundry 将自动尝试通过扫描 libs 文件夹来自动检测重映射，如果设置为 false，则只使用 foundry.toml 和 remappings.txt 中的重映射。</p></li><li><p>allow_paths：类型: array of strings (paths)，默认值: none，环境变量: FOUNDRY_ALLOW_PATHS 或 DAPP_ALLOW_PATHS</p><p>告诉 solc 允许从其他目录读取源文件。这主要适用于由 pnmp 或类似文件管理的复杂工作区。</p></li><li><p>include_paths：类型: array of strings (paths)，默认值: none，环境变量: FOUNDRY_INCLUDE_PATHS 或 DAPP_INCLUDE_PATHS</p><p>为默认导入回调提供一个额外的源代码目录。如果你想导入与你的主源码树相比位置不固定的合约，例如，使用软件包管理器安装的第三方库，请使用此选项。可以多次使用。只有当基本路径有一个非空值时才能使用。</p></li><li><p>libraries：类型: array of strings (libraries)，默认值: none，环境变量: FOUNDRY_LIBRARIES 或 DAPP_LIBRARIES</p><p>一个要链接的库的数组，格式如下。<file>:<lib>:<address>，例如：src&#x2F;MyLibrary.sol:MyLibrary:0xfD88CeE74f7D78697775aBDAE53f9Da1559728E4。</p></li><li><p>solc_version：类型: string (semver)，默认值: none，环境变量: FOUNDRY_SOLC_VERSION 或 DAPP_SOLC_VERSION</p><p>如果指定，则覆盖自动检测系统（更多内容见下文）并为项目使用单一的 Solidity 编译器版本，只支持严格的版本（即 0.8.11 有效，但 ^0.8.0 无效）。</p></li><li><p>auto_detect_solc：类型: boolean，默认值: true，环境变量: FOUNDRY_AUTO_DETECT_SOLC or DAPP_AUTO_DETECT_SOLC</p><p>如果启用，Foundry 将自动尝试解决适当的 Solidity 编译器版本来编译您的项目，如果设置了 solc_version，这个键就会被忽略</p></li><li><p>offline：类型: boolean，默认值: false，环境变量: FOUNDRY_OFFLINE or DAPP_OFFLINE</p><p>如果启用，Foundry 将不会尝试下载任何丢失的 solc 版本，如果 offline 和 auto-detect-solc 都被设置为 true，所需的 solc 版本将被自动检测，但任何缺失的版本将不会被安装。</p></li><li><p>ignored_error_codes：类型: array of integers，默认值: none for source, SPDX license identifiers and contract size for tests，环境变量: FOUNDRY_IGNORED_ERROR_CODES or DAPP_IGNORED_ERROR_CODES</p><p>Solidity 编译器错误代码的数组，以便在构建期间忽略，例如警告。</p></li><li><p>evm_version：类型: string，默认值: london，环境变量: FOUNDRY_EVM_VERSION or DAPP_EVM_VERSION</p><p>测试中使用的 EVM 版本。该值必须是 EVM 的硬分叉名称，如 london，byzantium 等等。</p></li><li><p>revert_strings：类型: string，默认值: default，环境变量: FOUNDRY_REVERT_STRINGS or DAPP_REVERT_STRINGS</p><p>有效值为：</p><ul><li><p>default 不注入编译器生成的 revert 字符串，而是保留用户提供的 revert 字符串。</p></li><li><p>strip 删除所有的 revert 字符串（如果可能的话，即如果使用了字面量），以保持副作用。</p></li><li><p>debug 为编译器生成的内部 revert 注入字符串，目前为ABI编码器 V1 和 V2 实现。</p></li><li><p>verboseDebug 甚至为用户提供的 revert 字符串添加进一步的信息（尚未实现）。</p></li></ul></li><li><p>extra_output_files：类型: array of strings，默认值: none，环境变量: N&#x2F;A</p><p>来自 Solidity 编译器的额外输出，应该被写入 artifacts 目录中的文件。</p><p>有效值为：</p><ul><li><p>metadata: 在 artifacts 目录中写入 metadata.json 文件</p></li><li><p>ir: 在 artifacts 目录中写入 .ir 文件</p></li><li><p>irOptimized: 在 artifacts 目录中写入 .iropt 文件</p></li><li><p>ewasm: 在 artifacts 目录中写入 .ewasm 文件</p></li><li><p>evm.assembly: 在 artifacts 目录中写入 .asm 文件</p></li></ul></li><li><p>extra_output：类型: array of strings，默认值: see below，环境变量: N&#x2F;A</p><p>在合约 artifact 目录中的额外输出，以下数值总是被设置，因为它们是Forge所需要的：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extra_output</span> = [</span><br><span class="line">  <span class="string">&quot;abi&quot;</span>,</span><br><span class="line">  <span class="string">&quot;evm.bytecode&quot;</span>,</span><br><span class="line">  <span class="string">&quot;evm.deployedBytecode&quot;</span>,</span><br><span class="line">  <span class="string">&quot;evm.methodIdentifiers&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>bytecode_hash：类型: string，默认值: ipfs，环境变量: FOUNDRY_BYTECODE_HASH or DAPP_BYTECODE_HASH</p><p>确定附加到字节码上的元数据哈希值的哈希方法。有效值为：ipfs (default)、bzzr1、none</p></li><li><p>sparse_mode：类型: boolean，默认值: false，环境变量: FOUNDRY_SPARSE_MODE or DAPP_SPARSE_MODE</p><p>启用 sparse mode 进行构建。</p></li></ol><h3 id="Optimizer：与-Solidity-优化器有关的配置"><a href="#Optimizer：与-Solidity-优化器有关的配置" class="headerlink" title="Optimizer：与 Solidity 优化器有关的配置"></a>Optimizer：与 Solidity 优化器有关的配置</h3><ol><li><p>optimizer：类型: boolean，默认值: true，环境变量: FOUNDRY_OPTIMIZER 或 DAPP_OPTIMIZER</p><p>是否要启用 Solidity 优化器。</p></li><li><p>optimizer_runs：类型: integer，默认值: 200，环境变量: FOUNDRY_OPTIMIZER_RUNS 或 DAPP_OPTIMIZER_RUNS</p><p>要执行的优化器 runs 的数量。</p></li><li><p>via_ir：类型: boolean，默认值: false，环境变量: FOUNDRY_VIA_IR 或 DAPP_VIA_IR</p><p>如果设置为 true，通过新的 IR 优化器改变编译管道.</p><p>[optimizer_details]:优化器细节部分用于调整 Solidity 优化器的行为方式</p><p>在此部分有几个可配置的值（每个都是布尔值）：</p><p>peephole、inliner、jumpdest_remover、order_literals、deduplicate、cse、constant_optimizer、yul</p><p>[optimizer_details.yul_details]:优化器细节部分的 Yul 细节小节是用来调整新的 IR 优化器的行为方式的</p><p>有两个配置值：</p><p>stack_allocation: 试图通过提前释放堆栈槽来改善堆栈槽的分配。</p><p>optimizer_steps: 选择要应用的优化器步骤。</p><blockquote><p>如果你在使用 via_ir 时遇到编译器错误，请明确启用传统的 optimizer，并将optimizer_steps 设为空字符串。</p></blockquote></li></ol><h3 id="Model-checker"><a href="#Model-checker" class="headerlink" title="Model checker"></a>Model checker</h3><p>Solidity 模型检查器是一个内置的选择模块，可用于 OSX 和 Linux 的 Solidity 编译器中</p><blockquote><p>模型检查器需要在 Linux 上的 z3 版本为 4.8.8 或 4.8.14。</p></blockquote><p>模型检查器的设置是在配置的 <a href="%E5%9C%A8%E6%A8%A1%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%99%A8%E9%83%A8%E5%88%86%E6%9C%89%E4%BB%A5%E4%B8%8B%E9%94%AE%E3%80%82">model_checker</a> 部分配置的</p><p>当调用 forge build 时，模型检查器将运行，任何发现将显示为警告。</p><p>以下是使用模型检查器时的推荐设置：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.default.model_checker]</span></span><br><span class="line"><span class="attr">contracts</span> = &#123;<span class="string">&#x27;/path/to/project/src/Contract.sol&#x27;</span> = [<span class="string">&#x27;Contract&#x27;</span>]&#125;</span><br><span class="line"><span class="attr">engine</span> = <span class="string">&#x27;chc&#x27;</span></span><br><span class="line"><span class="attr">timeout</span> = <span class="number">10000</span></span><br><span class="line"><span class="attr">targets</span> = [<span class="string">&#x27;assert&#x27;</span>]</span><br></pre></td></tr></table></figure><p>设置哪个合约需要被验证是非常重要的，否则所有可用的合约都会被验证，这可能需要很长的时间。</p><p>推荐的引擎是 chc，但 bmc 和 all (同时运行) 也可以接受。</p><p>设置适当的超时（以毫秒为单位）也很重要，因为给底层编码器的默认时间可能是不够的。</p><p>如果没有给出验证目标，将只检查断言。</p><ol><li><p>model_checker.contracts：类型: table，默认值: all，环境变量: N&#x2F;A</p><p>指定模型检查器分析哪些合约。table 的键是源文件的路径，而值是要检查的合约名称的数组。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.default.model_checker]</span></span><br><span class="line"><span class="attr">contracts</span> = &#123; <span class="string">&quot;src/MyContracts.sol&quot;</span> = [<span class="string">&quot;ContractA&quot;</span>, <span class="string">&quot;ContractB&quot;</span>] &#125;</span><br></pre></td></tr></table></figure></li><li><p>model_checker.engine：类型: string (see below)，默认值: all，环境变量: N&#x2F;A</p><p>指定要运行的模型检查器引擎。有效值是：</p><ul><li><p>chc: 受约束 horn clauses 引擎</p></li><li><p>bmc: 有界限的模型检查器引擎</p></li><li><p>all: 同时运行两种引擎</p></li></ul></li><li><p>model_checker.timeout：类型: number (milliseconds)，默认值: N&#x2F;A，环境变量: N&#x2F;A</p><p>设置底层模型检查器引擎的超时（以毫秒为单位）。</p></li><li><p>model_checker.targets：类型: array of strings，默认值: assert，环境变量: N&#x2F;A</p><p>设置模型检查器的目标。有效值是：</p><ul><li><p>assert: 断言</p></li><li><p>underflow: 算术下溢</p></li><li><p>overflow: 算术溢出</p></li><li><p>divByZero: 除以零</p></li><li><p>constantCondition: 琐碎的条件和无法到达的代码</p></li><li><p>popEmptyArray: 弹出一个空数组</p></li><li><p>outOfBounds: 越界的数组&#x2F;固定字节索引访问</p></li><li><p>default: 以上所有（注意：不是Forge的默认值）</p></li></ul></li></ol><h2 id="Test测试与-forge-test-的行为有关的配置"><a href="#Test测试与-forge-test-的行为有关的配置" class="headerlink" title="Test测试与 forge test 的行为有关的配置"></a>Test测试与 forge test 的行为有关的配置</h2><h3 id="General"><a href="#General" class="headerlink" title="General"></a>General</h3><h4 id="verbosity"><a href="#verbosity" class="headerlink" title="verbosity"></a>verbosity</h4><ul><li>类型: integer</li><li>默认值: 0</li><li>环境变量: FOUNDRY_VERBOSITY 或 DAPP_VERBOSITY</li></ul><p><strong>在测试中使用的详细日志级别。</strong></p><ul><li>Level 2 (-vv): 显示测试中的触发的事件(日志)。</li><li>Level 3 (-vvv): 显示失败测试的堆栈跟踪。</li><li>Level 4 (-vvvv): 显示所有测试的堆栈跟踪，并显示失败测试的设置跟踪。</li><li>Level 5 (-vvvvv): 堆栈跟踪和设置跟踪总是被显示。</li></ul><h4 id="ffi"><a href="#ffi" class="headerlink" title="ffi"></a>ffi</h4><ul><li>类型: boolean</li><li>默认值: false</li><li>环境变量: FOUNDRY_FFI 或 DAPP_FFI</li></ul><p><strong>是否启用 ffi 作弊代码。</strong></p><p>警告: 启用这个作弊代码对你的项目有安全影响，因为它允许测试代码在你的计算机上执行任意程序。</p><h4 id="sender"><a href="#sender" class="headerlink" title="sender"></a>sender</h4><ul><li>类型: string (address)</li><li>默认值: 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38</li><li>环境变量: FOUNDRY_SENDER 或 DAPP_SENDER</li></ul><p><strong>测试中 msg.sender 的值</strong>。</p><h4 id="tx-origin"><a href="#tx-origin" class="headerlink" title="tx_origin"></a>tx_origin</h4><ul><li>类型: string (address)</li><li>默认值: 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38</li><li>环境变量: FOUNDRY_TX_ORIGIN 或 DAPP_TX_ORIGIN</li></ul><p><strong>测试中 tx.origin 的值</strong>。</p><h4 id="initial-balance"><a href="#initial-balance" class="headerlink" title="initial_balance"></a>initial_balance</h4><ul><li>类型: string (hexadecimal)</li><li>默认值: 0xffffffffffffffffffffffff</li><li>环境变量: FOUNDRY_INITIAL_BALANCE 或 DAPP_INITIAL_BALANCE</li></ul><p><strong>测试合约的初始余额为Wei</strong>，以16进制书写。</p><h4 id="block-number"><a href="#block-number" class="headerlink" title="block_number"></a>block_number</h4><ul><li>类型: integer</li><li>默认值: 1</li><li>环境变量: FOUNDRY_BLOCK_NUMBER 或 DAPP_BLOCK_NUMBER</li></ul><p><strong>测试中 block.number 的值</strong>。</p><h4 id="chain-id"><a href="#chain-id" class="headerlink" title="chain_id"></a>chain_id</h4><ul><li>类型: integer</li><li>默认值: 31337</li><li>环境变量: FOUNDRY_CHAIN_ID 或 DAPP_CHAIN_ID</li></ul><p><strong>测试中 chainid 操作码的值</strong>。</p><h4 id="gas-limit"><a href="#gas-limit" class="headerlink" title="gas_limit"></a>gas_limit</h4><ul><li>类型: integer or string</li><li>默认值: 9223372036854775807</li><li>环境变量: FOUNDRY_GAS_LIMIT 或 DAPP_GAS_LIMIT</li></ul><p><strong>每个测试用例的 Gas 限制</strong>。</p><blockquote><p>由于 Forge 的一个依赖关系的限制，如果不把数值修改为字符串，就无法修改让 Gas 限制 提高到超过默认值。</p><p>为了使用更高的Gas限制，使用一个字符串：</p></blockquote><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gas_limit</span> = <span class="string">&quot;18446744073709551615&quot;</span> <span class="comment"># u64::MAX</span></span><br></pre></td></tr></table></figure><h4 id="gas-price"><a href="#gas-price" class="headerlink" title="gas_price"></a>gas_price</h4><ul><li>类型: integer</li><li>默认值: 0</li><li>环境变量: FOUNDRY_GAS_PRICE 或 DAPP_GAS_PRICE</li></ul><p><strong>测试中的 Gas 价格</strong>（单位：Wei）。</p><h4 id="block-base-fee-per-gas"><a href="#block-base-fee-per-gas" class="headerlink" title="block_base_fee_per_gas"></a>block_base_fee_per_gas</h4><ul><li>类型: integer</li><li>默认值: 0</li><li>环境变量: FOUNDRY_BLOCK_BASE_FEE_PER_GAS 或 DAPP_BLOCK_BASE_FEE_PER_GAS</li></ul><p><strong>测试中的每 Gas 基础费用</strong>（单位：Wei）。</p><h4 id="block-coinbase"><a href="#block-coinbase" class="headerlink" title="block_coinbase"></a>block_coinbase</h4><ul><li>类型: string (address)</li><li>默认值: 0x0000000000000000000000000000000000000000</li><li>环境变量: FOUNDRY_BLOCK_COINBASE 或 DAPP_BLOCK_COINBASE</li></ul><p><strong>测试中 block.coinbase 的值</strong>。</p><h4 id="block-timestamp"><a href="#block-timestamp" class="headerlink" title="block_timestamp"></a>block_timestamp</h4><ul><li>类型: integer</li><li>默认值: 1</li><li>环境变量: FOUNDRY_BLOCK_TIMESTAMP 或 DAPP_BLOCK_TIMESTAMP</li></ul><p><strong>测试中 block.timestamp 的值</strong>。</p><h4 id="block-difficulty"><a href="#block-difficulty" class="headerlink" title="block_difficulty"></a>block_difficulty</h4><ul><li>类型: integer</li><li>默认值: 0</li><li>环境变量: FOUNDRY_BLOCK_DIFFICULTY 或 DAPP_BLOCK_DIFFICULTY</li></ul><p><strong>测试中 block.difficulty 的值</strong>。</p><h4 id="gas-reports"><a href="#gas-reports" class="headerlink" title="gas_reports"></a>gas_reports</h4><ul><li>类型: array of strings (contract names)</li><li>默认值: [“*”]</li><li>环境变量: FOUNDRY_GAS_REPORTS 或 DAPP_GAS_REPORTS</li></ul><p><strong>打印合约 Gas 报告</strong>。</p><h4 id="no-storage-caching"><a href="#no-storage-caching" class="headerlink" title="no_storage_caching"></a>no_storage_caching</h4><ul><li>类型: boolean</li><li>默认值: false</li><li>环境变量: FOUNDRY_NO_STORAGE_CACHING 或 DAPP_NO_STORAGE_CACHING</li></ul><p><strong>如果设置为 true，那么测试中的 RPC 端点的区块数据将不会被缓存</strong>。否则，数据将被缓存到 $HOME&#x2F;.foundry&#x2F;cache&#x2F;<chain id>&#x2F;<block number>。</p><h5 id="rpc-storage-caching-：区块定义哪些-RPC-端点需要被缓存。"><a href="#rpc-storage-caching-：区块定义哪些-RPC-端点需要被缓存。" class="headerlink" title="[rpc_storage_caching]：区块定义哪些 RPC 端点需要被缓存。"></a>[rpc_storage_caching]：区块定义哪些 RPC 端点需要被缓存。</h5><h6 id="rpc-storage-caching-chains"><a href="#rpc-storage-caching-chains" class="headerlink" title="rpc_storage_caching.chains"></a>rpc_storage_caching.chains</h6><ul><li>类型: string or array of strings (chain names)</li><li>默认值: all</li><li>环境变量: N&#x2F;A</li></ul><p><strong>决定哪些链被缓存。默认情况下，所有链都被缓存。</strong></p><p>有效值为：</p><ul><li>“all”</li><li>链名称列表，例如 [“optimism”, “mainnet”]</li></ul><h6 id="rpc-storage-caching-endpoints"><a href="#rpc-storage-caching-endpoints" class="headerlink" title="rpc_storage_caching.endpoints"></a>rpc_storage_caching.endpoints</h6><ul><li>类型: string 或匹配 URL 的正则数组</li><li>默认值: remote</li><li>环境变量: N&#x2F;A</li></ul><p><strong>决定哪些RPC端点被缓存。默认情况下，只有远程端点被缓存。</strong></p><p>有效值为：</p><ul><li>all</li><li>remote (default)</li><li>一个正则匹配的数组，例如 [“localhost”]</li></ul><h4 id="eth-rpc-url"><a href="#eth-rpc-url" class="headerlink" title="eth_rpc_url"></a>eth_rpc_url</h4><ul><li>类型: string</li><li>默认值: none</li><li>环境变量: FOUNDRY_ETH_RPC_URL 或 DAPP_ETH_RPC_URL</li></ul><p><strong>应该用于任何 rpc 调用的 rpc 服务器的 URL</strong>。</p><h4 id="etherscan-api-key"><a href="#etherscan-api-key" class="headerlink" title="etherscan_api_key"></a>etherscan_api_key</h4><ul><li>类型: string</li><li>默认值: none</li><li>环境变量: FOUNDRY_ETHERSCAN_API_KEY 或 DAPP_ETHERSCAN_API_KEY</li></ul><p><strong>用于 RPC 调用的 etherscan API 密钥。</strong></p><h4 id="test-pattern"><a href="#test-pattern" class="headerlink" title="test_pattern"></a>test_pattern</h4><ul><li>类型: regex</li><li>默认值: none</li><li>环境变量: FOUNDRY_TEST_PATTERN 或 DAPP_TEST_PATTERN</li></ul><p><strong>只运行与正则表达式匹配的测试方法</strong>。 相当于 forge test –match-test <TEST_PATTERN></p><h4 id="test-pattern-inverse"><a href="#test-pattern-inverse" class="headerlink" title="test_pattern_inverse"></a>test_pattern_inverse</h4><ul><li>类型: regex</li><li>默认值: none</li><li>环境变量: FOUNDRY_TEST_PATTERN_INVERSE 或 DAPP_TEST_PATTERN_INVERSE</li></ul><p><strong>只运行与正则表达式不匹配的测试方法</strong>。 相当于 forge test –no-match-test <TEST_PATTERN_INVERSE></p><h4 id="contract-pattern"><a href="#contract-pattern" class="headerlink" title="contract_pattern"></a>contract_pattern</h4><ul><li>类型: regex</li><li>默认值: none</li><li>环境变量: FOUNDRY_CONTRACT_PATTERN 或 DAPP_CONTRACT_PATTERN</li></ul><p><strong>只在与正则表达式匹配的合约里运行测试方法</strong>。 相当于 forge test –match-contract <CONTRACT_PATTERN></p><h4 id="contract-pattern-inverse"><a href="#contract-pattern-inverse" class="headerlink" title="contract_pattern_inverse"></a>contract_pattern_inverse</h4><ul><li>类型: regex</li><li>默认值: none</li><li>环境变量: FOUNDRY_CONTRACT_PATTERN_INVERSE 或 DAPP_CONTRACT_PATTERN_INVERSE</li></ul><p><strong>只在与正则表达式不匹配的合约里运行测试方法。</strong> 相当于 forge test –no-match-contract <CONTRACT_PATTERN_INVERSE></p><h4 id="path-pattern"><a href="#path-pattern" class="headerlink" title="path_pattern"></a>path_pattern</h4><ul><li>类型: regex</li><li>默认值: none</li><li>环境变量: FOUNDRY_PATH_PATTERN 或 DAPP_PATH_PATTERN</li></ul><p><strong>只对匹配路径的文件运行测试方法。</strong></p><h4 id="path-pattern-inverse"><a href="#path-pattern-inverse" class="headerlink" title="path_pattern_inverse"></a>path_pattern_inverse</h4><ul><li>类型: regex</li><li>默认值: none</li><li>环境变量: FOUNDRY_PATH_PATTERN_INVERSE 或 DAPP_PATH_PATTERN_INVERSE</li></ul><p><strong>只在与路径不匹配的文件运行测试方法</strong>。</p><h4 id="block-gas-limit"><a href="#block-gas-limit" class="headerlink" title="block_gas_limit"></a>block_gas_limit</h4><ul><li>类型: integer</li><li>默认值: none</li><li>环境变量: FOUNDRY_BLOCK_GAS_LIMIT 或 DAPP_BLOCK_GAS_LIMIT</li></ul><p>EVM 执行期间的 block.gaslimit 值。</p><h4 id="memory-limit"><a href="#memory-limit" class="headerlink" title="memory_limit"></a>memory_limit</h4><ul><li>类型: integer</li><li>默认值: 33554432</li><li>环境变量: FOUNDRY_MEMORY_LIMIT 或 DAPP_MEMORY_LIMIT</li></ul><p><strong>EVM 的内存限制</strong>（以字节为单位）。</p><h4 id="names"><a href="#names" class="headerlink" title="names"></a>names</h4><ul><li>类型: boolean</li><li>默认值: false</li><li>环境变量: FOUNDRY_NAMES 或 DAPP_NAMES</li></ul><p><strong>打印编译的合约名称</strong>。</p><h4 id="sizes"><a href="#sizes" class="headerlink" title="sizes"></a>sizes</h4><ul><li>类型: boolean</li><li>默认值: false</li><li>环境变量: FOUNDRY_SIZES 或 DAPP_SIZES</li></ul><p><strong>打印编译的合约大小</strong>。</p><h4 id="rpc-endpoints"><a href="#rpc-endpoints" class="headerlink" title="rpc_endpoints"></a>rpc_endpoints</h4><ul><li>类型: table of RPC endpoints</li><li>默认值: none</li><li>环境变量: none</li></ul><p>此部分位于配置文件之外，并<strong>定义了一个 RPC 端点表</strong>，其中键指定 RPC 端点的名称，值是 RPC 端点本身。</p><p>该值可以是有效的 RPC 端点或对环境变量的引用（用 ${} 包裹）。</p><p>这些 RPC 端点可用于测试和 Solidity 脚本（参见 vm.rpc）。</p><p>以下示例定义了一个名为 optimism 的端点和一个名为 mainnet 的端点，它引用了一个环境变量RPC_MAINNET:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[rpc_endpoints]</span></span><br><span class="line"><span class="attr">optimism</span> = <span class="string">&quot;https://optimism.alchemyapi.io/v2/...&quot;</span></span><br><span class="line"><span class="attr">mainnet</span> = <span class="string">&quot;$&#123;RPC_MAINNET&#125;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Fuzz"><a href="#Fuzz" class="headerlink" title="Fuzz"></a>Fuzz</h3><h4 id="runs"><a href="#runs" class="headerlink" title="runs"></a>runs</h4><ul><li>类型: integer</li><li>默认值: 256</li><li>环境变量: FOUNDRY_FUZZ_RUNS 或 DAPP_FUZZ_RUNS</li></ul><p><strong>每个模糊测试用例要执行的模糊运行量</strong>。更高的值会以测试速度为代价提高结果的可信度。</p><h4 id="max-test-rejects"><a href="#max-test-rejects" class="headerlink" title="max_test_rejects"></a>max_test_rejects</h4><ul><li>类型: integer</li><li>默认值: 65536</li><li>环境变量: FOUNDRY_FUZZ_MAX_TEST_REJECTS</li></ul><p><strong>在整个测试中止之前可以拒绝的组合输入的最大数量</strong>。 “全局” 过滤器适用于整个测试用例。如果测试用例被拒绝，则整个测试用例将重新生成</p><h4 id="seed"><a href="#seed" class="headerlink" title="seed"></a>seed</h4><ul><li>类型: string (hexadecimal)</li><li>默认值: none</li><li>环境变量: FOUNDRY_FUZZ_SEED</li></ul><p><strong>模糊 RNG 算法的可选种子。</strong></p><h4 id="dictionary-weight"><a href="#dictionary-weight" class="headerlink" title="dictionary_weight"></a>dictionary_weight</h4><ul><li>类型: integer (between 0 and 100)</li><li>默认值: 40</li><li>环境变量: FOUNDRY_FUZZ_DICTIONARY_WEIGHT</li></ul><p><strong>字典的权重。</strong></p><h4 id="include-storage"><a href="#include-storage" class="headerlink" title="include_storage"></a>include_storage</h4><ul><li>类型: boolean</li><li>默认值: true</li><li>环境变量: FOUNDRY_FUZZ_INCLUDE_STORAGE</li></ul><p><strong>标志是否包含存储中的值。</strong></p><h4 id="include-push-bytes"><a href="#include-push-bytes" class="headerlink" title="include_push_bytes"></a>include_push_bytes</h4><ul><li>类型: boolean</li><li>默认值: true</li><li>环境变量: FOUNDRY_FUZZ_INCLUDE_PUSH_BYTES</li></ul><p><strong>标志是否包含推送字节值。</strong></p><h3 id="Invariant"><a href="#Invariant" class="headerlink" title="Invariant"></a>Invariant</h3><p>[invariant] 部分的配置具有回退逻辑 对于常见的配置条目（runs、seed、dictionary_weight 等）。</p><ul><li>如果在任一部分中都没有设置条目，则将使用默认值。</li><li>如果条目在 [fuzz] 部分中设置，但未在 [invariant] 中设置条目, 这些值将自动设置为指定的值在 [fuzz] 条目.</li><li>对于default以外的任何配置文件：<ul><li>如果在 [invariant] 中设置公共条目 (类似 [profile.default.invariant]) 条目, 从 [invariant] 条目的值会被使用。</li><li>如果公共条目未在 [invariant] 部分中设置， 但是在 [fuzz] 条目中设置 (类似 [profile.default.fuzz]) , 然后将使用 [fuzz] 部分的值。</li><li>如果不是上述任何一种情况， 则将使用默认值。</li></ul></li></ul><h4 id="runs-1"><a href="#runs-1" class="headerlink" title="runs"></a>runs</h4><ul><li>类型: integer</li><li>默认值: 256</li><li>环境变量: FOUNDRY_INVARIANT_RUNS</li></ul><p><strong>必须为每个不变测试组执行的运行次数</strong>。 另见 fuzz.runs</p><h4 id="depth"><a href="#depth" class="headerlink" title="depth"></a>depth</h4><ul><li>类型: integer</li><li>默认值: 256</li><li>环境变量: FOUNDRY_INVARIANT_DEPTH</li></ul><p><strong>在一次运行中为尝试破坏不变量而执行的调用次数</strong>。</p><h4 id="fail-on-revert"><a href="#fail-on-revert" class="headerlink" title="fail_on_revert"></a>fail_on_revert</h4><ul><li>类型: boolean</li><li>默认值: false</li><li>环境变量: FOUNDRY_INVARIANT_FAIL_ON_REVERT</li></ul><p><strong>如果发生 revert，不变的模糊测试将失败</strong>。</p><h4 id="call-override"><a href="#call-override" class="headerlink" title="call_override"></a>call_override</h4><ul><li>类型: boolean</li><li>默认值: false</li><li>环境变量: FOUNDRY_INVARIANT_CALL_OVERRIDE</li></ul><p><strong>允许在运行不变测试时覆盖不安全的外部调用</strong>。 例如： 重入检查。</p><h4 id="dictionary-weight-1"><a href="#dictionary-weight-1" class="headerlink" title="dictionary_weight"></a>dictionary_weight</h4><ul><li>类型: integer (between 0 and 100)</li><li>默认值: 80</li><li>环境变量: FOUNDRY_INVARIANT_DICTIONARY_WEIGHT</li></ul><p><strong>字典的权重。</strong>另见 fuzz.dictionary_weight</p><h4 id="include-storage-1"><a href="#include-storage-1" class="headerlink" title="include_storage"></a>include_storage</h4><ul><li>类型: boolean</li><li>默认值: true</li><li>环境变量: FOUNDRY_FUZZ_INCLUDE_STORAGE</li></ul><p>指示<strong>是否包括存储中的值的标志。</strong>另见 fuzz.include_storage</p><h4 id="include-push-bytes-1"><a href="#include-push-bytes-1" class="headerlink" title="include_push_bytes"></a>include_push_bytes</h4><ul><li>类型: boolean</li><li>默认值: true</li><li>环境变量: FOUNDRY_FUZZ_INCLUDE_PUSH_BYTES</li></ul><p><strong>指示是否包含推送字节值的标志</strong>。 另见 fuzz.include_push_bytes</p><h2 id="Formatter与-Forge-格式化器的行为有关的配置。"><a href="#Formatter与-Forge-格式化器的行为有关的配置。" class="headerlink" title="Formatter与 Forge 格式化器的行为有关的配置。"></a>Formatter与 Forge 格式化器的行为有关的配置。</h2><p>关键都在 [fmt] 部分。</p><h4 id="line-length"><a href="#line-length" class="headerlink" title="line_length"></a>line_length</h4><ul><li>类型: number</li><li>默认值: 120</li><li>环境变量: FOUNDRY_FMT_LINE_LENGTH or DAPP_FMT_LINE_LENGTH</li></ul><p><strong>指定格式化程序尝试换行的最大行长</strong>。</p><h4 id="tab-width"><a href="#tab-width" class="headerlink" title="tab_width"></a>tab_width</h4><ul><li>类型: number</li><li>默认值: 4</li><li>环境变量: FOUNDRY_FMT_TAB_WIDTH or DAPP_FMT_TAB_WIDTH</li></ul><p><strong>每个缩进级别的空格数。</strong></p><h4 id="bracket-spacing"><a href="#bracket-spacing" class="headerlink" title="bracket_spacing"></a>bracket_spacing</h4><ul><li>类型: bool</li><li>默认值: false</li><li>环境变量: FOUNDRY_FMT_BRACKET_SPACING or DAPP_FMT_BRACKET_SPACING</li></ul><p><strong>是否在括号之间打印空格。</strong></p><h4 id="int-types"><a href="#int-types" class="headerlink" title="int_types"></a>int_types</h4><ul><li>类型: string</li><li>默认值: long</li><li>环境变量: FOUNDRY_FMT_INT_TYPES or DAPP_FMT_INT_TYPES</li></ul><p>uint&#x2F;int256 类型的风格。 有效值为:</p><ul><li>long (默认): 使用明确的 uint256 或 int256</li><li>short: 使用隐式的 uint 或 int</li><li>preserve: 使用源代码中定义的类型</li></ul><h4 id="func-attrs-with-params-multiline"><a href="#func-attrs-with-params-multiline" class="headerlink" title="func_attrs_with_params_multiline"></a>func_attrs_with_params_multiline</h4><ul><li>类型: bool</li><li>默认值: true</li><li>环境变量: FOUNDRY_FMT_FUNC_ATTRS_WITH_PARAMS_MULTILINE or DAPP_FMT_FUNC_ATTRS_WITH_PARAMS_MULTILINE</li></ul><p><strong>如果函数参数是多行的，那么总是把函数属性放在不同的行上。</strong></p><h4 id="quote-style"><a href="#quote-style" class="headerlink" title="quote_style"></a>quote_style</h4><ul><li>类型: string</li><li>默认值: double</li><li>环境变量: FOUNDRY_FMT_QUOTE_STYLE or DAPP_FMT_QUOTE_STYLE</li></ul><p><strong>定义了引号的样式。</strong> 有效值为：</p><ul><li>double (默认): 尽可能使用双引号 (“)</li><li>single: 尽可能使用单引号 (‘)</li><li>preserve: 使用源代码中定义的引号</li></ul><h4 id="number-underscore"><a href="#number-underscore" class="headerlink" title="number_underscore"></a>number_underscore</h4><ul><li>类型: string</li><li>默认值: preserve</li><li>环境变量: FOUNDRY_FMT_NUMBER_UNDERSCORE or DAPP_FMT_NUMBER_UNDERSCORE</li></ul><p><strong>数字字段中下划线的样式。</strong> 有效值为：</p><ul><li>preserve (默认): 使用源代码中定义的下划线</li><li>thousands: 如果大于 9999，则每 1000 加一个下划线。例如 1000 的格式为 1000，10000 的格式为 10_000</li><li>remove: 去除所有下划线</li></ul><h2 id="Etherscan与-Etherscan-相关的配置"><a href="#Etherscan与-Etherscan-相关的配置" class="headerlink" title="Etherscan与 Etherscan 相关的配置"></a>Etherscan与 Etherscan 相关的配置</h2><p>如 API 密钥， 这个配置被 Forge 用在各个地方。</p><p><code>[etherscan]</code> 部分是密钥与 Etherscan 配置表的映射。Etherscan配置表持有以下键（属性）：</p><ul><li><code>key</code> (字符串) (<strong>必须</strong>): 给定网络的 Etherscan API 密钥。这个属性的值也可以指向一个环境变量。</li><li><code>chain</code>: 该 Etherscan 配置的链的名称或 ID。</li><li><code>url</code>: Etherscan的 API URL。</li></ul><p>如果配置的 key 是一个链的名称，那么就不需要 <code>chain</code>，否则就需要。<code>url</code> 可以用来为不支持名称的链明确设置 Etherscan API URL。</p><p>使用 TOML 内联表语法，所有这些都是有效的:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[etherscan]</span></span><br><span class="line"><span class="attr">mainnet</span> = &#123; key = <span class="string">&quot;$&#123;ETHERSCAN_MAINNET_KEY&#125;&quot;</span> &#125;</span><br><span class="line"><span class="attr">mainnet2</span> = &#123; key = <span class="string">&quot;ABCDEFG&quot;</span>, chain = <span class="string">&quot;mainnet&quot;</span> &#125;</span><br><span class="line"><span class="attr">optimism</span> = &#123; key = <span class="string">&quot;1234567&quot;</span> &#125;</span><br><span class="line"><span class="attr">unknown_chain</span> = &#123; key = <span class="string">&quot;ABCDEFG&quot;</span>, url = <span class="string">&quot;&lt;etherscan api url for this chain&gt;&quot;</span> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Foundry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 合约框架 </tag>
            
            <tag> Foundry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-Cast与Anvil</title>
      <link href="/2023/02/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Foundry/5-Cast%E4%B8%8EAnvil/"/>
      <url>/2023/02/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Foundry/5-Cast%E4%B8%8EAnvil/</url>
      
        <content type="html"><![CDATA[<h1 id="Cast-概述"><a href="#Cast-概述" class="headerlink" title="Cast 概述"></a>Cast 概述</h1><p>Cast 是 Foundry 用于执行以太坊 RPC 调用的命令行工具。 您可以进行智能合约调用、发送交易或检索任何类型的链数据——所有这些都来自您的命令行！</p><h2 id="如何使用-Cast"><a href="#如何使用-Cast" class="headerlink" title="如何使用 Cast"></a>如何使用 Cast</h2><p>要使用 Cast，请运行 cast 命令，然后运行子命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cast &lt;subcommand&gt;</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>让我们使用 cast 来检索 DAI 代币的总供应量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cast call 0x6b175474e89094c44da98b954eedeac495271d0f <span class="string">&quot;totalSupply()(uint256)&quot;</span> --rpc-url https://eth-mainnet.alchemyapi.io/v2/Lc7oIGYeL_QvInzI0Wiu_pOZZDEKBrdf</span><br><span class="line">8603853182003814300330472690</span><br></pre></td></tr></table></figure><p>cast 还提供了许多方便的子命令，例如用于解码 calldata：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cast 4byte-decode 0x1F1F897F676d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003e7</span><br><span class="line">1) <span class="string">&quot;fulfillRandomness(bytes32,uint256)&quot;</span></span><br><span class="line">0x676d000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">999</span><br></pre></td></tr></table></figure><p>您还可以使用 cast 发送任意消息。 下面是在两个 Anvil 帐户之间发送消息的示例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cast send --private-key &lt;Your Private Key&gt; 0x3c44cdddb6a900fa2b585dd299e03d12fa4293bc $(cast --from-utf8 <span class="string">&quot;hello world&quot;</span>) --rpc-url http://127.0.0.1:8545/</span><br></pre></td></tr></table></figure><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="General-命令"><a href="#General-命令" class="headerlink" title="General 命令"></a>General 命令</h3><p>cast help   获取 Cast 命令的帮助。</p><p>cast completions   生成 shell 自动补全脚本。</p><h3 id="Chain-命令"><a href="#Chain-命令" class="headerlink" title="Chain 命令"></a>Chain 命令</h3><p>cast chain-id   获取 Ethereum 的链 ID。</p><p>cast chain   获取当前链的名称。</p><p>cast client   获取当前客户端的版本。</p><h3 id="Transaction-命令"><a href="#Transaction-命令" class="headerlink" title="Transaction 命令"></a>Transaction 命令</h3><p>cast publish   向网络发布一个原始交易。</p><p>cast receipt   获取一个交易的交易收据。</p><p>cast send   签署并发布一项交易。</p><p>cast call   在不发布交易的情况下对一个账户进行调用。</p><p>cast rpc   执行一个原始的 JSON-RPC 请求 [aliases: rp]</p><p>cast tx   获得有关交易的信息。</p><p>cast run   在本地环境中运行一个已发布的交易，并打印出跟踪。</p><p>cast estimate   估算交易的 Gas 成本。</p><p>cast access-list   为一个交易创建一个访问列表。</p><h3 id="Block-命令"><a href="#Block-命令" class="headerlink" title="Block 命令"></a>Block 命令</h3><p>cast find-block   获取与提供的时间戳最接近的区块编号。</p><p>cast gas-price   获取当前 Gas 价格。</p><p>cast block-number   获取最新的区块号。</p><p>cast basefee   获取一个区块的基础费用。</p><p>cast block   获取一个区块的信息。</p><p>cast age   获取一个区块的时间戳。</p><h3 id="Account-命令"><a href="#Account-命令" class="headerlink" title="Account 命令"></a>Account 命令</h3><p>cast balance   获取一个账户的余额，单位为 Wei。</p><p>cast storage   获取一个合约的存储槽的原始值。</p><p>cast proof   为一个给定的存储槽生成一个存储证明。</p><p>cast nonce   获取一个账户的 nonce。</p><p>cast code   获取一个合约的字节码。</p><h3 id="ENS-命令"><a href="#ENS-命令" class="headerlink" title="ENS 命令"></a>ENS 命令</h3><p>cast lookup-address   进行 ENS 反向查询。</p><p>cast resolve-name   进行 ENS 查询。</p><p>cast namehash   计算一个名字的 ENS namehash。</p><h3 id="Etherscan-命令"><a href="#Etherscan-命令" class="headerlink" title="Etherscan 命令"></a>Etherscan 命令</h3><p>cast etherscan-source   从 Etherscan 获取合约的源代码。</p><h3 id="ABI-命令"><a href="#ABI-命令" class="headerlink" title="ABI 命令"></a>ABI 命令</h3><p>cast abi-encode   对给定的函数参数进行 ABI 编码，不包括选择器。</p><p>cast 4byte   从 <a href="https://sig.eth.samczsun.com/">https://sig.eth.samczsun.com</a> 中获取指定选择器的函数签名。</p><p>cast 4byte-decode   使用 <a href="https://sig.eth.samczsun.com/">https://sig.eth.samczsun.com</a> 对 ABI 编码的 calldata 进行解码。</p><p>cast 4byte-event   从 <a href="https://sig.eth.samczsun.com/">https://sig.eth.samczsun.com</a> 中获取 topic 0 的事件签名。</p><p>cast calldata   ABI 编码一个带参数的函数。</p><p>cast pretty-calldata   漂亮地打印 Calldata。</p><p>cast –abi-decode   解码 ABI 编码的输入或输出数据。</p><p>cast –calldata-decode   解码 ABI 编码的输入数据。</p><p>cast upload-signature   将指定的签名上传到 <a href="https://sig.eth.samczsun.com/">https://sig.eth.samczsun.com</a>.</p><h3 id="Conversion-命令"><a href="#Conversion-命令" class="headerlink" title="Conversion 命令"></a>Conversion 命令</h3><p>cast –format-bytes32-string   将一个字符串转换成 bytes32 编码。</p><p>cast –from-bin   将二进制数据转换为十六进制数据。</p><p>cast –from-fix   将一个定点数转换成一个整数。</p><p>cast –from-utf8   将 UTF8 文本转换为十六进制。</p><p>cast –parse-bytes32-string   从 bytes32 编码中解析出一个字符串。</p><p>cast –to-ascii   将十六进制数据转换为ASCII字符串。</p><p>cast –to-base   将一个进制底数转换为其它底数。</p><p>cast –to-bytes32   右移十六进制数据至 32 字节。</p><p>cast –to-fix   将一个整数转换成一个定点数。</p><p>cast –to-hexdata   将输入规范化为小写，0x- 前缀的十六进制。</p><p>cast –to-int256   将一个数字转换为十六进制编码的 int256。</p><p>cast –to-uint256   将一个数字转换成十六进制编码的 uint256。</p><p>cast –to-unit   将一个 eth 单位转换为另一个单位。 (ether, gwei, wei).</p><p>cast –to-wei   将 eth 金额转换为 wei 单位。</p><p>cast shl   进行左移操作。</p><p>cast shr   进行右移操作。</p><h3 id="Utility-Commands"><a href="#Utility-Commands" class="headerlink" title="Utility Commands"></a>Utility Commands</h3><p>cast sig   获取一个函数的选择器。</p><p>cast keccak   使用 keccak-256 对任意数据进行哈希。</p><p>cast compute-address   从给定的 nonce 和部署者地址计算合约地址。</p><p>cast interface   从一个给定的 ABI 生成一个 Solidity 接口。</p><p>cast index   计算集合中条目的存储插槽位置。</p><p>cast –concat-hex   串接十六进制字符串。</p><p>cast –max-int   获取 int256 最大值。</p><p>cast –min-int   获取 int256 最小值。</p><p>cast –max-uint   获取 uint256 最大值。</p><p>cast –to-checksum-address   将一个地址转换为校验过的格式 (EIP-55).</p><h3 id="Wallet-Commands"><a href="#Wallet-Commands" class="headerlink" title="Wallet Commands"></a>Wallet Commands</h3><p>cast wallet   钱包管理实用工具。</p><p>cast wallet new   创建一个新的随机密钥对。</p><p>cast wallet address   将一个私钥转换为一个地址。</p><p>cast wallet sign   签署消息。</p><p>cast wallet vanity   生成一个虚构的地址。</p><p>cast wallet verify   验证一个信息的签名。</p><h1 id="Anvil-概述"><a href="#Anvil-概述" class="headerlink" title="Anvil 概述"></a>Anvil 概述</h1><p><strong>Anvil 是 Foundry 附带的本地测试网节点。</strong> 您可以使用它从前端测试您的合约或通过 RPC 进行交互。</p><p>Anvil 是 Foundry 套件的一部分，与 forge 和 cast 一起安装。</p><blockquote><p>注意：如果您安装了旧版本的 Foundry，则需要重新安装 foundryup 才能下载 Anvil。</p></blockquote><h2 id="如何使用-Anvil"><a href="#如何使用-Anvil" class="headerlink" title="如何使用 Anvil"></a>如何使用 Anvil</h2><p>要使用 Anvil，只需输入 anvil。 您应该会看到可用的帐户和私钥列表，以及节点正在侦听的地址和端口。</p><p>Anvil 是高度可配置的。 您可以运行 anvil -h 查看所有配置选项。</p><p>一些基本选项是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要生成和配置的用户的帐户数[default: 10]</span></span><br><span class="line">anvil -a, --accounts &lt;ACCOUNTS&gt;</span><br><span class="line"><span class="comment"># 要使用的EVM硬分叉[default: latest]</span></span><br><span class="line">anvil --hardfork &lt;HARDFORK&gt;</span><br><span class="line"><span class="comment"># 要侦听的端口号[default: 8545]</span></span><br><span class="line">anvil  -p, --port &lt;PORT&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Foundry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 合约框架 </tag>
            
            <tag> Foundry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-Gas追踪</title>
      <link href="/2023/02/20/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Foundry/4-Gas%E8%BF%BD%E8%B8%AA/"/>
      <url>/2023/02/20/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Foundry/4-Gas%E8%BF%BD%E8%B8%AA/</url>
      
        <content type="html"><![CDATA[<h1 id="Gas-追踪"><a href="#Gas-追踪" class="headerlink" title="Gas 追踪"></a>Gas 追踪</h1><p>Forge 可以帮助您估算您的合约将消耗多少 gas。</p><p>目前，Forge 为这项工作提供了两种不同的工具，但它们可能会在未来合并：</p><ul><li>Gas reports：<strong>Gas 报告让您大致了解到 Forge 认为 你的合约中的各个函数消耗 gas 的概况</strong>。</li><li>Gas snapshots：<strong>Gas 快照让您大致了解 每次测试消耗 Gas 的概况。</strong></li></ul><p>Gas 报告和 Gas 快照在某些方面有所不同：</p><ul><li><strong>Gas 报告使用跟踪来计算单个合约调用的 Gas 成本</strong>。 这以速度为代价提供了更精细的洞察力。</li><li><strong>Gas 快照具有更多内置工具，例如将差异和结果导出到文件。</strong> 快照<strong>不像 Gas 报告那样精细，但生成速度更快。</strong></li></ul><h2 id="Gas-报告"><a href="#Gas-报告" class="headerlink" title="Gas 报告"></a>Gas 报告</h2><p>Forge 可以为您的合约生成 Gas 报告。 您可以<strong>通过 foundry.toml 中的 gas_reports 字段配置哪些合约输出 Gas 报告</strong>。</p><p>为特定合约生成报告：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gas_reports</span> = [<span class="string">&quot;MyContract&quot;</span>, <span class="string">&quot;MyContractFactory&quot;</span>]</span><br></pre></td></tr></table></figure><p>为所有合约生成报告：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gas_reports</span> = [<span class="string">&quot;*&quot;</span>]</span><br></pre></td></tr></table></figure><p>要生成 Gas 报告，请<strong>运行 forge test –gas-report</strong>。</p><p>您还可以<strong>将它与其他子命令结合使用，例如 forge test –match-test testBurn –gas-report，以仅生成与此测试相关的 Gas 报告。</strong></p><p>示例输出：</p><img src="/noteimg/区块链/区块链知识点总结/合约框架/Foundry/img/image-20230621205206454.png" alt="image-20230621205206454" style="zoom:80%;" /> <p>您还可以通过 foundry.toml 中的 gas_reports_ignore 字段忽略合约：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gas_reports_ignore</span> = [<span class="string">&quot;Example&quot;</span>]</span><br></pre></td></tr></table></figure><p>这会将输出更改为：</p><img src="/noteimg/区块链/区块链知识点总结/合约框架/Foundry/img/image-20230621205342754.png" alt="image-20230621205342754" style="zoom:80%;" /> <h2 id="Gas快照"><a href="#Gas快照" class="headerlink" title="Gas快照"></a>Gas快照</h2><p>Forge 可以为您的所有测试函数生成 Gas 快照。 这个可以有助于了解您的合约将消耗多少 Gas， 或者比较各种优化前后的 Gas 使用情况。</p><p><strong>要生成 Gas 快照，请运行 forge snapshot。</strong></p><p>默认情况下，这将<strong>生成一个名为 .gas-snapshot</strong> 的文件，其中包含你所有的测试及其各自的 Gas 使用情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ forge snapshot</span><br><span class="line">$ cat .gas-snapshot</span><br><span class="line"></span><br><span class="line">ERC20Test:testApprove() (gas: 31162)</span><br><span class="line">ERC20Test:testBurn() (gas: 59875)</span><br><span class="line">ERC20Test:testFailTransferFromInsufficientAllowance() (gas: 81034)</span><br><span class="line">ERC20Test:testFailTransferFromInsufficientBalance() (gas: 81662)</span><br><span class="line">ERC20Test:testFailTransferInsufficientBalance() (gas: 52882)</span><br><span class="line">ERC20Test:testInfiniteApproveTransferFrom() (gas: 90167)</span><br><span class="line">ERC20Test:testMetadata() (gas: 14606)</span><br><span class="line">ERC20Test:testMint() (gas: 53830)</span><br><span class="line">ERC20Test:testTransfer() (gas: 60473)</span><br><span class="line">ERC20Test:testTransferFrom() (gas: 84152)</span><br></pre></td></tr></table></figure><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>如果您想<strong>指定一个不同的输出文件，请运行 forge snapshot –snap <FILE_NAME>。</strong></p><p>您还可以按 Gas 使用量对结果进行排序。 使用 <strong>–asc 选项将结果按升序 排序和 –desc 将结果按降序排序。</strong></p><p>最后，您还可以为所有测试<strong>指定最小&#x2F;最大 Gas 阈值</strong>。 要仅包含高于阈值的结果，您可以使用 –min <VALUE> 选项。 以同样的方式，只包括阈值以下的结果， 您可以使用 –max <VALUE> 选项。</p><p>您还可以将其与 forge test 的过滤器结合使用，例如 forge snapshot –match-path contracts&#x2F;test&#x2F;ERC721.t.sol 以生成与此测试合约相关的 Gas 快照。</p><h3 id="比较Gas用量"><a href="#比较Gas用量" class="headerlink" title="比较Gas用量"></a>比较Gas用量</h3><p>如果您想<strong>将当前快照文件与您的最新更改进行比较</strong>，您可以使用 –diff 或 –check 选项。</p><p><strong>–diff 将与快照进行比较并显示快照的更改。</strong></p><p>它还可以<strong>选择使用文件名（–diff <FILE_NAME>），默认是 .gas-snapshot。</strong></p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ forge snapshot --diff .gas-snapshot2</span><br><span class="line"></span><br><span class="line">Running 10 tests for src/test/ERC20.t.sol:ERC20Test</span><br><span class="line">[PASS] testApprove() (gas: 31162)</span><br><span class="line">[PASS] testBurn() (gas: 59875)</span><br><span class="line">[PASS] testFailTransferFromInsufficientAllowance() (gas: 81034)</span><br><span class="line">[PASS] testFailTransferFromInsufficientBalance() (gas: 81662)</span><br><span class="line">[PASS] testFailTransferInsufficientBalance() (gas: 52882)</span><br><span class="line">[PASS] testInfiniteApproveTransferFrom() (gas: 90167)</span><br><span class="line">[PASS] testMetadata() (gas: 14606)</span><br><span class="line">[PASS] testMint() (gas: 53830)</span><br><span class="line">[PASS] testTransfer() (gas: 60473)</span><br><span class="line">[PASS] testTransferFrom() (gas: 84152)</span><br><span class="line">Test result: ok. 10 passed; 0 failed; finished in 2.86ms</span><br><span class="line">testBurn() (gas: 0 (0.000%))</span><br><span class="line">testFailTransferFromInsufficientAllowance() (gas: 0 (0.000%))</span><br><span class="line">testFailTransferFromInsufficientBalance() (gas: 0 (0.000%))</span><br><span class="line">testFailTransferInsufficientBalance() (gas: 0 (0.000%))</span><br><span class="line">testInfiniteApproveTransferFrom() (gas: 0 (0.000%))</span><br><span class="line">testMetadata() (gas: 0 (0.000%))</span><br><span class="line">testMint() (gas: 0 (0.000%))</span><br><span class="line">testTransfer() (gas: 0 (0.000%))</span><br><span class="line">testTransferFrom() (gas: 0 (0.000%))</span><br><span class="line">testApprove() (gas: -8 (-0.000%))</span><br><span class="line">Overall gas change: -8 (-0.000%)d</span><br></pre></td></tr></table></figure><p>–check 将快照与现有快照文件进行比较并显示所有差异，如果有的话。 您可以通过提供不同的文件名来更改要比较的文件：–check <FILE_NAME>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ forge snapshot --check .gas-snapshot2</span><br><span class="line"></span><br><span class="line">Running 10 tests for src/test/ERC20.t.sol:ERC20Test</span><br><span class="line">[PASS] testApprove() (gas: 31162)</span><br><span class="line">[PASS] testBurn() (gas: 59875)</span><br><span class="line">[PASS] testFailTransferFromInsufficientAllowance() (gas: 81034)</span><br><span class="line">[PASS] testFailTransferFromInsufficientBalance() (gas: 81662)</span><br><span class="line">[PASS] testFailTransferInsufficientBalance() (gas: 52882)</span><br><span class="line">[PASS] testInfiniteApproveTransferFrom() (gas: 90167)</span><br><span class="line">[PASS] testMetadata() (gas: 14606)</span><br><span class="line">[PASS] testMint() (gas: 53830)</span><br><span class="line">[PASS] testTransfer() (gas: 60473)</span><br><span class="line">[PASS] testTransferFrom() (gas: 84152)</span><br><span class="line">Test result: ok. 10 passed; 0 failed; finished in 2.47ms</span><br><span class="line">Diff in &quot;ERC20Test::testApprove()&quot;: consumed &quot;(gas: 31162)&quot; gas, expected &quot;(gas: 31170)&quot; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Foundry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 合约框架 </tag>
            
            <tag> Foundry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-部署和验证</title>
      <link href="/2023/02/19/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Foundry/3-%E9%83%A8%E7%BD%B2%E5%92%8C%E9%AA%8C%E8%AF%81/"/>
      <url>/2023/02/19/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Foundry/3-%E9%83%A8%E7%BD%B2%E5%92%8C%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h1 id="部署和验证"><a href="#部署和验证" class="headerlink" title="部署和验证"></a>部署和验证</h1><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>Forge 可以<strong>使用 forge create 命令</strong>将智能合约部署到指定网络。Forge <strong>一次只能部署一个合约</strong>。</p><p>要部署合约，您<strong>必须提供 RPC URL（env：ETH_RPC_URL）和部署合约的帐户私钥。</strong></p><p>将 MyContract 部署到网络：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ forge create --rpc-url &lt;your_rpc_url&gt; --private-key &lt;your_private_key&gt; src/MyContract.sol:MyContract</span><br></pre></td></tr></table></figure><p>Solidity 文件可能包含多个合约。 上面的 :MyContract 指定了从 src&#x2F;MyContract.sol 文件部署哪个合约。</p><p><strong>使用 –constructor-args 标志将参数传递给构造函数：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &#123;ERC20&#125; from &quot;solmate/tokens/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract MyToken is ERC20 &#123;</span><br><span class="line">    constructor(</span><br><span class="line">        string memory name,</span><br><span class="line">        string memory symbol,</span><br><span class="line">        uint8 decimals,</span><br><span class="line">        uint256 initialSupply</span><br><span class="line">    ) ERC20(name, symbol, decimals) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，我们可以告诉 Forge 在 Etherscan、Sourcify 或 Blockscout 上验证我们的合约（如果网络支持），方法是传递 –verify。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ forge create --rpc-url &lt;your_rpc_url&gt; \</span><br><span class="line">    --constructor-args <span class="string">&quot;ForgeUSD&quot;</span> <span class="string">&quot;FUSD&quot;</span> 18 1000000000000000000000 \</span><br><span class="line">    --private-key &lt;your_private_key&gt; src/MyToken.sol:MyToken \</span><br><span class="line">    --etherscan-api-key &lt;your_etherscan_api_key&gt; \</span><br><span class="line">    --verify</span><br></pre></td></tr></table></figure><h2 id="验证已部署的合约"><a href="#验证已部署的合约" class="headerlink" title="验证已部署的合约"></a>验证已部署的合约</h2><p>建议在 <strong>forge create 中使用 –verify 标志</strong>，以便部署后在 explorer 上<strong>自动验证合约</strong>。 请注意，对于 Etherscan，<strong>必须设置 ETHERSCAN_API_KEY</strong>。</p><p>如果您正在<strong>验证已部署的合约</strong>，请继续阅读。</p><p>您可以<strong>使用 forge verify-contract 命令</strong>在 Etherscan、Sourcify 或 Blockscout 上验证合约。</p><p>您<strong>必须提供：</strong></p><ul><li><strong>合约地址</strong></li><li><strong>合约名称或合约路径 <path>:<contractname></strong></li><li><strong>您的 Etherscan API 密钥（env：ETHERSCAN_API_KEY）（如果在 Etherscan 上验证）。</strong></li></ul><p>此外，您可能需要提供：</p><ul><li>ABI 编码格式的构造函数参数，如果有的话</li><li>编译器版本 用于构建，由提交版本前缀的 8 位十六进制数字组成（提交通常不是 nightly 版本）。 如果未指定，则会自动检测。</li><li>优化次数，如果激活了 Solidity 优化器。 如果未指定，则会自动检测。</li><li>链 ID，如果合约不在以太坊主网上</li></ul><p>假设您想验证 MyToken（见上文）。 您将 优化次数 设置为 100 万，使用 v0.8.10 对其进行编译，并将其部署到如上所示的 Kovan 测试网（链 ID : 42). 请注意，如果在验证时没有设置 –num-of-optimizations 将默认为 0，而如果在部署时没有设置则默认为 200，所以如果你使用默认的编译设置，请确保输入 –num-of-optimizations 200。</p><p>验证方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ forge verify-contract --chain-id 42 --num-of-optimizations 1000000 --watch --constructor-args \ </span><br><span class="line">    $(cast abi-encode <span class="string">&quot;constructor(string,string,uint256,uint256)&quot;</span> <span class="string">&quot;ForgeUSD&quot;</span> <span class="string">&quot;FUSD&quot;</span> 18 1000000000000000000000) \</span><br><span class="line">    --compiler-version v0.8.10+commit.fc410830 &lt;the_contract_address&gt; src/MyToken.sol:MyToken &lt;your_etherscan_api_key&gt;</span><br><span class="line"></span><br><span class="line">Submitted contract <span class="keyword">for</span> verification:</span><br><span class="line">                Response: `OK`</span><br><span class="line">                GUID: `a6yrbjp5prvakia6bqp5qdacczyfhkyi5j1r6qbds1js41ak1a`</span><br><span class="line">                url: https://kovan.etherscan.io//address/0x6a54…3a4c<span class="comment">#code</span></span><br></pre></td></tr></table></figure><p>建议在使用 verify-contract 命令的同时使用 –watch 标志 以便轮询验证结果。</p><p>如果未提供 –watch 标志，您可以 使用 forge verify-check 命令检查验证状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ forge verify-check --chain-id 42 &lt;GUID&gt; &lt;your_etherscan_api_key&gt;</span><br><span class="line">Contract successfully verified.</span><br></pre></td></tr></table></figure><blockquote><p>使用 Cast 的 abi-encode 对参数进行 ABI 编码。</p><p>在这个例子中，我们运行了 cast abi-encode “constructor(string,string,uint8,uint256)” “ForgeUSD” “FUSD” 18 1000000000000000000000 来对参数进行 ABI 编码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Foundry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 合约框架 </tag>
            
            <tag> Foundry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-Forge概述</title>
      <link href="/2023/02/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Foundry/2-Forge%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/02/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Foundry/2-Forge%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Forge"><a href="#Forge" class="headerlink" title="Forge"></a>Forge</h1><p>Forge 是 <code>Foundry</code> 附带的命令行工具。 Forge 可用来测试、构建和部署您的智能合约。</p><h2 id="Forge概述"><a href="#Forge概述" class="headerlink" title="Forge概述"></a>Forge概述</h2><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><strong>使用 forge test命令运行测试（用例）。 所有测试都是用 Solidity 编写的</strong></p><p>任何<strong>具有以<code>test</code>开头的函数的合约都被认为是一个测试</strong>。 通常，测试将按照约定<strong>放在 <code>src/test</code> 中，并以 <code>.t.sol</code> 结尾</strong>。</p><p>您还可以通过传递过滤器来运行特定测试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ forge <span class="built_in">test</span> --match-contract ComplicatedContractTest --match-test testDeposit</span><br></pre></td></tr></table></figure><p>这将在<strong>名称中带有 <code>testDeposit</code> 的 <code>ComplicatedContractTest</code> 测试合约中运行测试</strong>。 这些标志的反向版本也存在（<code>--no-match-contract</code> 和 <code>--no-match-test</code>）。</p><p>您可以<strong>使用 <code>--match-path</code> 与 glob 模式匹配的文件名中运行测试</strong>，<code>--match-path</code> 标志的反面是 <code>--no-match-path</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ forge <span class="built_in">test</span> --match-path <span class="built_in">test</span>/ContractB.t.sol</span><br></pre></td></tr></table></figure><h3 id="日志和跟踪"><a href="#日志和跟踪" class="headerlink" title="日志和跟踪"></a>日志和跟踪</h3><p><code>forge test</code> 的默认行为是只显示通过和失败测试的摘要。 您可以通过增加详细程度（使用<code>-v</code>标志）来控制此行为。 每个详细级别都会添加更多信息：</p><ul><li>**级别 2 (<code>-vv</code>)**：还会显示测试期间发出的日志。 这包括来自测试的断言错误，显示诸如预期与实际结果等之类的信息。</li><li>**级别 3 (<code>-vvv</code>)**：还显示失败测试的堆栈跟踪。</li><li>**级别 4 (<code>-vvvv</code>)**：显示所有测试的堆栈跟踪，并显示失败测试的设置（setup）跟踪。</li><li>**级别 5 (<code>-vvvvv</code>)**：始终显示堆栈跟踪和设置（setup）跟踪。</li></ul><h3 id="Watch模式"><a href="#Watch模式" class="headerlink" title="Watch模式"></a>Watch模式</h3><p>当您使用<code>forge test --watch</code>对文件进行更改时，Forge 可以重新运行您的测试。</p><p>默认情况下，仅重新运行更改的测试文件。 如果你想重新运行更改的所有测试，你可以使用 <code>forge test --watch --run-all</code>。</p><h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><h3 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h3><p>使用Forge 标准库的 <code>Test</code> 合约，这是使用 Forge 编写测试的首选方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br></pre></td></tr></table></figure><p>Forge 在测试中使用以下关键字：</p><ul><li><code>setUp</code>：在<strong>每个测试用例运行之前调用的可选函数</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function setUp() public &#123;</span><br><span class="line">    testNumber = 42;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>test</code>：<strong>以 <code>test</code> 为前缀的函数作为测试用例运行</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function testNumberIs42() public &#123;</span><br><span class="line">    assertEq(testNumber, 42);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>testFail</code>: <code>test</code> 前缀的测试的反面 - <strong>如果函数没有 revert，则测试失败</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function testFailSubtract43() public &#123;</span><br><span class="line">    testNumber -= 43;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>测试函数必须具有<code>external</code>或<code>public</code>可见性</strong>。 声明为<code>internal</code>或 <code>private</code> 不会被 Forge 选中，即使它们以 <code>test</code> 为前缀。</p></blockquote><h3 id="共享设置"><a href="#共享设置" class="headerlink" title="共享设置"></a>共享设置</h3><p>通过创建辅助抽象合约并在测试合约中继承它们来使用共享设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">abstract contract HelperContract &#123;</span><br><span class="line">    address constant IMPORTANT_ADDRESS = 0x543d...;</span><br><span class="line">    SomeContract someContract;</span><br><span class="line">    constructor() &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MyContractTest is Test, HelperContract &#123;</span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        someContract = new SomeContract(0, IMPORTANT_ADDRESS);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MyOtherContractTest is Test, HelperContract &#123;</span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        someContract = new SomeContract(1000, IMPORTANT_ADDRESS);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作弊码-Cheatcodes"><a href="#作弊码-Cheatcodes" class="headerlink" title="作弊码(Cheatcodes)"></a>作弊码(Cheatcodes)</h3><p>作弊码允许您更改区块号、您的身份（地址）等。 它们是通过<strong>在特别指定的地址上调用特定函数来调用的</strong>。</p><p>通过 Forge 标准库的 <code>Test</code> 合约中<strong>提供的 <code>vm</code> 实例轻松访问作弊码</strong></p><p>使用<code>prank</code> 作弊码将我们的身份更改为零地址再进行下一次调用 (<code>upOnly.increment()</code>)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vm.prank(address(0));</span><br><span class="line">upOnly.increment();</span><br><span class="line">//测试失败</span><br></pre></td></tr></table></figure><p>使用<code>expectRevert</code>作弊码来验证我们不是所有者的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm.expectRevert(Unauthorized.selector);</span><br><span class="line">vm.prank(address(0));</span><br><span class="line">upOnly.increment();</span><br><span class="line">//测试通过，因为获得了期望的Unauthorized的错误</span><br></pre></td></tr></table></figure><p>另一个可能不那么直观的作弊码是 <code>expectEmit</code> 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">event Transfer(address indexed from, address indexed to, uint256 amount);</span><br><span class="line">vm.expectEmit(true, true, false, true);</span><br><span class="line">// The event we expect</span><br><span class="line">emit Transfer(address(this), address(1337), 1337);</span><br><span class="line">// The event we get</span><br><span class="line">emitter.t();</span><br><span class="line">//在emitter.t()事件中期望是from是address(this)，而to是address(1337)</span><br><span class="line"></span><br><span class="line">event Transfer(address indexed from, address indexed to, uint256 amount);</span><br><span class="line">function t() public &#123;</span><br><span class="line">emit Transfer(msg.sender, address(1337), 1337);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>expectEmit</code> 中的第三个参数设置为 <code>false</code>，因为不需要检查 <code>Transfer</code> 事件中的第三个主题，因为只有两个主题。 即使我们设置为 <code>true</code> 也没关系，**<code>expectEmit</code> 中的第 4 个参数设置为 <code>true</code><strong>，这</strong>意味着我们要检查 “non-indexed topics（非索引主题）”，**也称为数据。</p><h3 id="理解跟踪"><a href="#理解跟踪" class="headerlink" title="理解跟踪"></a>理解跟踪</h3><p>Forge 可以为失败的测试（<code>-vvv</code>）或所有测试（<code>-vvvv</code>）生成跟踪(Traces)。</p><p>跟踪遵循相同的通用格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&lt;Gas Usage&gt;] &lt;Contract&gt;::&lt;Function&gt;(&lt;Parameters&gt;)</span><br><span class="line">  ├─ [&lt;Gas Usage&gt;] &lt;Contract&gt;::&lt;Function&gt;(&lt;Parameters&gt;)</span><br><span class="line">  │   └─ ← &lt;Return Value&gt;</span><br><span class="line">  └─ ← &lt;Return Value&gt;</span><br></pre></td></tr></table></figure><p>每个跟踪可以有更多的子跟踪（subtraces），每个 subtraces 表示对合约的调用和返回值。</p><p>如果您的终端支持颜色，跟踪也会有多种颜色：</p><ul><li><strong>绿色</strong>：对于不会 revert 的调用</li><li><strong>红色</strong>：用于有 evert 的调用</li><li><strong>蓝色</strong>：用于调用作弊码</li><li><strong>青色</strong>：用于触发日志</li><li><strong>黄色</strong>：用于合约部署</li></ul><h3 id="分叉测试-分叉模式-分叉作弊码"><a href="#分叉测试-分叉模式-分叉作弊码" class="headerlink" title="分叉测试(分叉模式&#x2F;分叉作弊码)"></a>分叉测试(分叉模式&#x2F;分叉作弊码)</h3><h4 id="分叉模式"><a href="#分叉模式" class="headerlink" title="分叉模式"></a>分叉模式</h4><p>要在分叉环境（例如分叉的以太坊主网）中运行所有测试，请通过 –fork-url 标志传递 RPC URL：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ forge <span class="built_in">test</span> --fork-url &lt;your_rpc_url&gt;</span><br></pre></td></tr></table></figure><p>以下值会更改以反映分叉时链的值：</p><p>block_number、chain_id、gas_limit、gas_price、block_base_fee_per_gas、block_coinbase、block_timestamp、block_difficulty</p><p>可以使用 <code>--fork-block-number</code> 指定要从中分叉的区块高度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ forge <span class="built_in">test</span> --fork-url &lt;your_rpc_url&gt; --fork-block-number 1</span><br></pre></td></tr></table></figure><p>当您需要与现有合约进行交互时，分叉特别有用。 您可以选择以这种方式进行集成测试，就好像您在实际网络上一样。</p><h5 id="缓存（Caching）"><a href="#缓存（Caching）" class="headerlink" title="缓存（Caching）"></a>缓存（Caching）</h5><p>如果同时指定了 <code>--fork-url</code> 和 <code>--fork-block-number</code>，那么该块的数据将被缓存以供将来的测试运行。</p><p>数据缓存在 <code>~/.foundry/cache/rpc/&lt;chain name&gt;/&lt;block number&gt;</code> 中。 </p><p><strong>要清除缓存，只需删除目录或运行 forge clean</strong>（删除所有构建工件和缓存目录）。</p><p>也可以<strong>通过传递 –no-storage-caching 或通过配置 no_storage_caching 和 foundry.toml 完全忽略缓存 rpc_storage_caching。</strong></p><h5 id="已改进的跟踪-traces"><a href="#已改进的跟踪-traces" class="headerlink" title="已改进的跟踪 traces"></a>已改进的跟踪 traces</h5><p>Forge 支持使用 Etherscan 在分叉环境中识别合约。</p><p>要使用此功能，请<strong>通过 <code>--etherscan-api-key</code> 标志传递 <code>Etherscan API </code>密钥：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ forge <span class="built_in">test</span> --fork-url &lt;your_rpc_url&gt; --etherscan-api-key &lt;your_etherscan_api_key&gt;</span><br></pre></td></tr></table></figure><p>或者，您可以设置 <code>ETHERSCAN_API_KEY</code> 环境变量。</p><h4 id="分叉作弊码"><a href="#分叉作弊码" class="headerlink" title="分叉作弊码"></a>分叉作弊码</h4><p>在逐个测试的基础上使用分叉模式，并在测试中使用多个分叉，每个分叉都通过其自己唯一的 <code>uint256</code> 标识符进行识别。</p><h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><p>用 <strong>createFork</strong> 创建两个分叉，没有在初始选择一个，**每个 fork 有一个唯一标识符 (uint256 forkId)**，该标识符在首次创建时分配。</p><p><strong>通过将该 forkId 传递给 selectFork 来启用特定的分叉。</strong>createSelectFork 是 createFork 加上 selectFork 的单行代码。<strong>一次只能有一个活动分叉，</strong>当前活动分叉的标识符<strong>可以通过 activeFork 检索</strong>。类似于 roll，您可以<strong>使用 rollFork 设置分叉的 block.number。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">contract ForkTest is Test &#123;</span><br><span class="line">    uint256 mainnetFork;</span><br><span class="line">    uint256 optimismFork;</span><br><span class="line">    </span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        mainnetFork = vm.createFork(MAINNET_RPC_URL);</span><br><span class="line">        optimismFork = vm.createFork(OPTIMISM_RPC_URL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testForkIdDiffer() public &#123;</span><br><span class="line">        assert(mainnetFork != optimismFork);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testCanSelectFork() public &#123;</span><br><span class="line">        vm.selectFork(mainnetFork);</span><br><span class="line">        assertEq(vm.activeFork(), mainnetFork);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testCanSwitchForks() public &#123;</span><br><span class="line">        vm.selectFork(mainnetFork);</span><br><span class="line">        assertEq(vm.activeFork(), mainnetFork);</span><br><span class="line">        vm.selectFork(optimismFork);</span><br><span class="line">        assertEq(vm.activeFork(), optimismFork);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testCanCreateAndSelectForkInOneStep() public &#123;</span><br><span class="line">        uint256 anotherFork = vm.createSelectFork(MAINNET_RPC_URL);</span><br><span class="line">        assertEq(vm.activeFork(), anotherFork);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testCanSetForkBlockNumber() public &#123;</span><br><span class="line">        vm.selectFork(mainnetFork);</span><br><span class="line">        vm.rollFork(1_337_000);</span><br><span class="line">        assertEq(block.number, 1_337_000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择分叉时，只有 msg.sender 和测试合约（ForkTest）的账户是持久的。 但是<strong>任何帐户都可以变成持久帐户</strong>：<strong>makePersistent</strong>，</p><p>persistent 帐户是唯一的， 即它存在于所有分叉上</p><blockquote><p> vm.makePersistent(address(simple));</p></blockquote><h1 id="高级测试"><a href="#高级测试" class="headerlink" title="高级测试"></a>高级测试</h1><h2 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h2><p>vm.assume(amount &gt; 0.1 ether);</p><p>**”vm.assume()”**方法通常用于在智能合约中进行条件断言（assertions）。它用于在代码执行过程中检查某个条件是否满足，如果条件不满足，则会引发异常或终止合约执行。</p><h2 id="差异测试"><a href="#差异测试" class="headerlink" title="差异测试"></a>差异测试</h2><p><strong>ffi</strong> 允许您执行任意 shell 命令并捕获输出。 这是一个模拟示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract TestContract is Test &#123;</span><br><span class="line"></span><br><span class="line">    function testMyFFI () public &#123;</span><br><span class="line">        string[] memory cmds = new string[](2);</span><br><span class="line">        cmds[0] = &quot;cat&quot;;</span><br><span class="line">        cmds[1] = &quot;address.txt&quot;; // assume contains abi-encoded address.</span><br><span class="line">        bytes memory result = vm.ffi(cmds);</span><br><span class="line">        address loadedAddress = abi.decode(result, (address));</span><br><span class="line">        // Do something with the address</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个地址之前已经写入了<code>address.txt</code>，我们使用 FFI 作弊码读取了它。 现在可以在整个测试合约中使用此数据。</p>]]></content>
      
      
      <categories>
          
          <category> Foundry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 合约框架 </tag>
            
            <tag> Foundry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-项目</title>
      <link href="/2023/02/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Foundry/1-%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/02/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%90%88%E7%BA%A6%E6%A1%86%E6%9E%B6/Foundry/1-%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="创建一个新项目"><a href="#创建一个新项目" class="headerlink" title="创建一个新项目"></a>创建一个新项目</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ forge init (--template https://github.com/foundry-rs/forge-template) hello_template</span><br></pre></td></tr></table></figure><p>如果你想使用不同的模板创建一个新项目，你可以传递 –template 指令,否则将从默认模板创建一个新目录 hello_foundry </p><blockquote><p>默认模板安装了一个依赖项：Forge 标准库。</p></blockquote><p>构建项目：forge build</p><p>运行测试：forge test</p><p>产生了两个新目录：out(artifact，例如 ABI) 和 cache(使用来记录，以便仅仅去重新编译那些必要编译的内容)。</p><h1 id="在现有项目工作"><a href="#在现有项目工作" class="headerlink" title="在现有项目工作"></a>在现有项目工作</h1><p>如果您下载一个使用 Foundry 的现有项目，那真的很容易上手。</p><p>首先，从某个地方获取项目。 在此示例中，我们将从 GitHub 克隆 femplate 存储库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/abigger87/femplate</span><br><span class="line">$ <span class="built_in">cd</span> femplate</span><br><span class="line">$ forge install</span><br></pre></td></tr></table></figure><p>我们运行 forge install 来安装项目中的子模块依赖项。</p><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><p>默认情况下，Forge 使用 git submodules 管理依赖项，这意味着它可以与任何包含智能合约的 GitHub 代码库一起使用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 添加依赖项(默认最新)</span><br><span class="line">$ forge install transmissions11/solmate</span><br><span class="line">//安装指定版本</span><br><span class="line">$ forge install transmission11/solmate@v7</span><br></pre></td></tr></table></figure><p>这将拉取 solmate 库，在 git 中暂存 .gitmodules 文件并使用消息“Installed solmate”进行提交。</p><h3 id="重新映射依赖项"><a href="#重新映射依赖项" class="headerlink" title="重新映射依赖项"></a>重新映射依赖项</h3><p>Forge 可以重新映射(remap)依赖关系，使它们更容易导入。 Forge 将自动尝试为您推断出一些重新映射：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ forge remappings</span><br><span class="line">ds-test/=lib/forge-std/lib/ds-test/src/</span><br><span class="line">forge-std/=lib/forge-std/src/</span><br></pre></td></tr></table></figure><p>这些重新映射意味着：</p><ul><li>要从 forge-std 导入，我们会这样写：import “forge-std&#x2F;Contract.sol”;</li><li>要从 ds-test 导入，我们会这样写：import “ds-test&#x2F;Contract.sol”;</li></ul><p>您可以通过在项目的根目录中创建一个 remappings.txt 文件来自定义这些重新映射。</p><p>让我们创建一个名为 solmate-utils 的重映射，它指向 solmate repo中的 utils 文件夹！</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solmate-utils/=lib/solmate/src/utils/</span><br></pre></td></tr></table></figure><p>现在我们可以像这样导入 solmate repo的 src&#x2F;utils 中的任何合约：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;solmate-utils/Contract.sol&quot;;</span><br></pre></td></tr></table></figure><h3 id="更新依赖"><a href="#更新依赖" class="headerlink" title="更新依赖"></a>更新依赖</h3><p>您可以使用 forge update 将特定依赖项更新为您指定版本的最新提交。 例如，如果我们想从我们之前安装的 solmate 主版本中提取最新的提交，我们将运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ forge update lib/solmate</span><br></pre></td></tr></table></figure><p>或者，您可以通过运行 forge update 一次对所有依赖项执行更新。</p><h3 id="删除依赖"><a href="#删除依赖" class="headerlink" title="删除依赖"></a>删除依赖</h3><p>您可以使用 forge remove … 删除依赖项，其中 <deps> 是依赖项的完整路径或只是名称 . 例如，要删除 solmate，这两个命令是等价的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ forge remove solmate</span><br><span class="line"><span class="comment"># ... 等同于 ...</span></span><br><span class="line">$ forge remove lib/solmate</span><br></pre></td></tr></table></figure><h1 id="项目布局"><a href="#项目布局" class="headerlink" title="项目布局"></a>项目布局</h1><p>Forge 在构建项目的方式上是灵活的。 默认情况下，Forge 项目结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── foundry.toml</span><br><span class="line">├── lib</span><br><span class="line">│   └── forge-std</span><br><span class="line">│       ├── LICENSE-APACHE</span><br><span class="line">│       ├── LICENSE-MIT</span><br><span class="line">│       ├── README.md</span><br><span class="line">│       ├── foundry.toml</span><br><span class="line">│       ├── lib</span><br><span class="line">│       └── src</span><br><span class="line">├── script</span><br><span class="line">│   └── Counter.s.sol</span><br><span class="line">├── src</span><br><span class="line">│   └── Counter.sol</span><br><span class="line">└── test</span><br><span class="line">    └── Counter.t.sol</span><br><span class="line"></span><br><span class="line">7 directories, 8 files</span><br></pre></td></tr></table></figure><ul><li>您可以使用 foundry.toml 配置 Foundry 的行为。</li><li>重新映射在 remappings.txt 中指定。</li><li>合约的默认目录是 src&#x2F;。</li><li>测试的默认目录是test&#x2F;，其中任何具有以test开头的函数的合约都被视为测试。</li><li>依赖项作为 git 子模块存储在 lib&#x2F; 中。</li></ul><p>您可以分别使用 –lib-paths 和 –contracts 标志配置 Forge 在何处查找依赖项和合约。 或者，您可以在 foundry.toml 中配置它。</p><p>结合重新映射，这为您提供了支持其他工具链（例如 Hardhat 和 Truffle）的项目结构所需的灵活性。</p><p>对于获得自动 Hardhat 支持，您还可以传递 –hh 标志，它设置以下标志：–lib-paths node_modules –contracts contracts。</p><h1 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="一般命令"><a href="#一般命令" class="headerlink" title="一般命令"></a>一般命令</h3><p>forge help：显示关于 Forge 的帮助信息。</p><p>forge completions：为 Forge 生成 shell 的自动补全。</p><h3 id="项目命令"><a href="#项目命令" class="headerlink" title="项目命令"></a>项目命令</h3><p>forge init：创建一个新的 Forge 项目。</p><p>forge install：安装一个或多个依赖。</p><p>forge update：更新一个或多个依赖。</p><p>forge remove：移除一个或多个依赖。</p><p>forge config：显示当前配置。</p><p>forge remappings：获取这个项目的自动推断的重映射。</p><p>forge tree：显示项目的树状可视化依赖关系图。</p><h3 id="构建命令"><a href="#构建命令" class="headerlink" title="构建命令"></a>构建命令</h3><p>forge build：构建项目的智能合约。</p><p>forge clean：移除构建的 artifacts 和 cache 目录。</p><p>forge inspect：获取关于智能合约的专门信息。</p><h3 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h3><p>forge test：运行项目的测试。</p><p>forge snapshot：创建每个测试的 Gas 使用快照。</p><h3 id="部署命令"><a href="#部署命令" class="headerlink" title="部署命令"></a>部署命令</h3><p>forge create：部署一个智能合约</p><p>forge verify-contract：在 Etherscan 上验证智能合约。</p><p>forge verify-check：在 Etherscan 上检查验证状态。</p><p>forge flatten：将一个源文件及其所有的导入文件扁平化到一个文件中。</p><h3 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h3><p>forge debug：将单个智能合约作为脚本进行调试。</p><p>forge bind：为智能合约生成 Rust bindings。</p><p>forge cache：管理 Foundry 缓存。</p><p>forge cache clean：从 ~&#x2F;.foundry 清除缓存数据。</p><p>forge cache ls：从 ~&#x2F;.foundry 显示缓存数据。</p><p>forge script：以脚本形式运行智能合约，建立可在链上发送的交易。</p><p>forge upload-selectors：将给定合约的 ABI 上传至 <a href="https://sig.eth.samczsun.com/">https://sig.eth.samczsun.com</a> 函数选择器数据库。</p>]]></content>
      
      
      <categories>
          
          <category> Foundry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 合约框架 </tag>
            
            <tag> Foundry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5- PAXOS-HotStuff</title>
      <link href="/2023/02/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/5-%20PAXOS-HotStuff/"/>
      <url>/2023/02/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/5-%20PAXOS-HotStuff/</url>
      
        <content type="html"><![CDATA[<h1 id="PAXOS"><a href="#PAXOS" class="headerlink" title="PAXOS"></a>PAXOS</h1><p>Paxos算法运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用大多数 (Majority) 机制<strong>保证了2F+1的容错能力，即2F+1个节点的系统最多允许F个节点同时出现故障。</strong></p><p>一个或多个提议进程 (Proposer) 可以发起提案 (Proposal)，Paxos算法使所有提案中的某一个提案，在所有进程中达成一致。系统中的多数派同时认可该提案，即达成了一致。最多只针对一个确定的提案达成一致。</p><p>Paxos将系统中的角色分为<strong>提议者 (Proposer)，决策者 (Acceptor)，和最终决策学习者 (Learner):</strong></p><ul><li><strong>Proposer</strong>: 提出提案 (Proposal)。Proposal信息包括提案编号 (Proposal ID) 和提议的值 (Value)。</li><li><strong>Acceptor</strong>：参与决策，回应Proposers的提案。收到Proposal后可以接受提案，若Proposal获得多数Acceptors的接受，则称该Proposal被批准。</li><li><strong>Learner</strong>：不参与决策，从Proposers&#x2F;Acceptors学习最新达成一致的提案（Value）。</li></ul><p>在多副本状态机中，每个副本同时具有Proposer、Acceptor、Learner三种角色。</p><p> <img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/img/image-20230321093843333.png" alt="image-20230321093843333"></p><ol><li><strong>第一阶段：Prepare阶段。Proposer向Acceptors发出Prepare请求，Acceptors针对收到的Prepare请求进行Promise承诺。</strong></li><li><strong>第二阶段：Accept阶段。Proposer收到多数Acceptors承诺的Promise后，向Acceptors发出Propose请求，Acceptors针对收到的Propose请求进行Accept处理。</strong></li><li><strong>第三阶段：Learn阶段。Proposer在收到多数Acceptors的Accept之后，标志着本次Accept成功，决议形成，将形成的决议发送给所有Learners。</strong></li></ol><h1 id="HotStuff"><a href="#HotStuff" class="headerlink" title="HotStuff"></a>HotStuff</h1><p>是一种<strong>优化后的三阶段bft算法</strong>，在拜占庭节点数小于总数1&#x2F;3时，保证系统的安全运行，同时提供更加高效的运行效率</p><p>以下是HotStuff算法的基本原理和过程：</p><ol><li>角色定义：<ul><li>Leader（领导者）：负责提出新区块的候选人，并驱动共识过程。</li><li>Validator（验证者）：参与共识的节点，验证和存储区块链数据。</li></ul></li><li>阶段一：投票阶段（Voting Phase）：<ul><li><strong>领导者提出一个新的候选区块，并将其广播给所有验证者。</strong></li><li><strong>验证者收到候选区块后，对其进行投票</strong>，表示接受或拒绝该候选区块。</li><li><strong>当一个验证者收到多数其他验证者的接受票时，它会将自己的投票广播给其他节点。</strong></li></ul></li><li>阶段二：证明阶段（Certify Phase）：<ul><li><strong>当一个验证者收到多数其他验证者的接受票时，它可以将该候选区块标记为已被证明。</strong></li><li><strong>该验证者会将证明消息广播给其他节点，以通知它们该候选区块已被共识接受。</strong></li></ul></li><li>阶段三：提交阶段（Commit Phase）：<ul><li><strong>一旦一个验证者收到多数其他验证者的证明消息，它可以将该候选区块提交到区块链中。</strong></li><li><strong>验证者将该候选区块添加到自己的本地区块链中，并广播提交消息给其他节点。</strong></li></ul></li></ol><p>HotStuff算法具有以下特点和优势：</p><ul><li>高性能：HotStuff采用了基于投票和多数决策的方式，使得共识过程具有较低的通信和计算开销。</li><li>简化流程：相比于传统的拜占庭容错共识算法，HotStuff的共识流程更为简化，减少了复杂性。</li><li>快速最终性：一旦一个候选区块被多数验证者接受，它就会被最终性地提交到区块链中，不再受到更长链的覆盖。</li><li>安全性：HotStuff算法基于拜占庭容错模型，可以容忍一部分节点的恶意行为或故障，保证共识结果的正确性和安全性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 共识算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 共识算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-RAFT</title>
      <link href="/2023/01/31/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/4-RAFT/"/>
      <url>/2023/01/31/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/4-RAFT/</url>
      
        <content type="html"><![CDATA[<h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="Raft-1"><a href="#Raft-1" class="headerlink" title="Raft"></a>Raft</h3><p>Raft（Replication and Fault Tolerant）是一个允许网络分区（Partition Tolerant）的一致性协议，它保证了在一个<strong>由N个恶意节点构成的系统中有2N+1</strong>节点正常工作的情况下的系统的一致性，比如在一个5个节点的系统中允许2个节点出现非拜占庭错误，如节点宕机、网络分区、消息延时。Raft相比于Paxos更容易理解，且被证明可以提供与Paxos相同的容错性以及性能。</p><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p>在Raft算法中，每个网络节点只能如下三种身份之一：<strong>Leader</strong>、<strong>Follower</strong>以及<strong>Candidate</strong>，其中:</p><ul><li><strong>Leader</strong>：<strong>主要负责与外界交互，由Follower节点选举而来</strong>，在每一次共识过程中<strong>有且仅有一个Leader节点</strong>，由<strong>Leader全权负责从交易池中取出交易、打包交易组成区块并将区块上链；</strong></li><li><strong>Follower</strong>：<strong>以Leader节点为准进行同步，并在Leader节点失效时举行选举以选出新的Leader节点；</strong></li><li><strong>Candidate</strong>：<strong>Follower节点在竞选Leader时拥有的临时身份</strong>。</li></ul><h3 id="点ID-节点索引"><a href="#点ID-节点索引" class="headerlink" title="点ID &amp; 节点索引"></a>点ID &amp; 节点索引</h3><p>在Raft算法中，<strong>每个网络节点都会有一个固定且全局的唯一的用于表明节点身份的ID</strong>（一般是一个64字节表示数字），这称为节点ID；<strong>同时每个共识节点还会维护一份公共的共识节点列表，这个列表记录了每个共识节点的ID，而自己在这个列表中的位置被称为节点索引。</strong></p><h3 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h3><p><strong>Raft算法将时间划分为不定长度的任期Terms，Terms为连续的数字</strong>。每个Term以选举开始，如果选举成功，则由当前leader负责出块，<strong>如果选举失败，并没有选举出新的单一Leader，则会开启新的Term，重新开始选举。</strong></p><p> <img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/img/raft_terms.png" alt="../../../_images/raft_terms.png">.</p><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p><strong>在Raft算法中，每个网络节点间通过发送消息进行通讯</strong>，当前Raft模块包括四种消息：<strong>VoteReq</strong>、<strong>VoteResp</strong>、<strong>Heartbeat</strong>、<strong>HeartbeatResp</strong>，其中：</p><ul><li><strong>VoteReq</strong>：投票请求，由Candidate节点主动发出，用于<strong>向网络中其他节点请求投票以竞选Leader；</strong></li><li><strong>VoteResp</strong>：投票响应，在节点收到投票请求后，用于<strong>对投票请求进行响应，响应内容为同意或拒绝该投票请求；</strong></li><li><strong>Heartbeat</strong>：心跳，<strong>由Leader节点主动周期发出</strong>，其作用有两个：(1) <strong>用于维护Leader节点身份，只要Leader能够一直正常发送心跳且被其他节点响应，Leader身份就不会发生变化</strong>；(2) 区块数据复制，<strong>当Leader节点成功打包一个区块后，会将区块数据编码至心跳中以将区块进行广播，其他节点在收到该心跳后会解码出区块数据并将区块放入自己的缓冲区中；</strong></li><li><strong>HeartbeatResp</strong>：心跳响应，<strong>在节点收到心跳后，用于对心跳进行响应，特别的，当收到一个包含区块数据的心跳时，该心跳的响应中会带上该区块的哈希；</strong></li></ul><p>所有消息共有的字段如下表所示：</p><table><thead><tr><th>字段名</th><th>字段含义</th></tr></thead><tbody><tr><td>idx</td><td>自身节点索引</td></tr><tr><td>term</td><td>前节点所处在的任期</td></tr><tr><td>height</td><td>当前节点所持有的最高块的块高</td></tr><tr><td>blockHash</td><td>前节点所持有的最高块的哈希</td></tr></tbody></table><p>每种消息类型特有的字段如下表所示：</p><table><thead><tr><th>消息类型</th><th>字段名</th><th>字段含义</th></tr></thead><tbody><tr><td>VoteReq</td><td>candidate</td><td>Candidate自身的节点索引</td></tr><tr><td>lastLeaderTerm</td><td>Candidate见到过的最后一个Leader的Term，其详细作用见3.1.2节</td><td></td></tr><tr><td>lastBlockNumber</td><td>Candidate见到过的最新块的块高，其详细作用见3.1.2节</td><td></td></tr><tr><td>VoteResp</td><td>voteFlag</td><td>对投票请求的响应标志位，用以标记对是否同意投票请求，若是拒绝还会具体标记拒绝原因，其详细作用见3.1.2节</td></tr><tr><td>lastLeaderTerm</td><td>收到VoteReq的节点见到过的最新块的块高，其详细作用见3.1.2节</td><td></td></tr><tr><td>Heartbeat</td><td>leader</td><td>发出心跳的Leader节点的节点索引</td></tr><tr><td>uncommitedBlock</td><td>当Leader节点预备提交一个新块时，会先将区块数据编码进此字段以并通过心跳进行广播，其详细作用见3.2节</td><td></td></tr><tr><td>uncommitedBlockNumber</td><td>uncommitedBlock对应的块高，其详细作用见3.2节</td><td></td></tr><tr><td>HeartbeatResp</td><td>uncommitedBlockHash</td><td>当收到Leader发送过来的uncommitedBlock数据时，节点在心跳响应中写入uncommitedBlock对应的哈希（指纹），并发送回Leader，表明节点已经收到Leader预备提交的区块数据且已写入本地缓存，其详细作用见3.2节</td></tr></tbody></table><h2 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h2><p>系统框架如下图所示：</p><img src="/noteimg/区块链/区块链知识点总结/共识算法/img/raft_architecture.png" alt="../../../_images/raft_architecture.png" style="zoom: 80%;" /> <ul><li>Raft Sealer：负责从交易池取出交易并打包成区块，并发送至Raft Engine进行共识。区块上链后，Raft Sealer负责从交易池中删除已上链交易；</li><li>Raft Engine：负责在共识节点进行共识，将达成共识的区块上链。</li></ul><h2 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h2><h3 id="节点状态转换"><a href="#节点状态转换" class="headerlink" title="节点状态转换"></a>节点状态转换</h3><p>节点类型之间转换关系如下图所示，每种状态转换形式将在接下来的各个小节进行阐述：</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/img/raft_nodes_transfer.jpg" alt="../../../_images/raft_nodes_transfer.jpg"></p><h4 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h4><p>Raft共识模块中<strong>使用心跳机制来触发Leader选举</strong>。当节点启动时，节点自动成为Follower且将Term置0。只要Follower从Leader或者Candidate收到有效的Heartbeat或RequestVote消息，其就会保持在Follower状态，**如果Follower在一段时间内（这段时间称为 <em>Election Timeout</em>）没收到上述消息，则它会假设系统当前的Leader已经失活，然后增加自己的Term并转换为Candidiate，开启新一轮的Leader选举流程，**流程如下:</p><ol><li>Follower增加当前的Term，转换为Candidate；</li><li>Candidate将票投给自己，并<strong>广播RequestVote到其他节点请求投票</strong>；</li><li>Candidate节点保持在Candidate状态，直到下面三种情况中的一种发生：**(1)该节点赢得选举；(2) 在等待选举期间，Candidate收到了其他节点的Heartbeat；(3) 经过<em>Election Timeout</em>后，没有Leader被选出<strong>。</strong>Raft算法采用随机定时器的方法来避免节点选票出现平均瓜分的情况**以保证大多数时候只会有一个节点超时进入Candidate状态并获得大部分节点的投票成为Leader。</li></ol><h4 id="投票"><a href="#投票" class="headerlink" title="投票"></a>投票</h4><p>节点在收到VoteReq消息后，会根据消息的内容选择不同的响应策略：</p><ol><li><p><em><strong>VoteReq的Term小于或等于自己的Term</strong></em></p><ul><li><strong>如果节点是Leader，则拒绝该投票请求</strong>，Candidate收到此响应后会放弃选举转变为Follower，并增加投票超时；</li><li>如果节点不是Leader：<ul><li><strong>如果VoteReq的Term小于自己的Term，则拒绝该投票请求</strong>，如果Candidate收到超过半数的该种响应则表明其已经过时，此时Candidate会放弃选举转变为Follower，并增加投票超时；</li><li><strong>如果VoteReq的Term等于自己的Term，则拒绝该投票请求</strong>，对于该投票请求不作任何处理。对于每个节点而言，只能按照先到先得的原则投票给一个Candidate，从而保证每轮选举中至多只有一个Candidate被选为Leader。</li></ul></li></ul></li><li><p><em><strong>VoteReq的lastLeaderTerm小于自己的lastLeaderTerm</strong></em></p><p>每个节点中会有一个lastLeaderTerm字段表示该节点见过的最后一个Leader的Term，lastLeaderTerm仅能由Heartbeat进行更新。<strong>如果VoteReq中的lastLeaderTerm小于自己的lastLeaderTerm，表明Leader访问这个Candidate存在问题，如果此时Candidate处于网络孤岛的环境中，会不断向外提起投票请求，因此需要打断它的投票请求，所以此时节点会拒绝该投票请求。</strong></p></li><li><p><em><strong>VoteReq的lastBlockNumber小于自己的lastBlockNumber</strong></em></p><p>每个节点中会有一个lastBlockNumber字段表示节点见到过的最新块的块高。在出块过程中，节点间会进行区块复制（详见3.2节），在区块复制的过程中，可能有部分节点收到了较新的区块数据而部分没有，从而导致不同节点的lastBlockNumber不一致。<strong>为了使系统能够达成一致，需要要求节点必须把票投给拥有较新数据的节点，因此在这种情况下节点会拒绝该投票请求。</strong></p></li><li><p><em><strong>节点是第一次投票</strong></em></p><p>为了避免出现Follower因为网络抖动导致重新发起选举，<strong>规定如果节点是第一次投票，直接拒绝该投票请求，</strong>同时会将自己的firstVote字段置为该Candidate的节点索引。</p></li><li><p><em><strong>1~4步骤中都没有拒绝投票请求</strong></em></p><p><strong>同意该投票请求。</strong></p></li></ol><h4 id="心跳超时"><a href="#心跳超时" class="headerlink" title="心跳超时"></a>心跳超时</h4><p>在Leader成为网络孤岛时，<strong>Leader可以发出心跳、Follower可以收到心跳但是Leader收不到心跳回应，</strong>这种情况下Leader此时已经出现网络异常，但是由于一直可以向外发送心跳包会导致Follower无法切换状态进行选取，系统陷入停滞。为了避免第二种情况发生，模<strong>块中设置了心跳超时机制，Leader每次收到心跳回应时会进行相应记录，一旦一段时间后记录没有更新则Leader放弃Leader身份并转换为Follower节点。</strong></p><h3 id="区块复制"><a href="#区块复制" class="headerlink" title="区块复制"></a>区块复制</h3><p>Raft协议强依赖Leader节点的可用性来确保集群数据的一致性，因为数据只能从Leader节点向Follower节点转移。<strong>当Raft Sealer向集群Leader提交区块数据后，Leader将该数据置为未提交（uncommitted）状态</strong>，接着<strong>Leader 节点会通过在Heartbeat中附加数据的形式并发向所有Follower节点复制数据并等待接收响应，在确保网络中超过半数节点已接收到数据后，再将区块数据写入底层存储中，此时区块数据状态已经进入已提交（committed）状态</strong>。此后Leader节点再通过Sync模块<strong>向其他Follower节点广播该区块数据</strong>，区块复制及提交的流程图如下图所示：</p><img src="/noteimg/区块链/区块链知识点总结/共识算法/img/image-20230614100627108.png" alt="image-20230614100627108" style="zoom:67%;" /> <p>其中RaftSealer验证是否当前是否能打包交易的验证条件包括：**(1) 是否为Leader；(2) 是否存在尚未完成同步的peer； (3) uncommitBlock字段是否为空，只有三个条件均符合才允许打包。**</p>]]></content>
      
      
      <categories>
          
          <category> 共识算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 共识算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-PBFT</title>
      <link href="/2023/01/27/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/3-PBFT/"/>
      <url>/2023/01/27/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/3-PBFT/</url>
      
        <content type="html"><![CDATA[<h2 id="PBFT-实用拜占庭容错算法"><a href="#PBFT-实用拜占庭容错算法" class="headerlink" title="PBFT 实用拜占庭容错算法"></a>PBFT <strong>实用拜占庭容错算法</strong></h2><h3 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h3><p>一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。<strong>因此，将军们必须有一个预定的方法协议，使所有忠诚的将军够达成一致</strong>。而且少数几个叛徒不能使忠诚的将军做出错误的计划。<strong>也就是说，拜占庭将军问题的实质就是要寻找一个方法，使得将军们在一个有版徒的非信任环境中建立对战斗计划的共识</strong>。</p><p>在该模型下，<strong>系统不会对集群中的节点做任何的限制</strong>，它们可以向其他节点发送随机数据、错误数据，也可以选择不响应其他节点的请求，这些无法预测的行为使得容错这一问题变得更加复杂。<strong>拜占庭将军问题是对分布式系统容错的最高要求</strong>。 <img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/img/image-20230321100125432.png" alt="image-20230321100125432"></p><p>其中C为发送请求端，0123为服务端，3为宕机的服务端，具体步骤如下：</p><ol><li>Request请求阶段：请求端C发送请求到主节点0</li><li>Pre-Prepare预准备阶段：客户端请求消息签名是否正确，然后广播给其他副本节点</li><li>Prepare准备阶段：123收到后记录并再次广播，1-&gt;023，2-&gt;013，3因为宕机无法广播</li><li>Commit提交阶段：如果副本节点收到了2f个验证通过的PREPARE消息，则广播Commit请求</li><li>Reply响应阶段：如果副本节点i收到了2f+1个验证通过的COMMIT消息，备份节点在执行完请求后，将结果发送给客户端，则对C进行反馈</li></ol><h2 id="PBFT算法的运作原理"><a href="#PBFT算法的运作原理" class="headerlink" title="PBFT算法的运作原理"></a>PBFT算法的运作原理</h2><ol><li>取一个副本作为主节点，其他的副本作为备份</li><li><strong>用户端向主节点发送使用服务操作的请求</strong></li><li><strong>主节点通过广播将请求发送给其他副本</strong></li><li>所有<strong>副本执行请求并将结果发回用户端</strong></li><li>用户端需要<strong>等待F+1个不同副本节点发回相同的结果</strong>，作为整个操作的最终结果。</li></ol><h2 id="主节点的选择"><a href="#主节点的选择" class="headerlink" title="主节点的选择"></a>主节点的选择</h2><p>在PBFT算法中，主节点的选择是通过一种基于视图号（View）和轮次（Round）的选举机制完成的。以下是主节点选择的基本过程：</p><ol><li><strong>视图切换：</strong><ul><li>PBFT算法中的视图是一个递增的编号，代表了系统中的不同状态。</li><li>初始状态下，系统进入视图1。</li><li><strong>如果系统中的节点检测到当前视图的主节点发生故障或无法正常运行，它们可以发起视图切换</strong>。</li></ul></li><li><strong>视图切换请求：</strong><ul><li><strong>当节点检测到主节点故障时，它们会广播一个视图切换请求。</strong></li><li><strong>视图切换请求包含了提议新主节点的信息，</strong>如节点的标识符和签名。</li></ul></li><li><strong>视图切换预准备：</strong><ul><li>其他节点在收到视图切换请求后，首先验证请求的合法性。</li><li><strong>如果请求合法，节点会将其广播给其他节点，以便获得足够数量的预准备消息。</strong></li></ul></li><li><strong>视图切换准备：</strong><ul><li><strong>节点在收到足够数量的预准备消息后，可以生成视图切换准备消息并广播给其他节点。</strong></li><li>视图切换准备消息中包含了足够数量的预准备消息的摘要。</li></ul></li><li><strong>视图切换提交：</strong><ul><li><strong>节点在收到足够数量的准备消息后，可以生成视图切换提交消息并广播给其他节点。</strong></li><li>视图切换提交消息中包含了足够数量的准备消息的摘要。</li></ul></li><li><strong>新视图的主节点选举：</strong><ul><li><strong>当节点收到足够数量的视图切换提交消息后，可以认为新视图已经达成共识。</strong></li><li>节点根据一定的规则从候选主节点中选择新的主节点，例如，<strong>可以选择具有最高编号的节点作为新的主节点。</strong></li></ul></li></ol><p>需要注意的是，<strong>视图切换是通过多数投票的方式完成的</strong>。即系统中的节点需要达成一致，并广播足够数量的消息来确保选举结果的合法性。只有在新的主节点被选举出来后，系统才能进入新的视图并继续执行PBFT算法的各个阶段。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>优点：高速、可扩展。缺点：通常用于私有网络和许可网络。(f是有可能失效的副本的最大个数)</p><ol><li>计算效率依赖于参与协议的节点数量，不适用于节点数量过大的区块链系统，扩展性差。</li><li>系统节点是固定的，无法应对公有链的开放环境，只适用于联盟链或私有链环境。</li><li>PBFT算法要求总节点数n&gt;&#x3D;3f+1(其中，f代表作恶节点数)。系统的失效节点数量不得超过全网节点的1&#x2F;3，容错率相对较低</li><li>尽管可以存在多于3f+1个副本，但是额外的副本除了降低性能之外不能提高可靠性。</li></ol><h2 id="DBFT-授权拜占庭容错算法"><a href="#DBFT-授权拜占庭容错算法" class="headerlink" title="DBFT 授权拜占庭容错算法"></a>DBFT <strong>授权拜占庭容错算法</strong></h2><p><strong>在这个机制当中，存在两个参与者，一个是专业记账的“记账节点”，一个是系统当中的普通用户</strong>。</p><p><strong>普通用户基于持有权益的比例来投票决定记账节点</strong>，当<strong>需要通过一项共识时，在这些记账节点中随机推选出一名发言人拟定方案</strong>，然后由其他记账节点根据<strong>拜占庭容错算法，即少数服从多数的原则进行表态，如果超过66%的节点表示同意发言人方案</strong>，则共识达成；否则，重新推选发言人，重复投票过程。</p><p><strong>所以说，dBFT机制实际使用了一种迭代共识的方法来保证系统达成一致决定。</strong>然而，<strong>这种机制的缺点在于，当系统中有超过三分之一的记账节点停止工作时，整个区块链网络将无法提供正常的服务</strong>；当超过三分之一的节点联合作恶时，区块链将有可能发生分叉。</p>]]></content>
      
      
      <categories>
          
          <category> 共识算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 共识算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-共识算法</title>
      <link href="/2023/01/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/1-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2023/01/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/1-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h1><p>共识算法（Consensus algorithm）是指<strong>在分布式系统中，参与者就某个共享状态达成一致的过程或协议</strong>。<strong>在分布式系统中，各个节点可能由于网络延迟、节点故障或恶意行为等原因导致信息不同步，因此需要通过共识算法来解决一致性问题。</strong></p><p>共识算法的目标是<strong>确保分布式系统中的节点就某个共享状态达成一致，并且保证系统的安全性、可用性和正确性</strong>。常见的应用场景包括区块链系统、分布式数据库、分布式存储系统等。</p><h1 id="以太坊的POS"><a href="#以太坊的POS" class="headerlink" title="以太坊的POS"></a>以太坊的POS</h1><p>以太坊采用权益证明机制，在该机制下，<strong>验证者明确地通过以太币将资本质押到以太坊上的智能合约中</strong>。 这些质押的以太币充当抵押品，<strong>如果验证者有失信行为或者消极怠工，那么可以销毁抵押品。</strong> 之后，<strong>验证者负责检查在网络上传播的新区块是否有效，并偶尔自己也创建和传播新区块。</strong></p><h3 id="验证者"><a href="#验证者" class="headerlink" title="验证者"></a>验证者</h3><p>要想作为验证者参与，<strong>用户必须向存款合约存入 32 个以太币并运行三种独立的软件：执行客户端、共识客户端和验证者</strong>。 存入以太币时，用户会进入一个激活队列，限制新验证者加入网络的速度。 <strong>激活后，验证者将从以太坊网络上的对等节点接收新区块</strong>。 区块中交付的交易会被重新执行，并且对区块签名进行检查以确保区块是有效的。 然后<strong>验证者在整个网络上发送支持该区块的投票</strong>（称为认证）。</p><p>在工作量证明中，生成区块的时间是由挖矿难度决定的，而在权益证明中，节奏是固定的。 权益证明以太坊中的时间分为时隙（12 秒）和时段（32 个时隙）。 <strong>在每个时隙中随机选择一位验证者作为区块提议者。 该验证者负责创建新区块并发送给网络上的其他节点。 另外在每个时隙中，都会随机选择一个验证者委员会，通过他们的投票确定所提议区块的有效性</strong></p><h3 id="区块创建"><a href="#区块创建" class="headerlink" title="区块创建"></a>区块创建</h3><p>验证者创建区块。 <strong>每个时隙中都会随机选择一个验证者成为区块提议者。 区块提议者的共识客户端请求配对执行客户端对交易打包，</strong>作为“执行负载”。 然后它们<strong>将“执行负载”包装成共识数据并形成一个区块</strong>，再把这个区块发送给以太坊网络上的其他节点。 这样的区块生产会得到以太币奖励。 <strong>在极少数情况下，一个时隙中产生了多个可能的区块，或节点在不同时间收到区块，</strong>分叉选择算法就<strong>会选择使形成的链具有最大认证权重的那个区块</strong>（<strong>认证权重是指为该区块提供认证的验证者数量</strong>，并根据验证者质押的以太币余额调整）。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>没有最好的算法，只有最适合自己的算法</strong>。共识算法的选择与应用场景高度相关，可信环境使用Paxos 或者RAFT，带许可的联盟可使用PBFT ，非许可链可以是PoW，PoS，Ripple共识等。根据根据自己的实际需求选择共识算法，才是最优解。</p>]]></content>
      
      
      <categories>
          
          <category> 共识算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 共识算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-pow-pos</title>
      <link href="/2023/01/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/2-pow-pos/"/>
      <url>/2023/01/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/2-pow-pos/</url>
      
        <content type="html"><![CDATA[<h2 id="POW-工作量证明"><a href="#POW-工作量证明" class="headerlink" title="POW 工作量证明"></a>POW <strong>工作量证明</strong></h2><p><strong>提交一份用来确认你做过一定量的工作的证明。</strong>监测工作的整个过程通常是极为低效的，而<strong>通过对工作的结果进行认证来证明完成了相应的工作量是一种非常高效的方式。</strong></p><p>工作量证明最常用的技术原理是哈希函数。由于输入哈希函数h的任意值n，会对应到一个h(n)结果，而n只要变动一个位元，就会引起雪崩效应，所以几乎无法从h(n)反推回n，因此借由指定查找h(n)的特征，<strong>让用户进行大量的穷举运算，就可以达成工作量证明</strong>。</p><p><strong>特点</strong>：稳定可靠(攻击者必须投入超过总体一半的运算量51%攻击，难于实现)</p><p>​非常浪费能源，技术人员开发出了由ASIC组成的特制计算设备（矿机），垄断算力</p><h2 id="POS-权益证明"><a href="#POS-权益证明" class="headerlink" title="POS 权益证明"></a>POS <strong>权益证明</strong></h2><p>Pow带来的问题最主要的是能耗问题，通过挖矿比拼的是设备的数量，其实也就是拼钱。因此为什么不直接拼钱来分成奖励呢？省下了不必要的挖矿过程。因此基于这个理论，提出权益证明。</p><p>权益证明的原理是指<strong>通过抵押代币，并计算抵押的代币数量和抵押时间的乘积，也就是币龄。每次出块时，币龄最大的矿工获得出块权。产生区块后，该矿工获得出块奖励，同时币龄清零并重新开始计算，如此类推。</strong></p><p><strong>特点</strong>:硬件要求低，不需要消耗巨大的能源，出块速度更快。缺点是：去中心化程度不高</p><h2 id="DPOW-延迟工作量证明"><a href="#DPOW-延迟工作量证明" class="headerlink" title="DPOW 延迟工作量证明"></a>DPOW <strong>延迟工作量证明</strong></h2><p>DPow的原理是<strong>允许一个区块链利用第二个区块链的哈希算力所提供的安全。</strong>该机制是通过一组公证员节点实现的。公证员节点实现将第一个区块链的数据添加到第二个区块链中。进而，第二个区块链请求在两个区块链间达成妥协，弱化第一个区块链的安全。</p><p><strong>DPOW系统中有两种类型的节点：公证人节点和正常节点</strong></p><p>64 个公证人节点是由 DPoW 区块链的权益持有者（stakeholder）选举产生的，它们可从 DPoW 区块链向所附加的 PoW 区块链添加经公证确认的块。<strong>一旦添加了一个块，该块的哈希值将被添加到由 33 个公证人节点签署的 Bitcoin 交易中，并创建一个哈希到 Bitcoin 区块链的 dPow 块记录</strong>。该记录已被网络中的大多数公证人节点公证。</p><p>为避免公证人节点间在挖矿上产生战争，进而降低网络的效率，Komodo 设计采用轮询机制的挖矿方法，该方法具有两种运行模式。</p><p><strong>在“无公证人”（No Notary）模式下，支持所有网络节点参与挖矿，这类似于传统 PoW 共识机制。而在“公证人激活”（Notaries Active）模式下，网络公证人使用一种显著降低的网络难度率挖矿</strong>。“公证人激活”模式下，允许每位公证人使用其当前的难度挖掘一个区块，而其它公证人节点必须采用 10 倍难度挖矿，所有正常节点使用公证人节点难度的 100 倍挖矿。</p><p><strong>特点：</strong>只有使用PoW或PoS的区块链，才能采用这种共识算法；在“公证员激活”模式下，必须校准不同节点的哈希率</p><h2 id="DPOS-委托权益证明"><a href="#DPOS-委托权益证明" class="headerlink" title="DPOS 委托权益证明"></a>DPOS <strong>委托权益证明</strong></h2><p>先<strong>由代币持有者投票选出若干个见证人</strong>，<strong>又称为超级节点</strong>，<strong>再由这些见证人轮流出块</strong>。这种做法是在运行效率和去中心化两者中获得平衡。见证人类似于股份制公司里的董事会成员。<strong>普通的代币持有者只有进行投票的权利，持有的代币越多，他能投的票数也越多。获得投票数最高的若干候选人将当选见证人。</strong>见证人有任期，一般是一周。一周过后重新选举新的见证人。<strong>每个区块如果能获得一定比例（EOS为大于2&#x2F;3）的所有见证人的同意，这个区块就是有效的。</strong>区块链上的所有的升级和提议，都必须经过委员会（由所有见证人组成）的同意才能执行。</p><p><strong>特点：</strong>不需要消耗巨大的能源，运行效率更高，出块速度更快，不容易产生分叉。缺点是：去中心化程度不高，容易出现贿选问题</p><h2 id="PoB（Proof-of-Burn）焚烧证明机制"><a href="#PoB（Proof-of-Burn）焚烧证明机制" class="headerlink" title="PoB（Proof of Burn）焚烧证明机制"></a><strong>PoB（Proof of Burn）焚烧证明机制</strong></h2><p><strong>是一种通过焚烧自己手中的代币来表决谁拥有对网络的领导地位的承诺</strong></p><p>在基于DPoW的区块链中，矿工挖矿所获得的不再是奖励的代币，而是可以焚烧的“wood”——燃木。矿工使用自己的算力，通过哈希算法，最终证明自己的工作量之后，获取对应的wood，wood不可交易。当wood积攒到一定量之后，可以前往燃烧场地燃烧wood。<strong>通过一组算法计算后，燃烧较多wood的人或者BP或者一组BP可以获取下个事件段出块的权利，成功出块后获取奖励（代币）</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 共识算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> 共识算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>V3合约导读</title>
      <link href="/2023/01/22/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV3/V3%E5%90%88%E7%BA%A6%E5%AF%BC%E8%AF%BB/"/>
      <url>/2023/01/22/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV3/V3%E5%90%88%E7%BA%A6%E5%AF%BC%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="UniswapV3-合约导读"><a href="#UniswapV3-合约导读" class="headerlink" title="UniswapV3 合约导读"></a>UniswapV3 合约导读</h1><img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/ExactInput.png" alt="ExactInput"  /><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><h3 id="core"><a href="#core" class="headerlink" title="core"></a>core</h3><ul><li><strong>UniswapV3Factory</strong>: 提供<strong>创建 pool 的接口，并且追踪所有的 pool</strong></li><li><strong>UniswapV3Pool</strong>: 实现<strong>代币交易，流动性管理，交易手续费的收取</strong>，oracle 数据管理。接口的实现粒度比较低，不适合普通用户使用，错误的调用其中的接口可能会造成经济上的损失。</li></ul><h3 id="periphery"><a href="#periphery" class="headerlink" title="periphery"></a>periphery</h3><ul><li><strong>SwapRouter</strong>: 提供<strong>代币交易的接口</strong>，它是对 UniswapV3Pool 合约中交易相关接口的进一步封装，前端界面主要与这个合约来进行对接。</li><li><strong>NonfungiblePositionManager</strong>: 用来<strong>增加&#x2F;移除&#x2F;修改 Pool 的流动性，并且通过 NFT token 将流动性代币化。使用 ERC721 token（v2 使用的是 ERC20）的原因是同一个池的多个流动性并不能等价替换</strong>（v3 的集中流性动功能）。</li></ul><h2 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h2><h3 id="NonfungiblePositionManager"><a href="#NonfungiblePositionManager" class="headerlink" title="NonfungiblePositionManager"></a>NonfungiblePositionManager</h3><h4 id="CreatePool"><a href="#CreatePool" class="headerlink" title="CreatePool"></a>CreatePool</h4><p><a href="https://github.com/Dapp-Learning-DAO/Dapp-Learning/blob/main/defi/Uniswap-V3/contractGuide/img/create-pool.png"><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV3/img/create-pool.png" alt="创建交易对流程图"></a></p><p>用户首先调用 <code>NonfungiblePositionManager</code> 合约的 <code>createAndInitializePoolIfNecessary</code> 方法创建交易对，传入的参数为交易对的 token0, token1, fee 和初始价格 sqrtPrice.</p><ul><li>调用<code>Factory.getPool(tokenA, tokenB, fee)</code>获取 Pool 地址</li><li>如果 Pool 地址为 0，说明 Pool 还未创建<ul><li>调用Factory.createPool(tokenA, tokenB, fee)，创建 Pool<ul><li>Factory调用 <code>Pool.deploy</code> 部署Pool合约</li></ul></li><li>调用<code>Pool.initialize(sqrtPriceX96)</code>对 Pool 初始化</li></ul></li><li>如果 Pool 地址不为 0 ，说明 Pool 已存在<ul><li>检查 Pool 的价格，若为 0，调用<code>Pool.initialize(sqrtPriceX96)</code>对 Pool 初始化</li></ul></li></ul><h4 id="mint"><a href="#mint" class="headerlink" title="mint"></a>mint</h4><p>铸造代表流动性头寸的ERC721代币返回给用户</p><p><a href="https://github.com/Dapp-Learning-DAO/Dapp-Learning/blob/main/defi/Uniswap-V3/contractGuide/img/add-liquidity.png"><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV3/img/add-liquidity.png" alt="添加流动性对流程图"></a></p><p>用户调用 <code>Manager.mint</code>创建Position并添加流动性：</p><ul><li>Manager内部调用 <code>Manager.addLiquidity</code></li><li>Manager调用<code>Pool.mint</code><ul><li>修改用户的position状态</li><li>调用manager的mint回调函数，进行token的转帐操作</li></ul></li><li>Manager内部调用<code>Manager.mint</code>，返回<code>amount0</code> <code>amount1</code>(token0,token1 的实际注入数量)<ul><li>将代表相关流动性postion的ERC721代币返回给用户</li><li>创建流动性头寸存入Manager</li></ul></li><li>广播 <code>IncreaseLiquidity(tokenId, liquidity, amount0, amount1)</code></li></ul><h4 id="increaseLiquidity"><a href="#increaseLiquidity" class="headerlink" title="increaseLiquidity"></a>increaseLiquidity</h4><p>用户调用 <code>Manager.increaseLiquidity</code> 向已有Position添加流动性：</p><ul><li>Manager内部调用 <code>Manager.addLiquidity</code></li><li>从Pool中获取position最新的手续费数值</li><li>将手续费加到position的记录中（两种token分别记录）</li><li>广播 <code>IncreaseLiquidity(tokenId, liquidity, amount0, amount1)</code></li></ul><p>注意：<strong>添加或移除流动性都会触发Manager从Pool中更新手续费数据</strong>，但不会提取</p><h4 id="decreaseLiquidity"><a href="#decreaseLiquidity" class="headerlink" title="decreaseLiquidity"></a>decreaseLiquidity</h4><p>用户调用 <code>Manager.decreaseLiquidity</code> 移除已有Position的流动性：</p><ul><li>检查入参，position现有流动性 &gt;&#x3D; 传入的流动性</li><li>调用<code>Pool.burn</code> 返回实际移除的流动性转换为token的数量（amount0, amount1）</li><li>回收用户在Pool中积累的手续费<ul><li>先获取Pool中手续费数值</li><li>手续费增量 &#x3D; Pool手续费数值 - position中记录的手续费数值</li><li>将手续费增量累加到position的待取token数量中</li><li>更新 position中记录的手续费数值</li></ul></li><li>更新 position中记录的流动性</li><li>广播 <code>IncreaseLiquidity(tokenId, liquidity, amount0, amount1)</code></li></ul><h4 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h4><p>用户调用 <code>Manager.collect</code> 回收Pool中累计的手续费收益：</p><ul><li>检查入参<ul><li>回收手续费最大数量需要 &gt; 0</li><li>当入参recipient为0，设为本Manager合约地址</li></ul></li><li>如果position流动性 &gt; 0，触发Pool更新手续费相关数据的快照<ul><li>调用<code>Pool.burn</code>触发更新手续费相关的数据，这里数量传0，并不会真的移除流动性</li><li>Pool的手续费 - Manager中记录的手续费 &#x3D; 手续费增量（即本次可取的手续费数量）</li><li>期望取回的手续费数量 &#x3D; max(手续费增量，入参的手续费最大值)</li></ul></li><li>调用 <code>Pool.collect</code> ，Pool将手续费转给接收者，返回实际取回的手续费数量</li><li>更新Manager中手续费数据与Pool同步</li><li>广播 <code>Collect(params.tokenId, recipient, amount0Collect, amount1Collect)</code></li></ul><h4 id="burn"><a href="#burn" class="headerlink" title="burn"></a>burn</h4><p>用户调用 <code>Manager.burn</code>，移除position，并销毁ERC721token</p><h3 id="SwapRouter"><a href="#SwapRouter" class="headerlink" title="SwapRouter"></a>SwapRouter</h3><h4 id="exactInput"><a href="#exactInput" class="headerlink" title="exactInput"></a>exactInput</h4><p>指定交易对路径，给出期望的输入数量，返回实际的交易数量。</p><p><a href="https://github.com/Dapp-Learning-DAO/Dapp-Learning/blob/main/defi/Uniswap-V3/contractGuide/img/swap-exact-input.png"><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV3/img/swap-exact-input.png" alt="exactInput"></a></p><h5 id="路径选择"><a href="#路径选择" class="headerlink" title="路径选择"></a>路径选择</h5><p>在进行两个代币交易时，是首先需要在链下计算出交易的路径，例如使用 <code>ETH</code> -&gt; <code>DAI</code> ：</p><ul><li>可以直接通过 <code>ETH</code>&#x2F;<code>DAI</code> 的交易池完成</li><li>也可以通过 <code>ETH</code> -&gt; <code>USDC</code> -&gt; <code>DAI</code> 路径，即经过 <code>ETH/USDC</code>, <code>USDC/DAI</code> 两个交易池完成交易</li><li>token地址没有排序限制</li></ul><h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h5><p>这里流程比较多，建议配合xmind流程图梳理。</p><p>用户调用 <code>Router.exactInput</code>：</p><ol><li><p>将支付者payer设置为交易发起者（用户）</p></li><li><p>进入while循环，对当前交易对执行具体的交易操作</p></li><li><p>获取 <code>hasMultiplePools</code> </p><p>a. <code>path.length &gt;= 3 * tokenAddressLength + 2 * feeLength</code> 的布尔值</p><p>b. <code>token + fee + token</code> 组成一个交易对，即 PoolKey </p><p>c. 这里是判断是否存在1个以上的交易对，即交易是否需要中转交易（A-&gt;B-&gt;C)</p></li><li><p>调用<code>Router.exactInputInternal</code>exactInput的内部方法 </p><p>a. recipient若为0，则改为本router合约地址 </p><p>b. 从交易链路path中解析出tokenIn,fee, tokenOut, 即当前第一个 Pool 的关键信息，以此可计算出Pool的地址 </p><p>c. 获取zeroForOne，即tokenIn &lt; tokenOut的布尔值</p><ul><li>在Pool中价格始终以 <code>y/x</code> 表示，这里 <code>address(x) &lt; address(y)</code></li><li><code>zeroForOne</code> 代表的是交易的方向，即<code>tokenIn</code>是作为x还是y，<code>tokenOut</code>反之 d. 调用 <code>Pool.swap</code> 执行实际的交易方法</li><li><code>amountIn</code> 入参是 <code>int256</code> 类型，即有符号，若传负数，则表示 exactOutinput 模式，这里是 exactInput，传入的是正数</li><li><code>priceLimit</code> 是交易执行的价格限制，一旦触及即停止交易。这里传0，代表以市价执行交易</li><li><code>SwapCallbackData</code> 是交易回调函数</li><li>在<code>Pool.swap</code>中交易是分段执行，具体细节参见其代码。swap函数在计算完实际交易量后，会先把输出token转账给接收者，然后调用回调将输入token从发送者转账到Pool合约 e. 返回实际的输入输出交易数量</li></ul></li><li><p>根据hasMultiplePools判断循环是否继续 a. true 交易路径中仍有待执行的交易对</p><ul><li>将支付者payer设为本router合约地址</li><li><code>path</code>剔除掉第一个token和fee的信息，继续使用后续的token地址和fee信息组成交易对</li><li>回到2继续执行 b. false 交易完成，跳出while循环，返回 <code>amountOut</code> 实际的输出token数量</li></ul></li><li><p>最后检查交易实际的输出量是否满足用户设置的最小输出数量</p></li></ol><h4 id="exactOutput"><a href="#exactOutput" class="headerlink" title="exactOutput"></a>exactOutput</h4><p>指定交易对路径，给出期望的输出数量，返回实际的交易数量。</p><p>程序逻辑和 exactInput 类似</p><h3 id="flash-swap"><a href="#flash-swap" class="headerlink" title="flash swap"></a>flash swap</h3><p>闪电贷接口，无需抵押和零信任的借贷，借贷到还贷需要在一个区块内完成。</p><p>Uniswap v3 版本中，和 v2 一样也有两种闪电贷的方式，但是是通过不同的函数接口来完成的。</p><ul><li><code>Pool.flash</code> 借出和归还是同一币种</li><li><code>Pool.swap</code> 借出swap函数先将输出token转给接收者，再通过回调将输入token转给Pool的机制，实现了借出和归还不同币种的闪电贷</li></ul>]]></content>
      
      
      <categories>
          
          <category> UniswapV3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> UniswapV3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnsiwapV4</title>
      <link href="/2023/01/22/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UnswapV4/UnsiwapV4/"/>
      <url>/2023/01/22/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UnswapV4/UnsiwapV4/</url>
      
        <content type="html"><![CDATA[<h1 id="uniswap-v4"><a href="#uniswap-v4" class="headerlink" title="uniswap_v4"></a>uniswap_v4</h1><h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><p>v4 实现了 8 个回掉函数：</p><ul><li>beforeInitialize &#x2F; afterInitialize</li><li>beforeModifyPosition &#x2F; afterModifyPosition</li><li>beforeSwap &#x2F; afterSwap</li><li>beforeDonate &#x2F; afterDonate</li></ul><p>当有人在 v4 上创建一个 pool 时，可以指定一个 hooks 合约。通过 hooks 合约可以对 swap 和 withdrawLiquidity 操作收取费用，并自定义收费策略。或者进行其他操作。</p><h3 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h3><p>v4 使用一个 contract 完成所有 token 的保管。在 v4 上创建 pool 会改变 contarct 状态，而不是像 v3 一样新建 contract。这减少了新建 pool 的 gas 费用。</p><h3 id="Flash-Accouting"><a href="#Flash-Accouting" class="headerlink" title="Flash Accouting"></a>Flash Accouting</h3><p>在 v3 上执行多跳 swap 需要在每个 swap 完成之后执行 transfer。但由于 Singleton，在 v4 中每个 swap 都只会更新内部 balance，仅在全部 swap 结束之后进行 transfer。这减少了多跳 swap 的 gas 费用。</p><h3 id="Native-ETH"><a href="#Native-ETH" class="headerlink" title="Native ETH"></a>Native ETH</h3><p>v4 支持原生 ETH，相比 v3 使用的 weth 减少了 Gas 的使用。</p><h3 id="ERC1155-Accounting"><a href="#ERC1155-Accounting" class="headerlink" title="ERC1155 Accounting"></a>ERC1155 Accounting</h3><p>v4 使用 ERC1155 用于额外 token 的记账，用户可以将 token 保留在 contract 中，避免将 token 频繁转入或转出，以节约 gas。</p><h3 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h3><p>v4 引入 hooks 使得协议内嵌的价格预言机变得不再必要，一些 pool 可以完全放弃预言机，并在每个 pool 在 block 中的第一次 swap 中节省 gas。</p><h3 id="Donate"><a href="#Donate" class="headerlink" title="Donate"></a>Donate</h3><p>v4 允许给特定范围内的流动性提供者支付 token，可以是池中的任意一种或两种代币。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>v4 对 v3 的改进主要在提出 hooks 和节约 gas 上，虽然新的使用场景还不明朗，但新协议往往就是新的机会，现在就开始研究是有价值的。</p>]]></content>
      
      
      <categories>
          
          <category> UnswapV4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> UnswapV4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>V3白皮书</title>
      <link href="/2023/01/22/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV3/V3%E7%99%BD%E7%9A%AE%E4%B9%A6/"/>
      <url>/2023/01/22/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV3/V3%E7%99%BD%E7%9A%AE%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="UniswapV3白皮书"><a href="#UniswapV3白皮书" class="headerlink" title="UniswapV3白皮书"></a>UniswapV3白皮书</h1><h2 id="资金利用率"><a href="#资金利用率" class="headerlink" title="资金利用率"></a>资金利用率</h2><p>价格区间(0, ∞)看起来很理想，我们的资金在任何时候（任意价格点）都能为我们赚取手续费。</p><p>但我们忽略了另一个影响收益的重要因素，那就是资金的利用率。<strong>当一个用户来用我们的池子做交易时，其交易的量相比我们的流动性来说是很小的</strong>。</p><p>比如，ETH的历史价格大致在 $0.75 到 $4,800 这个区间。在今天（2022年6月），1 个 ETH 的现货价格是 $1800，没有人会愿意用 $5000 购买一个 ETH，所以在这个价格上提供流动性是毫无用处的。因此，在远离当前价格区间的、永远不会达到的某个点上提供流动性是毫无意义的。</p><p>假设现在池子内资产 X 和 Y 都有 8 个，价格 p 为 1。现在有一笔订单，<strong>用 1 个 X 来换取 1 个 Y</strong>，我们先不考虑滑点和手续费的影响，这一笔交易为我们带来的手续费收益是 <code>fee = 1 * 0.3%</code>，实际参与赚取手续费的流动性就是输出的 1 个 y，这相比于总流动性是很小的，在这一笔交易中，<strong>资金利用率是大约是 <code>1 / 8</code>。</strong>也就是说，我们<strong>只需要极少一部分流动性就能承载这一笔交易</strong>，而大部分流动性在交易过程中只是躺在那做收益的分母而已……</p><p><a href="https://github.com/Dapp-Learning-DAO/Dapp-Learning/blob/main/defi/Uniswap-V3/whitepaperGuide/img/understanding-02-liquidityrate.png"><img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/understanding-02-liquidityrate.png" alt="liquidity rate" style="zoom:50%;" /></a> </p><h2 id="集中流动性"><a href="#集中流动性" class="headerlink" title="集中流动性"></a>集中流动性</h2><p>Uniswap V3 引入了 <em>集中流动性(concentrated liquidity)</em> 的概念：<strong>LP 可以选择他们希望在哪个价格区间提供流动性</strong>。这个机制通过将更多的流动性提供在一个相对狭窄的价格区间，来大大提高资产利用效率；这也使 Uniswap 的使用场景更加多样化：<strong>它现在可以对于不同价格波动性的池子进行不同的配置。</strong>这就是 V3 相对于 V2 的主要提升点。</p><p>简单地来说，<strong>一个 Uniswap V3 的交易对由许多个 Uniswap V2 的交易对构成。</strong>V2 与 V3 的区别是，<strong>在 V3 中，一个交易对有许多的价格区间</strong>，而每个价格区间内都有<strong>一定数量的资产</strong>。从零到正无穷的整个价格区间被划分成了许多个小的价格区间，<strong>每一个区间中都有一定数量的流动性</strong>。而更关键的点在于，在每个小的价格区间中，<strong>工作机制与 Uniswap V2</strong> 完全一样。这也是为什么我们说一个 Uniswap V3 的池子就是许多个 V2 的池子。</p><p>下面，我们来对这种机制进行可视化。我们并不是重新选择一个有限的曲线，而是我们把它在价格 a 与价格 b之间的部分截取出来，把它们当作是是曲线的边界。更进一步，我们把曲线进行平移使得边界点落在坐标轴上，于是得到了下图：</p><img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/curve_finite.png" alt="Uniswap V3 price range" style="zoom:50%;" /> <blockquote><p>它看起来或许有点单调， 因此 Uniswap V3 有许多的价格区间——这样它们就不会感到孤单了 🙂</p></blockquote><blockquote><p>一个有趣的事实：根据这个原理，可以利用V3的价格区间来挂限价单。</p></blockquote><h3 id="限价单"><a href="#限价单" class="headerlink" title="限价单"></a>限价单</h3><p>事实上，这种资产 X 全部转为资产 Y 的特性并不能算是缺陷，反而是一种可以利用的特性。比如当我们与市场看法相反的时候，<strong>市场大部分人看好 X，而你却看好 Y（或者看空 X）</strong>，于是你故意<strong>设置了一个比较窄的价格区间</strong>（容易被价格穿过），放在比当前价格高的地方，此时注入流动性，将会全部是资产 X。当资产 X 价格上涨时，先进入你的流动性价格区间，不断有人用资产 Y 换走你池内的资产 X，直至价格完全穿过价格区间的上限，<strong>池内的资产 X 被全部换成了资产 Y。</strong></p><p>下面一图展示了 <a href="https://info.uniswap.org/#/pools/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8">USDC&#x2F;ETH 池子的流动性分布</a>:</p><img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/usdceth_liquidity.png" alt="Liquidity in the real USDC/ETH pool" style="zoom: 33%;" /> <p>可以看到，大量流动性集中在现价的附近，而较远的价格区间中的流动性较少——这是因为 LP 更希望提高它们的资产利用效率。当然，整个区间也不是无穷的，在图片右侧也显示了其上界。</p><h2 id="价格区间的风险与收益"><a href="#价格区间的风险与收益" class="headerlink" title="价格区间的风险与收益"></a>价格区间的风险与收益</h2><p><strong>当出现价格在区间以外的情况，此时流动性头寸不但不能继续赚取手续费，同时必定全部变成了单一资产</strong>，且一定是当时市场中处于弱势一方的资产。比如当资产 Y 涨价，将会有大量订单用资产 X 从池子中换取 Y，于是池子中的 X 越来越多，而 Y 最终会清零。因为 AMM 自动做市，实际上也是一种被动的做市，永远需要和市场中的订单做对手盘。</p><p>也就是说，价格区间越窄，价格移出区间的概率越大，风险越大，而区间越宽，风险就越小。如果你厌恶这种价格移出区间的风险，那么大可<strong>直接将价格区间设置为 (0, ∞)</strong> ，官方的 UI 界面也支持这个操作，那么你就会得到一个完全没有虚拟流动性，和 V2 差不多的全价格区间流动性了。</p><p>当然这么做的代价就是，<strong>资金利用率和 V2 也没差别，非常的低</strong>。这就相当于你将资金均匀分散到一个很长的价格轴上，虽然每次交易都能赚取手续费，但由于资金在每个价格点上被摊薄的太厉害，导致<strong>每次赚取手续费的占比权重非常低</strong>。</p><h2 id="Uniswap-V3-的数学原理"><a href="#Uniswap-V3-的数学原理" class="headerlink" title="Uniswap V3 的数学原理"></a>Uniswap V3 的数学原理</h2><p>在数学原理上，V3 是基于 V2 的：它们使用了相同的底层公式，但实际上 V3 使用的是<em>增强版</em>。</p><p>为了处理价格区间之间的转换，简化流动性管理，以及避免取整出现问题，V3 使用了下面这些新的标识：</p><img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230612212257348.png" alt="image-20230612212257348" style="zoom:67%;" /> <p><em>L</em> 被称作 <em>流动性数量</em>。池子中的流动性是两种 token 资产数量的组合。我们知道，按照公式，两种代币数量乘积为 <em>k</em>，因此我们可以用<strong>sqrt(x<em>y</em>)</strong> 来衡量池子流动性。<em>L</em> 实际上是 <em>x</em> 和 <em>y</em> 的几何平均数。</p><p><em>y</em>&#x2F;<em>x</em> 是 token0 相对于 token1 的价格。由于池子里两种代币的价格互为倒数，我们在计算中仅使用其中一个( Uniswap V3使用的是 y*&#x2F;<em>x</em>)。token1 相对于 token0 的价格即为 1&#x2F;(<em>y</em>&#x2F;<em>x</em>)&#x3D;x&#x2F;y*。类似地，1&#x2F;sqrt(p) &#x3D; 1&#x2F;sqrt(<em>y</em>&#x2F;<em>x</em>)&#x3D;sqrt(x&#x2F;y)</p><p>我们使用 sqrt(<em>P</em>) 而不是 <em>P</em> 有两个原因：</p><ol><li><p>平方根计算并不精确并且会引入取整的问题。因此，更简单的方法是我们干脆就在合约中存平方根的结果，而不是在合约中计算它。合约中并不存储 x 和 y</p></li><li><p>sqrt(P) 与 <em>L</em> 之间有一个有趣的关系：L也表示了输出数量的变化与 sqrt(P) 的变化之间的关系：</p><img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230612213006843.png" alt="image-20230612213006843" style="zoom:67%;" /></li></ol><h2 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h2><p>同样，我们并不需要计算准确的价格——我们可以直接计算获得的token数量。并且，由于我们在合约中并不存储 x 和 <em>y</em>，我们将仅通过 <em>L</em> 和 sqrt(<em>P</em>) 进行计算。</p><p>根据上文中的公式，我们能得到Δ<em>y</em>：</p><img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230612213108342.png" alt="image-20230612213108342" style="zoom:67%;" /> <h2 id="Ticks"><a href="#Ticks" class="headerlink" title="Ticks"></a>Ticks</h2><p>正如我们前面说到的，V2 中的无穷价格区间在 V3 中被分成了更小的价格区间，每个区间都由上下界端点进行限制。为了进行这些边界的协调，V3引入了 <em>ticks</em>。</p><img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/ticks_and_ranges.png" alt="Price ranges and ticks" style="zoom:67%;" /> <p>在 V3，整个价格区间由离散的、均匀分布的 ticks 进行标定。每个 tick 有一个 index 和对应的价格：</p><p><em>p</em>(<em>i</em>)&#x3D;1.0001^<em>i</em></p><p><em>p</em>(<em>i</em>) 即为 tick <em>i</em> 的价格. 使用 1.0001 的幂次作为标定有一个很好的性质：两个相邻 tick 之间的差距为 0.01% 或者<em>一个基点。</em></p><blockquote><p>基点 (1% 的百分之一，或者 0.01%，或者 0.0001)是在金融中用来衡量百分比的一个单位。你可能在央行宣布对于利率的调整中听过基点这个名词。</p></blockquote><img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230612213210938.png" alt="image-20230612213210938" style="zoom: 67%;" /> <p>Ticks 可以为正也可以为负，并且显然它不是无穷的。V3 把sqrt(<em>P</em> )存储为一个 Q64.96 类型的定点数，使用 64 位作为整数部分，使用 96 位作为小数部分。因此，价格的取值范围是 [2^(−128),2^128][2−128,2128]，ticks 的取值范围是：</p><img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230612213253656.png" alt="image-20230612213253656" style="zoom:67%;" /> <h2 id="预言机"><a href="#预言机" class="headerlink" title="预言机"></a>预言机</h2><p>V2 的预言机提供了 TWAP (time-weighted average price 时间加权平均价格)，更新时间是每个区块的第一笔交易的价格，其数值是上一次的数值加上当前价格乘以时间差。</p><img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230613092300794.png" alt="image-20230613092300794" style="zoom:80%;" /> <p>外部用户可以通过记录该数值的变化和时间点，获得在一段时间内受短期波动影响较小的时间加权价格。</p><img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230613092310737.png" alt="image-20230613092310737" style="zoom:80%;" /> <p>上述公式得出了在 t1 到 t2 的时间内，预言机提供的时间加权价格。因为其值是经过时间加权的（累加的是价格乘以时间差），所以受短期波动影响较小，这样能有效防止恶意的价格波动。</p><p><strong>V2 的预言机在核心合约上只保留最新的一个值，所以如果外部用户想要使用这个预言机，需要自己搭建一套监控和记录的设施，增加了使用者成本。</strong></p><p>V3 相比于 V2 的预言机，有以下较大改动：</p><ol><li>相比 V2 累加的是价格的加权数值，V3 累加的是价格的 log 值，即 <code>log(price, 1.0001)</code></li><li>在核心合约中增加了存储预言机数值的空间，最大 65536 个数值，至少 9 天的数值，建立监控和记录设施不再是必要条件</li><li>增加关于流动性的预言机数值，记录周期和价格一致（每个区块的第一笔交易），其值是当前激活状态的流动性数量的倒数，即 <code>1/liquidity</code></li></ol><h3 id="算术平均与几何平均"><a href="#算术平均与几何平均" class="headerlink" title="算术平均与几何平均"></a>算术平均与几何平均</h3><p>V2 的方式是直接记录价格的累加值，而使用时再除以时间间隔，这就是一种<strong>算术平均</strong> (arithmetic mean)。而 V3 累加的是 <code>log(price, 1.0001)</code> 也就是价格的幂，使用时再除以时间间隔，这是<strong>几何平均</strong> (geometric mean)。</p><p>所以 V3 的预言机公式需要改成如下:</p><p><code>a(t)</code> 是时间 t 时，预言机记录的值（累加价格的 log 值）。</p><img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230613092344185.png" alt="image-20230613092344185" style="zoom:80%;" /> <p>这里的 log 数值后面其实还有一个 <code>* 1s</code> 即以每秒作为时间间隔。然而实际情况中，合约中是以区块的时间戳作为标记时间的，所以合约中的代码跟公式不同。每个区块的头一笔交易时更新，此时距离上一次更新时间间隔肯定大于 1s，所以需要将更新值乘以两个区块的时间戳的差。<code>tickCumulative</code> 是 tick 序号的累计值，tick 的序号就是 <code>log(√price, 1.0001)</code>。</p><img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230613092409473.png" alt="image-20230613092409473" style="zoom:80%;" /> <p>当外部用户使用时，求 t1 到 t2 时间内的时间加权价格 <code>p(t1,t2)</code> ，需要计算两个时间点的累计值的差 <code>a(t2) - a(t1)</code> 除以时间差。</p><img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230613092421643.png" alt="image-20230613092421643" style="zoom:80%;" /> <p>使用几何平均的原因：</p><ul><li>因为合约中记录了 tick 序号，序号是整型，且跟价格相关，所以直接计算序号更加节省 gas。（全局变量中存储的不是价格，而是根号价格，如果直接用价格来记录，要多比较复杂的计算）</li><li>V2 中算数平均价格并不总是倒数关系（以 token1 计价 token0，或反过来），所以需要记录两种价格。V3 中使用几何平均不存在该问题，只需要记录一种价格。<ul><li>举个例子，在 V2 中如果 USD&#x2F;ETH 价格在区块 1 中是 100，在区块 2 中是 300，USD&#x2F;ETH 的均价是 200 USD&#x2F;ETH，但是 ETH&#x2F;USD 的均价是 1&#x2F;150</li></ul></li><li><strong>几何平均比算数平均能更好的反应真实的价格，受短期波动影响更小。</strong>白皮书中的引用提到在几何布朗运动中，算数平均会受到高价格的影响更多。</li></ul><blockquote><p>我在 <a href="https://github.com/Dapp-Learning-DAO/Dapp-Learning/blob/main/defi/Uniswap-V3/whitepaperGuide/oracleCompare.ipynb">oracleCompare.ipynb</a> 中简单模拟了算数平均和几何平均的预言机机制，实际结果是算数平均受高价影响较大，而几何平均受低价影响较大。</p></blockquote><h3 id="流动性预言机"><a href="#流动性预言机" class="headerlink" title="流动性预言机"></a>流动性预言机</h3><p>相比于 V2，任何时刻活跃的流动性就是池子内所有流动性数量总和（因为都是全价格区间），V3 有了不同价格区间，所以不同时刻，激活状态的流动性数量并不是池子内的总流动性数量。为了便于外部使用者更好的观测激活流动性的数量，V3 添加了预言机的 <code>secondsPerLiquidityCumulative</code> 变量。</p><img src="/noteimg/区块链/区块链知识点总结/UniswapV3/img/image-20230613092504648.png" alt="image-20230613092504648" style="zoom:80%;" /> <p>（因为 liquidity 可能为 0，此时分母为 1）</p><p>这里的具体含义是每单位流动性参与的做市时长，即一段时间内，参与的流动性越多，那么每单位流动性参与的时长越短，因为分摊收益的流动性数量变多了，反之亦然。</p><p>其记录机制和价格逻辑一致，不再赘述。这里介绍一下它的用途。</p><h3 id="Tick-上辅助预言机计算的数据"><a href="#Tick-上辅助预言机计算的数据" class="headerlink" title="Tick 上辅助预言机计算的数据"></a>Tick 上辅助预言机计算的数据</h3><p>每个已初始化的 tick 上（有流动性添加的），不光有流动性数量和手续费相关的变量(<code>liquidityNet</code>, <code>liquidityGross</code>, <code>feeGrowthOutside</code>)，还有三个可用于做市策略。</p><p>tick 变量一览：</p><table><thead><tr><th>Type</th><th>Variable Name</th><th>含义</th></tr></thead><tbody><tr><td>int128</td><td>liquidityNet</td><td>流动性数量净含量</td></tr><tr><td>int128</td><td>liquidityGross</td><td>流动性数量总量</td></tr><tr><td>int256</td><td>feeGrowthOutside0X128</td><td>以 token0 收取的 outside 的手续费总量</td></tr><tr><td>int256</td><td>feeGrowthOutside1X128</td><td>以 token1 收取的 outside 的手续费总量</td></tr><tr><td>int256</td><td>secondsOutside</td><td>价格在 outside 的总时间</td></tr><tr><td>int256</td><td>tickCumulativeOutside</td><td>价格在 outside 的 tick 序号累加</td></tr><tr><td>int256</td><td>secondsPerLiquidityOutsideX128</td><td>价格在 outside 的每单位流动性参与时长</td></tr></tbody></table><p>outside 的含义参考手续费部分的讲解，这些变量前几个都是手续费部分用到的，最后三个则是预言机相关的数据。</p><p>tick 辅助预言机的变量的使用方法：</p><ol><li><code>secondsOutside</code>： 用池子创建以来的总时间减去价格区间两边 tick 上的该变量，就能得出该区间做市的总时长</li><li><code>tickCumulativeOutside</code>： 用预言机的 <code>tickCumulative</code> 减去价格区间两边 tick 上的该变量，除以做市时长，就能得出该区间平均的做市价格（tick 序号）</li><li><code>secondsPerLiquidityOutsideX128</code>： 用预言机的 <code>secondsPerLiquidityCumulative</code> 减去价格区间两边 tick 上的该变量，就是该区间内的每单位流动性的做市时长（使用该结果乘以你的流动性数量，得出你的流动性参与的做市时长，这个时长比上 1 的结果，就是你在该区间赚取的手续费比例）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> UniswapV3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> UniswapV3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UniswapV2Router02</title>
      <link href="/2023/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV2/UniswapV2Router02/"/>
      <url>/2023/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV2/UniswapV2Router02/</url>
      
        <content type="html"><![CDATA[<h1 id="UniswapV2Router02"><a href="#UniswapV2Router02" class="headerlink" title="UniswapV2Router02"></a>UniswapV2Router02</h1><p>在构造函数中传入factory合约和WETH合约地址，WETH的作用是将以太币包装成ERC-20代币，Route合约是与pair交易对进行交互的合约，常用于添加流动性、移除流动性、兑换、获取交易对信息……</p><p><strong>其中amountMin用于控制滑点，若amount_min &#x3D; amount_desired - (amount_desired * 0.01)  表示 1%滑点容忍度</strong></p><h2 id="合约当中比较重要的方法有："><a href="#合约当中比较重要的方法有：" class="headerlink" title="合约当中比较重要的方法有："></a>合约当中比较重要的方法有：</h2><h4 id="addLiquidity：-address-tokenA-address-tokenB-uint-amountADesired-uint-amountBDesired-uint-amountAMin-uint-amountBMin-address-to-uint-deadline-ensure-deadline-returns-uint-amountA-uint-amountB-uint-liquidity"><a href="#addLiquidity：-address-tokenA-address-tokenB-uint-amountADesired-uint-amountBDesired-uint-amountAMin-uint-amountBMin-address-to-uint-deadline-ensure-deadline-returns-uint-amountA-uint-amountB-uint-liquidity" class="headerlink" title="addLiquidity：(address tokenA, address tokenB,uint amountADesired,uint amountBDesired,uint amountAMin,uint amountBMin,address to,uint deadline) ensure(deadline) returns (uint amountA, uint amountB, uint liquidity)"></a>addLiquidity：(address tokenA, address tokenB,uint amountADesired,uint amountBDesired,uint amountAMin,uint amountBMin,address to,uint deadline) ensure(deadline) returns (uint amountA, uint amountB, uint liquidity)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1.调用 _addLiquidity方法，返回amountA，amountB</span><br><span class="line">// 2.获取两个token的pair合约地址,并转账两个token</span><br><span class="line">address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);</span><br><span class="line">TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);</span><br><span class="line">TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);</span><br><span class="line">// 3.向to地址铸造lptoken</span><br><span class="line">liquidity = IUniswapV2Pair(pair).mint(to);</span><br></pre></td></tr></table></figure><p>添加流动性方法：通过_addLiquidity方法传入期望添加token的数量和愿意接受的最低token数量返回实际添加到资金池中token的数量，想pair合约转账token并铸造lptoken</p><h4 id="removeLiquidity：-address-tokenA-address-tokenB-uint-liquidity-uint-amountAMin-uint-amountBMin-address-to-uint-deadline-ensure-deadline-returns-uint-amountA-uint-amountB"><a href="#removeLiquidity：-address-tokenA-address-tokenB-uint-liquidity-uint-amountAMin-uint-amountBMin-address-to-uint-deadline-ensure-deadline-returns-uint-amountA-uint-amountB" class="headerlink" title="removeLiquidity：(address tokenA, address tokenB,uint liquidity,uint amountAMin,uint amountBMin,address to,uint deadline) ensure(deadline) returns (uint amountA, uint amountB)"></a>removeLiquidity：(address tokenA, address tokenB,uint liquidity,uint amountAMin,uint amountBMin,address to,uint deadline) ensure(deadline) returns (uint amountA, uint amountB)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1.获取两个token的pair合约地址并将lptoken发送到pair合约</span><br><span class="line">address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);</span><br><span class="line">IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity);</span><br><span class="line">// 2.销毁lptoken，返回销毁lptoken获得两种token的数量</span><br><span class="line">(uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);</span><br></pre></td></tr></table></figure><p>移除流动性方法：通过pair合约销毁lptoken移除流动性，获得的两个token需要大于愿意接受的最低token数量</p><h4 id="swapExactTokensForTokens：-uint-amountIn-uint-amountOutMin-address-calldata-path-address-to-uint-deadline-ensure-deadline-returns-uint-memory-amounts"><a href="#swapExactTokensForTokens：-uint-amountIn-uint-amountOutMin-address-calldata-path-address-to-uint-deadline-ensure-deadline-returns-uint-memory-amounts" class="headerlink" title="swapExactTokensForTokens：(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline ) ensure(deadline) returns (uint[] memory amounts)"></a>swapExactTokensForTokens：(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline ) ensure(deadline) returns (uint[] memory amounts)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 根据传入的tokenA的数量和path获得amounts</span><br><span class="line">amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);</span><br><span class="line">// 判断最终获得的tokenB的数量是否大于amountOutMin</span><br><span class="line">require(amounts[amounts.length - 1] &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27;);</span><br><span class="line">// 将tokenA传入第一对交易对中</span><br><span class="line">TransferHelper.safeTransferFrom(path[0],msg.sender,UniswapV2Library.pairFor(factory, path[0], path[1]),amounts[0]);</span><br><span class="line">// 兑换</span><br><span class="line">_swap(amounts, path, to);</span><br></pre></td></tr></table></figure><p>兑换：根据确切的tokenA的数量兑换tokenB</p><h2 id="合约内部调用的方法："><a href="#合约内部调用的方法：" class="headerlink" title="合约内部调用的方法："></a>合约内部调用的方法：</h2><h4 id="addLiquidity：-address-tokenA-address-tokenB-uint-amountADesired-uint-amountBDesired-uint-amountAMin-uint-amountBMin-returns-uint-amountA-uint-amountB-uint-liquidity"><a href="#addLiquidity：-address-tokenA-address-tokenB-uint-amountADesired-uint-amountBDesired-uint-amountAMin-uint-amountBMin-returns-uint-amountA-uint-amountB-uint-liquidity" class="headerlink" title="_addLiquidity：(address tokenA, address tokenB,uint amountADesired,uint amountBDesired,uint amountAMin,uint amountBMin)  returns (uint amountA, uint amountB uint liquidity)"></a>_addLiquidity：(address tokenA, address tokenB,uint amountADesired,uint amountBDesired,uint amountAMin,uint amountBMin)  returns (uint amountA, uint amountB uint liquidity)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1.获取两个token的pair地址，若不存则创建新的交易对</span><br><span class="line">// 2.获取储备量并且不等于零</span><br><span class="line">// 根据两种token的储备量和期望tokenA的数额获取tokenB最佳的数额</span><br><span class="line">uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);</span><br><span class="line">// 3.根据期望值和愿意接受的最低token数量通过判断返回amountA，amountB</span><br></pre></td></tr></table></figure><h4 id="swap：-uint-memory-amounts-address-memory-path-address-to"><a href="#swap：-uint-memory-amounts-address-memory-path-address-to" class="headerlink" title="_swap：(uint[] memory amounts, address[] memory path, address _to)"></a>_swap：(uint[] memory amounts, address[] memory path, address _to)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1.循环path路径</span><br><span class="line">// 2.计算每对交易对的兑换量</span><br><span class="line">// 3.如果中间还有其他的路径，to地址为其中交易对的pair地址</span><br><span class="line">address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;</span><br><span class="line">// 进行兑换</span><br><span class="line">IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(amount0Out,amount1Out,to,new bytes(0));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> UniswapV2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> UniswapV2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UniswapV2Pair</title>
      <link href="/2023/01/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV2/UniswapV2Pair/"/>
      <url>/2023/01/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV2/UniswapV2Pair/</url>
      
        <content type="html"><![CDATA[<h1 id="UniswapV2Pair"><a href="#UniswapV2Pair" class="headerlink" title="UniswapV2Pair"></a>UniswapV2Pair</h1><p>在构造函数中factory地址为msg.sender，因为该合约是由UniswapV2Factory进行部署，该合约继承了UniswapV2ERC20，主要用于管理以及操作交易对，托管两种token</p><h2 id="合约当中比较重要的方法有-lptoken即UniswapV2ERC20"><a href="#合约当中比较重要的方法有-lptoken即UniswapV2ERC20" class="headerlink" title="合约当中比较重要的方法有(lptoken即UniswapV2ERC20):"></a>合约当中比较重要的方法有(lptoken即UniswapV2ERC20):</h2><p>  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external：判断签名的有效性</p><p>  function mint(address to) external returns (uint liquidity)：铸造lptoken</p><p>  function burn(address to) external returns (uint amount0, uint amount1)：销毁lptoken退出流动性</p><p>  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external：根据tokenA的数量在交易池中进行兑换tokenB</p><p>  function skim(address to) external：使两个token的余额与储备相等</p><p>  function sync() external：使两个token的储备与余额相匹配</p><p>  function initialize(address, address) external：设置pair地址交易对的两种token</p><h4 id="permit-address-owner-address-spender-uint-value-uint-deadline-uint8-v-bytes32-r-bytes32-s"><a href="#permit-address-owner-address-spender-uint-value-uint-deadline-uint8-v-bytes32-r-bytes32-s" class="headerlink" title="permit:(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s)"></a>permit:(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ecrecover 函数可以返回与签名者对应的公钥地址</span><br><span class="line">address recoveredAddress = ecrecover(digest, v, r, s);</span><br><span class="line">// 判断签名者对应的公钥地址与授权地址是否一致</span><br><span class="line">require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &#x27;UniswapV2: INVALID_SIGNATURE&#x27;);</span><br><span class="line">_approve(owner, spender, value);</span><br></pre></td></tr></table></figure><p>用户现在签名一笔交易，用该方法可有判断该签名的有效性,如果通过判断，则进行授权</p><h4 id="mint：-address-to-lock-returns-uint-liquidity"><a href="#mint：-address-to-lock-returns-uint-liquidity" class="headerlink" title="mint：(address to) lock returns (uint liquidity)"></a>mint：(address to) lock returns (uint liquidity)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 1.获取进行添加流动性的两个token的数量</span><br><span class="line">(uint112 _reserve0, uint112 _reserve1, ) = getReserves();</span><br><span class="line">uint balance0 = IERC20(token0).balanceOf(address(this));</span><br><span class="line">uint balance1 = IERC20(token1).balanceOf(address(this));</span><br><span class="line">uint amount0 = balance0.sub(_reserve0);</span><br><span class="line">uint amount1 = balance1.sub(_reserve1);</span><br><span class="line">// 2.调用_mintFee方法</span><br><span class="line">// 3.添加流动性所获得的lptoken数量(进行添加流动性的两种token的数量*目前lptoken的数量/当前token的储备量--&gt;取较小值)</span><br><span class="line">liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);</span><br><span class="line">// 4.铸造lptoken函数和更新储备函数</span><br><span class="line">_mint(to, liquidity);</span><br><span class="line">_update(balance0, balance1, _reserve0, _reserve1);</span><br></pre></td></tr></table></figure><p>主要是根据两个token在交易对的增量计算出应该铸造lptoken的数量，然后将lptoken铸造给to地址，具有防重入锁lock</p><h4 id="burn：-address-to-lock-returns-uint-amount0-uint-amount1"><a href="#burn：-address-to-lock-returns-uint-amount0-uint-amount1" class="headerlink" title="burn：(address to) lock returns (uint amount0, uint amount1)"></a>burn：(address to) lock returns (uint amount0, uint amount1)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 1.为什么用addres(this)?--&gt;因为获取退出lptoken数量时，是在Route合约中先将lptoken转到当前合约，然后直接获得当前合约lptoken的数量</span><br><span class="line">uint liquidity = balanceOf[address(this)];</span><br><span class="line">// 2.调用_mintFee方法</span><br><span class="line">// 3.使用余额确保按比例分配--&gt;(持有lptoken/总lptoken)*合约中持有token的数量</span><br><span class="line">amount0 = liquidity.mul(balance0) / _totalSupply; </span><br><span class="line">amount1 = liquidity.mul(balance1) / _totalSupply; </span><br><span class="line">// 4.转账两种token并更新储备量</span><br><span class="line">_safeTransfer(_token0, to, amount0);</span><br><span class="line">_safeTransfer(_token1, to, amount1);</span><br><span class="line">balance0 = IERC20(_token0).balanceOf(address(this));</span><br><span class="line">balance1 = IERC20(_token1).balanceOf(address(this));</span><br><span class="line">_update(balance0, balance1, _reserve0, _reserve1);</span><br></pre></td></tr></table></figure><p>根据lptokne的比例计算出两种token的各自的数量，然后销毁lptoken并将转账两种token给to地址</p><h4 id="swap：-uint-amount0Out-uint-amount1Out-address-to-bytes-calldata-data"><a href="#swap：-uint-amount0Out-uint-amount1Out-address-to-bytes-calldata-data" class="headerlink" title="swap：(uint amount0Out, uint amount1Out, address to, bytes calldata data)"></a>swap：(uint amount0Out, uint amount1Out, address to, bytes calldata data)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1.转移代币</span><br><span class="line">if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); </span><br><span class="line">if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); </span><br><span class="line">// 2.用于回调合约来实现一些特定的业务逻辑或其他自定义功能(例如：闪电贷....)</span><br><span class="line">if (data.length &gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);</span><br><span class="line">// 3.确保在交易完成后，资金池的储备量满足 Uniswap V2 中的 K 恒定公式，即 K = _reserve0 * _reserve1</span><br><span class="line">// 4.更新储备</span><br></pre></td></tr></table></figure><p>1.在Route合约用户已经将需要兑换的tokenA转入pair合约中，在Route合约中传入需要输出的tokenB的数量和一个data，转移tokenB后判断data长度是否大于零去进行回调合约</p><p>2.直接调用swap方法进行回调合约获得套利，只要套利后满足后续条件即可</p><h2 id="合约内部调用的方法："><a href="#合约内部调用的方法：" class="headerlink" title="合约内部调用的方法："></a>合约内部调用的方法：</h2><h4 id="update：-uint-balance0-uint-balance1-uint112-reserve0-uint112-reserve1-private"><a href="#update：-uint-balance0-uint-balance1-uint112-reserve0-uint112-reserve1-private" class="headerlink" title="_update：(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private"></a>_update：(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1.更新priceCumulativeLast，永远不会溢出，+ overflow是理想的</span><br><span class="line">price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;</span><br><span class="line">price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;</span><br><span class="line">// 2.更新储备量</span><br><span class="line">reserve0 = uint112(balance0);</span><br><span class="line">reserve1 = uint112(balance1);</span><br></pre></td></tr></table></figure><p>更新储备方法：四个参数前两个为更新后两个token的储备量，后两个为更新前两个token的储备量</p><h4 id="mintFee：-uint112-reserve0-uint112-reserve1-private-returns-bool-feeOn"><a href="#mintFee：-uint112-reserve0-uint112-reserve1-private-returns-bool-feeOn" class="headerlink" title="_mintFee：(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn)"></a>_mintFee：(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1.获取收取手续费的地址如果不是零地址并且kLast!=0则继续下面部分</span><br><span class="line">// 2.获取上一次交易后和目前交易对中的K值</span><br><span class="line">uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));</span><br><span class="line">uint rootKLast = Math.sqrt(_kLast);</span><br><span class="line">// 3.如果rootK&gt;rootKLast</span><br><span class="line">uint numerator = totalSupply.mul(rootK.sub(rootKLast));</span><br><span class="line">uint denominator = rootK.mul(5).add(rootKLast);</span><br><span class="line">uint liquidity = numerator / denominator;</span><br><span class="line">// 4.如果liquidity大于零为收取手续费地址铸造lptoken </span><br><span class="line">if (liquidity &gt; 0) _mint(feeTo, liquidity);</span><br></pre></td></tr></table></figure><p>收取手续费方法，参数为当前两个token的储备量</p>]]></content>
      
      
      <categories>
          
          <category> UniswapV2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> UniswapV2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UniswapV2Factory</title>
      <link href="/2023/01/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV2/UniswapV2Factory/"/>
      <url>/2023/01/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV2/UniswapV2Factory/</url>
      
        <content type="html"><![CDATA[<h1 id="UniswapV2Factory"><a href="#UniswapV2Factory" class="headerlink" title="UniswapV2Factory"></a>UniswapV2Factory</h1><p>在构造函数中传入一个设置feeTo的权限者地址，主要用于创建两种token的交易对，并为其部署一个UniswapV2Pair合约用于管理这个交易对，UniswapV2Factory还包含一些手续费的一些设置.</p><h2 id="合约当中具有的方法"><a href="#合约当中具有的方法" class="headerlink" title="合约当中具有的方法:"></a>合约当中具有的方法:</h2><ul><li>function feeTo() external view returns (address)：返回收取手续费地址</li><li>function feeToSetter() external view returns (address)：设置手续费收取地址的权限地址</li><li>function getPair(address tokenA, address tokenB) external view returns (address pair)：获取两个token的交易对地址</li><li>function allPairs(uint) external view returns (address pair)：返回指定位置的交易对地址</li><li>function allPairsLength() external view returns (uint)：返回所有交易对的长度</li><li>function createPair(address tokenA, address tokenB) external returns (address pair)：创建两个token的交易对地址</li><li>function setFeeTo(address) external：更改收取手续费地址</li><li>function setFeeToSetter(address) external：更改设置手续费收取地址的权限地址</li></ul><p>在 Uniswap 协议中，<code>feeTo</code> 是一个变量，用于指定手续费收取地址。当用户在 Uniswap 上进行交易时，一定比例的交易手续费会被收取，并根据协议的设定进行分配。这个手续费分配的过程包括将一部分手续费发送给流动性提供者，同时还有一部分手续费发送到 <code>feeTo</code> 地址。</p><h4 id="createPair-address-tokenA-address-tokenB-returns-address-pair"><a href="#createPair-address-tokenA-address-tokenB-returns-address-pair" class="headerlink" title="createPair:(address tokenA, address tokenB) returns (address pair)"></a>createPair:(address tokenA, address tokenB) returns (address pair)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">bytes memory bytecode = type(UniswapV2Pair).creationCode;</span><br><span class="line">assembly &#123;</span><br><span class="line">//add(bytecode, 32)：opcode操作码的add方法,将bytecode偏移后32位字节处,因为前32位字节存的是bytecode长度</span><br><span class="line">//mload(bytecode)：opcode操作码的方法,获得bytecode长度</span><br><span class="line">pair := create2(0, add(bytecode, 32), mload(bytecode), salt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pair地址是通过<strong>内联汇编assembly做create2</strong>方法创建的，其中<strong>salt</strong>盐值是通过两个两个代币的地址计算</p><blockquote><p>内联汇编：在 Solidity 源程序中嵌入汇编代码，对 EVM 有更细粒度的控制</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> UniswapV2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> UniswapV2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UniswapV2</title>
      <link href="/2023/01/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV2/UniswapV2/"/>
      <url>/2023/01/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV2/UniswapV2/</url>
      
        <content type="html"><![CDATA[<h1 id="UniswapV2"><a href="#UniswapV2" class="headerlink" title="UniswapV2"></a>UniswapV2</h1><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/UniswapV2/img/image-20230524155033168.png" alt="image-20230524155033168"> </p><p>Uniswap V2是一种基于以太坊的去中心化交易协议，旨在提供快速、安全、无信任的代币交换服务。它是Uniswap协议的第二个版本，是对第一个版本的改进和升级。</p><p>Uniswap V2的核心特点包括以下几个方面：</p><ol><li>去中心化交易：Uniswap V2使用智能合约来执行交易，而不需要传统的中心化交易所。这意味着用户可以直接通过他们的以太坊钱包进行交易，无需信任或依赖第三方中介。</li><li>自动化做市商模型：Uniswap V2采用自动化做市商模型，其中流动性提供者可以将资金存入流动性池中，并通过提供资金来帮助形成交易对的市场价格。这种模型使得任何人都可以成为流动性提供者，并从交易手续费中获得奖励。</li><li>常量乘积函数：Uniswap V2使用常量乘积函数作为交易价格计算模型。根据这个函数，交易所需的两种代币的数量乘积在交易前后保持不变，从而决定了交易价格。这种机制可以在没有订单簿的情况下进行交易，并保持相对简单和高效。</li><li>ERC-20代币支持：Uniswap V2支持以太坊上的ERC-20代币进行交易。用户可以通过选择不同的代币对进行交易，并且任何人都可以创建新的代币对，只需提供相应的流动性即可。</li><li>流动性挖矿：Uniswap V2引入了流动性挖矿机制，通过奖励流动性提供者来吸引更多的资金注入流动性池。流动性提供者可以获得代币奖励作为对其提供流动性的补偿，如果市场价格剧烈波动，您存入的资金可能面临损失。</li></ol>]]></content>
      
      
      <categories>
          
          <category> UniswapV2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> UniswapV2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-AAVE区别</title>
      <link href="/2023/01/07/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/6-AAVE%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/01/07/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/6-AAVE%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>AAVE和Compound都是去中心化金融（DeFi）领域的借贷协议，旨在提供用户借贷和存款的解决方案。尽管它们有相似之处，但也存在一些区别。</p><ol><li>借贷模型：AAVE采用了一种固定利率模型，即借款人和存款人可以获知在借贷过程中的具体利率。而Compound采用了一种浮动利率模型，利率根据市场供需和协议内部的算法进行调整。</li><li>抵押品：在Compound中，借款人必须提供抵押品来获得借款。抵押品的价值必须超过所借款项的价值，以确保借款的安全性。而AAVE引入了闪电贷款功能，允许借款人在没有抵押品的情况下进行借贷，但必须在同一交易中将借款和利息还回。</li><li>用户界面：AAVE提供了一种用户友好的界面，使用户可以直接与协议进行交互。它还支持更多的功能和创新，如闪电贷款和利息交易。Compound更加注重协议的底层机制，对于开发者和技术用户更为友好。</li><li>支持的资产：Compound和AAVE都支持多种加密货币作为存款和借贷的资产。然而，具体支持的资产可能在两个协议之间有所不同。</li></ol><p>综上所述，AAVE和Compound在借贷协议的设计和特点上有所不同。AAVE提供了固定利率和闪电贷款等创新功能，而Compound采用了浮动利率和抵押品的模型。用户可以根据自己的需求和偏好选择适合的协议。</p>]]></content>
      
      
      <categories>
          
          <category> Compound </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> Compound </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-治理</title>
      <link href="/2023/01/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/5-%E6%B2%BB%E7%90%86/"/>
      <url>/2023/01/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/5-%E6%B2%BB%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Compound 协议由 COMP Token 持有者管理和升级，使用三个不同的组件； COMP Token、治理模块（Governor  Alpha）和 Timelock。这些合约一起，允许社区通过 cToken 或 Comproller  的管理功能提出、投票和实时更改。提案可以包括调整利率模型，到增加对新资产的支持等改变。</p><p>任何授权超过 10 万 COMP Token 的地址都可以提出治理活动，这些活动都是可执行的代码。提案产生后，社区可以在 3 天的投票期内提交投票。如果投票获得多数、且至少 40 万票以上，就会在 Timlock 中排队，2 天后可以实施。</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/img/SuUUgiG761828cb5bc421.png" alt="image.png"></p><h2 id="COMP"><a href="#COMP" class="headerlink" title="COMP"></a>COMP</h2><p>COMP 是一个 <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md">ERC-20</a> 代币，允许所有者将投票权委托给任何地址，包括自己的地址。所有者的代币余额会自动调整被委托人的投票权。</p><h2 id="委托-Delegate"><a href="#委托-Delegate" class="headerlink" title="委托(Delegate)"></a>委托(Delegate)</h2><p>将发送者的投票数委托给被委托人。用户每次可以委托给一个地址，被委托人的投票数相当于用户账号的 COMP 代币余额。投票将从当前区块开始进行委托，直到发送者再次委托或者转移其 COMP。</p><p><strong>COMP</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function delegate(address delegatee)</span><br></pre></td></tr></table></figure><ul><li>delegatee : 发送者希望委托投票的地址；</li><li>msg.sender : 试图委托投票的 COMP 代币持有者的地址；</li><li>返回值 : 无返回值，错误时恢复。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Comp comp = Comp(0x123...); // contract address</span><br><span class="line">2 comp.delegate(delegateeAddress);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.2.6</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const tx = await comp.methods.delegate(delegateeAddress).send(&#123; from: sender &#125;);</span><br></pre></td></tr></table></figure><h2 id="签名委托-Delegate-By-Signature"><a href="#签名委托-Delegate-By-Signature" class="headerlink" title="签名委托(Delegate By Signature)"></a>签名委托(Delegate By Signature)</h2><p>Delegate 投票从签名者到被委托人。这种方法与 Delegate 的目的相同，但它可以离线签名参与Compound 治理投票授权。有关如何创建离线签名的更多细节，请查看 <a href="https://eips.ethereum.org/EIPS/eip-712">EIP-712</a>。</p><p><strong>COMP</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function delegateBySig(address delegateeAddress,uint256 nonce,uint256 expiry,uint256 v,uint256 r,uint256 s);</span><br></pre></td></tr></table></figure><ul><li>delegatee : 发送者希望委托投票的地址；</li><li>nonce : 合约状态要求与签名相匹配。这一点可以从合同的公共 nonce 映射中检索；</li><li>expiry : 签名过期时间。以 unix epoch (uint) 后的秒数表示的区块时间戳；</li><li>v : 签名恢复字节；</li><li>r :  ECDSA 签名对的一部分；</li><li>s : ECDSA 签名对的一部分；</li><li>返回值 : 无，错误时恢复。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Comp comp = Comp(0x123...); // contract address</span><br><span class="line">2 comp.delegateBySig(delegateeAddress, nonce, expiry, v, r, s);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.2.6</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const tx = await comp.methods.delegateBySig(delegateeAddress, nonce, expiry, v, r, s).send(&#123;&#125;);</span><br></pre></td></tr></table></figure><h2 id="获取当前投票数"><a href="#获取当前投票数" class="headerlink" title="获取当前投票数"></a>获取当前投票数</h2><p>获取一个账户当前区块的票数余额。</p><p><strong>COMP</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function getCurrentVotes(address account) returns (uint96)</span><br></pre></td></tr></table></figure><ul><li>account : 检索票数的账户地址；</li><li>RETURN : 票数（整型）。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Comp comp = Comp(0x123...); // contract address</span><br><span class="line">2 uint votes = comp.getCurrentVotes(0xabc...);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.2.6</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const account = &#x27;0x123...&#x27;; // contract address</span><br><span class="line">2 const votes = await comp.methods.getCurrentVotes(account).call();</span><br></pre></td></tr></table></figure><h2 id="获取先前投票数"><a href="#获取先前投票数" class="headerlink" title="获取先前投票数"></a>获取先前投票数</h2><p>获取一个账户在特定区块上的投票数。传入的区块高度必须是最终确定的区块，否则函数将revert。</p><p><strong>COMP</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function getPriorVotes(address account, uint blockNumber) returns (uint96)</span><br></pre></td></tr></table></figure><ul><li>account : 检索先前的投票数的账户地址；</li><li>blockNumber : 取回之前的票数的区块高度；</li><li>返回值 : 先前投票数；</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Comp comp = Comp(0x123...); // contract address</span><br><span class="line">2 uint priorVotes = comp.getPriorVotes(account, blockNumber);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.2.6</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const priorVotes = await comp.methods.getPriorVotes(account, blockNumber).call();</span><br></pre></td></tr></table></figure><h2 id="Governor-Alpha"><a href="#Governor-Alpha" class="headerlink" title="Governor Alpha"></a>Governor Alpha</h2><p>Governor Alpha 是协议的治理模块；它允许超过 10 万 COMP 代币的地址提出修改建议。在提案开始时，手握投票权（通过调用 getpriorvotes 方法）的地址可以在 3 天的投票期内提交投票。如果提取被投了多数，且至少有 40 万票，则会在 Timelock  中排队，2 两天后实施。</p><p>Govern Alpha 合约包含一个守卫者地址，由 Compound 团队控制，可以取消提案，或在紧急情况下禁用治理模块。在最初的沙盒期后，守护者可以放弃权利，标志着 COMP 代币持有者开始完全控制。</p><h2 id="法定投票数-Quorum-Votes"><a href="#法定投票数-Quorum-Votes" class="headerlink" title="法定投票数(Quorum Votes)"></a>法定投票数(Quorum Votes)</h2><p>成功支持一项提案的最低票数要求。</p><p><strong>Governor Alpha</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function quorumVotes() public pure returns (uint)</span><br></pre></td></tr></table></figure><ul><li>返回值 : 成功支持一项提案的最低票数。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 uint quorum = gov.quorumVotes();</span><br></pre></td></tr></table></figure><p><strong>Web3 1.2.6</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const quorum = await gov.methods.quorumVotes().call();</span><br></pre></td></tr></table></figure><h2 id="提案门槛-Proposal-Threshold"><a href="#提案门槛-Proposal-Threshold" class="headerlink" title="提案门槛(Proposal Threshold)"></a>提案门槛(Proposal Threshold)</h2><p>账户创建一个提案所需的最低票数；</p><p><strong>Governor Alpha</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function proposalThreshold() returns (uint)</span><br></pre></td></tr></table></figure><ul><li>返回值ETURN : 账户创建一个提案所需的最低票数。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 uint threshold = gov.proposalThreshold();</span><br></pre></td></tr></table></figure><p><strong>Web3 1.2.6</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const threshold = await gov.methods.proposalThreshold().call();</span><br></pre></td></tr></table></figure><h2 id="提案最大操作量-Proposal-Max-Operations"><a href="#提案最大操作量-Proposal-Max-Operations" class="headerlink" title="提案最大操作量(Proposal Max Operations)"></a>提案最大操作量(Proposal Max Operations)</h2><p>提案中可以包含的最大操作数量。操作是指提案成功并执行时将进行的函数调用。</p><p><strong>Governor Alpha</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function proposalMaxOperations() returns (uint)</span><br></pre></td></tr></table></figure><ul><li>返回值 : 提案中可以包含的最大操作数量。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 uint operations = gov.proposalMaxOperations();</span><br></pre></td></tr></table></figure><p><strong>Web3 1.2.6</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const operations = await gov.methods.proposalMaxOperations().call();</span><br></pre></td></tr></table></figure><h2 id="投票延迟-Voting-Delay"><a href="#投票延迟-Voting-Delay" class="headerlink" title="投票延迟(Voting Delay)"></a>投票延迟(Voting Delay)</h2><p>在对一个提案投票前需要等到的以太坊区块数。当创建一个提案时，该值会被添加到当前区块高度上。</p><p><strong>Governor Alpha</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>function <span class="built_in">votingDelay</span>() returns (uint)</span><br></pre></td></tr></table></figure><ul><li>返回值：在对一个提案投票前需要等到的以太坊区块数。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 uint blocks = gov.votingDelay();</span><br></pre></td></tr></table></figure><p><strong>Web3 1.2.6</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const blocks = await gov.methods.votingDelay().call();</span><br></pre></td></tr></table></figure><h2 id="投票期-Voting-Period"><a href="#投票期-Voting-Period" class="headerlink" title="投票期(Voting Period)"></a>投票期(Voting Period)</h2><p>以以太坊区块为单位，对提案进行投票的持续时间。</p><p><strong>Governor Alpha</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function votingPeriod() returns (uint)</span><br></pre></td></tr></table></figure><ul><li>RETURN : 对提案进行投票的持续时间。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 uint blocks = gov.votingPeriod();</span><br></pre></td></tr></table></figure><p><strong>Web3 1.2.6</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const blocks = await gov.methods.votingPeriod().call();</span><br></pre></td></tr></table></figure><h2 id="提案-Propose"><a href="#提案-Propose" class="headerlink" title="提案(Propose)"></a>提案(Propose)</h2><p>创建一个提案来改变协议。比如：一个提案能在 Comproller 上设置 cToken 的利率模型或者风险参数。</p><p>提案将委托投票人进行投票表决。如果在投票期结束前有足够的支持，提案将被自动颁布。已颁布的提案将在 Compound Timelock 合约中排队并执行。</p><p>发送者在紧邻的前一个区块中持有的 COMP 代币必须超过当前的提案阈值（proposalThreshold）。如果阈值是 10 万  COMP 代币，则发送者必须被委托超过所有 COMP 的 1% 才能创建一个提案。提案最多有 10 个操作（基于  proposalMaxOperations() ）。</p><p>如果提案者当前有待处理或活动中的提案，则他们不能创建另一个提案。不可能在同一个区块中排队两个相同的操作（由于 Timelock 中的限制）。因此一个提案中的操作必须是唯一的，共享一个相同操作的唯一提案必须在不同的区块中排队。</p><p><strong>Governor Alpha</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) returns (uint)</span><br></pre></td></tr></table></figure><ul><li>targets : 在提案执行过程中，将被调用的目标地址的有序列表。这个数组的长度必须和这个方法中所有其他数组参数的长度相同；</li><li>values : 在提案执行过程中要传递给调用的值（即msg.value）的有序列表。这个数组的长度必须和这个方法中所有其他数组参数的长度相同；</li><li>signatures : 提案执行过程中要传递的方法签名的有序列表。这个数组的长度必须和这个方法中所有其他数组参数的长度相同；</li><li>calldatas : 在提案执行过程中要传递给每个方法调用的数据的有序列表。这个数组必须和这个方法中所有其他数组参数的长度相同；</li><li>description : 对该提案的可读性说明及其将作出的修改；</li><li>返回值 : 新创建的提案 ID。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 uint proposalId = gov.propose(targets, values, signatures, calldatas, description);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.2.6</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1const tx = gov.methods.propose(targets, values, signatures, calldatas, description).send(&#123; from: sender &#125;);</span><br></pre></td></tr></table></figure><h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h2><p>提案通过后，任何地址可以调用 queue 方法将提案转移到  Timelock 队列中。提案只有在成功通过后，才能被排队。</p><p><strong>Governor Alpha</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function queue(uint proposalId)</span><br></pre></td></tr></table></figure><ul><li>proposalId : 已通过的提案 ID；</li><li>返回值 : 无，错误时将 revert。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 gov.queue(proposalId);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.2.6</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const tx = gov.methods.queue(proposalId).send(&#123; from: sender &#125;);</span><br></pre></td></tr></table></figure><h2 id="执行-Execute"><a href="#执行-Execute" class="headerlink" title="执行(Execute)"></a>执行(Execute)</h2><p>在 Timelock 延迟期之后，任何账户都可以调用 execu 方法将提案中的更改应用到目标合约中。这将调用提案中描述的每一个操作。</p><p>这个功能是可支付(payable)的，所以 Timelock 合约可以调用提案中选择的可支付功能。例如，A 提案可以 像cETH 一样在市场上添加准备金，设置 cToken 的利率模型，或者在 Comptroller上设置风险参数。</p><p><strong>Governor Alpha</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1function execute(uint proposalId) payable returns (uint)</span><br></pre></td></tr></table></figure><ul><li>proposalId : 要执行的成功提案 ID；</li><li>返回值 : 无，错误时将 revert。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 gov.execute(proposalId).value(999).gas(999)();</span><br></pre></td></tr></table></figure><p><strong>Web3 1.2.6</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const tx = gov.methods.execute(proposalId).send(&#123; from: sender, value: 1 &#125;);</span><br></pre></td></tr></table></figure><h2 id="取消-Cancel"><a href="#取消-Cancel" class="headerlink" title="取消(Cancel)"></a>取消(Cancel)</h2><p>取消尚未执行的提案。除非提案人没有维持创建提案所需的委托量，否则监护人是唯一可以执行取消的人。如果提案人的委托人数没有超过提案的阈值，任何人都可以取消该提案。</p><p><strong>Governor Alpha</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function cancel(uint proposalId)</span><br></pre></td></tr></table></figure><ul><li>proposalId : 要取消的提案 ID。提案不能重复取消。</li><li>RETURN : 无，错误时 revert。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 gov.cancel(proposalId);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.2.6</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const tx = gov.methods.cancel(proposalId).send(&#123; from: sender &#125;);</span><br></pre></td></tr></table></figure><h2 id="获取操作-Get-Actions"><a href="#获取操作-Get-Actions" class="headerlink" title="获取操作(Get Actions)"></a>获取操作(Get Actions)</h2><p>获取所选提案的操作列表。传递一个提案 ID，获取该提案的目标对象、值、签名和调用数据。</p><p><strong>Governor Alpha</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function getActions(uint proposalId) returns (uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas)</span><br></pre></td></tr></table></figure><ul><li>proposalId : 拟获取操作的提案 ID。</li><li>RETURN : 如果提案 ID 非法，则 revert 。否则成功时返回以下 4 个 参考信息：<ol><li>提案调用的合约地址数组；</li><li>提案中使用的值 - 无符号整数数组；</li><li>提案签名的字符串数组；</li><li>提案的 calldata 字节数组。</li></ol></li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 uint proposalId = 123;</span><br><span class="line">3 (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) = gov.getActions(proposalId);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.2.6</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const &#123;0: targets, 1: values, 2: signatures, 3: calldatas&#125; = gov.methods.getActions(proposalId).call();</span><br></pre></td></tr></table></figure><h2 id="获取回执-Get-Receipt"><a href="#获取回执-Get-Receipt" class="headerlink" title="获取回执(Get Receipt)"></a>获取回执(Get Receipt)</h2><p>获得指定投票者的提案选票。</p><p><strong>Governor Alpha</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function getReceipt(uint proposalId, address voter) returns (Receipt memory)</span><br></pre></td></tr></table></figure><ul><li>proposalId : 提案ID，以获取投票者的选票收据；</li><li>voter : 提案投票者的账户地址；</li><li>RETURN : 错误时 revert。成功时返回投票者地址的选票收据结构数据。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 Receipt ballot = gov.getReceipt(proposalId, voterAddress);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.2.6</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">const</span> proposalId = <span class="number">11</span>;</span><br><span class="line"><span class="number">2</span> <span class="keyword">const</span> voterAddress = <span class="string">&#x27;0x123...&#x27;</span>;</span><br><span class="line"><span class="number">3</span> <span class="keyword">const</span> result = <span class="keyword">await</span> gov.methods.getReceipt(proposalId, voterAddress).call();</span><br><span class="line"><span class="number">4</span> <span class="keyword">const</span> &#123; hasVoted, support, votes &#125; = result;</span><br></pre></td></tr></table></figure><h2 id="获取提案状态-State"><a href="#获取提案状态-State" class="headerlink" title="获取提案状态(State)"></a>获取提案状态(State)</h2><p>获取指定提案的提案状态。返回值 ProposalState 是一个 Governor Alpha 合约中定义的枚举类型。</p><p><strong>Governor Alpha</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function state(uint proposalId) returns (ProposalState)</span><br></pre></td></tr></table></figure><ul><li><p>proposalId : 提案ID，以获得其状态；</p></li><li><p>返回值 : 枚举类型 ProposalState。类型有：Pending(等待中)、Active(活动中)、</p><p>Canceled(已取消)、Defeated(已败北)、 Succeeded（已成功）、Queued（已排队）、Expired（已过期）和Executed（已执行）。</p></li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 overnorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 GovernorAlpha.ProposalState state = gov.state(123);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.2.6</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 const proposalStates = [&#x27;Pending&#x27;, &#x27;Active&#x27;, &#x27;Canceled&#x27;, &#x27;Defeated&#x27;, &#x27;Succeeded&#x27;, &#x27;Queued&#x27;, &#x27;Expired&#x27;, &#x27;Executed&#x27;];</span><br><span class="line">2 const proposalId = 123;</span><br><span class="line">3 result = await gov.methods.state(proposalId).call();</span><br><span class="line">4 const proposalState = proposalStates[result];</span><br></pre></td></tr></table></figure><h2 id="投票-Cast-Vote"><a href="#投票-Cast-Vote" class="headerlink" title="投票(Cast Vote)"></a>投票(Cast Vote)</h2><p>对某项提案进行投票。该账户的表决权重取决于该账户在提案开始生效时的表决权重。</p><p><strong>Governor Alpha</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function castVote(uint proposalId, bool support)</span><br></pre></td></tr></table></figure><ul><li>proposalId : 提案ID，以进行投票；</li><li>support : 布尔值，赞同提案为 true ，反对为 false；</li><li>RETURN : 无返回值，错误时 revert。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 gov.castVote(proposalId, true);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.2.6</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const tx = gov.methods.castVote(proposalId, false).send(&#123; from: sender &#125;);</span><br></pre></td></tr></table></figure><h2 id="通过签名投票-Cast-Vote-By-Signature"><a href="#通过签名投票-Cast-Vote-By-Signature" class="headerlink" title="通过签名投票(Cast Vote By Signature)"></a>通过签名投票(Cast Vote By Signature)</h2><p>对某项提案进行投票。该账户的投票权重由该账户在该提案状态生效时的投票权重决定。此方法的目的与 “cast vote “相同，但它可以让脱机签名参与 Compound 治理投票。有关如何创建离线签名的详细信息，请查看 EIP-712。</p><p><strong>Governor Alpha</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s)</span><br></pre></td></tr></table></figure><ul><li>proposalId : 提案ID，以进行投票；</li><li>support : 布尔值，赞同提案为 true ，反对为 false；</li><li>v : 签名恢复字节；</li><li>r :  ECDSA 签名对的一部分；</li><li>s : ECDSA 签名对的一部分；</li><li>返回值 : 无，错误时恢复。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 GovernorAlpha gov = GovernorAlpha(0x123...); // contract address</span><br><span class="line">2 gov.castVoteBySig(proposalId, true, v, r, s);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.2.6</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 const tx = await gov.methods.castVoteBySig(proposalId, false, v, r, s).send(&#123;&#125;);</span><br></pre></td></tr></table></figure><h2 id="时间锁-Timelock"><a href="#时间锁-Timelock" class="headerlink" title="时间锁(Timelock)"></a>时间锁(Timelock)</h2><p>每个 cToken 合约和 Comptroller 合约都允许 Timelock 地址修改。Timelock 合约可以修改系统参数、逻辑和合约，以 “延迟时间、选择退出 “ 的升级模式进行修改。</p><p>Timelock 有一个 2 天的最小延迟时间硬性规定，这是治理行动的最小通知时间。每项拟采取的治理行动，都会在公告后至少 2 天内公布。重大升级，如变更风险系统等，可能会有 14 天的延迟时间。</p><p>时间锁由治理模块控制；待定和已完成的治理行动可以在<a href="https://app.compound.finance/timelock">时间锁仪表板</a>上监控。</p><h2 id="暂停守护者-Pause-Guardian"><a href="#暂停守护者-Pause-Guardian" class="headerlink" title="暂停守护者(Pause Guardian)"></a>暂停守护者(Pause Guardian)</h2><p>Comptroller  合约指定了一个能够禁用协议功能的暂停守护者地址。暂停守护者只有在出现不可预见的漏洞时才会使用，暂停守护者只有一种能力：禁用一组选定的功能。Mint、Borrow、Borrow、Transfer  和 Liquidate。暂停守护者不能解除一个动作，也不能阻止用户调用赎回、偿还借款以平仓和退出协议。</p><p>目前，Compound 团队控制了暂停守护者的地址。</p>]]></content>
      
      
      <categories>
          
          <category> Compound </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> Compound </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-协议风险管理</title>
      <link href="/2023/01/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/4-%E5%8D%8F%E8%AE%AE%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86/"/>
      <url>/2023/01/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/4-%E5%8D%8F%E8%AE%AE%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Comptroller 是 Compound 协议的风险管理层；它决定了用户需要维持多少抵押品，以及是否可以（和多少）清算用户。每次用户与 cToken 交互时，Comptroller 都会被要求批准或拒绝交易。</p><p>Comptroller 将用户余额映射到价格（通过价格预言机），再映射到风险权重（称为<a href="https://learnblockchain.cn/article/3169">抵押系数</a> ）来进行判断。用户通过调用“<a href="https://learnblockchain.cn/article/3169">进入市场</a>”和“<a href="https://learnblockchain.cn/article/3169">退出市场</a>”，明确列出他们希望在风险评分中包括哪些资产。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Comptroller 作为一个可升级的代理实现。Unitroller 将所有逻辑都代理给 Comptroller 实现，但存储值是在  Unitroller 上设置的。要调用 Comptroller 方法，请使用 Unitroller 地址上的 Comptroller ABI。</p><h2 id="进入市场"><a href="#进入市场" class="headerlink" title="进入市场"></a>进入市场</h2><p>进入一个市场的清单 – 重复进入同一个市场，不是错误。要想在一个市场中提供抵押品或借贷，必须先进入市场。</p><p><strong>Comptroller</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function enterMarkets(address[] calldata cTokens) returns (uint[] memory)</span><br></pre></td></tr></table></figure><ul><li>msg.sender : 应进入特定市场的账户。</li><li>cTokens : 要进入的 cToken 市场地址。</li><li>返回值: 对于每个市场，返回一个错误代码，表示是否已进入市场。成功时为 0，否则返回<a href="https://learnblockchain.cn/article/3169">错误代码</a>。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 Comptroller troll = Comptroller(0xABCD...);</span><br><span class="line">2 CToken[] memory cTokens = new CToken[](2);</span><br><span class="line">3 cTokens[0] = CErc20(0x3FDA...);</span><br><span class="line">4 cTokens[1] = CEther(0x3FDB...);</span><br><span class="line">5 uint[] memory errors = troll.enterMarkets(cTokens);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 const troll = Comptroller.at(0xABCD...);</span><br><span class="line">2 const cTokens = [CErc20.at(0x3FDA...), CEther.at(0x3FDB...)];</span><br><span class="line">3 const errors = await troll.methods.enterMarkets(cTokens).send(&#123;from: ...&#125;);</span><br></pre></td></tr></table></figure><h2 id="退出市场"><a href="#退出市场" class="headerlink" title="退出市场"></a>退出市场</h2><p>退出一个市场 – 退出当前没有进入的市场，这不是错误。退出市场将不计入账户流动性计算。</p><p><strong>Comptroller</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function exitMarket(address cToken) returns (uint)</span><br></pre></td></tr></table></figure><ul><li>msg.sender : 应退出特定市场的账户。</li><li>cTokens : 要退出的市场 cToken 地址。</li><li>RETURN : 成功时为 0，否则返回<a href="https://learnblockchain.cn/article/3169">错误代码</a>。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1Comptroller troll = Comptroller(0xABCD...);</span><br><span class="line">2uint error = troll.exitMarket(CToken(0x3FDA...));</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const troll = Comptroller.at(0xABCD...);</span><br><span class="line">2 const errors = await troll.methods.exitMarket(CEther.at(0x3FDB...)).send(&#123;from: ...&#125;);</span><br></pre></td></tr></table></figure><h2 id="Get-Assets-In"><a href="#Get-Assets-In" class="headerlink" title="Get Assets In"></a>Get Assets In</h2><p>获取一个账户目前进入的市场列表。要在市场上提供抵押品或借款，必须先进入市场。已进入的市场计入账户流动性计算中。</p><p><strong>Comptroller</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function getAssetsIn(address account) view returns (address[] memory)</span><br></pre></td></tr></table></figure><ul><li>account : 应查询其进入市场清单的账户；</li><li>RETURN : 目前进入的每个市场的地址。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Comptroller troll = Comptroller(0xABCD...);</span><br><span class="line">2 address[] memory markets = troll.getAssetsIn(0xMyAccount);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const troll = Comptroller.at(0xABCD...);</span><br><span class="line">2 const markets = await troll.methods.getAssetsIn(cTokens).call();</span><br></pre></td></tr></table></figure><h2 id="抵押系数"><a href="#抵押系数" class="headerlink" title="抵押系数"></a>抵押系数</h2><p>一个 cToken 的抵押系数(Collateral factors)可以在 0-90% 之间，代表账户通过铸造 cToken 获得的流动性（借款限额）的比例增加。</p><p>一般来说，大额资产或流动性较强的资产抵押系数较高，而小额资产或流动性较差的资产抵押系数较低。如果一项资产的抵押系数为 0%，则不能作为抵押品（或在清算时被扣押），但仍可借入。</p><p>随着市场情况的变化，可以通过 Compound 治理，提高（或降低）抵押品系数。</p><p><strong>Comptroller</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function markets(address cTokenAddress) view returns (bool, uint)</span><br></pre></td></tr></table></figure><ul><li>cTokenAddress : 检查特定的 cToken 是否上市，并获得其抵押系数。</li><li>RETURN : 值元祖（isListed, collateralFactorMantissa）；isListed  代表审计是否承认这个cToken；collateralFactorMantissa 代表（抵押系数），按 1e18  比例乘以一个供给余额来确定可以借入多少资产。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Comptroller troll = Comptroller(0xABCD...);</span><br><span class="line">2 (bool isListed, uint collateralFactorMantissa) = troll.markets(0x3FDA...);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 const troll = Comptroller.at(0xABCD...);</span><br><span class="line">2 const result = await troll.methods.markets(0x3FDA...).call();</span><br><span class="line">3 const &#123;0: isListed, 1: collateralFactorMantissa&#125; = result;</span><br></pre></td></tr></table></figure><h2 id="获取账户流动性"><a href="#获取账户流动性" class="headerlink" title="获取账户流动性"></a>获取账户流动性</h2><p>在 Compound 协议中，账户流动性被定义为账户抵押品的预估以太值（供应余额乘以协议<a href="https://learnblockchain.cn/article/3169">抵押系数</a>，减去账户借款余额的总价值）。这些价值仅使用账户<a href="https://learnblockchain.cn/article/3169">已进入</a>的市场计算。</p><p>没有正账户流动性的用户在没有提供更多的资产或者偿还未偿还的借款，使其账户流动性恢复到正值之前，没有能力提取或借入任何资产。</p><p><strong>Comptroller</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function getAccountLiquidity(address account) view returns (uint, uint, uint)</span><br></pre></td></tr></table></figure><ul><li><p>account : 应计算其流动性的账户；</p></li><li><p>RETURN : 数组值（error、liquidity、shortfall）。成功时错误为0，否则为<a href="https://learnblockchain.cn/article/3169">错误代码</a>。非零</p><p>liquidity 表示该账户有可用的账户流动性。非零 shortfall 表示该账户目前低于其抵押品要求，需要清算。 liquidity 和 shortfall 最多只有一个不为零。</p></li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 Comptroller troll = Comptroller(0xABCD...);</span><br><span class="line">2 (uint error, uint liquidity, uint shortfall) = troll.getAccountLiquidity(msg.caller); </span><br><span class="line">3 require(error == 0, &quot;join the Discord&quot;); </span><br><span class="line">4 require(shortfall == 0, &quot;account underwater&quot;); </span><br><span class="line">5 require(liquidity &gt; 0, &quot;account has excess collateral&quot;);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 const troll = Comptroller.at(0xABCD...);</span><br><span class="line">2 const result = await troll.methods.getAccountLiquidity(0xBorrower).call();</span><br><span class="line">3 const &#123;0: error, 1: liquidity, 2: shortfall&#125; = result;</span><br></pre></td></tr></table></figure><h2 id="关闭系数"><a href="#关闭系数" class="headerlink" title="关闭系数"></a>关闭系数</h2><p>可清偿借款的账户中，可在一次清算交易中偿还的借款的百分比，范围从 0% 到 100%。如果一个用户有多个借款资产，则 closeFactor 适用于任何单一的借款资产，而不是用户未清偿借款的总价值。</p><p><strong>Comptroller</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function closeFactorMantissa() view returns (uint)</span><br></pre></td></tr></table></figure><ul><li>返回值 : 关闭系数，按 1e18 比例计算，乘以未偿还的借款余额，确定可以结清多少借款。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Comptroller troll = Comptroller(0xABCD...);</span><br><span class="line">2 uint closeFactor = troll.closeFactorMantissa();</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const troll = Comptroller.at(0xABCD...);</span><br><span class="line">2 const closeFactor = await troll.methods.closeFactoreMantissa().call();</span><br></pre></td></tr></table></figure><h2 id="清算奖励"><a href="#清算奖励" class="headerlink" title="清算奖励"></a>清算奖励</h2><p>给予清算人的额外抵押品，作为清算水下账户的奖励。例如，如果清算奖励是 1.1 ，那么清算人每关闭一个单位，就能额外获得借款人抵押品的 10%。</p><p><strong>Comptroller</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function liquidationIncentiveMantissa() view returns (uint)</span><br></pre></td></tr></table></figure><ul><li>返回值 : 清算奖励，按 1e18 比例计算，再乘以清算人的平仓借款金额，以确定可以扣押多少抵押品。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Comptroller troll = Comptroller(0xABCD...);</span><br><span class="line">2 uint closeFactor = troll.liquidationIncentiveMantissa();</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const troll = Comptroller.at(0xABCD...);</span><br><span class="line">2 const closeFactor = await troll.methods.liquidationIncentiveMantissa().call();</span><br></pre></td></tr></table></figure><h2 id="主要事件"><a href="#主要事件" class="headerlink" title="主要事件"></a>主要事件</h2><table><thead><tr><th>Event</th><th>Description</th></tr></thead><tbody><tr><td>MarketEntered(CToken cToken, address account)</td><td>成功<a href="https://learnblockchain.cn/article/3169">进入市场</a>时发生</td></tr><tr><td>MarketExited(CToken cToken, address account)</td><td>成功<a href="https://learnblockchain.cn/article/3169">退出市场</a>时发生</td></tr></tbody></table><h2 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h2><table><thead><tr><th>Code</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>NO_ERROR</td><td>不算错误</td></tr><tr><td>1</td><td>UNAUTHORIZED</td><td>The sender is not authorized to perform this action.</td></tr><tr><td>2</td><td>COMPTROLLER_MISMATCH</td><td>Liquidation cannot be performed in markets with different comptrollers.</td></tr><tr><td>3</td><td>INSUFFICIENT_SHORTFALL</td><td>The account does not have sufficient shortfall to perform this action.</td></tr><tr><td>4</td><td>INSUFFICIENT_LIQUIDITY</td><td>The account does not have sufficient liquidity to perform this action.</td></tr><tr><td>5</td><td>INVALID_CLOSE_FACTOR</td><td>The close factor is not valid.</td></tr><tr><td>6</td><td>INVALID_COLLATERAL_FACTOR</td><td>The collateral factor is not valid.</td></tr><tr><td>7</td><td>INVALID_LIQUIDATION_INCENTIVE</td><td>The liquidation incentive is invalid.</td></tr><tr><td>8</td><td>MARKET_NOT_ENTERED</td><td>The market has not been entered by the account.</td></tr><tr><td>9</td><td>MARKET_NOT_LISTED</td><td>The market is not currently listed by the comptroller.</td></tr><tr><td>10</td><td>MARKET_ALREADY_LISTED</td><td>An admin tried to list the same market more than once.</td></tr><tr><td>11</td><td>MATH_ERROR</td><td>A math calculation error occurred.</td></tr><tr><td>12</td><td>NONZERO_BORROW_BALANCE</td><td>The action cannot be performed since the account carries a borrow balance.</td></tr><tr><td>13</td><td>PRICE_ERROR</td><td>The comptroller could not obtain a required price of an asset.</td></tr><tr><td>14</td><td>REJECTION</td><td>The comptroller rejects the action requested by the market.</td></tr><tr><td>15</td><td>SNAPSHOT_ERROR</td><td>The comptroller could not get the account borrows and exchange rate from the market.</td></tr><tr><td>16</td><td>TOO_MANY_ASSETS</td><td>Attempted to enter more markets than are currently supported.</td></tr><tr><td>17</td><td>TOO_MUCH_REPAY</td><td>Attempted to repay more than is allowed by the protocol.</td></tr></tbody></table><h2 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><table><thead><tr><th>Code</th><th>Name</th></tr></thead><tbody><tr><td>0</td><td>ACCEPT_ADMIN_PENDING_ADMIN_CHECK</td></tr><tr><td>1</td><td>ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK</td></tr><tr><td>2</td><td>EXIT_MARKET_BALANCE_OWED</td></tr><tr><td>3</td><td>EXIT_MARKET_REJECTION</td></tr><tr><td>4</td><td>SET_CLOSE_FACTOR_OWNER_CHECK</td></tr><tr><td>5</td><td>SET_CLOSE_FACTOR_VALIDATION</td></tr><tr><td>6</td><td>SET_COLLATERAL_FACTOR_OWNER_CHECK</td></tr><tr><td>7</td><td>SET_COLLATERAL_FACTOR_NO_EXISTS</td></tr><tr><td>8</td><td>SET_COLLATERAL_FACTOR_VALIDATION</td></tr><tr><td>9</td><td>SET_COLLATERAL_FACTOR_WITHOUT_PRICE</td></tr><tr><td>10</td><td>SET_IMPLEMENTATION_OWNER_CHECK</td></tr><tr><td>11</td><td>SET_LIQUIDATION_INCENTIVE_OWNER_CHECK</td></tr><tr><td>12</td><td>SET_LIQUIDATION_INCENTIVE_VALIDATION</td></tr><tr><td>13</td><td>SET_MAX_ASSETS_OWNER_CHECK</td></tr><tr><td>14</td><td>SET_PENDING_ADMIN_OWNER_CHECK</td></tr><tr><td>15</td><td>SET_PENDING_IMPLEMENTATION_OWNER_CHECK</td></tr><tr><td>16</td><td>SET_PRICE_ORACLE_OWNER_CHECK</td></tr><tr><td>17</td><td>SUPPORT_MARKET_EXISTS</td></tr><tr><td>18</td><td>SUPPORT_MARKET_OWNER_CHECK</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Compound </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> Compound </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-与cToken合约交互</title>
      <link href="/2022/12/31/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/3-%E4%B8%8EcToken%E5%90%88%E7%BA%A6%E4%BA%A4%E4%BA%92/"/>
      <url>/2022/12/31/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/3-%E4%B8%8EcToken%E5%90%88%E7%BA%A6%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Compound 协议所支持的每项资产都通过 <strong>cToken 合约</strong>进行整合，cToken 合约是提供给协议的余额的 <a href="https://eips.ethereum.org/EIPS/eip-20">EIP-20</a> 合格表示。通过铸造 cToken，用户（1）通过 cToken 的汇率赚取利息，该汇率相对于标的资产的价值增加，以及（2）获得试用 <strong>cToken 作为抵押品的能力</strong>。</p><p>cToken 是与 Compound 协议交互的主要手段；当用户在使用 cToken 合约时，会**使用 cToken  合约来进行铸币(mint)、赎回(redeem)、借款(borrow)、偿还借款(repay)、清算借款(liquidate)或者划转  cToken (transfer)**。</p><p>目前有两种类型的 cToken ： CErc20 和 CEther。尽管两者都暴露了 EIP-20 接口，但 CErc20 封装了  ERC-20 标的资产，而 CEther 只是封装了 Ether  本身。因此，根据类型的不同，涉及将资产传输到协议中的核心功能的接口也略有不同，每种类型的接口如下所示。</p><h2 id="铸币-Mint"><a href="#铸币-Mint" class="headerlink" title="铸币(Mint)"></a>铸币(Mint)</h2><p>mint 方法将一个资产转移到协议中，协议开始根据该资产的当前<a href="https://learnblockchain.cn/article/3168">供应率</a>开始累积利息。用户收到的 cToken 数量等于标的代币数量除以当前<a href="https://learnblockchain.cn/article/3168">汇率</a>。</p><p><strong>CErc20</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function mint(uint mintAmount) returns (uint)</span><br></pre></td></tr></table></figure><ul><li>msg.sender : 供应资产并拥有已铸 cToken 的账户。</li><li>mintAmount : 供应的资产金额，单位为标的资产的单位。</li><li>RETURN : 成功时为0，否则是<a href="https://learnblockchain.cn/article/3168">错误代码</a>。</li></ul><p>供应资产前，用户必须先 <a href="https://eips.ethereum.org/EIPS/eip-20#approve">批准(approve)</a>， cToken 才能访问其代币余额。</p><p><strong>CEther</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">function</span> <span class="title function_">mint</span>(<span class="params"></span>) payable</span><br></pre></td></tr></table></figure><ul><li>msg.value :  供应的 ETH 数量，单位 wei。</li><li>msg.sender : 供应 ETH 并拥有已铸 cToken 的账户。</li><li>RETURN : 无返回值，错误时还原。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 Erc20 underlying = Erc20(0xToken...);     // 获取标的资产合约句柄 </span><br><span class="line">2 CErc20 cToken = CErc20(0x3FDA...);        // 获取相应 cToken 合约的句柄 </span><br><span class="line">3 underlying.approve(address(cToken), 100); // 批准划转 </span><br><span class="line">4 assert(cToken.mint(100) == 0);            // 铸 cToken 币，并断言是否有错误</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...); </span><br><span class="line">2 await cToken.methods.mint().send(&#123;from: myAccount, value: 50&#125;);</span><br></pre></td></tr></table></figure><h2 id="赎回-Redeem"><a href="#赎回-Redeem" class="headerlink" title="赎回(Redeem)"></a>赎回(Redeem)</h2><p>redeem 方法将指定数量的 cToken 转换为标的资产，并将其返还给用户。收到的标的数量等于赎回的 cToken 数量乘以当前<a href="https://learnblockchain.cn/article/3168">汇率</a>。赎回额必须小于用户的<a href="https://compound.finance/docs/comptroller#account-liquidity">账户流动性</a>和市场可用的流动性。</p><p><strong>CErc20 &#x2F; CEther</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function redeem(uint redeemTokens) returns (uint)</span><br></pre></td></tr></table></figure><ul><li>msg.sender : 应将赎回的标的资产转入的账户。</li><li>redeemTokens : 将被赎回的 cToken 数量。</li><li>RETURN : 成功时为0，否则是<a href="https://learnblockchain.cn/article/3168">错误代码</a>。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CEther cToken = CEther(0x3FDB...);</span><br><span class="line">2 require(cToken.redeem(7) == 0, &quot;something went wrong&quot;);</span><br></pre></td></tr></table></figure><h2 id="赎回标的-Redeem-Underlying"><a href="#赎回标的-Redeem-Underlying" class="headerlink" title="赎回标的(Redeem Underlying)"></a>赎回标的(Redeem Underlying)</h2><p>redeem underlying 方法将 cToken兑换成指定数量的标的资产，并返回给用户。赎回的 cToken的数量等于收到的标的数量除以当前<a href="https://learnblockchain.cn/article/3168">汇率</a>。赎回额必须小于用户的<a href="https://compound.finance/docs/comptroller#account-liquidity">账户流动性</a>和市场可用的流动性。</p><p><strong>CErc20 &#x2F; CEther</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function redeemUnderlying(uint redeemAmount) returns (uint)</span><br></pre></td></tr></table></figure><ul><li>msg.sender : 应将赎回的标的资产转入的账户。</li><li>redeemAmount : 将被赎回的标的资产数量。</li><li>RETURN : 成功时为0，否则是<a href="https://learnblockchain.cn/article/3168">错误代码</a>。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CEther cToken = CEther(0x3FDB...);</span><br><span class="line">2 require(cToken.redeemUnderlying(50) == 0, &quot;something went wrong&quot;);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CErc20.at(0x3FDA...);</span><br><span class="line">2 cToken.methods.redeemUnderlying(10).send(&#123;from: ...&#125;);</span><br></pre></td></tr></table></figure><h2 id="借款-Borrow"><a href="#借款-Borrow" class="headerlink" title="借款(Borrow)"></a>借款(Borrow)</h2><p>borrow 方法<strong>将协议中的资产转移给用户</strong>，并创建一个借款余额，根据该资产的<a href="https://learnblockchain.cn/article/3168">借款利率</a>开始累积利息。借款额必须小于用户的<a href="https://compound.finance/docs/comptroller#account-liquidity">账户流动性</a>和市场可用的流动性。</p><p>要想借入以太，借款人必须是 ‘payable’ （Solidity）。</p><p><strong>CErc20 &#x2F; CEther</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function borrow(uint borrowAmount) returns (uint)</span><br></pre></td></tr></table></figure><ul><li>msg.sender : 应将借款资金转入的账户。</li><li>borrowAmount :  标的资产借款数量。</li><li>ETURN : 成功时为0，否则是<a href="https://learnblockchain.cn/article/3168">错误代码</a>。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CErc20(0x3FDA...);</span><br><span class="line">2 require(cToken.borrow(100) == 0, &quot;got collateral?&quot;);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...);</span><br><span class="line">2 await cToken.methods.borrow(50).send(&#123;from: 0xMyAccount&#125;);</span><br></pre></td></tr></table></figure><h2 id="偿还借款-Repay-Borrow"><a href="#偿还借款-Repay-Borrow" class="headerlink" title="偿还借款(Repay Borrow)"></a>偿还借款(Repay Borrow)</h2><p>repay 方法将资产转移到协议中，并减少用户的借款余额。</p><p><strong>CErc20</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function repayBorrow(uint repayAmount) returns (uint)</span><br></pre></td></tr></table></figure><ul><li>msg.sender : 借入资产的账户，应偿还借款。</li><li>repayAmount : 拟偿还的标的资产借款金额。值为-1（即2256-1）表示偿还全部借款额。</li><li>RETURN : 成功时为0，否则是<a href="https://learnblockchain.cn/article/3168">错误代码</a>。</li></ul><p>偿还资产前，用户必须先 <a href="https://eips.ethereum.org/EIPS/eip-20#approve">批准(approve)</a>， cToken 才能访问其代币余额。</p><p><strong>CEther</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">function</span> <span class="title function_">repayBorrow</span>(<span class="params"></span>) payable</span><br></pre></td></tr></table></figure><ul><li>msg.value : 用于偿还的 ETH 数量，单位 wei。</li><li>msg.sender : 借入资产的账户，应偿还借款。</li><li>RETURN : 无返回值，错误时还原。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 CEther cToken = CEther(0x3FDB...);</span><br><span class="line"></span><br><span class="line">2 require(cToken.repayBorrow.value(100)() == 0, &quot;transfer approved?&quot;);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CErc20.at(0x3FDA...);</span><br><span class="line"></span><br><span class="line">2 cToken.methods.repayBorrow(10000).send(&#123;from: ...&#125;);</span><br></pre></td></tr></table></figure><h2 id="代偿还借款-Repay-Borrow-Behalf"><a href="#代偿还借款-Repay-Borrow-Behalf" class="headerlink" title="代偿还借款(Repay Borrow Behalf)"></a>代偿还借款(Repay Borrow Behalf)</h2><p>repay 方法将资产转移到协议中，并减少目标用户的借款余额。</p><p><strong>CErc20</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function repayBorrowBehalf(address borrower, uint repayAmount) returns (uint)</span><br></pre></td></tr></table></figure><ul><li>msg.sender : 偿还借款的账户。</li><li>borrower : 借入资产要偿还的账户。</li><li>repayAmount : 拟偿还的标的资产借款金额。值为-1（即2256-1）表示偿还全部借款额。</li><li>RETURN : 成功时为0，否则是<a href="https://learnblockchain.cn/article/3168">错误代码</a>。</li></ul><p>偿还资产前，用户必须先 <a href="https://eips.ethereum.org/EIPS/eip-20#approve">批准(approve)</a>， cToken 才能访问其代币余额。</p><p><strong>CEther</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function repayBorrowBehalf(address borrower) payable</span><br></pre></td></tr></table></figure><ul><li>msg.value : 用于偿还的 ETH 数量，单位 wei。</li><li>msg.sender : 偿还借款的账户。</li><li>borrower : 借入资产要偿还的账户。</li><li>RETURN : 无返回值，错误时还原。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CEther cToken = CEther(0x3FDB...);</span><br><span class="line">2 require(cToken.repayBorrowBehalf.value(100)(0xBorrower) == 0, &quot;transfer approved?&quot;);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CErc20.at(0x3FDA...);</span><br><span class="line">2 await cToken.methods.repayBorrowBehalf(0xBorrower, 10000).send(&#123;from: 0xPayer&#125;);</span><br></pre></td></tr></table></figure><h2 id="清算借款-Liquidate-Borrow"><a href="#清算借款-Liquidate-Borrow" class="headerlink" title="清算借款(Liquidate Borrow)"></a>清算借款(Liquidate Borrow)</h2><p><a href="https://compound.finance/docs/comptroller#account-liquidity">账户流动性</a>为负值的用户，由协议的其他用户进行<a href="https://learnblockchain.cn/article/3168">清算</a>，使其账户流动性恢复到正值（即高于抵押品要求）。当发生清算时，清算人(liquidator)可以代表借款人偿还部分或全部未偿还的借款，作为回报，可以获得借款人持有的抵押品的折价；这种折价被定义为清算奖励。</p><p>清算人可将水下账户的任何一个未偿还借款以一定的固定比例（即结算系数）进行结算。与 V1 中不同的是，清算者必须与每一个 cToken  合约中偿还借款并扣押另一项资产作为抵押品的 cToken 进行交互。当抵押品被扣押时，清算人会被转移 cToken，他们可以赎回这些  cToken，就像他们自己提供资产一样。用户必须在调用清算前批准每个 cToken  合约（即在他们要偿还的借款资产上），因为他们正在将资金转移到合约中。</p><p><strong>CErc20</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function liquidateBorrow(address borrower, uint amount, address collateral) returns (uint)</span><br></pre></td></tr></table></figure><ul><li>msg.sender : 应通过偿还借款人的债务和扣押抵押品来结算借款人的账户。</li><li>borrower : 应予清算的负<a href="https://compound.finance/docs/comptroller#account-liquidity">账户流动性</a>账户。</li><li>repayAmount : 借款资产的偿还和转换为抵押品的金额，以标的抵押资产的单位为单位。</li><li>cTokenCollateral : 清算人应扣押借款人目前作为抵押品持有的 cToken 地址。</li><li>RETURN : 成功时为0，否则是<a href="https://learnblockchain.cn/article/3168">错误代码</a>。</li></ul><p>偿还资产前，用户必须先 <a href="https://eips.ethereum.org/EIPS/eip-20#approve">批准(approve)</a>， cToken 才能访问其代币余额。</p><p><strong>CEther</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function liquidateBorrow(address borrower, address cTokenCollateral) payable</span><br></pre></td></tr></table></figure><ul><li>msg.value : 转换为抵押品的 ETH 金额，单位 wei 。</li><li>msg.sender : 应通过偿还借款人的债务和扣押抵押品来结算借款人的账户。</li><li>borrower : 应予清算的负<a href="https://compound.finance/docs/comptroller#account-liquidity">账户流动性</a>账户。</li><li>cTokenCollateral : 清算人应扣押借款人目前作为抵押品持有的 cToken 地址。</li><li>RETURN : 成功时为0，否则是<a href="https://learnblockchain.cn/article/3168">错误代码</a>。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 CEther cToken = CEther(0x3FDB...); </span><br><span class="line">2 CErc20 cTokenCollateral = CErc20(0x3FDA...);</span><br><span class="line">3  require(cToken.liquidateBorrow.value(100)(0xBorrower, cTokenCollateral) == 0, &quot;borrower underwater??&quot;);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CErc20.at(0x3FDA...); </span><br><span class="line">2 const cTokenCollateral = CEther.at(0x3FDB...);</span><br><span class="line">3  await cToken.methods.liquidateBorrow(0xBorrower, 33, cTokenCollateral).send(&#123;from: 0xLiquidator&#125;);</span><br></pre></td></tr></table></figure><h2 id="主要事件-Key-Events"><a href="#主要事件-Key-Events" class="headerlink" title="主要事件(Key Events)"></a>主要事件(Key Events)</h2><table><thead><tr><th>Event</th><th>Description</th></tr></thead><tbody><tr><td>Mint(address minter, uint mintAmount, uint mintTokens)</td><td><a href="https://compound.devdapp.cn/kai-fa-zhe-wen-dang/ctoken#zhu-bi-mint">铸币</a>成功后发出</td></tr><tr><td>Redeem(address redeemer, uint redeemAmount, uint redeemTokens)</td><td><a href="https://learnblockchain.cn/article/3168">赎回</a>成功后发出</td></tr><tr><td>Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows)</td><td><a href="https://compound.devdapp.cn/kai-fa-zhe-wen-dang/ctoken#jie-kuan-borrow">借款</a>成功后发出</td></tr><tr><td>RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows)</td><td><a href="https://learnblockchain.cn/article/3168">偿还借款</a>成功后发出</td></tr><tr><td>LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens)</td><td><a href="https://learnblockchain.cn/article/3168">借款清算</a>成功后发出</td></tr></tbody></table><h2 id="错误代码-Error-Codes"><a href="#错误代码-Error-Codes" class="headerlink" title="错误代码(Error Codes)"></a>错误代码(Error Codes)</h2><table><thead><tr><th>Code</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>NO_ERROR</td><td>不是失败。</td></tr><tr><td>1</td><td>UNAUTHORIZED</td><td>发件人无权实施这一操作。</td></tr><tr><td>2</td><td>BAD_INPUT</td><td>调用者提供了一个无效参数。</td></tr><tr><td>3</td><td>COMPTROLLER_REJECTION</td><td>该操作将违反审计官政策。</td></tr><tr><td>4</td><td>COMPTROLLER_CALCULATION_ERROR</td><td>审计内部计算失败 。</td></tr><tr><td>5</td><td>INTEREST_RATE_MODEL_ERROR</td><td>利率模型返回了一个无效值。</td></tr><tr><td>6</td><td>INVALID_ACCOUNT_PAIR</td><td>指定的账户组合是无效的。</td></tr><tr><td>7</td><td>INVALID_CLOSE_AMOUNT_REQUESTED</td><td>清算金额无效。</td></tr><tr><td>8</td><td>INVALID_COLLATERAL_FACTOR</td><td>抵押因子无效。</td></tr><tr><td>9</td><td>MATH_ERROR</td><td>出现了数学计算错误。</td></tr><tr><td>10</td><td>MARKET_NOT_FRESH</td><td>利息没有正确产生。</td></tr><tr><td>11</td><td>MARKET_NOT_LISTED</td><td>目前，市场没有由审计员列出。</td></tr><tr><td>12</td><td>TOKEN_INSUFFICIENT_ALLOWANCE</td><td>ERC-20 合约必须**允许(allow)**货币市场合约调用<code>transferForm</code>。当前 allow 额为0或小于请求的供给、偿还借款或清算金额。</td></tr><tr><td>13</td><td>TOKEN_INSUFFICIENT_BALANCE</td><td>调用者在 ERC-20 合约中没有足够的余额来完成所需的操作。</td></tr><tr><td>14</td><td>TOKEN_INSUFFICIENT_CASH</td><td>市场上没有足够的现金金额来完成交易。您可以稍后再尝试此项交易。</td></tr><tr><td>15</td><td>TOKEN_TRANSFER_IN_FAILED</td><td>在 ERC-20 代币转入市场时失败。</td></tr><tr><td>16</td><td>TOKEN_TRANSFER_OUT_FAILED</td><td>在 ERC-20 代币转出市场时失败。</td></tr></tbody></table><h2 id="失败信息-Failure-Info"><a href="#失败信息-Failure-Info" class="headerlink" title="失败信息(Failure Info)"></a>失败信息(Failure Info)</h2><table><thead><tr><th>Code</th><th>Name</th></tr></thead><tbody><tr><td>0</td><td>ACCEPT_ADMIN_PENDING_ADMIN_CHECK</td></tr><tr><td>1</td><td>ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED</td></tr><tr><td>2</td><td>ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED</td></tr><tr><td>3</td><td>ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED</td></tr><tr><td>4</td><td>ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED</td></tr><tr><td>5</td><td>ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED</td></tr><tr><td>6</td><td>ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED</td></tr><tr><td>7</td><td>BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED</td></tr><tr><td>8</td><td>BORROW_ACCRUE_INTEREST_FAILED</td></tr><tr><td>9</td><td>BORROW_CASH_NOT_AVAILABLE</td></tr><tr><td>10</td><td>BORROW_FRESHNESS_CHECK</td></tr><tr><td>11</td><td>BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED</td></tr><tr><td>12</td><td>BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED</td></tr><tr><td>13</td><td>BORROW_MARKET_NOT_LISTED</td></tr><tr><td>14</td><td>BORROW_COMPTROLLER_REJECTION</td></tr><tr><td>15</td><td>LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED</td></tr><tr><td>16</td><td>LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED</td></tr><tr><td>17</td><td>LIQUIDATE_COLLATERAL_FRESHNESS_CHECK</td></tr><tr><td>18</td><td>LIQUIDATE_COMPTROLLER_REJECTION</td></tr><tr><td>19</td><td>LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED</td></tr><tr><td>20</td><td>LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX</td></tr><tr><td>21</td><td>LIQUIDATE_CLOSE_AMOUNT_IS_ZERO</td></tr><tr><td>22</td><td>LIQUIDATE_FRESHNESS_CHECK</td></tr><tr><td>23</td><td>LIQUIDATE_LIQUIDATOR_IS_BORROWER</td></tr><tr><td>24</td><td>LIQUIDATE_REPAY_BORROW_FRESH_FAILED</td></tr><tr><td>25</td><td>LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED</td></tr><tr><td>26</td><td>LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED</td></tr><tr><td>27</td><td>LIQUIDATE_SEIZE_COMPTROLLER_REJECTION</td></tr><tr><td>28</td><td>LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER</td></tr><tr><td>29</td><td>LIQUIDATE_SEIZE_TOO_MUCH</td></tr><tr><td>30</td><td>MINT_ACCRUE_INTEREST_FAILED</td></tr><tr><td>31</td><td>MINT_COMPTROLLER_REJECTION</td></tr><tr><td>32</td><td>MINT_EXCHANGE_CALCULATION_FAILED</td></tr><tr><td>33</td><td>MINT_EXCHANGE_RATE_READ_FAILED</td></tr><tr><td>34</td><td>MINT_FRESHNESS_CHECK</td></tr><tr><td>35</td><td>MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED</td></tr><tr><td>36</td><td>MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED</td></tr><tr><td>37</td><td>MINT_TRANSFER_IN_FAILED</td></tr><tr><td>38</td><td>MINT_TRANSFER_IN_NOT_POSSIBLE</td></tr><tr><td>39</td><td>REDEEM_ACCRUE_INTEREST_FAILED</td></tr><tr><td>40</td><td>REDEEM_COMPTROLLER_REJECTION</td></tr><tr><td>41</td><td>REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED</td></tr><tr><td>42</td><td>REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED</td></tr><tr><td>43</td><td>REDEEM_EXCHANGE_RATE_READ_FAILED</td></tr><tr><td>44</td><td>REDEEM_FRESHNESS_CHECK</td></tr><tr><td>45</td><td>REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED</td></tr><tr><td>46</td><td>REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED</td></tr><tr><td>47</td><td>REDEEM_TRANSFER_OUT_NOT_POSSIBLE</td></tr><tr><td>48</td><td>REDUCE_RESERVES_ACCRUE_INTEREST_FAILED</td></tr><tr><td>49</td><td>REDUCE_RESERVES_ADMIN_CHECK</td></tr><tr><td>50</td><td>REDUCE_RESERVES_CASH_NOT_AVAILABLE</td></tr><tr><td>51</td><td>REDUCE_RESERVES_FRESH_CHECK</td></tr><tr><td>52</td><td>REDUCE_RESERVES_VALIDATION</td></tr><tr><td>53</td><td>REPAY_BEHALF_ACCRUE_INTEREST_FAILED</td></tr><tr><td>54</td><td>REPAY_BORROW_ACCRUE_INTEREST_FAILED</td></tr><tr><td>55</td><td>REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED</td></tr><tr><td>56</td><td>REPAY_BORROW_COMPTROLLER_REJECTION</td></tr><tr><td>57</td><td>REPAY_BORROW_FRESHNESS_CHECK</td></tr><tr><td>58</td><td>REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED</td></tr><tr><td>59</td><td>REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED</td></tr><tr><td>60</td><td>REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE</td></tr><tr><td>61</td><td>SET_COLLATERAL_FACTOR_OWNER_CHECK</td></tr><tr><td>62</td><td>SET_COLLATERAL_FACTOR_VALIDATION</td></tr><tr><td>63</td><td>SET_COMPTROLLER_OWNER_CHECK</td></tr><tr><td>64</td><td>SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED</td></tr><tr><td>65</td><td>SET_INTEREST_RATE_MODEL_FRESH_CHECK</td></tr><tr><td>66</td><td>SET_INTEREST_RATE_MODEL_OWNER_CHECK</td></tr><tr><td>67</td><td>SET_MAX_ASSETS_OWNER_CHECK</td></tr><tr><td>68</td><td>SET_ORACLE_MARKET_NOT_LISTED</td></tr><tr><td>69</td><td>SET_PENDING_ADMIN_OWNER_CHECK</td></tr><tr><td>70</td><td>SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED</td></tr><tr><td>71</td><td>SET_RESERVE_FACTOR_ADMIN_CHECK</td></tr><tr><td>72</td><td>SET_RESERVE_FACTOR_FRESH_CHECK</td></tr><tr><td>73</td><td>SET_RESERVE_FACTOR_BOUNDS_CHECK</td></tr><tr><td>74</td><td>TRANSFER_COMPTROLLER_REJECTION</td></tr><tr><td>75</td><td>TRANSFER_NOT_ALLOWED</td></tr><tr><td>76</td><td>TRANSFER_NOT_ENOUGH</td></tr><tr><td>77</td><td>TRANSFER_TOO_MUCH</td></tr></tbody></table><h2 id="汇率-Exchange-Rate"><a href="#汇率-Exchange-Rate" class="headerlink" title="汇率(Exchange Rate)"></a>汇率(Exchange Rate)</h2><p>每个cToken 都可以兑换成数量不断增加的标的资产，因为在市场上会产生利息。cToken 与相关资产之间的汇率等于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 exchangeRate = (getCash() + totalBorrows() - totalReserves()) / totalSupply()</span><br></pre></td></tr></table></figure><p><strong>CErc20 &#x2F; CEther</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function exchangeRateCurrent() returns (uint)</span><br></pre></td></tr></table></figure><ul><li>返回值 : 当前的汇率，为无符号整数，按 1e18 缩放；</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2 uint exchangeRateMantissa = cToken.exchangeRateCurrent();</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...); </span><br><span class="line">2 const exchangeRate = (await cToken.methods.exchangeRateCurrent().call()) / 1e18;</span><br></pre></td></tr></table></figure><blockquote><p>请注意，对比 send 使用 <code>call</code> 是在链外调用方法，而不需要导致 Gas 成本。</p></blockquote><h2 id="获取现金-Get-Cash"><a href="#获取现金-Get-Cash" class="headerlink" title="获取现金(Get Cash)"></a>获取现金(Get Cash)</h2><p>现金是指该 cToken 合约所拥有的标的资产余额。人民可以查询到目前这个市场上的现金总量。</p><p><strong>CErc20 &#x2F; CEther</strong></p><p>1 function getCash() returns (uint)</p><ul><li>返回值 : 该 cToken 合约所拥有的标的资产数量。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2 uint cash = cToken.getCash();</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...);</span><br><span class="line">2 const cash = (await cToken.methods.getCash().call());</span><br></pre></td></tr></table></figure><h2 id="总借款-Total-Borrow"><a href="#总借款-Total-Borrow" class="headerlink" title="总借款(Total Borrow)"></a>总借款(Total Borrow)</h2><p>总借贷额是指目前市场上借出的标的额，以及累计向市场上的供应商支付的利息。</p><p><strong>CErc20 &#x2F; CEther</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function totalBorrowsCurrent() returns (uint)</span><br></pre></td></tr></table></figure><ul><li>返回值：借出的标的总额与利息。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2 uint borrows = cToken.totalBorrowsCurrent();</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...);</span><br><span class="line">2 const borrows = (await cToken.methods.totalBorrowsCurrent().call());</span><br></pre></td></tr></table></figure><h2 id="借款余额-Borrow-Balance"><a href="#借款余额-Borrow-Balance" class="headerlink" title="借款余额(Borrow Balance)"></a>借款余额(Borrow Balance)</h2><p>从协议中借入资产的用户要根据借款利率进行累计利息。利息是每块都要累计的，集成商可以通过这个功能来获得用户的借款余额的当前价值与利息。</p><p><strong>CErc20 &#x2F; CEther</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function borrowBalanceCurrent(address account) returns (uint)</span><br></pre></td></tr></table></figure><ul><li>account : 借入资产的账户。</li><li>返回值 : 用户的当前借款余额（与利息），单位是标的资产的单位。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2 uint borrows = cToken.borrowBalanceCurrent(msg.caller);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...);</span><br><span class="line">2 const borrows = await cToken.methods.borrowBalanceCurrent(account).call();</span><br></pre></td></tr></table></figure><h2 id="借款利率-Borrow-Rate"><a href="#借款利率-Borrow-Rate" class="headerlink" title="借款利率(Borrow Rate)"></a>借款利率(Borrow Rate)</h2><p>在任何时候，任何人都可以通过查询合约来获取当前每个区块的借款利率。</p><p><strong>CErc20 &#x2F; CEther</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function borrowRatePerBlock() returns (uint)</span><br></pre></td></tr></table></figure><ul><li>返回值 : 当前借款利率，为一个无符号整数，按 1e18 缩放。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2 uint borrowRateMantissa = cToken.borrowRatePerBlock();</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...);</span><br><span class="line">2 const borrowRate = (await cToken.methods.borrowRatePerBlock().call()) / 1e18;</span><br></pre></td></tr></table></figure><h2 id="总供应量-Total-Supply"><a href="#总供应量-Total-Supply" class="headerlink" title="总供应量(Total Supply)"></a>总供应量(Total Supply)</h2><p>总供应量是指目前在 cToken 市场上流通的代币数量。它是 cToken 合约的 EIP-20 接口的一部分 。</p><p><strong>CErc20 &#x2F; CEther</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function totalSupply() returns (uint)</span><br></pre></td></tr></table></figure><ul><li>返回值 : 在市场上流通的代币总数量。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2  uint tokens = cToken.totalSupply();</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...);</span><br><span class="line">2 const tokens = (await cToken.methods.totalSupply().call());</span><br></pre></td></tr></table></figure><h2 id="标的余额-Balance"><a href="#标的余额-Balance" class="headerlink" title="标的余额 Balance"></a>标的余额 Balance</h2><p>用户的标的月，代币他们在协议中的资产，等于用户的 cToken 余额乘以<a href="https://learnblockchain.cn/article/3168">汇率</a>。</p><p><strong>CErc20 &#x2F; CEther</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function balanceOfUnderlying(address account) returns (uint)</span><br></pre></td></tr></table></figure><ul><li>account : 获取标的余额的账户。</li><li>返回值 : 该账户当前拥有的标的数量。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2 uint tokens = cToken.balanceOfUnderlying(msg.caller);</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...);</span><br><span class="line">2 const tokens = await cToken.methods.balanceOfUnderlying(account).call();</span><br></pre></td></tr></table></figure><h2 id="供给率-Supply-Rate"><a href="#供给率-Supply-Rate" class="headerlink" title="供给率(Supply Rate)"></a>供给率(Supply Rate)</h2><p>在任何时候，人们都可以通过查询合约来获取当前每块的供给率。供给率是由<a href="https://learnblockchain.cn/article/3168">借款利率</a>、准备金系数(<a href="https://compound.finance/docs/ctokens#reserve-factor">reserve factor</a>)和<a href="https://learnblockchain.cn/article/3168">总借款额</a>得出的。</p><p><strong>CErc20 &#x2F; CEther</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function supplyRatePerBlock() returns (uint)</span><br></pre></td></tr></table></figure><ul><li>返回值 : 当前供给率，为一个无符号整数，按 1e18 缩放。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2 uint supplyRateMantissa = cToken.supplyRatePerBlock();</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...);</span><br><span class="line">2 const supplyRate = (await cToken.methods.supplyRatePerBlock().call()) / 1e18;</span><br></pre></td></tr></table></figure><h2 id="总储备金-Total-Reserves"><a href="#总储备金-Total-Reserves" class="headerlink" title="总储备金(Total Reserves)"></a>总储备金(Total Reserves)</h2><p>储备金是每个 cToken 合约中的会计分录，代币历史利息的一部分，作为现金预留，可以通过协议的治理来提取或转移。借款人利息的一小部分应计入协议中，由准备金系数 <a href="https://compound.finance/docs/ctokens#reserve-factor">reserve factor</a>决定。</p><p><strong>CErc20 &#x2F; CEther</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function totalReserves() returns (uint)</span><br></pre></td></tr></table></figure><ul><li>返回值 : 市场上持有的储备金总额。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2 uint reserves = cToken.totalReserves();</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...);</span><br><span class="line">2 const reserves = (await cToken.methods.totalReserves().call());</span><br></pre></td></tr></table></figure><h2 id="储备金系数-Reserve-Factor"><a href="#储备金系数-Reserve-Factor" class="headerlink" title="储备金系数(Reserve Factor)"></a>储备金系数(Reserve Factor)</h2><p>准备金系数确定了借款人利息中转化为准备金的部分。</p><p><strong>CErc20 &#x2F; CEther</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 function reserveFactorMantissa() returns (uint)</span><br></pre></td></tr></table></figure><ul><li>返回值 : 当前市场准备金系数，为一个无符号整数，按 1e18 缩放。</li></ul><p><strong>Solidity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 CErc20 cToken = CToken(0x3FDA...);</span><br><span class="line">2uint reserveFactorMantissa = cToken.reserveFactorMantissa();</span><br></pre></td></tr></table></figure><p><strong>Web3 1.0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const cToken = CEther.at(0x3FDB...); </span><br><span class="line">2 const reserveFactor = (await cToken.methods.reserveFactorMantissa().call()) / 1e18;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Compound </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> Compound </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-开发者入门</title>
      <link href="/2022/12/27/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/2-%E5%BC%80%E5%8F%91%E8%80%85%E5%85%A5%E9%97%A8/"/>
      <url>/2022/12/27/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/2-%E5%BC%80%E5%8F%91%E8%80%85%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Compound-开发者入门"><a href="#Compound-开发者入门" class="headerlink" title="Compound 开发者入门"></a>Compound 开发者入门</h1><p>Compound 协议已经部署在以下网络中：networks:Mainnet、Rinkeby、Kovan、Ropsten、Goerli</p><h2 id="应计利息计算"><a href="#应计利息计算" class="headerlink" title="应计利息计算"></a>应计利息计算</h2><p>在每个市场上的任何一个区块的<strong>借款资产和供给资产的比例发生变化时，市场的利息率就会发送变化</strong>。利率的变化量取决于市场所实施的利率模型智能合约，以及市场上的借款资产与供应资产的比例变化量。</p><p>请看  <a href="https://observablehq.com/@jflatow/compound-interest-rates">Observable</a> 上的利率数据可视化笔记本，可以直观的了解到目前每个市场上应用的利率模型是哪个利率模型。</p><p>历史利率可以从  <a href="https://compound.finance/docs/api#MarketHistoryService">MarketHistoryService API</a> 中检索。</p><p>当任何以太坊地址和市场上的 cToken  合约交互，调用这些方法中的一个时，利息就会累积到市场的所有供应商和借款人身上：mint、redeem、borrow 或 repay。  <strong>成功执行其中一个方法就会触发 accrueInterest 方法</strong>，导致<strong>利息被添加到市场上没个供应商和借款人的基础余额中</strong>。当前区块以及之前没有触发 accrueInterest 方法的每个区块（没用户与 cToken 合约交互）都会产生利息。<strong>只有在 cToken  合约调用了上述方法之一的区块中，才会产生利息。</strong></p><p>这里以供给应计利息为例：</p><p>张三向 Compound 协议供应 1 个 ETH。供给时， supplyRatePerBlock 是 37893605 wei，或每块  0.000000000037893605 ETH。在 3 个以太坊区块中，没人与 cETH 合约交互。在随后的第 4 个区块上，李四借了一些  ETH。现在，张三的底层资产余额是 1.000000000151574420 ETH（也就是 37893605 wei 乘以 4  个区块，加上原来的 1 ETH）。张三在后续区块中的底层 ETH 余额将根据 1.000000000151574420 ETH  新值计息，而不是最初的 1 ETH。请注意，supplyRatePerBlock的值可能会随时发生变化。</p><h3 id="使用每块利率计算年利率"><a href="#使用每块利率计算年利率" class="headerlink" title="使用每块利率计算年利率"></a>使用每块利率计算年利率</h3><p>每个市场中的供应或借款的年收益率（APY）可以用本公式中的 supplyRatePerBlock（求供应年收益率）或 borrowRatePerBlock （求借款年收益率）的值来计算：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> Rate <span class="operator">=</span> cToken.supplyRatePerBlock(); <span class="operator">/</span><span class="operator">/</span> 整数</span><br><span class="line"><span class="number">2</span> Rate <span class="operator">=</span> <span class="number">37893566</span></span><br><span class="line"><span class="number">3</span> ETH Mantissa <span class="operator">=</span> <span class="number">1</span> <span class="operator">*</span> <span class="number">10</span> <span class="operator">^</span> <span class="number">18</span> <span class="operator">/</span><span class="operator">/</span> ETH 是 <span class="number">18</span> 个小数点</span><br><span class="line"><span class="number">4</span> Blocks <span class="keyword">Per</span> <span class="keyword">Day</span> <span class="operator">=</span> <span class="number">4</span> <span class="operator">*</span> <span class="number">60</span> <span class="operator">*</span> <span class="number">24</span> <span class="operator">/</span><span class="operator">/</span> 按每分钟 <span class="number">4</span> 个区块计算</span><br><span class="line"><span class="number">5</span> Days <span class="keyword">Per</span> <span class="keyword">Year</span> <span class="operator">=</span> <span class="number">365</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span> APY <span class="operator">=</span> ((((Rate <span class="operator">/</span> ETH Mantissa <span class="operator">*</span> Blocks <span class="keyword">Per</span> <span class="keyword">Day</span> <span class="operator">+</span> <span class="number">1</span>) <span class="operator">^</span> Days <span class="keyword">Per</span> <span class="keyword">Year</span> <span class="operator">-</span> <span class="number">1</span>)) <span class="operator">-</span> <span class="number">1</span>) <span class="operator">*</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p>用 Web3.js JavaScript 计算供应和借款年收益率示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 const ethMantissa = 1e18;</span><br><span class="line">2 const blocksPerDay = 4 * 60 * 24;</span><br><span class="line">3 const daysPerYear = 365;</span><br><span class="line">4</span><br><span class="line">5 const cToken = new web3.eth.Contract(cEthAbi, cEthAddress);</span><br><span class="line">6 const supplyRatePerBlock = await cToken.methods.supplyRatePerBlock().call();</span><br><span class="line">7 const borrowRatePerBlock = await cToken.methods.borrowRatePerBlock().call();</span><br><span class="line">8 const supplyApy = (((Math.pow((supplyRatePerBlock / ethMantissa * blocksPerDay) + 1, daysPerYear - 1))) - 1) * 100;</span><br><span class="line">9 const borrowApy = (((Math.pow((borrowRatePerBlock / ethMantissa * blocksPerDay) + 1, daysPerYear - 1))) - 1) * 100;</span><br><span class="line">10 console.log(`Supply APY for ETH $&#123;supplyApy&#125; %`);</span><br><span class="line">11 console.log(`Borrow APY for ETH $&#123;borrowApy&#125; %`);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Compound </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> Compound </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-介绍</title>
      <link href="/2022/12/24/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/1-%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/12/24/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Compound/1-%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Compound-介绍"><a href="#Compound-介绍" class="headerlink" title="Compound 介绍"></a>Compound 介绍</h1><h2 id="什么是-Compound"><a href="#什么是-Compound" class="headerlink" title="什么是 Compound"></a>什么是 Compound</h2><p>Compound 是一个<strong>允许用户借贷代币的智能合约</strong>，它与你的银行类似，Compound  <strong>把你的钱借给借款人，并随着时间的推移赚取利息</strong>。但与银行不同的是，<strong>你的利息是从你存入 Compound  的智能合约后开始复利计算的。</strong>因为这是一个智能合约，整个流程中没有中间人，因此利息会比传统银行要高。</p><p>Compound 的贷款是通过<strong>超额担保</strong>确立的。借贷者将代币存入 Compound 中以增加他们的 <strong>“借款能力”</strong>，如果借贷者的<strong>借款能力低于 0</strong>，他们的<strong>抵押品将被出售以偿还债务</strong>。另外，<strong>每个资产的贷款利率是不同的，这根据资产的需求而决定</strong>。</p><h2 id="Compound的运作机制"><a href="#Compound的运作机制" class="headerlink" title="Compound的运作机制"></a>Compound的运作机制</h2><p>Compound 协议让开发者可以基于以太坊建立各种各样的货币市场（money market）。</p><p>所谓的<strong>「货币市场」，其实就是一个个的独立币池单元</strong>，每个币池里只有一种代币，协议<strong>通过算法来决定这个池子里的币借贷的利率</strong>是多少。<strong>简单点说，这个算法会基于人们对这个币借贷的供需关系自动计算出利率。</strong></p><p>而在 Compound 协议里，每个代币（比如 Ether、Dai、USDC）<strong>都有一个属于自己的借贷市场</strong>，里面包含<strong>每个用户在这个市场里的余额，以及各笔生效的借贷交易，乃至每段时期的历史利率</strong>，等等。</p><p>用户可以通<strong>过抵押品的信贷额度无缝地从协议上借钱</strong>，你只需要看自己要借哪个币，不需要和别人沟通还款日期、利率，就能马上借钱。借款是实时且可预测的。<strong>每个货币市场都有一个由市场决定的浮动利率。</strong></p><h2 id="Compound-清算保证"><a href="#Compound-清算保证" class="headerlink" title="Compound 清算保证"></a>Compound 清算保证</h2><p>Compound 协议强制应用了一条规则，即<strong>每个账户必须拥有足够的余额能够偿还借款的额度</strong>，叫做<strong>抵押率</strong>。每个账户无法做出任何会使「余额／借款额度」低于「抵押率」的行为。比如<strong>再借更多的钱或者把抵押款的余额提现。要增大或者重置抵押率，用户可以全额或者部分偿还借款</strong>。<strong>任何被 Compound 持有的余额，包括用户用来做抵押品的余额，同时也会产生正常的应计利息。</strong></p><p><strong>如果一个用户提供的抵押资产，除以他们信用额度所借的款项，低于抵押率，那他们的抵押资产就会（通过借款资产）被出售</strong>，出售的价格是当前市场价格减去清算折扣（liquidation discount）。这个机制会激励系统里的套利者，去快速减少借款人还不了的借款资产的短缺，从而降低协议的风险。</p>]]></content>
      
      
      <categories>
          
          <category> Compound </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识点总结 </tag>
            
            <tag> Compound </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/2022/12/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/12/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库索引，hash索引与B-树索引的适用场景，为什么用B-树索引"><a href="#数据库索引，hash索引与B-树索引的适用场景，为什么用B-树索引" class="headerlink" title="数据库索引，hash索引与B+树索引的适用场景，为什么用B+树索引"></a>数据库索引，hash索引与B+树索引的适用场景，为什么用B+树索引</h1><p>hash索引适用于等值查询，即查询条件为精确匹配的情况。相比于B+树索引，hash索引在等值查询方面更加高效，但是在范围查询和排序等操作上性能较差。</p><p>B+树索引适用于范围查询和排序等操作，相比于hash索引在这些操作上更加高效。此外，B+树索引还支持多列联合索引和覆盖索引等高级功能。</p><h1 id="主键与非主键和索引的关系"><a href="#主键与非主键和索引的关系" class="headerlink" title="主键与非主键和索引的关系"></a>主键与非主键和索引的关系</h1><p>主键是一种唯一标识表中每一行数据的列，它可以用来保证数据的唯一性和完整性。</p><p>非主键则是除主键以外的其他列，它们可以用来描述数据的其他属性和特征。</p><p>索引是一种用于加速数据查询的数据结构，它可以提高查询效率和减少查询时间，主键和非主键都可以被用作索引列。</p><h1 id="Redis为什么快（内存数据库，单线程IO多路复用）"><a href="#Redis为什么快（内存数据库，单线程IO多路复用）" class="headerlink" title="Redis为什么快（内存数据库，单线程IO多路复用）"></a>Redis为什么快（内存数据库，单线程IO多路复用）</h1><ol><li>内存存储：Redis<strong>将数据存储在内存中</strong>，而不是磁盘上，因此可以实现非常快的读写速度。</li><li>单线程模型：Redis采用单线程模型，避免了多线程之间的竞争和锁等问题，从而<strong>提高了并发性能。</strong></li><li>高效的数据结构：Redis<strong>支持多种高效的数据结构</strong>，如字符串、哈希表、列表、集合和有序集合等，可以满足不同的数据存储和查询需求。</li><li>异步IO：Redis<strong>采用异步IO模型</strong>，可以在等待IO操作的同时处理其他请求，从而提高了系统的并发性能。</li><li>持久化机制：Redis支持<strong>多种持久化机制</strong>，如RDB和AOF等，可以保证数据的可靠性和持久性。</li></ol><h1 id="MySQL的B-树"><a href="#MySQL的B-树" class="headerlink" title="MySQL的B+树"></a>MySQL的B+树</h1><p>MySQL的B+树是一种基于B+树的索引结构，用于加速数据查询和范围查询等操作。MySQL的B+树索引与一般的B+树索引相似，但是在实现上有一些特殊的优化和限制，以适应MySQL的特殊需求。</p><p>MySQL的B+树索引的特点包括：</p><ol><li>支持多列联合索引：MySQL的B+树索引支持多列联合索引，可以根据多个列的组合来进行查询和排序等操作。</li><li>支持覆盖索引：MySQL的B+树索引支持覆盖索引，可以在索引中包含所有需要查询的列，从而避免了对数据表的访问，提高了查询效率。</li><li>支持前缀索引：MySQL的B+树索引支持前缀索引，可以只对列的前缀进行索引，从而减少索引的大小和查询的时间。</li><li>支持自适应哈希索引：MySQL的B+树索引支持自适应哈希索引，可以根据数据的分布情况自动选择使用哈希索引或B+树索引，从而提高查询效率。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 区块链知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共识算法</title>
      <link href="/2022/12/18/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2022/12/18/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="PBFT的3f-1，证明为什么是2f"><a href="#PBFT的3f-1，证明为什么是2f" class="headerlink" title="PBFT的3f+1，证明为什么是2f"></a>PBFT的3f+1，证明为什么是2f</h1><p>主节点的选举和每个阶段的消息确认都需要至少f+1个节点的支持，这样总共就需要2f个节点的参与和确认</p><h1 id="HotStuff怎么满足safe-vote"><a href="#HotStuff怎么满足safe-vote" class="headerlink" title="HotStuff怎么满足safe vote"></a>HotStuff怎么满足safe vote</h1><p>HotStuff确保了只有在多数验证者的确认下，一个候选区块才能被标记为已被证明，从而达到了”safe vote”的目标。</p><h1 id="Raft的非对称分区是怎么解决的"><a href="#Raft的非对称分区是怎么解决的" class="headerlink" title="Raft的非对称分区是怎么解决的"></a>Raft的非对称分区是怎么解决的</h1><p>Leader选举：在非对称分区的情况下，<strong>如果一个节点无法与大多数节点通信，它将无法成为Leader，</strong>因为它无法获得大多数节点的投票。因此，<strong>Raft算法可以保证在非对称分区的情况下，只有大多数节点可以成为Leader</strong>，从而保证系统的一致性和可用性。</p><h1 id="对称分区的prevote是怎么做的"><a href="#对称分区的prevote是怎么做的" class="headerlink" title="对称分区的prevote是怎么做的"></a>对称分区的prevote是怎么做的</h1><p>在prevote机制中，<strong>每个节点可以先进行预投票，然后再进行正式投票</strong>。预投票的目的是<strong>为了避免出现由于网络延迟等原因导致的选举过程中的竞争情况</strong>，从而提高选举的效率和准确性。具体来说，<strong>当一个节点收到来自候选人的请求时，它会先进行prevote，向其他节点询问它们是否同意该候选人成为Leader。如果大多数节点都同意，那么该节点就会进行正式投票，将自己的票投给该候选人。</strong>通过prevote机制，可以避免出现由于网络延迟等原因导致的选举过程中的竞争情况，从而提高选举的效率和准确性。</p><h1 id="PBFT与Raft的区别（拜占庭容错与崩溃容错）"><a href="#PBFT与Raft的区别（拜占庭容错与崩溃容错）" class="headerlink" title="PBFT与Raft的区别（拜占庭容错与崩溃容错）"></a>PBFT与Raft的区别（拜占庭容错与崩溃容错）</h1><ol><li>拜占庭容错性质：<ul><li>PBFT旨在实现拜占庭容错，<strong>可以容忍拜占庭错误节点的存在</strong>。它<strong>通过投票和多个消息阶段的协商来确保一致性</strong>。</li><li>Raft是一种<strong>基于领导者（Leader）选举的共识算法</strong>，旨在<strong>解决崩溃错误节点（即停止响应）的问题</strong>，<strong>并不直接解决拜占庭错误</strong>。</li></ul></li><li>容错性能：<ul><li>PBFT需要至少2f+1个节点来容忍f个拜占庭错误节点，即<strong>节点数量至少为3f+1</strong>。它在正常情况下具有高性能，但拜占庭错误的存在会影响性能。</li><li>Raft<strong>需要大多数节点的参与（即至少半数+1）来达成共识。它对于崩溃错误具有容错性能</strong></li></ul></li><li>消息复制：<ul><li>PBFT中的消息复制需要经过多个消息阶段，节点通过互相发送消息来达成共识。</li><li>Raft中的消息复制是通过领导者发送日志条目给跟随者来实现的。一旦多数节点复制了日志，就可以达成共识</li></ul></li></ol><h1 id="PoS、PoW、Raft、Pbft等共识算法定义、区别"><a href="#PoS、PoW、Raft、Pbft等共识算法定义、区别" class="headerlink" title="PoS、PoW、Raft、Pbft等共识算法定义、区别"></a>PoS、PoW、Raft、Pbft等共识算法定义、区别</h1><ol><li>PoS：PoS是一种<strong>基于持有货币数量的共识算法</strong>，它<strong>通过随机选择持有货币的节点来验证交易和生成新的区块</strong>。持有货币数量越多的节点，获得验证和生成区块的机会就越大。相比于PoW，PoS算法更加节能和环保，但是容易出现寡头垄断的问题。</li><li>PoW：PoW是一种<strong>基于计算能力的共识算法</strong>，它<strong>通过解决数学难题来验证交易和生成新的区块</strong>。计算能力越强的节点，获得验证和生成区块的机会就越大。相比于PoS，PoW算法更加安全和去中心化，但是需要大量的计算资源和能源消耗。</li><li>Raft：Raft是一种<strong>基于领导者选举和日志复制的共识算法</strong>，它通过<strong>选举一个Leader节点来协调各个节点之间的数据同步和一致性</strong>。Raft算法相对于PBFT算法更加简单和高效，但是对于节点故障或者恶意行为的容忍度较低。</li><li>PBFT：PBFT是一种<strong>基于拜占庭将军问题的共识算法</strong>，它<strong>可以容忍一定数量的节点故障或者恶意行为</strong>，从而保证系统的一致性和可用性。PBFT算法需要进行多轮消息交互和数字签名验证，因此在性能方面相对较低，但是对于安全性和容错性要求较高的场景比较适用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 区块链知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链</title>
      <link href="/2022/12/18/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
      <url>/2022/12/18/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="智能合约中如何解决随机数的问题"><a href="#智能合约中如何解决随机数的问题" class="headerlink" title="智能合约中如何解决随机数的问题"></a>智能合约中如何解决随机数的问题</h1><p>使用区块变量，常见方法是使用<code>block.timestamp</code> 和 <code>block.difficulty</code></p><p>使用API：通过数字签名的方式来证明随机数是取自于某个随机数服务提供并且未被篡改过</p><p>Chainlink VRF：提供了一个链上去中心化的解决方案</p><h1 id="oracle预言机-oraclize-chainlink-TEE-SGX"><a href="#oracle预言机-oraclize-chainlink-TEE-SGX" class="headerlink" title="oracle预言机(oraclize,chainlink,TEE(SGX))"></a>oracle预言机(oraclize,chainlink,TEE(SGX))</h1><p>在区块链中，智能合约通常只能读取和修改区块链上的数据，而无法访问外部的数据源，Oracle预言机被引入到区块链中。Oracle预言机是一种中心化的服务，它可以从外部数据源获取数据，并将数据传递给智能合约。智能合约可以使用这些数据来执行相应的操作。</p><p>分类：</p><ol><li>中心化Oracle预言机：中心化的Oracle预言机是最简单的实现方式。它通常由一个中心化的服务提供商提供，可以从外部数据源获取数据并将数据传递给智能合约。这种实现方式具有简单、易用和高可用的特点，但也存在单点故障和安全性问题。</li><li>分布式Oracle预言机：分布式的Oracle预言机采用多个服务提供商来提供数据。它的实现方式可以基于共识算法（如PoS、PoW等），或者基于多方计算（MPC）协议。这种实现方式可以提高可靠性和安全性，但也增加了复杂度和成本。</li><li>去中心化Oracle预言机：去中心化的Oracle预言机是最安全的实现方式。它通常基于区块链技术实现，使用智能合约来管理Oracle预言机。数据由多个服务提供商提供，并经过验证后提交到智能合约中。这种实现方式具有高可靠性和高安全性的特点，但也存在复杂度高和成本高的问题。</li></ol><h1 id="event-modifier的作用和用法"><a href="#event-modifier的作用和用法" class="headerlink" title="event,modifier的作用和用法"></a>event,modifier的作用和用法</h1><p>event：</p><p>​作用：应用程序通过以太坊客户端的 RPC 接口订阅和监听这些事件，外部应用程序可以根据这些通知做出相应的响应或者记录区块链的日志，日志与合约的地址关联，并记录到区块链中</p><p>​用法：event ，emit，indexed关键字表示该参数可以在Event日志中被索引</p><p>modifier：</p><p>​作用: 将一些通用的操作提取出来，包装为函数修改器，来提高代码的复用性，改善编码效率。是函数高内聚，低耦合的延伸。</p><p>​用法：常用于在函数执行前检查某种前置条件。</p><h1 id="solidity-各大版本的新特性"><a href="#solidity-各大版本的新特性" class="headerlink" title="solidity 各大版本的新特性"></a>solidity 各大版本的新特性</h1><p>Solidity 0.7.0:</p><ul><li>支持了 try&#x2F;catch 异常处理</li><li>引入了 receive() 和 fallback() 函数，用于接收 Ether</li><li>引入了 contract 关键字，用于定义新的合约类型</li></ul><p>Solidity 0.8.0:</p><ul><li>引入了 calldata 关键字，用于指示函数参数应该在 calldata 中传递</li><li>支持了 struct 和 enum 的本地定义</li><li>支持了抽象合约（abstract contract）</li><li>函数参数可以标记为 immutable</li><li>引入了 error 关键字，用于定义错误类型</li></ul><p>Solidity 0.9.0:</p><ul><li>引入了 revert 可接受一个 string 参数</li><li>引入了内部可变映射（Internal Mutable Mapping）</li><li>引入了枚举元素间的数学操作符</li><li>引入了事件上的 gas 注释</li></ul><h1 id="形式化证明"><a href="#形式化证明" class="headerlink" title="形式化证明"></a>形式化证明</h1><p>形式化验证是指根据形式化规范评估系统正确性的过程。 简言之，形式化验证让我们可以检查系统的行为是否满足某些要求（即，系统按照我们的想法运作）</p><h1 id="contractfuzzer-模糊测试-有什么缺点"><a href="#contractfuzzer-模糊测试-有什么缺点" class="headerlink" title="contractfuzzer(模糊测试)有什么缺点"></a>contractfuzzer(模糊测试)有什么缺点</h1><ol><li>覆盖率限制：模糊测试<strong>通常只能测试少数路径，而不能测试所有路径</strong>，因此存在漏洞被忽略的可能性。这可能导致合约中潜在的漏洞未被发现，从而导致安全风险。</li><li>资源限制：使用模糊测试<strong>需要耗费大量的计算资源和时间</strong>，这可能会使得测试成本变得很高。特别是对于非常大的合约，测试过程可能需要数天或数周才能完成。</li><li>精度问题：尽管模糊测试可以检测出许多常见的漏洞类型，但它可能<strong>无法检测出复杂的漏洞</strong>。例如，对于需要多步操作的漏洞，模糊测试可能无法完全模拟所有必要的操作序列。</li><li>误报率高：模糊测试<strong>可能会产生大量误报</strong>，即将无害的代码标记为漏洞。这可能会导致开发人员在排查问题时浪费时间和精力。</li><li>无法解决语义问题：模糊测试通常只能检查合约的语法正确性，而不能检查合约的<strong>语义正确性</strong>。这意味着即使合约代码通过了模糊测试，仍然可能存在潜在的逻辑问题</li></ol><h1 id="以太坊中nonce的作用-防止重放攻击-，如何获得nonce"><a href="#以太坊中nonce的作用-防止重放攻击-，如何获得nonce" class="headerlink" title="以太坊中nonce的作用(防止重放攻击)，如何获得nonce"></a>以太坊中nonce的作用(防止重放攻击)，如何获得nonce</h1><p>nonce是一个递增的随机数，用于确保每笔交易是唯一的，并防止重放攻击。每个账户都有一个对应的nonce值，用于记录该账户已经发送了多少笔交易。当一个账户发送一笔交易时，交易的nonce值必须是该账户的当前nonce值加1，这样就确保了每笔交易的唯一性。</p><p>nonce值是公开可见的，可以通过区块浏览器等工具查询，或者web3.js、ethers.js</p><h1 id="如何调用他人的合约："><a href="#如何调用他人的合约：" class="headerlink" title="如何调用他人的合约："></a>如何调用他人的合约：</h1><p>通过接口方式调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface AnimalEat &#123;</span><br><span class="line">    function eat() external returns (string memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Animal &#123;</span><br><span class="line">    function test(address _addr) external returns (string memory) &#123;</span><br><span class="line">        AnimalEat general = AnimalEat(_addr);</span><br><span class="line">        return general.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过签名方式调用：三个call</p><h1 id="除开EVM，还知道什么虚拟机"><a href="#除开EVM，还知道什么虚拟机" class="headerlink" title="除开EVM，还知道什么虚拟机"></a>除开EVM，还知道什么虚拟机</h1><ol><li>Java虚拟机（JVM）：JVM是用于执行Java字节码的虚拟机，它是Java平台的核心组成部分之一。</li><li>NEO虚拟机（NeoVM）：NEO是一个开源的智能合约平台，它的虚拟机是NeoVM。</li><li>EOS虚拟机（EOS VM）：EOS是一个分散式应用平台，它使用的虚拟机是EOS VM。</li><li>蚂蚁区块链虚拟机（AntChain VM）微众银行虚拟机（WeBank Chain VM）百度区块链虚拟机（XuperVM）万向区块链虚拟机（WASM VM）</li></ol><p>区别：</p><ol><li>虚拟机类型：不同的区块链平台可能会使用不同类型的虚拟机，如<strong>以太坊使用基于堆栈的EVM，NEO使用基于寄存器的NeoVM等等。</strong></li><li>执行效率：不同的虚拟机在执行智能合约时，可能会有<strong>不同的效率和速度，这取决于虚拟机的设计和实现。</strong></li><li>编程语言支持：不同的虚拟机可能<strong>支持不同的编程语言和智能合约开发框架</strong>，例如以太坊支持Solidity、Vyper和Serpent等语言，NEO支持C#和Python等语言。</li><li>安全性和可靠性：虚拟机在执行智能合约时需要确保安全和可靠，不同的虚拟机可能会<strong>采用不同的安全机制和代码审核策略</strong>，以确保智能合约的正确性和安全性。</li><li><strong>社区支持和生态系统</strong>：不同的虚拟机可能有不同的社区支持和生态系统，这对于开发者和用户来说都非常重要，因为这意味着有更多的工具、文档和资源可供使用。</li></ol><h1 id="Merkle树，MPT树如何构建，有何区别-这个经常问"><a href="#Merkle树，MPT树如何构建，有何区别-这个经常问" class="headerlink" title="Merkle树，MPT树如何构建，有何区别(这个经常问)"></a>Merkle树，MPT树如何构建，有何区别(这个经常问)</h1><p>Merkle树和MPT（Merkle Patricia Trie）树都是一种<strong>哈希树数据结构</strong>，通常<strong>用于验证数据的完整性和构建区块链系统中的状态树</strong></p><p>构建方式：</p><ul><li><p>Merkle树：Merkle树由叶子节点和父节点组成，叶子节点是数据块的哈希值，父节点是其两个子节点的哈希值的哈希值。构建Merkle树时，需要将所有数据块的哈希值按顺序排列成叶子节点，并对相邻的叶子节点进行哈希运算，得到它们的父节点。重复这个过程，直到得到根节点，也就是整棵树的哈希值。</p></li><li><p>MPT树：健值对</p><ul><li>扩展节点（Extension Node）：只能有一个子节点。</li><li>分支节点（Branch Node）：可以有多个节点。</li><li>叶子节点（Leaf Node）：没有子节点。</li><li>空节点：空字符串。</li></ul><p> <img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/img/image-20230412220424100.png" alt="image-20230412220424100"></p></li></ul><p>区别：</p><ul><li>数据存储方式不同：<strong>Merkle树是一种二叉树，每个叶节点存储的是数据的哈希值</strong>，而非数据本身。MPT树是一种多叉树，每个节点存储的是<strong>键值对</strong>（Key-Value Pair），其中Key是数据的哈希值，而Value是数据本身。</li><li>数据更新方式不同：Merkle树是一种静态结构，一旦树构建完成，就<strong>不能再添加或修改数据</strong>。如果需要添加或修改数据，就需要重新构建整棵树。MPT树是一种动态结构，<strong>可以动态地添加、修改、删除数据</strong>。</li><li>查询方式不同：Merkle树<strong>只能支持对整个数据块的完整性进行验证</strong>，而不能支持对单个数据的验证和查询。MPT树可以<strong>支持对单个数据的验证和查询</strong>，因为每个节点存储的是Key-Value Pair，可以通过Key快速查找对应的Value。</li></ul><h1 id="以太坊是如何从POW转向POS的-Casper协议"><a href="#以太坊是如何从POW转向POS的-Casper协议" class="headerlink" title="以太坊是如何从POW转向POS的(Casper协议)"></a>以太坊是如何从POW转向POS的(Casper协议)</h1><ol><li>引入Casper：Casper是一种基于权益证明的共识机制，节点被分为两种角色：<strong>验证节点和提案节点。</strong>验证节点验证区块和交易的有效性，并根据其权益大小来选择提案节点。提案节点负责创建新的区块并提交到链上。</li><li>引入Beacon Chain：Beacon Chain是以太坊2.0版本的核心部分，是一个新的区块链，用于管理以太坊2.0中的验证器。验证器是指参与权益证明共识机制的节点，他们会投入自己的以太坊代币（ETH）来获得权益，然后运行验证器软件，对交易进行验证，并参与新块的生成。这两个区块链之间<strong>通过分片技术进行交互</strong>，共同组成了以太坊2.0的整体系统。</li><li>以太坊2.0上线：在经过长时间的开发和测试后，以太坊2.0于2020年12月1日正式上线。</li></ol><h1 id="以太坊使用的密码学，对两者进行介绍"><a href="#以太坊使用的密码学，对两者进行介绍" class="headerlink" title="以太坊使用的密码学，对两者进行介绍"></a>以太坊使用的密码学，对两者进行介绍</h1><p>哈希函数Keccak-256：计算数据的摘要，以确保数据的完整性和一致性</p><p>椭圆曲线加密算法 ECDSA：生成公钥和私钥对，并使用这些密钥对来加密和签名交易数据</p><h1 id="区块链怎么开启新的Epoch"><a href="#区块链怎么开启新的Epoch" class="headerlink" title="区块链怎么开启新的Epoch"></a>区块链怎么开启新的Epoch</h1><p>区块链中的<strong>Epoch是一个时间段，在该时间段内区块链网络采用相同的规则来验证和处理交易</strong>。每个Epoch的长度和开始时间都可以由区块链协议的设计者来定义。一些区块链协议（如Ethereum）使用<strong>基于区块高度的Epoch，而其他协议则使用基于时间的Epoch</strong>。</p><p>要开启一个新的Epoch，需要满足以下条件：</p><ol><li>规定Epoch长度：首先，设计者需要规定一个新的Epoch的长度，这通常是一定的时间段（例如1个月），也可能是特定的区块高度。</li><li>配置新的规则：设计者需要在新的Epoch开始之前确定新的规则，并将这些规则编码到区块链协议中。</li><li>更新协议版本：如果新的Epoch需要更新协议版本，则需要将新版本的协议发布到网络中。在新的Epoch开始之前，节点需要升级到新版本的协议，以确保能够正确地验证和处理交易。</li><li>触发新的Epoch：当达到新的Epoch的开始时间或区块高度时，节点将开始采用新的规则。新的Epoch的开始可能需要一些时间，以便所有节点都可以升级到新的协议版本并开始使用新的规则。</li></ol><p>需要注意的是，开启新的Epoch需要区块链网络中的大多数节点都同意并接受新的规则。因此，设计者需要考虑到网络中各种参与者的需求和利益，以确保新的规则得到广泛的接受和采用。</p><h1 id="每次fork-block的时候具体算法是什么"><a href="#每次fork-block的时候具体算法是什么" class="headerlink" title="每次fork block的时候具体算法是什么"></a>每次fork block的时候具体算法是什么</h1><ol><li>选择分支点：确定要创建新分支的区块链上的分支点。这个分支点通常是一个已经存在的区块，它将成为新分支的起点。</li><li>创建新分支：创建一个新的区块链分支，该分支从分支点开始并包含一组新的交易和一个新的区块。</li><li>确定新分支的长度：为了确定哪个分支是主链，需要确定每个分支的长度。这通常是通过比较每个分支的工作量来完成的。</li><li>解决分支冲突：如果多个节点都创建了一个新的分支，则需要解决分支冲突。这通常是通过选择具有最长长度的分支来解决的。</li><li>更新状态：一旦确定了主链，所有节点都将更新他们的状态，以反映新的交易和新的区块链状态。</li></ol><h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><p>是<strong>存储在区块链上的程序</strong>，它是位于以太坊区块链上一个特定地址的一系列代码（函数）和数据（状态）。 它们<strong>通常用于自动执行协议</strong>，以便所有参与者都可以立即确定结果，而<strong>无需任何中间人参与</strong>，也不会浪费时间。 它们还可以自动完成工作流程，在满足条件时触发下一个操作。</p><h1 id="区块链有哪些应用？"><a href="#区块链有哪些应用？" class="headerlink" title="区块链有哪些应用？"></a>区块链有哪些应用？</h1><ol><li>去中心化：区块链是一种去中心化的技术，没有中央机构或单一实体来管理它。相反，它<strong>由网络中的所有节点共同维护和管理</strong>。</li><li>不可篡改：区块链的数据是以区块的形式记录在链中，并且每个区块都包含前一个区块的哈希值。</li><li>透明性：区块链是公开透明的，任何人都可以查看和验证交易记录。使得区块链非常适合需要公共透明度的领域，如金融和政府监（投票选举）</li><li>安全性：由于区块链采用了加密技术来保护数据的完整性和安全性，因此它被认为是非常安全的技术。这使得区块链非常适合处理敏感数据和交易。</li><li>智能合约：区块链技术还支持智能合约，这是一种自动执行的合约，其中条件和规则被编码到合约中。这使得合约的执行非常透明和可靠，因为它们完全基于代码和算法来执行。</li></ol><p>DeFi，去中心化金融，利用区块链智能合约在链上完成资产兑换、借贷、杠杆、期货等交易。</p><p>数字艺术品&#x2F;NFT：唯一性、稀缺性、可交易性，通过 NFT 可使从产生到交易都可追溯，版权的保护变得更加方便。</p><p>数字存证&#x2F;防伪:数字身份认证确保身份信息的安全和隐私保护,技术可以被用于保护数字版权，以确保知识产权的安全和可追溯性</p><p>游戏:游戏数据不可篡改、玩家数据保护、虚拟物品拥有权等等的新型游戏方式</p><h1 id="以太坊中有哪些树（交易树、收据树、状态树）"><a href="#以太坊中有哪些树（交易树、收据树、状态树）" class="headerlink" title="以太坊中有哪些树（交易树、收据树、状态树）"></a>以太坊中有哪些树（交易树、收据树、状态树）</h1><ol><li>状态树（State Tree）：以太坊中的状态树是一个Merkle树，用于存储整个以太坊网络中所有账户的状态信息，包括余额、智能合约代码、合约存储器中的数据等。</li><li>交易树（Transaction Tree）：交易树是一个Merkle树，用于存储所有交易信息。每个区块中的交易都被添加到这个树中，并用于验证和确定区块的有效性。</li><li>日志树（Receipt Tree）：日志树是一个Merkle树，用于存储交易执行后的日志信息。它包含了交易执行的结果、事件触发信息等。</li></ol><h1 id="为什么需要收据树"><a href="#为什么需要收据树" class="headerlink" title="为什么需要收据树"></a>为什么需要收据树</h1><ul><li>向轻节点提供Merkle Proof</li><li>更加复杂的查找查询，比如查询过去⼗天与某⼀智能合约有关的交易、过去⼗天的众筹事件等</li></ul><h1 id="以太坊里的状态是什么，状态树怎么存的状态"><a href="#以太坊里的状态是什么，状态树怎么存的状态" class="headerlink" title="以太坊里的状态是什么，状态树怎么存的状态"></a>以太坊里的状态是什么，状态树怎么存的状态</h1><p>状态是指所有账户的集合状态，包括它们的余额、合约代码和存储在合约中的数据</p><p>每个账户都有一个唯一的地址（20个字节），它被用作状态树中叶子节点的键。</p><h1 id="以太坊的合约数据的储存形式"><a href="#以太坊的合约数据的储存形式" class="headerlink" title="以太坊的合约数据的储存形式"></a>以太坊的合约数据的储存形式</h1><p>(还是MPT。合约账户中的storage root，对应账户的storage trie)</p><h1 id="比特币里的交易是怎么存的"><a href="#比特币里的交易是怎么存的" class="headerlink" title="比特币里的交易是怎么存的"></a>比特币里的交易是怎么存的</h1><p>（Merkle Tree，MT）</p><h1 id="介绍Merkle-Tree的性质、优点，为什么用Merkle-Tree存"><a href="#介绍Merkle-Tree的性质、优点，为什么用Merkle-Tree存" class="headerlink" title="介绍Merkle Tree的性质、优点，为什么用Merkle Tree存"></a>介绍Merkle Tree的性质、优点，为什么用Merkle Tree存</h1><p>实现SPV、Merkle Proof</p><p>SPV是一种轻量级的验证方式，允许用户验证自己的交易和区块链数据，而无需下载和存储整个区块链的全部数据。相比于完整节点（Full Node），SPV节点只需保存区块头（block header）和一部分交易信息，可以通过少量的数据获取和验证自己的交易。</p><h1 id="为什么以太坊要将MT改成MPT"><a href="#为什么以太坊要将MT改成MPT" class="headerlink" title="为什么以太坊要将MT改成MPT"></a>为什么以太坊要将MT改成MPT</h1><ul><li>数据存储方式不同：<strong>Merkle树是一种二叉树，每个叶节点存储的是数据的哈希值</strong>，而非数据本身。MPT树是一种多叉树，每个节点存储的是<strong>键值对</strong>（Key-Value Pair），其中Key是数据的哈希值，而Value是数据本身。</li><li>数据更新方式不同：Merkle树是一种静态结构，一旦树构建完成，就<strong>不能再添加或修改数据</strong>。如果需要添加或修改数据，就需要重新构建整棵树。MPT树是一种动态结构，<strong>可以动态地添加、修改、删除数据</strong>。</li><li>查询方式不同：Merkle树<strong>只能支持对整个数据块的完整性进行验证</strong>，而不能支持对单个数据的验证和查询。MPT树可以<strong>支持对单个数据的验证和查询</strong>，因为每个节点存储的是Key-Value Pair，可以通过Key快速查找对应的Value。</li></ul><h1 id="介绍比特币的UTXO"><a href="#介绍比特币的UTXO" class="headerlink" title="介绍比特币的UTXO"></a>介绍比特币的UTXO</h1><p>UTXO代表”Unspent Transaction Output”，即未花费的交易输出。UTXO模型是比特币使用的一种账户模型，与传统的账户余额模型不同。</p><p>每当一个比特币交易发生时，输入和输出被创建。交易的输入引用之前交易的输出，而交易的输出定义了新的UTXO。</p><h1 id="比特币查询余额只能从头开始遍历整条链吗，有没有高效方法"><a href="#比特币查询余额只能从头开始遍历整条链吗，有没有高效方法" class="headerlink" title="比特币查询余额只能从头开始遍历整条链吗，有没有高效方法"></a>比特币查询余额只能从头开始遍历整条链吗，有没有高效方法</h1><ol><li>索引和数据库优化：区块链浏览器和钱包服务可以使用索引和数据库优化技术来加快查询速度。通过构建针对地址和UTXO的索引，可以快速定位相关的交易和UTXO，而不需要遍历整个区块链。</li><li>UTXO集合缓存：一些服务会在内存中维护一个UTXO集合的缓存，以提供快速的查询响应。这些缓存通常存储最近使用频繁的UTXO，使得查询余额时无需每次都遍历整个区块链。</li></ol><h1 id="比特币地址是怎么生成的"><a href="#比特币地址是怎么生成的" class="headerlink" title="比特币地址是怎么生成的"></a>比特币地址是怎么生成的</h1><p>（助记词 &lt;-&gt; seed -&gt; 私钥 -&gt; 公钥 -&gt; PubKeyHash &lt;-&gt; address, 其中&lt;-&gt;表可双向转换，-&gt;表单向转换，最后的PubKeyHash转换为address的时候用的是base58编码，base58编码的原理即辗转相除法）</p><h1 id="介绍Bloom-filter特点"><a href="#介绍Bloom-filter特点" class="headerlink" title="介绍Bloom filter特点"></a>介绍Bloom filter特点</h1><p>常数时间内判断一个元素是否可能属于一个集合、位数组相对于存储实际元素的集合所需的内存要小得多有一定的错误率、插入元素只需要对位数组进行哈希操作并设置相应的位删除操作在传统的Bloom filter中是不支持的、可调的错误率错误率取决于位数组的大小和哈希函数的个数</p><h1 id="以太坊智能合约如何执行，介绍EVM底层"><a href="#以太坊智能合约如何执行，介绍EVM底层" class="headerlink" title="以太坊智能合约如何执行，介绍EVM底层"></a>以太坊智能合约如何执行，介绍EVM底层</h1><p>编译为字节码文件 –&gt; 支付gas部署合约 –&gt; 发起交易与合约交互 –&gt; 交易上链后EVM执行合约字节码 –&gt; 合约状态更新 –&gt; 结果返回</p><h1 id="以太坊相比于比特币的创新点"><a href="#以太坊相比于比特币的创新点" class="headerlink" title="以太坊相比于比特币的创新点"></a>以太坊相比于比特币的创新点</h1><ol><li>智能合约：以太坊引入了智能合约的概念，使得开发者可以在区块链上编写和执行具有逻辑和功能的可编程合约。智能合约允许在区块链上进行复杂的业务逻辑，从简单的转账到复杂的去中心化应用（DApp）。</li><li>图灵完备性：与比特币的脚本语言相比，以太坊的智能合约语言Solidity是图灵完备的，这意味着它可以进行更复杂的计算和逻辑运算。这为开发者提供了更大的灵活性和创新空间。</li><li>共识算法：pos节省能源</li></ol><h1 id="geth中的block、transction、log、receipt数据结构"><a href="#geth中的block、transction、log、receipt数据结构" class="headerlink" title="geth中的block、transction、log、receipt数据结构"></a>geth中的block、transction、log、receipt数据结构</h1><h1 id="HP编码、RLP编码"><a href="#HP编码、RLP编码" class="headerlink" title="HP编码、RLP编码"></a>HP编码、RLP编码</h1><p>HP编码主要用于数据压缩和编码方面，通过减少编码长度来节省存储空间和传输带宽。</p><p>RLP编码则更适用于序列化和反序列化数据，特别是在以太坊中作为一种通用的数据编码方式，用于存储和传输合约数据、交易数据等。</p><h1 id="最长链原则"><a href="#最长链原则" class="headerlink" title="最长链原则"></a>最长链原则</h1><p>最长链定义：最长链是指具有最多区块的链，其中每个区块都是经过验证且有效的。</p><h1 id="从架构设计层面说一下以太坊的各个层的作用"><a href="#从架构设计层面说一下以太坊的各个层的作用" class="headerlink" title="从架构设计层面说一下以太坊的各个层的作用"></a>从架构设计层面说一下以太坊的各个层的作用</h1><ol><li>基础设施层（Infrastructure Layer）： 基础设施层是以太坊的底层基础设施，包括<strong>网络协议、点对点通信、数据同步和共识算法</strong>等。这一层负责提供以太坊网络的运行环境和支持，确保节点之间的连接和通信，以及确保区块链的一致性和安全性。</li><li>合约层（Contract Layer）： 合约层是以太坊的智能合约执行层，它<strong>负责处理智能合约的执行和交互</strong>。合约层包括以太坊虚拟机（EVM）和智能合约的执行环境。EVM 是一个隔离且安全的虚拟机环境，负责解释和执行智能合约的字节码。它提供了一组指令集和状态操作，使得智能合约可以在安全的环境中执行。</li><li>表现层（Presentation Layer）： 表现层是以太坊的用户界面层，它提供了用户与以太坊网络进行交互的界面。这包括<strong>钱包应用、区块浏览器、交易界面</strong>等。表现层为用户提供了友好的界面和功能，使他们能够方便地管理钱包、查看交易和与智能合约进行交互。</li><li>应用层（Application Layer）： 应用层是以太坊的最上层，包括去中心化应用（DApp）和智能合约的具体应用场景。在这一层，开发者可以基于智能合约构建各种应用，如<strong>去中心化金融（DeFi）、数字身份、供应链管理</strong>等。应用层利用以太坊提供的智能合约和区块链功能来实现特定的业务逻辑和功能，为用户提供创新和去中心化的应用体验。</li></ol><h1 id="如何理解Ai与web3之间的关系"><a href="#如何理解Ai与web3之间的关系" class="headerlink" title="如何理解Ai与web3之间的关系"></a>如何理解Ai与web3之间的关系</h1><p><strong>AI更多是生产力的发展，Web3则是生产关系的重新定义</strong> </p><p><strong>AI作为一种技术工具，可以在许多领域提高生产效率和效益。通过机器学习和深度学习等技术，AI能够处理大量的数据、自动化任务和决策过程</strong>，从而减少人力资源的需求，提高工作效率。例如，在制造业中，AI可以用于优化生产流程、预测设备故障、提高产品质量等方面，从而提高整体生产力。</p><p>另一方面，<strong>Web3代表了一种新的互联网模式，强调去中心化、自治和用户主权</strong>。它基于区块链和智能合约等技术，重新定义了生产关系和价值交换方式。在传统的Web2模式中，平台拥有者掌握着用户数据和利益分配的权力，<strong>而Web3则通过去中心化的方式，使用户能够更直接地参与到价值创造和分享中。这种重新定义的生产关系可以促进更公平、透明和可持续的经济模式。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 区块链知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solidity</title>
      <link href="/2022/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/Solidity/"/>
      <url>/2022/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/Solidity/</url>
      
        <content type="html"><![CDATA[<h1 id="solidity上如何在数组删除一个数"><a href="#solidity上如何在数组删除一个数" class="headerlink" title="solidity上如何在数组删除一个数"></a>solidity上如何在数组删除一个数</h1><p>根据下标用delete使其变为默认值，如果是动态数组可以通过pop方法移除该数组不过需要与最后一个位置的元素交换</p><h1 id="你是如何用以太坊实现资金托管的"><a href="#你是如何用以太坊实现资金托管的" class="headerlink" title="你是如何用以太坊实现资金托管的"></a>你是如何用以太坊实现资金托管的</h1><p>function用payable修饰，然后可以对合约账户balance</p><p>低级CALL调用<strong>不需要<code>payable address</code></strong>,transfer 和 send <strong>只能是 <code>payable address</code></strong></p><p>transfer()错误会回滚，send会返回一个bool，call也是返回bool和返回数据bytes memory</p><p>call的 gas 可以动态调整,transfer 和 send 只能是固定制 <code>2300</code></p><h1 id="如何对一个数组去重"><a href="#如何对一个数组去重" class="headerlink" title="如何对一个数组去重"></a>如何对一个数组去重</h1><p>用一个map检查数组元素有无出现，无出现就装进res</p><p>双重循环</p><p>还有其他实现吗(使用 Solidity 的 Set 数据结构进行去重，一个库）</p><p>跟最后一个元素互换然后pop &#x2F; 直接delete</p><h1 id="solidity的function的可见性"><a href="#solidity的function的可见性" class="headerlink" title="solidity的function的可见性"></a>solidity的function的可见性</h1><ul><li>函数有四可见型，分别是 <code>private</code> &#x2F; <code>external</code> &#x2F; <code>internal</code> &#x2F; <code>public</code></li><li>状态变量可以有三种可见型，分别是 <code>private</code> &#x2F; <code>internal</code> &#x2F; <code>public</code></li></ul><ol><li><p><strong>private</strong>: 私有，仅在当前合约中可以访问，在继承的合约内不可访问</p></li><li><p><strong>internal(默认)</strong>: 能在它们所定义的合约和派生合同中访问,它们不能被外部访问</p><blockquote><p>需要注意的是不能加前缀 this，前缀 this 是表示通过外部方式访问</p></blockquote></li><li><p><strong>external:</strong> 只能从智能合约外部调用。 如果要从智能合约中调用它，则必须使用this</p></li><li><p><strong>public</strong>: 公开可视(合约内部，被继承的，外部都可以调用)</p></li></ol><h1 id="合约发布的数据结构"><a href="#合约发布的数据结构" class="headerlink" title="合约发布的数据结构"></a>合约发布的数据结构</h1><p>合约发布的数据结构主要包括状态变量和函数：</p><p>状态变量（State Variables）：状态变量是在合约中声明的变量，存储在区块链上。</p><p>函数（Functions）：合约中的函数定义了合约的行为和操作。函数可以接受参数、返回值，并且可以修改合约的状态（通过修改状态变量）。</p><h1 id="solidity函数修饰器"><a href="#solidity函数修饰器" class="headerlink" title="solidity函数修饰器"></a>solidity函数修饰器</h1><p>可以将一些通用的操作提取出来，包装为函数修改器，来提高代码的复用性，改善编码效率。是函数高内聚，低耦合的延伸。</p><p>作用: 常用于在函数执行前检查某种前置条件。</p><ul><li>比如地址对不对，余额是否充足，参数值是否允许等</li><li>修改器内可以写逻辑</li></ul><p>如果同一个函数有多个修改器 modifier，它们之间以空格隔开，修改器 modifier 会依次检查执行。</p><p><strong>修改器不能隐式地访问或改变它们所修饰的函数的参数和返回值。</strong> 这些值只能在调用时明确地以参数传递。</p><p><code>_</code> 符号可以在修改器中出现多次，每处都会替换为函数体。</p><h1 id="Solc编译器的原理、汇编过程"><a href="#Solc编译器的原理、汇编过程" class="headerlink" title="Solc编译器的原理、汇编过程"></a>Solc编译器的原理、汇编过程</h1><p>Solc是Solidity编译器，它的主要功能是将Solidity源代码编译成EVM字节码</p><ol><li><p>原理：<strong>Solc编译器会先对Solidity源代码进行词法分析和语法分析，生成抽象语法树（AST）。然后，Solc编译器会将AST转换为中间语言（IR），并进行优化和分析。最后，Solc编译器会将IR转换为EVM字节码，并输出编译结果。</strong></p></li><li><p>汇编过程</p><p>（1）将Solidity源代码转换为中间语言（IR）。</p><p>（2）对IR进行优化和分析，包括常量折叠、死代码删除、控制流图重构等操作。</p><p>（3）将IR转换为EVM汇编代码，包括指令选择、寄存器分配、代码生成等操作。</p><p>（4）将EVM汇编代码转换为二进制字节码。</p><p>在上述过程中，Solc编译器使用了多种技术和算法，包括词法分析、语法分析、AST转换、中间代码优化、寄存器分配、指令选择等。这些技术和算法的目的是提高编译器的性能和生成的字节码的质量，从而使Solidity合约在EVM上的执行更加高效和安全。</p></li></ol><h1 id="说一下合约的安全分析方法、原理"><a href="#说一下合约的安全分析方法、原理" class="headerlink" title="说一下合约的安全分析方法、原理"></a>说一下合约的安全分析方法、原理</h1><ol><li><strong>静态分析：</strong>静态分析是通过<strong>检查源代码或字节码</strong>来识别潜在的安全问题。它可以帮助<strong>发现潜在的漏洞、错误和安全隐患</strong>。静态分析工具<strong>会检查代码中的常见安全问题，例如整数溢出、未经授权的访问、重入漏洞等，并给出相应的警告或错误信息。</strong></li><li><strong>污点分析：</strong>污点分析是一种静态或动态分析技术，用于<strong>追踪数据流中的敏感信息（称为污点）并检测潜在的漏洞</strong>。在合约中，污点分析可用于<strong>追踪用户输入数据（如交易输入、合约参数等）如何在代码中传播，并检测是否存在未经适当处理的污点数据访问或潜在的漏洞。</strong></li><li><strong>符号执行：</strong>符号执行是一种静态分析技术，它通过<strong>符号变量替代具体输入值</strong>，以<strong>遍历可能的执行路径并生成约束条件</strong>。通过符号执行，可以<strong>检测合约中的潜在漏洞，如条件分支错误、溢出漏洞等</strong>。然而，由于符号执行的复杂性，它在实际中的应用受到一些限制。</li><li><strong>模糊测试：</strong>模糊测试是一种动态测试技术，<strong>通过生成大量的随机或半随机输入来评估系统的安全性</strong>。在合约中，模糊测试可以<strong>通过生成随机交易和参数等输入来模拟潜在的攻击情景，以便发现合约中的漏洞和异常行为。</strong></li><li><strong>形式验证：</strong>形式验证是一种基于数学和逻辑推理的方法，用于<strong>验证合约是否满足特定的安全属性或规范</strong>。通过形式验证，可以<strong>对合约的正确性进行严格的数学证明</strong>，从而<strong>排除特定类型的漏洞</strong>。然而，<strong>形式验证通常需要高度专业的知识和复杂的建模过程，因此在实践中的应用相对较少。</strong></li><li><strong>动态分析：</strong>动态分析是<strong>在实际运行合约时监测和分析其行为</strong>。通过<strong>模拟不同的输入和交互场景</strong>，可以发现潜在的漏洞和异常情况。动态分析可以<strong>帮助检测运行时的安全问题，例如重入攻击、溢出等</strong>。</li></ol><h1 id="合约内部调用和外部调用"><a href="#合约内部调用和外部调用" class="headerlink" title="合约内部调用和外部调用"></a>合约内部调用和外部调用</h1><p>内部：合约内部调用是指<strong>在同一个合约内部调用另一个函数</strong>，可以直接使用函数名进行调用，无需指定地址，<strong>可以访问所有的状态变量和函数。</strong></p><p>外部：合约外部调用是指<strong>在一个合约中调用另一个合约的函数</strong>。在合约外部调用时，<strong>需要指定被调用合约的地址，并使用<code>call</code>、<code>delegatecall</code>或<code>staticcall</code>等函数进行调用</strong>。在合约外部调用时，<strong>只能访问公共状态变量和函数。</strong></p><h1 id="内部函数和外部函数区别"><a href="#内部函数和外部函数区别" class="headerlink" title="内部函数和外部函数区别"></a>内部函数和外部函数区别</h1><ol><li>访问权限：<strong>内部函数可以被当前合约以及继承自当前合约的合约访问</strong>，包括私有（private）和内部（internal）函数。而<strong>外部函数只能被其他合约或外部账户通过消息调用的方式访问，通过合约地址和函数签名来执行外部调用。</strong></li><li>调用开销：<strong>内部函数的调用不涉及 EVM 的上下文切换和消息传递</strong>，因为调用发生在同一个合约内部，没有跨合约的开销。而<strong>外部函数的调用涉及 EVM 的上下文切换和消息传递，需要通过消息调用（message call）机制执行，因此具有更高的调用开销。</strong></li><li>函数可见性修饰符：为了明确指定函数的可见性，<strong>内部函数使用 <code>internal</code> 修饰符进行声明，而外部函数使用 <code>external</code> 修饰符进行声明。</strong></li></ol><h1 id="Solidity引用类型storage、memory、calldata"><a href="#Solidity引用类型storage、memory、calldata" class="headerlink" title="Solidity引用类型storage、memory、calldata"></a>Solidity引用类型storage、memory、calldata</h1><p><code>storage</code>是指<strong>永久存储在区块链上的数据位置</strong>，用于<strong>存储合约状态变量</strong>和映射类型的值。</p><p><code>memory</code>是指<strong>临时存储在计算机内存中的数据位置</strong>，用于<strong>存储函数局部变量和函数参数</strong>。在函数内部声明的变量默认情况下会使用<code>memory</code>数据位置，<code>memory</code> 中的数据只在函数执行期间存在，并在函数执行结束后被清除。<strong>引用类型局部变量，要显式指定数据位置</strong>。</p><p><code>calldata</code>是指<strong>用于保存函数参数和外部函数调用数据的特殊区域</strong>，<strong>包括函数参数和函数签名等信息</strong>。在函数调用时，函数参数会被复制到<code>calldata</code>中，并传递给被调用函数。在函数内部访问函数参数时，默认情况下会使用<code>calldata</code>数据位置。<code>calldata</code> 是只读的。</p><p>按照函数参数:</p><ul><li>内部函数参数: (包括返回参数)都存储在<strong>memory（内存）</strong>中。</li><li>外部函数参数: (不包括返回参数)存储在 <code>calldata</code> 中。</li></ul><h1 id="数据赋值时何时进行值传递、何时进行引用传递"><a href="#数据赋值时何时进行值传递、何时进行引用传递" class="headerlink" title="数据赋值时何时进行值传递、何时进行引用传递"></a>数据赋值时何时进行值传递、何时进行引用传递</h1><ol><li><strong>在 storage 和 memory 之间两两赋值（或者从 calldata 赋值 ），值传递</strong>。</li><li>从 memory 到 memory 的两个引用赋值，引用传递。</li></ol><h1 id="说一下ERC20、ERC721的函数和作用、以及对应的缺点和改进的方案"><a href="#说一下ERC20、ERC721的函数和作用、以及对应的缺点和改进的方案" class="headerlink" title="说一下ERC20、ERC721的函数和作用、以及对应的缺点和改进的方案"></a>说一下ERC20、ERC721的函数和作用、以及对应的缺点和改进的方案</h1><p> <strong>标准 ERC20 接口</strong></p><p>3 个查询：</p><ul><li><code>balanceOf</code>: 查询指定地址的 Token 数量</li><li><code>totalSupply</code>: 查询当前合约的 Token 总量</li><li><code>allowance</code>: 查询指定地址对另外一个地址的剩余授权额度</li></ul><p>2 个交易：</p><ul><li><code>transfer</code>: 从当前调用者地址发送指定数量的 Token 到指定地址,这是一个写入方法，所以还会抛出一个 <code>Transfer</code> 事件。</li><li><code>transferFrom</code>: 当向另外一个合约地址存款时，对方合约必须调用 transferFrom 才可以把 Token 拿到它自己的合约中。</li></ul><p>1 个授权：<code>approve</code>: 授权指定地址可以操作调用者的最大 Token 数量。</p><p>缺点：ERC20标准<strong>没有考虑到代币的独特性，所有代币都是同质化的，无法区分不同的代币。</strong></p><p>改进方案：<strong>ERC1155标准是一种新的代币标准，它支持多种类型的代币，并且可以在一个合约中管理多种代币。</strong></p><p><strong>标准 ERC721 接口</strong></p><p>4 个查询：</p><ul><li><code>balanceOf</code>: 查询指定地址的 NFT数量</li><li><code>ownerOf</code>: 查询当前NFT 的所属地址</li><li><code>isApprovedForAll</code>: 查询一个地址是否是另一个地址的授权操作员</li><li><code>getApproved</code>:获取单个 NFT 的授权地址</li></ul><p>2 个交易：</p><ul><li><code>safeTransferFrom</code>: 从 <code>_from</code> 地址转移到 <code>_to</code> 地址。与 <code>transferFrom</code> 不同，<code>safeTransferFrom</code> 函数在转移代币时会进行安全性检查。它会检查接收方合约是否实现了 ERC721Receiver 接口，并调用接收方合约中的 <code>onERC721Received</code> 方法，旨在确保代币转移的目的地是一个合适的接收方，并且能够正确处理接收的代币。</li><li><code>transferFrom</code>:从 <code>_from</code> 地址转移到 <code>_to</code> 地址，但它并没有提供任何安全性检查机制。</li></ul><p>2个授权：</p><ul><li><code>approve</code>: 授权指定地址可以操作某个NFT</li><li><code>setApprovalForAll</code>：授权指定地址可以操作msg.sender地址下的所有NFT</li></ul><p>缺点：ERC721标准的转账操作比较复杂，需要调用多个函数才能完成，而且转账过程中可能会出现错误，导致代币丢失。</p><p>改进方案：ERC998标准是一种新的代币标准，它支持代币的组合和嵌套，可以将多个代币组合成一个更复杂的代币，并且可以在一个合约中管理多种代币。这样可以简化转账操作，减少出错的可能性。</p><h1 id="事件中加indexed属性的作用"><a href="#事件中加indexed属性的作用" class="headerlink" title="事件中加indexed属性的作用"></a>事件中加indexed属性的作用</h1><p>indexed 数据会被记录到 <code>topics</code> 中，可以用于检索，主题（topic）让我们可以可以搜索事件，比如在为某些事件过滤一些区块，还可以按发起事件的合同地址来过滤事件。</p><h1 id="映射能否被声明为memory类型、映射中的key能否为复杂类型、映射的key是keccak256哈希还是真实的值、映射能否作为返回值、映射能否嵌套"><a href="#映射能否被声明为memory类型、映射中的key能否为复杂类型、映射的key是keccak256哈希还是真实的值、映射能否作为返回值、映射能否嵌套" class="headerlink" title="映射能否被声明为memory类型、映射中的key能否为复杂类型、映射的key是keccak256哈希还是真实的值、映射能否作为返回值、映射能否嵌套"></a>映射能否被声明为memory类型、映射中的key能否为复杂类型、映射的key是keccak256哈希还是真实的值、映射能否作为返回值、映射能否嵌套</h1><ol><li><strong>映射不能被声明为 <code>memory</code> 类型</strong>。<code>memory</code> 类型用于临时存储和操作函数内的数据，而映射（<code>mapping</code>）是一种存储在存储器（<code>storage</code>）中的数据结构，无法在 <code>memory</code> 中声明。</li><li><strong>映射的键（<code>key</code>）可以是复杂类型，包括结构体、枚举和数组等。</strong>映射的键类型不仅限于基本数据类型，你可以使用复杂类型作为映射的键。</li><li><strong>映射的键存储它的 <code>keccak256</code> 哈希值</strong>，从而便于查询实际的值。正因为如此，映射是没有长度的，也没有 <code>key 的集合</code>或 <code>value 的集合</code>的概念</li><li><strong>映射不能用于合约公有函数的参数或返回值，只允许作为状态变量或作为函数内的存储引用或作为库函数的参数。</strong></li><li><strong>映射可以进行嵌套</strong></li></ol><h1 id="Solidity中receive函数、fallback函数"><a href="#Solidity中receive函数、fallback函数" class="headerlink" title="Solidity中receive函数、fallback函数"></a>Solidity中receive函数、fallback函数</h1><p>fallback 函数是调用合约没有的方法时候执行，同时也可以设置为允许接收网络主币。</p><p>receive 只负责接收主币,一个合约最多有一个 <code>receive</code> 函数，receive 函数类型必须是 <code>payable</code> 的，声明为 payable 之后，其所消耗的 gas 最大量就会被限定在 2300。</p><h1 id="Solidity中view函数、pure函数的作用和区别"><a href="#Solidity中view函数、pure函数的作用和区别" class="headerlink" title="Solidity中view函数、pure函数的作用和区别"></a>Solidity中view函数、pure函数的作用和区别</h1><p>pure: 既<strong>不读取也不修改状态变量</strong>，这种函数被称为<strong>纯函数</strong></p><p>view: 读取状态变量，但是不修改状态变量，这种函数被称为<strong>视图函数</strong>，状态变量的 Getter 方法默认是 view 函数。</p><h1 id="Solidity中字符串和字节有什么不同（bytes元素的内存是紧密连续存放的，不是按照-32-个字节为一单元）"><a href="#Solidity中字符串和字节有什么不同（bytes元素的内存是紧密连续存放的，不是按照-32-个字节为一单元）" class="headerlink" title="Solidity中字符串和字节有什么不同（bytes元素的内存是紧密连续存放的，不是按照 32 个字节为一单元）"></a>Solidity中字符串和字节有什么不同（bytes元素的内存是紧密连续存放的，不是按照 32 个字节为一单元）</h1><p>字节分为定长字节数组(值类型)和变长字节数组(引用类型)，字符串是引用类型</p><p>定长字节数组：length、下标访问元素</p><p>不定长字节数组：length、下标访问元素、concat 拼接、push添加单个字节、pop删除数组的最后一个元素、delete、x[start:end]:数组切片</p><p>字符串：无length属性、无下标访问元素、concat 拼接</p><p>字符串（string）是动态大小的UTF-8编码字符序列，而字节（bytes）是一个固定大小的字节数组。在存储时，字符串会占用一个指针，指向实际存储字符串内容的位置，而字节则直接存储其内容。</p><blockquote><p>比较两个字符串</p><ul><li><code>keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))</code></li><li><code>keccak256(bytes(s1)) == keccak256(bytes(s2))</code>:更省 gas</li></ul></blockquote><h1 id="bytes和bytes32的应用场景和区别"><a href="#bytes和bytes32的应用场景和区别" class="headerlink" title="bytes和bytes32的应用场景和区别"></a>bytes和bytes32的应用场景和区别</h1><p>bytes类型适用于处理动态长度的字节数组，比如存储可变长度的文本数据或二进制数据。</p><p>bytes32类型适用于处理固定长度的字节数组，比如存储哈希值、加密签名等固定长度的二进制数据。</p><p>bytes类型没有固定的长度限制，可以根据需要动态调整大小。可以进行拼接、截取、访问等操作。</p><p>bytes32类型具有固定的长度限制，长度为32字节（256位）。可以进行比较、运算等操作。</p><h1 id="Solidity中constant和immutable的作用和区别"><a href="#Solidity中constant和immutable的作用和区别" class="headerlink" title="Solidity中constant和immutable的作用和区别"></a>Solidity中constant和immutable的作用和区别</h1><p>gas 要低很多、赋值后不可以修改</p><p>constant常量不是储存在<code>storage</code> 上，所以函数内读取常量不算<code>view</code>，可以使用 pure</p><p>constant常量在编译时确定，支持的仅有<strong>值类型（包括地址类型）&#x2F;字符串&#x2F;bytes</strong>，不允许任何通过访问 storage，区块链数据（例如 <code>block.timestamp</code>,<code>address(this).balance</code> 或者 <code>block.number</code>）或执行数据（ <code>msg.value</code> 或<code>gasleft()</code> ）对其赋值，</p><p>immutable不可变量可以在构建时确定，<code>immutable</code>仅支持值类型</p><h1 id="Solidity中创建合约的两种方式的区别和应用场景"><a href="#Solidity中创建合约的两种方式的区别和应用场景" class="headerlink" title="Solidity中创建合约的两种方式的区别和应用场景"></a>Solidity中创建合约的两种方式的区别和应用场景</h1><p>通过 <code>new</code> 创建合约 &#x2F; <code>create</code>：在<strong>创建合约时根据创建合约的地址和创建合约交易时的 <code>nonce</code> 来计算合约的地址</strong>。</p><p>通过 <code>salt</code> 创建合约 &#x2F; <code>create2</code>：指定了一个可选的 <code>salt</code> （一个 bytes32 值），它将<strong>根据给定的 <code>salt</code></strong> ，<strong>创建合约的字节码和构造函数参数</strong>来计算创建合约的地址，不再使用 <code>nonce</code>。</p><p>Uniswap中利用create2创建交易对，然后通过交易对代币地址可以推测出交易对地址与之交互，确保每次实例化的合约地址都是唯一的</p><blockquote><p>salt 决定了合约地址，不能重复使用，除非之前 salt 生成的合约被销毁了。</p></blockquote><h1 id="Solidity中的错误类型（Panic和Error）出现的场景和表示意义"><a href="#Solidity中的错误类型（Panic和Error）出现的场景和表示意义" class="headerlink" title="Solidity中的错误类型（Panic和Error）出现的场景和表示意义"></a>Solidity中的错误类型（Panic和Error）出现的场景和表示意义</h1><ol><li>Panic（紧急情况）：<ul><li>场景：Panic<strong>在发生无法恢复的严重错误或异常情况时触发</strong>，例如<strong>数组越界、除零操作、无效的操作</strong>等。这些错误通常表示<strong>合约处于一个不可处理的状态，无法继续执行，需要立即停止。</strong></li><li>表示意义：Panic表示了<strong>一种严重的错误或异常情况，合约无法继续正常执行</strong>。它的目的是提醒开发者和用户发生了不可恢复的错误，可能需要修复合约代码或采取其他措施来处理问题。</li></ul></li><li>Error（错误）：<ul><li>场景：Error通常在<strong>可处理的错误或异常情况下触发</strong>，例如<strong>输入验证失败、外部调用返回错误结果</strong>等。这些错误通常可以<strong>通过适当的错误处理逻辑进行处理或恢复，不会导致合约无法继续执行</strong>。</li><li>表示意义：Error表示了<strong>一种可处理的错误或异常情况，合约可以通过适当的错误处理逻辑进行恢复</strong>。它的目的是<strong>提供一种错误处理机制，使合约能够适当地处理错误情况，继续执行或采取适当的措施。</strong></li></ul></li></ol><blockquote><p>Panic通常通过使用<code>revert()</code>、<code>require()</code>或<code>assert()</code>等函数来触发。这些函数会中止当前的合约执行并回滚状态改变。而Error可以通过自定义的错误处理逻辑或使用<code>try-catch</code>语句来捕获和处理</p></blockquote><h1 id="Solidity中assert和require的区别和应用场景"><a href="#Solidity中assert和require的区别和应用场景" class="headerlink" title="Solidity中assert和require的区别和应用场景"></a>Solidity中assert和require的区别和应用场景</h1><ul><li><code>require</code>：用于验证<strong>前置条件，例如输入验证、边界检查和约束条件的断言。</strong>返还剩余的燃气</li><li><code>assert</code>：用于<strong>验证合约内部的不变量和内部错误，主要用于验证内部逻辑的正确性。</strong>不返还剩余的燃气</li></ul><h1 id="Solidity中transfer、send、call转账的区别"><a href="#Solidity中transfer、send、call转账的区别" class="headerlink" title="Solidity中transfer、send、call转账的区别"></a>Solidity中transfer、send、call转账的区别</h1><p>低级CALL调用<strong>不需要<code>payable address</code></strong>,ransfer 和 send <strong>只能是 <code>payable address</code></strong></p><p>transfer()失败时抛出异常,send()失败时仅会返回false,不会终止执行（合约地址转账）</p><p>call的 gas 可以动态调整,transfer 和 send 只能是固定制 <code>2300</code></p><p>call除了可以转账外，可以还可以调用不知道 ABI 的方法，还可以调用的时候转账</p><h1 id="Solidity中call、delegatecall、staticcall、callcode区别"><a href="#Solidity中call、delegatecall、staticcall、callcode区别" class="headerlink" title="Solidity中call、delegatecall、staticcall、callcode区别"></a>Solidity中call、delegatecall、staticcall、callcode区别</h1><p>为了与不知道 ABI 的合约进行交互，Solidity 提供了函数 <code>call</code>&#x2F;<code>delegatecall</code>&#x2F;<code>staticcall</code> 直接控制编码。它们都带有一个 <code>bytes memory</code> 参数和返回执行<strong>成功状态</strong>（bool）和<strong>数据</strong>（bytes memory）。</p><p><strong>三种方法都提供 <code>gas</code> 选项，而 <code>value</code> 选项仅 <code>call</code> 支持</strong> 。</p><p>call()：被调用合约内部如果有状态变量修改，则会被修改</p><p>delegatecall()：<code>delegatecall</code> 只调用给定地址的代码（函数），其他状态属性如（存储，余额 …）都来自当前合约。<code>delegatecall</code> 的目的是使用另一个合约中的库代码。(用于升级合约)</p><p>staticcall()：与 call 基本相同，但<strong>如果被调用的函数以任何方式修改状态变量，都将回退</strong></p><p>callcode()：在Solidity v0.5.0版本中被废弃，用于在当前合约的上下文中调用另一个合约的函数，但<strong>共享相同的存储空间。</strong></p><h1 id="Solidity中的隐式转换和显示转换、函数可见性类型转换"><a href="#Solidity中的隐式转换和显示转换、函数可见性类型转换" class="headerlink" title="Solidity中的隐式转换和显示转换、函数可见性类型转换"></a>Solidity中的隐式转换和显示转换、函数可见性类型转换</h1><p><strong>隐式转换：值类型，源类型必须是目标类型的子集。</strong></p><p>例如，<code>uint8</code> 可以转换为 <code>uint16</code>&#x2F;<code>uint24</code>..&#x2F;<code>uint256</code>，因为<code>uint8</code>是<code>uint16</code>这些类型的子集。</p><p>但是 <code>int8</code> 不可以转换为 <code>uint256</code>，因为 <code>int8</code> 可以包含 <code>uint256</code> 中不允许的负值，比如 <code>-1</code>。</p><p><strong>显示转换：使用类型关键字，显式地将数据类型转换为另一种类型</strong></p><p>整型加大数据位置是从左侧增加，减小数据位置也是从左侧移除；（<strong>整型是右对齐</strong>）</p><p>字节加大数据位置是从右侧增加，减小数据位置也是从右侧移除；（<strong>字节是左对齐</strong>）</p><p>只有当字节类型和整数类型大小相同时，才可以进行转换。</p><p>bytes 和 bytesN 之间转换左对齐</p><p>bytes 与 address 转换：地址是取 <code>bytes32</code> 数据中的后 20 位，address(uint160(uint256(bytes32)))</p><p><strong>pure转view、view转non-payable、payable转non-payable</strong></p><h1 id="Solidity中合约继承方式、继承多个合约的顺序写法、super关键字作用"><a href="#Solidity中合约继承方式、继承多个合约的顺序写法、super关键字作用" class="headerlink" title="Solidity中合约继承方式、继承多个合约的顺序写法、super关键字作用"></a>Solidity中合约继承方式、继承多个合约的顺序写法、super关键字作用</h1><p>使用 <code>is</code> 实现继承：子类可以访问父类的权限修饰符只有：<code>public/internal</code>，不能是 <code>external/private</code>。</p><p>传参：contract C is A(“n”),B(“v”) {}   &#x2F;     constructor(string memory _name) A(_name) {}</p><p>一个合约<strong>同时继承 2 个合约时，这种情况叫多重继承</strong>，多重继承中不允许出现相同的<strong>函数名</strong>、<strong>事件名</strong>、<strong>修改器名</strong>以及<strong>状态变量名</strong>等，使用逗号分隔它们，并按照从左到右的顺序进行继承。</p><p><code>super</code>关键字作用：</p><ul><li>在子合约中，可以使用<code>super</code>关键字来引用父合约的函数和状态。</li><li>通过<code>super</code>关键字，可以调用父合约中的同名函数，并且可以在子合约中访问父合约的状态变量。</li><li>使用<code>super</code>关键字可以实现在子合约中对父合约行为的扩展或覆盖。</li></ul><h1 id="Solidity中函数重写规则"><a href="#Solidity中函数重写规则" class="headerlink" title="Solidity中函数重写规则"></a>Solidity中函数重写规则</h1><p>solidity 引入了 <code>abstract</code>, <code>virtual</code>, <code>override</code> 几个关键字，用于重写函数。<strong>父合约标记为 <code>virtual</code>函数可以在继承合约里重写(overridden)以更改他们的行为</strong>。重写的函数需要使用关键字 <code>override</code> 修饰。</p><p>对于多重继承，如果有多个父合约有相同定义的函数， override 关键字后必须指定所有父合约名。</p><p> <code>nonpayable</code> 可以被 <code>view</code> 和<code>pure</code> 覆盖。 <code>view</code> 可以被 <code>pure</code> 覆盖。 <code>payable</code>是一个例外，不能更改为任何其他可变性。</p><p>基础合约中可以包含没有实现代码的函数，也就是纯虚函数，那么基础合约必须声明为 <code>abstract</code>(interface)</p><h1 id="Solidity中的接口是什么"><a href="#Solidity中的接口是什么" class="headerlink" title="Solidity中的接口是什么"></a>Solidity中的接口是什么</h1><p>接口需要有 interface 关键字，并且内部只需要有函数的声明，不用实现，用于调用，里面的函数都没有实现且都是external，可以被继承和重写，限制：不包含变量或状态</p><h1 id="Solidity中的库"><a href="#Solidity中的库" class="headerlink" title="Solidity中的库"></a>Solidity中的库</h1><p>library 是智能合约的精简版，像智能合约一样，位于区块链上，通过EVM的delegatecall实现调用，库无状态变量，不能继承其他合约，如果被继承传参是引用，参数标识为storage，库合约函数的可视范围通常为internal，可变性为pure</p><p>直接调用库合约方法：Math.max(_x, _y);</p><p>using…for… 使用库合约：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using ArrayLib for uint256[];</span><br><span class="line">uint256[] public arr = [10, 11, 12, 13, 14,...];</span><br><span class="line">...</span><br><span class="line">arr.find(15); // 直接使用</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="如何分析链上交易过程、如何借助区块浏览器查询信息"><a href="#如何分析链上交易过程、如何借助区块浏览器查询信息" class="headerlink" title="如何分析链上交易过程、如何借助区块浏览器查询信息"></a>如何分析链上交易过程、如何借助区块浏览器查询信息</h1><p>搜索栏中输入要查询的信息，如<strong>交易哈希、地址或合约地址。</strong></p><p>显示您查询相关的信息，如<strong>交易细节、区块高度、转账金额等。</strong></p><p>查看交易的<strong>确认状态、合约代码、事件日志等其他相关信息。</strong></p><p><strong>查看交易的输入和输出</strong>，以了解合约函数的调用、转账操作等。</p><p><strong>检查合约事件日志</strong>，了解触发的事件和相关数据。</p><p>可以<strong>查看合约的源代码、合约持有人、合约创建者等详细信息</strong>。</p><p><strong>Tenderly：</strong></p><p>智能合约调试：逐步执行合约代码，查看变量值和调用栈跟踪，更容易地定位和解决合约中的 bug 和问题。</p><p>交易模拟和回放：测试合约的行为和效果。这对于验证合约在不同情况下的行为非常有用，并且可以帮助发现潜在的安全问题和错误。</p><p>监视和警报：跟踪合约的状态变化、事件触发和交易执行情况，设置自定义警报规则，及时接收关键事件的通知。</p><p>性能分析：分析智能合约的性能和瓶颈，识别潜在的效率问题，并提供优化建议。</p><p>团队协作和共享：允许多个开发人员共同使用和管理合约，并在开发过程中共享调试会话、测试结果和分析数据。</p><h1 id="ABI的编码方式、solidity内置的ABI相关函数"><a href="#ABI的编码方式、solidity内置的ABI相关函数" class="headerlink" title="ABI的编码方式、solidity内置的ABI相关函数"></a>ABI的编码方式、solidity内置的ABI相关函数</h1><p>ABI编码方式取决于参数的类型,以下是一些常见的数据类型和对应的ABI编码方式：</p><ul><li>布尔类型（bool）：布尔值 <code>true</code> 编码为 1，布尔值 <code>false</code> 编码为 0。</li><li>整数类型（uint、int）：整数类型按照固定长度进行编码，如 uint8 编码为一个字节（8 位），uint256 编码为 32 字节（256 位）。整数类型的值通过大端（big-endian）字节序进行编码。</li><li>地址类型（address）：地址类型编码为 20 字节，其中前面 12 个字节为 0，后面 20 个字节表示地址的真实值。</li><li>字符串类型（string）：字符串类型的ABI编码与动态大小的字节数组类似，也包含一个32个字节的偏移量和实际的字符串数据。</li><li>字节数组类型（bytes）：动态大小的字节数组的ABI编码分为两部分，第一部分是32个字节的偏移量，指示实际数据在字节数组中的位置；第二部分是实际的字节数组数据。</li><li>动态数组类型（uint[]、address[]、string[] 等）：动态数组类型首先编码一个固定长度的字节数组，其中包含数组元素的 ABI 编码。然后在编码的开头添加表示数组长度的 32 位整数。</li><li>结构体类型（struct）：结构体类型的编码方式将结构体的各个成员依次进行 ABI 编码，按顺序将编码后的值拼接在一起。</li></ul><p>以上是一些常见数据类型的ABI编码方式，对于更复杂的数据类型，如映射（mapping）和函数类型（function），其ABI编码方式会更加复杂。</p><p>Solidity 内置的 ABI 相关函数：进行ABI编码和解码，使得在Solidity中<strong>与其他合约进行交互更加简单和高效。</strong></p><ul><li><code>abi.encode(...) returns (bytes)</code>：将函数参数编码为字节数组</li><li><code>abi.encodePacked(...) returns (bytes)</code>：类似于 <code>abi.encode()</code>，但是不会为编码的参数添加长度前缀，返回一个紧凑的字节数组。</li><li><code>abi.decode(bytes memory encodedData, (...)) returns (...)</code>: 对给定的数据进行 ABI 解码，而数据的类型在括号中第二个参数给出 。 例如: <code>(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))</code></li><li><code>abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)</code>： :用于将函数名称和参数编码为一个字节数组，包括函数选择器。它接受函数选择器和函数参数列表作为参数，并返回编码后的字节数组。</li><li><code>abi.encodeWithSignature(string signature, ...) returns (bytes)</code>：类似于 <code>abi.encodeWithSelector()</code>，但是使用函数的完整签名来生成函数选择器。等价于 <code>abi.encodeWithSelector(bytes4(keccak256(selector), ...)</code></li><li><code>abi.encodeCall(function functionPointer, (...)) returns (bytes memory)</code>: 使用 tuple 类型参数 ABI 编码调用 <code>functionPointer</code> 。执行完整的类型检查, 确保类型匹配函数签名。结果和 <code>abi.encodeWithSelector(functionPointer.selector, (...))</code> 一致。</li></ul><h1 id="用户发起交易的整个过程描述一下，包括交易的数据结构、交易的过程"><a href="#用户发起交易的整个过程描述一下，包括交易的数据结构、交易的过程" class="headerlink" title="用户发起交易的整个过程描述一下，包括交易的数据结构、交易的过程"></a>用户发起交易的整个过程描述一下，包括交易的数据结构、交易的过程</h1><ol><li>RLP编码：首先，<strong>将交易数据按照RLP编码规则进行序列化</strong>。RLP编码会将交易的各个字段转换为字节流，并添加长度前缀以表示字段的长度。(节省空间)</li><li>私钥签名：<strong>使用发送者的私钥对RLP编码后的交易数据进行签名</strong>。这个过程使用<strong>椭圆曲线数字签名算法</strong>（ECDSA），通过将交易哈希与私钥进行加密生成数字签名。</li><li>广播交易：<strong>将签名后的交易广播到区块链网络中的节点。</strong></li><li>进入交易池：<strong>广播的交易首先进入待处理的交易池中。</strong>交易池是存储待处理交易的缓冲区。<strong>节点将验证交易的签名和有效性，</strong>确保交易满足一些基本的规则和约束条件。</li><li>排序：在交易池中，<strong>交易会按照一定的规则进行排序</strong>。常见的排序规则包括<strong>按照交易的优先级、交易费用等进行排序。</strong></li><li>打包进区块：<strong>矿工节点从交易池中选择一些交易，并将它们打包进一个新的区块中。</strong>矿工会将交易进行有效性验证，并根据交易费用的高低选择收入最高的交易。</li><li>广播上链：一旦区块被<strong>矿工节点打包完成，它会广播到网络中的其他节点。</strong>其他节点会验证该区块的有效性，并将其添加到自己的本地副本中。</li></ol><p>所提交的交易包括下列信息：</p><ul><li><code>recipient</code> – 接收地址</li><li><code>signature</code> – 发送者的标识符。 当通过发送者的私钥签名交易来确保发送者已授权此交易时，生成此签名。</li><li><code>nonce</code> - 一个连续的递增计数器，表示帐户中的交易编号。</li><li><code>value</code> – 发送人向接收人转移的以太币金额（以以太币的一种面值 WEI 为单位）</li><li><code>data</code> – 可包括任意数据的可选字段</li><li><code>gasLimit</code> – 交易可以消耗的最大数量的燃料单位。 燃料单位代表计算步骤</li><li><code>maxPriorityFeePerGas</code> - 作为验证者小费包含的最大燃料数量</li><li><code>maxFeePerGas</code> - 愿意为交易支付的最大燃料数量</li></ul><h1 id="函数选择器的生成方式、组成、作用、为什么只取前4字节、以及在合约执行中的作用"><a href="#函数选择器的生成方式、组成、作用、为什么只取前4字节、以及在合约执行中的作用" class="headerlink" title="函数选择器的生成方式、组成、作用、为什么只取前4字节、以及在合约执行中的作用"></a>函数选择器的生成方式、组成、作用、为什么只取前4字节、以及在合约执行中的作用</h1><p>函数选择器（Function Selector）是在以太坊智能合约中用于<strong>标识函数的唯一标识符</strong>。它由<strong>函数的签名生成，并且通常只取前4个字节。</strong></p><p><strong>生成方式：</strong>将函数的名称和参数类型按照特定规则进行编码，使用Keccak-256哈希算法（也称为SHA3-256）对编码后的数据进行哈希计算，从哈希结果中取前4个字节作为函数选择器。</p><p><strong>作用：</strong>唯一标识函数、优化函数调用 (由于函数选择器只取前4个字节，因此可以减少传输的数据量，提高交易的效率。)</p><p><strong>在合约执行中的作用</strong>:确定要执行的函数,确保在合约中正确地执行所需的操作。</p><h1 id="详细说一下基于栈的虚拟机EVM（256位）、其上下文有哪些、存储空间有哪几类（stack、memory、storage）、stack的深度、访问的最大深度"><a href="#详细说一下基于栈的虚拟机EVM（256位）、其上下文有哪些、存储空间有哪几类（stack、memory、storage）、stack的深度、访问的最大深度" class="headerlink" title="详细说一下基于栈的虚拟机EVM（256位）、其上下文有哪些、存储空间有哪几类（stack、memory、storage）、stack的深度、访问的最大深度"></a>详细说一下基于栈的虚拟机EVM（256位）、其上下文有哪些、存储空间有哪几类（stack、memory、storage）、stack的深度、访问的最大深度</h1><p>EVM使用了基于栈的执行模型，其中包含以下几个关键组件：</p><ol><li>栈（Stack）：EVM<strong>使用一个栈来存储和处理数据</strong>。栈是一种<strong>后进先出的数据结构</strong>，用于<strong>保存操作数、中间结果和返回值等</strong>。</li><li>存储器（Memory）：EVM提供了<strong>一个字节数组作为存储器</strong>，用于<strong>临时存储合约执行过程中的数据</strong>。存储器可以<strong>通过索引访问，并且可以动态扩展。</strong></li><li>存储（Storage）：EVM提供了<strong>一个持久化的键值存储</strong>，用于<strong>在合约之间共享数据。存储是永久性的，即使合约执行结束后仍然保留。</strong></li><li>指令集（Instruction Set）：EVM<strong>定义了一套指令集，用于执行各种操作</strong>，如算术运算、逻辑运算、内存访问、存储访问等。每个指令都有特定的操作码和操作数。</li><li>状态转换（State Transition）：EVM<strong>通过执行指令来改变合约的状态。每个指令都会消耗一定的气体（Gas）</strong>，而气体是以太坊中的计价单位，用于限制合约执行的资源消耗。</li></ol><p>EVM的设计目标是实现安全、确定性和可验证性。它提供了一个隔离的执行环境，<strong>确保合约的执行结果在不同节点上是一致的</strong>，并且可以通过区块链上的交易历史进行验证。</p><blockquote><p>栈的最大深度为1024个元素,每层 32 字节,当栈的深度达到1024时，进一步的栈操作将会导致栈溢出错误（Stack Overflow Error）并终止合约的执行。</p></blockquote><h1 id="详细说一下EVM的“stack-too-deep”错误"><a href="#详细说一下EVM的“stack-too-deep”错误" class="headerlink" title="详细说一下EVM的“stack too deep”错误"></a>详细说一下EVM的“stack too deep”错误</h1><p>EVM栈最多 1024 层，每层 32 字节， <strong>对EVM栈的访问并不是完全严格按照先进后出，允许将顶端的 16 个元素中的某一个复制或者交换到栈顶</strong>。每次操作<strong>只能取栈顶的若干元素，把结果压栈</strong>。也能够把<strong>栈顶元素放到 memory 或者 storage 区域保存</strong>。<strong>因此一个函数最多16个变量。</strong></p><h1 id="从EVM的角度阐述交易发送和调用合约的整个过程"><a href="#从EVM的角度阐述交易发送和调用合约的整个过程" class="headerlink" title="从EVM的角度阐述交易发送和调用合约的整个过程"></a>从EVM的角度阐述交易发送和调用合约的整个过程</h1><ul><li><strong>交易创建：</strong>用户通过以太坊钱包或其他工具<strong>创建一笔交易</strong>。交易包括发送者地址、接收者地址、数额以及其他必要的信息。交易被<strong>广播到以太坊网络中。</strong></li><li><strong>交易验证：</strong>矿工节点在收到交易后，首先会<strong>对交易进行验证</strong>。验证包括检查交易的签名是否有效、发送者账户是否有足够的余额支付燃气费用等。</li><li><strong>燃气消耗评估：</strong>在验证通过后，矿工节点会评估交易执行所需的燃气消耗。每个操作码都有对应的燃气消耗，矿工节点会根据交易中的操作码和参数来计算燃气消耗。</li><li><strong>合约创建&#x2F;调用：</strong>如果<strong>交易的接收者地址是一个合约地址，则是对合约的调用。如果接收者地址是空，则是合约的创建。</strong>对于合约的调用，矿工节点会<strong>加载合约的字节码和状态，并按照交易中指定的函数和参数执行合约代码。</strong>对于合约的创建，矿工节点会在以太坊网络上创建新的合约账户，并<strong>将合约的字节码存储到账户的代码字段</strong>。</li><li><strong>状态变更：</strong>在执行合约的过程中，<strong>EVM会根据合约的代码逻辑和数据操作来进行状态变更。</strong>这包括更新合约的存储（Storage）和内存（Memory），修改账户余额，创建新的合约账户等。<strong>状态变更会被记录在内存中</strong>，但<strong>尚未写入区块链</strong>。</li><li><strong>状态回滚：</strong>如果<strong>合约执行过程中发生错误或抛出异常，EVM会回滚之前的状态变更，恢复到执行前的状态。</strong></li><li><strong>交易广播：</strong>如果交易通过了所有验证，并且燃气消耗检查也通过，<strong>矿工节点将把交易添加到待处理交易池中</strong>，等待被打包进区块。</li></ul><h1 id="以太坊的字节码、操作码是什么、如何进行单步调试、观察栈、内存的变化"><a href="#以太坊的字节码、操作码是什么、如何进行单步调试、观察栈、内存的变化" class="headerlink" title="以太坊的字节码、操作码是什么、如何进行单步调试、观察栈、内存的变化"></a>以太坊的字节码、操作码是什么、如何进行单步调试、观察栈、内存的变化</h1><p>字节码是一种低级的<strong>指令集</strong>，用于在以太坊虚拟机（EVM）上执行智能合约。操作码是字节码中的<strong>具体指令</strong>，用于执行各种操作，例如算术运算、逻辑运算、内存访问等</p><p>Remix、Geth控制台、Tenderly….</p><h1 id="合约中的数据在存储中的组织形式、内存布局"><a href="#合约中的数据在存储中的组织形式、内存布局" class="headerlink" title="合约中的数据在存储中的组织形式、内存布局"></a>合约中的数据在存储中的组织形式、内存布局</h1><p>数据可以存储在两个地方：存储（storage）和内存（memory）。</p><ol><li>存储（Storage）：存储<strong>是永久性的，用于持久化保存合约的状态数据</strong>。存储使用键值对的形式进行组织，其中键是一个256位的整数，值可以是任意大小的字节串。存储的访问是昂贵的，每次读取或写入都会消耗燃气。存储的内容在区块链上永久保存，并且可以被其他合约或外部账户访问。</li><li>内存（Memory）：内存<strong>是临时性的，用于在合约执行期间存储临时数据</strong>。内存的访问速度较快，但在合约执行结束后会被清空。内存的布局是线性的，从位置0开始，可以按需分配和释放。合约可以通过指定偏移量和长度来访问内存中的数据。</li></ol><p>内存布局包括以下几个部分：</p><ul><li>栈（Stack）：栈用于存储函数调用时的局部变量、函数参数和返回值等数据。栈以先进后出的方式管理数据。</li><li>活动区域（Active Area）：活动区域用于存储当前正在执行的函数的局部变量和临时变量等数据。</li><li>自由区域（Free Area）：自由区域是未被使用的内存空间，可以用于存储额外的临时数据。</li></ul><h1 id="哪些地方会收取交易费gas？"><a href="#哪些地方会收取交易费gas？" class="headerlink" title="哪些地方会收取交易费gas？"></a>哪些地方会收取交易费gas？</h1><p>每个操作码都有一个固定的燃气成本，对存储区域的写入和读取操作都会消耗燃气</p><p>非cesop（constant external state operation）操作：cesop操作是指不修改合约状态的操作，如只读函数调用。这些操作不会产生燃气费用。</p><h1 id="合约的内联汇编是什么、如何通过内联汇编操作数据"><a href="#合约的内联汇编是什么、如何通过内联汇编操作数据" class="headerlink" title="合约的内联汇编是什么、如何通过内联汇编操作数据"></a>合约的内联汇编是什么、如何通过内联汇编操作数据</h1><p>内联汇编是一种在<strong>底层访问以太坊虚拟机的语言</strong>，实现一些高级语言无法直接表达的功能。</p><p>通过 <code>assembly &#123;&#125;</code> 包裹代码</p><h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><p>智能合约是存储在区块链上的一段程序代码，智能合约无需信任，其有几个特点：自动执行、结果可预见、记录公开可审计、透明和不可篡改、去中心化等等</p>]]></content>
      
      
      <categories>
          
          <category> 区块链知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>预言机</title>
      <link href="/2022/12/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E9%A2%84%E8%A8%80%E6%9C%BA/"/>
      <url>/2022/12/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E9%A2%84%E8%A8%80%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="预言机"><a href="#预言机" class="headerlink" title="预言机"></a>预言机</h1><p>预言机是指数据馈送，它<strong>提取区块链数据源（链下）的数据并将数据存放到区块链（链上）上供智能合约使用。</strong> 因为运行在以太坊上的智能合约无法访问存储在区块链网络之外的信息，预言机是必不可少的。</p><p>赋予智能合约使用链下数据输入执行的能力，扩展了去中心化应用程序的价值。 例如，去中心化预测市场依靠预言机提供关于结果的信息，并且能够使用这些信息验证用户的预测。 <strong>假设 Alice 下注 20 个以太币赌谁将成为下一任美国 总统</strong>。 在这种情况下，预测市场去中心化应用程序<strong>需要预言机来确认选举结果，并判定 Alice 是否有资格获得付款。</strong></p><h2 id="什么是区块链预言机？"><a href="#什么是区块链预言机？" class="headerlink" title="什么是区块链预言机？"></a>什么是区块链预言机？</h2><p>预言机是指获取、验证外部信息（即<strong>存储在链下的信息</strong>）并将外部信息传送给在区块链上运行的智能合约的应用程序。 除了“拉取”链下数据并在以太坊进行广播之外，预言机还将信息从区块链“推送”到外部系统。 在用户通过以太坊交易发送费用后解锁智能锁的预言机就是一个推送信息的示例。</p><p><strong>预言机充当一座“桥梁”，连接区块链上的智能合约与链下数据提供者。</strong> 如果没有预言机，智能合约应用程序只能访问链上数据。 预言机提供了一种使用链下数据触发智能合约功能的机制。</p><p>预言机的差别在于数据来源（一种或多种来源）、信任模型（中心化或去中心化）和系统架构（立即读取、发布-订阅和请求-响应）。 我们还可以根据以下因素区分预言机：是否检索外部数据供链上合约使用（输入预言机）、将区块链中的信息发送给链下应用程序（输出预言机）或在链下执行计算任务（计算预言机）。</p><h2 id="智能合约为什么需要预言机？"><a href="#智能合约为什么需要预言机？" class="headerlink" title="智能合约为什么需要预言机？"></a>智能合约为什么需要预言机？</h2><p>大多数开发者只是将智能合约视为在区块链特定地址运行的代码段。 然而，对于智能合约更广义的观点是，智能合约是指在满足特定条件后能够执行各方之间协议的自执行软件程序，这解释了术语“智能合约”。</p><p>但是，使用智能合约执行人之间的协议并非易事，因为以太坊是确定性系统。 确<strong>定性系统是指在给定初始状态和特定输入时总是产生相同结果的系统，即在使用输入计算输出的过程中不存在随机性或变化。</strong></p><p>要实现确定性执行，区块链将节点限制为通过仅使用存储在区块链本身中的数据就简单的二进制 (true&#x2F;false) 问题达成共识。 这类问题的示例包括：</p><ul><li>“帐户所有者（由公钥识别）是否使用配对私钥签署该交易?”</li><li>“该帐户是否有足够资金支付这笔交易？”</li><li>“这笔交易在该智能合约中是否有效？”等等。</li></ul><p>如果区块链从外部来源（例如现实世界）接收信息，确定性将不可能实现，阻止节点就区块链状态变化的有效性达成一致。 以一个智能合约为例，该合约根据从一个传统价格应用程序接口获得的当前以太币-美元汇率执行交易。 该汇率可能会经常变动（更不用说该应用程序接口可能被弃用或遭到黑客攻击），这意味着执行相同合约代码的节点会得出不同的结果。</p><p>对于在世界各地有数千个节点处理交易的公共区块链，如以太坊，确定性至关重要。 由于没有中心化组织作为真实性来源，期望节点应在进行相同交易后达到相同状态。 <strong>节点 A 执行智能合约的代码并得到结果“3”，而节点 B 在运行相同交易后得到“7”，这将打破共识并消除以太坊作为去中心化计算平台的价值。</strong></p><p>为此，<strong>预言机通常由链上运行的智能合约和一些链下组件构成。 链上合约接收其他智能合约的数据请求，并将这些请求传送给链下组件（称为预言机节点）</strong>。 这类预言机节点可以查询数据源—例如使用应用程序接口 (API)—并发送交易将请求的数据存储在智能合约的存储中。</p><p>就本质而言，区块链预言机弥合了区块链和外部环境之间的信息缺口，创建了“混合智能合约”。 混合智能合约的工作原理基于链上合约代码和链下基础设施的结合。 简介部分描述的去中心化预测市场就是混合智能合约的一个很好的示例。 其他示例可能包括作物保险智能合约，在一组预言机确定某些天气现象已经发生时这些合约做出赔付。</p><h2 id="什么是预言机问题？"><a href="#什么是预言机问题？" class="headerlink" title="什么是预言机问题？"></a>什么是预言机问题？</h2><p>通过依赖一个实体（或多个实体）向区块链引入外部信息（即将信息存储在交易的数据有效负载中），很容易让智能合约获取链下数据。 但这带来了新问题：</p><ul><li>如何验证注入信息是从正确来源提取的或者未被篡改？</li><li>如何确保这些数据始终可用并且定期更新？</li></ul><p>所谓的“预言机问题”显示了使用区块链预言机给智能合约发送输入时出现的问题。 重要的是确保来自预言机的数据是正确的，否则智能合约执行会产生错误结果。 免信任也同样重要，必须“信任”预言机运营者能够可靠地提供准确信息，这会剥夺智能合约最关键的特性。</p><p>不同预言机在解决预言机问题方面采取的办法各不相同，我们稍后探讨这些办法。 虽然任何预言机都不是完美的，但<strong>预言机的优点</strong>应该根据它如何处理以下挑战来衡量：</p><ol><li><strong>正确性</strong>：<strong>真实性是指数据是从正确来源获取的。完整性是指数据在发送到链上前保持完好无缺（即数据未修改过）。</strong></li><li><strong>可用性</strong>：预言机不应延迟或阻止智能合约执行操作或触发状态变化。 该特点<strong>要求预言机提供的数据在请求时可用并且不会出现间断。</strong></li><li><strong>激励兼容性</strong>：<strong>预言机应激励链下数据提供者向智能合约提交正确的信息</strong>。 奖励兼容性包括可归因性和问责性。 可归因性允许将一条外部信息与其提供者关联起来，而问责性将数据提供者与其提供的信息绑定，这样就可以根据所提供信息的质量对他们进行奖励或惩罚。</li></ol><h2 id="区块链预言机服务是如何运作的？"><a href="#区块链预言机服务是如何运作的？" class="headerlink" title="区块链预言机服务是如何运作的？"></a>区块链预言机服务是如何运作的？</h2><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p><strong>用户是指需要区块链外部的信息以完成特定操作的实体（即智能合约）</strong>。 <strong>预言机服务的基本工作流程始于用户向预言机合约发送数据请求</strong>。 数据请求通常将回答下列一部分或所有问题：</p><ol><li>链下节点可以在哪些来源中查询请求的信息？</li><li>报告者如何处理数据来源中的信息并提取有用的数据点？</li><li>有多少预言机节点可以参与数据检索？</li><li>应如何管理预言机报告中的差异？</li><li>在筛选提交并将报告聚合为单个值时应该采用什么方法?</li></ol><h3 id="预言机合约"><a href="#预言机合约" class="headerlink" title="预言机合约"></a>预言机合约</h3><p>预言机合约是预言机服务的链上组成部分：它<strong>侦听其他合约发出的数据请求。将数据查询转发到预言机节点并将返回的数据向客户端合约广播</strong>。 该合约还可以对返回的数据点进行一些计算，以产生聚合值并发送给请求合约。</p><p>预言机合约公开了一些函数，客户端合约在发出数据请求时调用它们。 收到新查询后，<strong>智能合约将触发一个日志事件</strong>，其中有数据请求详细信息。 这将通知订阅该日志的链下节点（通常使用类似 JSON-RPC <code>eth_comment</code> 的命令），让其继续检索日志事件中定义的数据。</p><p>下面是 Pedro Costa 提供的预言机合约示例。 它是一个简单的预言机服务，可以在其他智能合约发出请求时查询链下应用程序接口，并在区块链上存储请求的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.21 &lt;0.6.0;</span><br><span class="line"></span><br><span class="line">contract Oracle &#123;</span><br><span class="line">  Request[] requests; //list of requests made to the contract</span><br><span class="line">  uint currentId = 0; //increasing request id</span><br><span class="line">  uint minQuorum = 2; //minimum number of responses to receive before declaring final result</span><br><span class="line">  uint totalOracleCount = 3; // Hardcoded oracle count</span><br><span class="line"></span><br><span class="line">  // defines a general api request</span><br><span class="line">  struct Request &#123;</span><br><span class="line">    uint id;                            //request id</span><br><span class="line">    string urlToQuery;                  //API url</span><br><span class="line">    string attributeToFetch;            //json attribute (key) to retrieve in the response</span><br><span class="line">    string agreedValue;                 //value from key</span><br><span class="line">    mapping(uint =&gt; string) answers;     //answers provided by the oracles</span><br><span class="line">    mapping(address =&gt; uint) quorum;    //oracles which will query the answer (1=oracle hasn&#x27;t voted, 2=oracle has voted)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //event that triggers oracle outside of the blockchain</span><br><span class="line">  event NewRequest (</span><br><span class="line">    uint id,</span><br><span class="line">    string urlToQuery,</span><br><span class="line">    string attributeToFetch</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  //triggered when there&#x27;s a consensus on the final result</span><br><span class="line">  event UpdatedRequest (</span><br><span class="line">    uint id,</span><br><span class="line">    string urlToQuery,</span><br><span class="line">    string attributeToFetch,</span><br><span class="line">    string agreedValue</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  function createRequest (</span><br><span class="line">    string memory _urlToQuery,</span><br><span class="line">    string memory _attributeToFetch</span><br><span class="line">  )</span><br><span class="line">  public</span><br><span class="line">  &#123;</span><br><span class="line">    uint length = requests.push(Request(currentId, _urlToQuery, _attributeToFetch, &quot;&quot;));</span><br><span class="line">    Request storage r = requests[length-1];</span><br><span class="line"></span><br><span class="line">    // Hardcoded oracles address</span><br><span class="line">    r.quorum[address(0x6c2339b46F41a06f09CA0051ddAD54D1e582bA77)] = 1;</span><br><span class="line">    r.quorum[address(0xb5346CF224c02186606e5f89EACC21eC25398077)] = 1;</span><br><span class="line">    r.quorum[address(0xa2997F1CA363D11a0a35bB1Ac0Ff7849bc13e914)] = 1;</span><br><span class="line"></span><br><span class="line">    // launch an event to be detected by oracle outside of blockchain</span><br><span class="line">    emit NewRequest (</span><br><span class="line">      currentId,</span><br><span class="line">      _urlToQuery,</span><br><span class="line">      _attributeToFetch</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // increase request id</span><br><span class="line">    currentId++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //called by the oracle to record its answer</span><br><span class="line">  function updateRequest (</span><br><span class="line">    uint _id,</span><br><span class="line">    string memory _valueRetrieved</span><br><span class="line">  ) public &#123;</span><br><span class="line"></span><br><span class="line">    Request storage currRequest = requests[_id];</span><br><span class="line"></span><br><span class="line">    //check if oracle is in the list of trusted oracles</span><br><span class="line">    //and if the oracle hasn&#x27;t voted yet</span><br><span class="line">    if(currRequest.quorum[address(msg.sender)] == 1)&#123;</span><br><span class="line"></span><br><span class="line">      //marking that this address has voted</span><br><span class="line">      currRequest.quorum[msg.sender] = 2;</span><br><span class="line"></span><br><span class="line">      //iterate through &quot;array&quot; of answers until a position if free and save the retrieved value</span><br><span class="line">      uint tmpI = 0;</span><br><span class="line">      bool found = false;</span><br><span class="line">      while(!found) &#123;</span><br><span class="line">        //find first empty slot</span><br><span class="line">        if(bytes(currRequest.answers[tmpI]).length == 0)&#123;</span><br><span class="line">          found = true;</span><br><span class="line">          currRequest.answers[tmpI] = _valueRetrieved;</span><br><span class="line">        &#125;</span><br><span class="line">        tmpI++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      uint currentQuorum = 0;</span><br><span class="line"></span><br><span class="line">      //iterate through oracle list and check if enough oracles(minimum quorum)</span><br><span class="line">      //have voted the same answer has the current one</span><br><span class="line">      for(uint i = 0; i &lt; totalOracleCount; i++)&#123;</span><br><span class="line">        bytes memory a = bytes(currRequest.answers[i]);</span><br><span class="line">        bytes memory b = bytes(_valueRetrieved);</span><br><span class="line"></span><br><span class="line">        if(keccak256(a) == keccak256(b))&#123;</span><br><span class="line">          currentQuorum++;</span><br><span class="line">          if(currentQuorum &gt;= minQuorum)&#123;</span><br><span class="line">            currRequest.agreedValue = _valueRetrieved;</span><br><span class="line">            emit UpdatedRequest (</span><br><span class="line">              currRequest.id,</span><br><span class="line">              currRequest.urlToQuery,</span><br><span class="line">              currRequest.attributeToFetch,</span><br><span class="line">              currRequest.agreedValue</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="预言机节点"><a href="#预言机节点" class="headerlink" title="预言机节点"></a>预言机节点</h3><p>预言机节点是预言机服务的链下组件：它从外部来源提取信息（例如在第三方服务器上托管的应用程序接口）并将信息置于链上供智能合约使用。 预言机节点侦听链上预言机合约中的事件，继而完成日志中描述的任务。</p><p>预言机节点的常见任务是，向应用程序接口服务发送 HTTP GET请求，解析响应以提取相关数据，设置为区块链可读的输出格式，并通过将输入包含在预言机合约的交易中将其发送到链上 在利用“真实性证明”证明所提交信息的有效性和完整性时，可能也会用到预言机节点，我们稍后会对此进行探讨。</p><p>计算型预言机还依赖链下节点执行密集的计算任务，考虑到燃料成本和区块大小限制，这类计算在链上执行是不切实际的。 例如，预言机节点的任务可能是生成一个可验证的随机数字（例如，用于区块链游戏）。</p><h2 id="预言机设计模式"><a href="#预言机设计模式" class="headerlink" title="预言机设计模式"></a>预言机设计模式</h2><p>预言机有不同的类型，包括立即读取、发布-订阅和请求-响应，后两者在太坊智能合约中最受欢迎。 下面简要介绍两类预言机服务：</p><h3 id="发布-订阅预言机"><a href="#发布-订阅预言机" class="headerlink" title="发布-订阅预言机"></a>发布-订阅预言机</h3><p>基于发布-订阅机制的<strong>预言机服务公开“数据馈送”，其他合约可以定期读取以获取信息</strong>。 在这种情况下，数据可能会频繁变化，因此客户端合约必须侦听预言机存储中数据的更新。 向用户提供最新以太币-美元价格的预言机便是一个很好的示例。</p><h3 id="请求-响应预言机"><a href="#请求-响应预言机" class="headerlink" title="请求-响应预言机"></a>请求-响应预言机</h3><p>请求-响应设置允许客户端合约请求除发布-订阅预言机所提供数据以外的任意数据。 请求-响应预言机最适合以下条件下：</p><ul><li>数据集过大，无法存储在智能合约的存储中</li><li>用户在任何时间点只需要一小部分数据</li></ul><p>虽然比发布-订阅预言机复杂，但请求-响应预言机基本上和我们在上一节中描述的一样。 预言机将有一个链上组件，用于接收数据请求并传送给链下节点进行处理。发起数据查询的用户必须承担从链下来源检索信息的费用。 客户端合约还必须提供资金，用以支付预言机合约通过请求中指定的回调函数返回响应所产生的燃料费用。</p><h2 id="预言机的类型"><a href="#预言机的类型" class="headerlink" title="预言机的类型"></a>预言机的类型</h2><h3 id="中心化预言机"><a href="#中心化预言机" class="headerlink" title="中心化预言机"></a>中心化预言机</h3><p><strong>中心化预言机由单个实体控制</strong>，该实体负责聚合链下信息并按照请求更新预言机合约的数据。 中心化预言机效率高，因为它们依赖单一真实性来源。 在专有数据集由所有者直接发布并且有公认签名的情况下，中心化预言机甚至可能是更好的选择。 但是，使用中心化预言机会带来各种问题：</p><ul><li><strong>低正确性保障：</strong>使用中心化预言机时，无法确认提供的信息是否正确。 预言机提供者可能“信誉良好”，但这并不能排除有人行为不端或黑客篡改系统的可能性。 如果预言机被破坏，智能合约将基于错误数据执行。</li><li><strong>可用性差：</strong>中心化预言机无法保证始终向其他智能合约提供链下数据。 如果提供者决定关闭服务或者黑客劫持了预言机的链下组件，智能合约则会面临拒绝服务 (Dos) 攻击的风险。</li><li><strong>激励兼容性差：</strong>中心化预言机的激励往往设计不善或根本没有激励，鼓励数据提供者发送准确&#x2F;未更改的信息。 为预言机的服务付费可能会鼓励诚实的行为，但这可能还不够。 由于智能合约控制着巨额价值，操纵预言机数据的收益是前所未有的。</li></ul><h3 id="去中心化预言机"><a href="#去中心化预言机" class="headerlink" title="去中心化预言机"></a>去中心化预言机</h3><h4 id="高正确性保障"><a href="#高正确性保障" class="headerlink" title="高正确性保障"></a>高正确性保障</h4><p>去中心化预言机尝试<strong>使用不同的方法实现数据的正确性</strong>。 其中包括使用证明来证明返回信息的真实性和完整性，以及要求多个实体就链下数据的有效性集体达成一致。</p><h4 id="真实性证明"><a href="#真实性证明" class="headerlink" title="真实性证明"></a>真实性证明</h4><p>真实性证明是一种加密机制，<strong>支持对从外部来源检索的信息进行独立验证</strong>。 这些证明可以验证信息的来源，并在检索后发现对数据可能进行的更改。</p><p>真实性证明的示例包括：</p><p><strong>传输层安全性 (TLS) 证明</strong>：预言机节点通常使用基于传输层安全性 (TLS) 协议的安全 HTTP 连接从外部数据源检索数据。 一些去中心化预言机使用真实性证明验证传输层安全性会话（即，确认节点和特定服务器之间的信息交换），并确认会话内容未被改动。</p><p><strong>可信执行环境 (TEE) 认证</strong>：可信执行环境 (TEE) 是一种沙盒计算环境，它与主机系统的操作进程隔离。 可信执行环境确保在计算环境中存储&#x2F;使用的任何应用代码或数据都保持完整性、保密性和不可变性。 用户还可以生成一个认证，证明应用程序实例正在可信执行环境中运行。</p><p>某些类别的去中心化预言机要求预言机节点运营者提供可信执行环境认证。 这向用户证实，节点运营者在可信执行环境中运行预言机客户端的实例。 可信执行环境防止外部进程更改或读取应用程序的代码和数据，因此，这些认证证明预言机节点保持了信息的完整性和保密性。</p><h4 id="基于共识的信息验证"><a href="#基于共识的信息验证" class="headerlink" title="基于共识的信息验证"></a>基于共识的信息验证</h4><p>为智能合约提供数据时，中心化预言机依靠单一真实性来源，因此有可能发布不准确的信息。 去中心化预言机依靠多个预言机节点查询链下信息，解决了这个问题。 通过对多个来源的数据进行比较，去中心化预言机降低了将无效信息传递到链上合约的风险。</p><p>然而，去中心化预言机必须处理从多个链下来源检索的信息中的差异。 为了尽量减少信息差异并确保传送给预言机合约的数据反映了预言机节点的集体看法，去中心化预言机采用了下列机制：</p><h5 id="对数据的准确性进行投票-质押"><a href="#对数据的准确性进行投票-质押" class="headerlink" title="对数据的准确性进行投票&#x2F;质押"></a>对数据的准确性进行投票&#x2F;质押</h5><p>一些去中心化预言机网络要求参与者对数据查询答案的准确性进行投票或质押（例如，“谁赢得了 2020 年美国大选?”） （例如，“谁赢得了 2020 年美国大选?”） 然后，聚合协议聚合投票和质押，并将多数参与者支持的答案作为有效答案。</p><p>如果节点的答案不同于多数答案，将对其进行惩罚，即将其代币分发给提供更正确值的其他节点。 强制节点在提供数据之前提供保证金将激励节点做出诚实的响应，因为假定节点是理性的经济活动参与者，意在最大限度地增加回报。</p><p>质押&#x2F;投票还保护去中心化预言机免受“女巫攻击”，在这种攻击中，恶意参与者创建多个身份来利用共识系统。 然而，质押机制不能防止“揩油行为”（预言机节点从其他节点复制信息）和“懒散验证”（预言机节点随大流而不亲自验证信息）。</p><h5 id="谢林点机制"><a href="#谢林点机制" class="headerlink" title="谢林点机制"></a>谢林点机制</h5><p><a href="https://en.wikipedia.org/wiki/Focal_point_(game_theory)">谢林点</a>是一个博弈论概念，它假设在缺乏任何沟通的情况下，多个实体总是默认对一个问题选择共同解决方案。 谢林点机制常用于去中心化预言机网络，使节点对数据请求的应答达成共识。</p><p>一个早期的示例是<a href="https://blog.ethereum.org/2014/03/28/schellingcoin-a-minimal-trust-universal-data-feed/">谢林币</a>，这是一种提议的数据馈送，参与者提交“标量”问题的答案（这些问题的答案由数量描述，例如“以太币的价格是多少?”）及存款。 提供的值在第 25 和第 75 <a href="https://en.wikipedia.org/wiki/Percentile">百分位</a>之间的用户将得到奖励，而提供的值大幅偏离中值的用户将受到惩罚。</p><p>虽然谢林币目前已不存在，但许多去中心化预言机—特别是 <a href="https://docs.makerdao.com/smart-contract-modules/oracle-module">Maker 协议预言机</a>—仍使用谢林点机制来提高预言机数据的准确性。 每个 Maker 预言机均由提交抵押品资产的市场价格的链下对等节点网络（“中继者”和“馈送者”）和链上“中值器”合约组成，后者计算所有提供价值的中值。 规定的延迟期结束后，该中值成为相关资产的新参考价格。</p><p>使用谢林点机制的其他预言机示例包括 <a href="https://docs.chain.link/docs/off-chain-reporting/">Chainlink 链下报告</a>和 Witnet。 在这两种系统中，对等网络中的预言机节点的答复聚合成一个单一聚合值，如平均值或中值。 根据其答复与聚合值的一致或偏离程度奖励或惩罚节点。</p><p>谢林点机制具有吸引力，因为这类机制能够最大限度地减少对链上的影响（只需要发送一笔交易）同时又能保证去中心化。 后者是可行的，因为节点必须批准已提交答复的列表，然后再将答复输入生成平均值&#x2F;中值的算法。</p><h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><p>去中心化预言机服务确保链下数据对智能合约的高可用性。 高可用性是通过对链下信息来源和负责将信息传输到链上的节点同时去中心化实现的。</p><p>这确保了容错，因为预言机合约能够依靠多个节点（这些节点也依靠多个数据源）执行其他合约发出的查询。 在信息来源<em>和</em>节点运营商层面实现去中心化至关重要—提供从同一来源检索的信息的预言机节点网络将遇到与中心化预言机相同的问题。</p><p>基于质押的预言机也可以对未能快速响应数据请求的节点运营商进行惩罚。 这极大地激励了预言机节点投资于容错基础设施并及时提供数据。</p><h4 id="激励兼容性好"><a href="#激励兼容性好" class="headerlink" title="激励兼容性好"></a>激励兼容性好</h4><p>去中心化预言机采纳了不同的激励设计，避免预言机节点中出现<a href="https://en.wikipedia.org/wiki/Byzantine_fault">拜占庭</a>行为。 具体而言，它们实现了<em>可归因性</em>和<em>问责性</em>：</p><ol><li>通常，要求去中心化预言机节点对它们为了响应数据请求而提供的数据签名。 这些信息有助于评估预言机节点的历史表现，让用户在发出数据请求时筛选掉不可靠的预言机节点。 示例包括 Chainlink 的<a href="https://oracle.reputation.link/">预言机信誉</a>或 Witnet 的<a href="https://docs.witnet.io/intro/about/architecture#algorithmic-reputation-system">算法信誉系统</a>。</li><li>如前所述，去中心化预言机可能要求节点对其提交数据的真实性的可信度进行质押。 如果声明得到证实，这笔质押可以连同诚信服务的奖励一起返还。 但是如果信息不正确，也可以对节点进行惩罚，这就提供了一定程度的问责性。</li></ol><h2 id="预言机在智能合约中的应用"><a href="#预言机在智能合约中的应用" class="headerlink" title="预言机在智能合约中的应用"></a>预言机在智能合约中的应用</h2><p>以下是以太坊中预言机的常见用例：</p><h3 id="检索金融数据"><a href="#检索金融数据" class="headerlink" title="检索金融数据"></a>检索金融数据</h3><p><a href="https://ethereum.org/zh/defi/">去中心化金融</a> (DeFi) 应用程序允许点对点贷款、借款和资产交易。 通常，这需要获取不同的金融信息，包括汇率数据（用于计算加密货币的法币价值或比较两种代币的价格）和资本市场数据（用于计算代币化资产的价值，如黄金或美元）。</p><p>例如，如果你计划构建一个去中心化金融贷款协议，将需要查询作为抵押品存放的资产（如以太币）的当前市场价格。 这就是为什么你的智能合约可以确定抵押品资产的价值，并确定它们可以从系统中借出多少钱。</p><p>去中心化金融中流行的“价格预言机”（常用名称）包括 Chainlink Price Feeds、Compound Protocol 的<a href="https://compound.finance/docs/prices">开放式喂价工具</a>、Uniswap 的<a href="https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles">时间加权平均价格 (TWAP) </a>以及 <a href="https://docs.makerdao.com/smart-contract-modules/oracle-module">Maker 预言机</a>。 建议将这些价格预言机集成到你的项目之前，先了解它们的注意事项。 这篇<a href="https://blog.openzeppelin.com/secure-smart-contract-guidelines-the-dangers-of-price-oracles/">文章</a>详细分析了计划使用任何上述价格预言机时的考虑因素。</p><h3 id="生成可验证的随机性"><a href="#生成可验证的随机性" class="headerlink" title="生成可验证的随机性"></a>生成可验证的随机性</h3><p>某些区块链应用程序（如基于区块链的游戏或彩票方案），需要高度的不可预测性和随机性才能有效工作。 然而，区块链的确定性执行消除了任何随机性来源。</p><p>通常的方法是使用伪随机密码函数，例如<code>blockhash</code>，但这也适用于其他参与者[的](<a href="https://ethereum.stackexchange.com/questions/3140/risk-of-using-blockhash-other-miners-preventing-attack#:~:text=So">https://ethereum.stackexchange.com/questions/3140/risk-of-using-blockhash-other-miners-preventing-attack#:~:text=So</a> while the miners can,to one of the players.)操作，即解决工作量证明算法的矿工。 此外，以太坊<a href="https://ethereum.org/zh/roadmap/merge/">过渡到权益证明</a>意味着开发者不能再依靠 <code>blockhash</code> 获得链上随机性（然而，信标链的 <a href="https://eth2book.info/altair/part2/building_blocks/randomness">RANDAO 机制</a>提供了另一种随机性来源）。</p><p>可以在链下生成随机值并发送到链上，但这样做对用户有很高的信任要求。 他们必须相信值确实是通过不可预测的机制产生的，并且未在传输过程中被改动。</p><p>为链下计算设计的预言机解决了这一问题，它们安全地生成链下随机结果并连同证实该过程不可预测性的加密证明一起在链上广播。 一个示例是 <a href="https://docs.chain.link/docs/chainlink-vrf/">Chainlink VRF</a>（可验证随机函数），它是一个可证明公平且防篡改的随机数生成器 (RNG)，用于为依靠不可预测结果的应用程序构建可靠的智能合约。</p><h3 id="获取事件结果"><a href="#获取事件结果" class="headerlink" title="获取事件结果"></a>获取事件结果</h3><p>有了预言机，创建响应真实事件的智能合约并非难事。 预言机服务允许合约通过链下组件连接到外部应用程序接口并使用来自这些数据源的信息，实现这一点。 例如，前面介绍的预测去中心化应用程序可能会请求预言机返回可信链下来源（如美联社）提供的选举结果。</p><p>使用预言机根据实际结果检索数据支持其他新用例，包括去中心化保险应用程序。 向用户付费的保险智能合约需要准确的信息（例如，天气数据、灾难报告等）才能有效工作。</p><h3 id="智能合约自动化"><a href="#智能合约自动化" class="headerlink" title="智能合约自动化"></a>智能合约自动化</h3><p>与流行的说法相反，智能合约不会自动运行，外部帐户 (EOA) 或另一种合约帐户必须触发正确的函数才能执行合约的代码。 大多数情况下，合约的大部分函数是公共函数，可由外部帐户和其他合约调用。</p><p>但合约中也有其他合约无法访问的<em>私有函数</em>；通常它们对于去中心化应用程序的整体功能至关重要。 可能的示例包括定期为用户铸造新非同质化代币的 <code>mintERC721Token()</code> 函数、在预测市场上授予付款的函数或解锁去中心化交易所中质押的代币的函数。</p><p>开发者需要每隔一段时间触发这些函数，以保持应用程序平稳运行。 然而，这可能导致开发者在普通任务上浪费更多时间，这就是智能合约自动执行具有吸引力的原因。</p><p>一些去中心化预言机网络提供自动化服务，允许链下预言机节点根据用户定义的参数触发智能合约函数。 通常，这需要向预言机服务“注册”目标合约，提供资金支付预言机运营商，并指定触发合约的条件或时间。</p><p>一个示例是 Chainlink 的 <a href="https://chain.link/keepers">Keeper 网络</a>，它为智能合约提供一些选项，以信任最小化和去中心化的方式将定期维护任务外包。 请阅读官方 <a href="https://docs.chain.link/docs/chainlink-keepers/introduction/">Keeper 相关文档</a>，了解如何使合约与 keeper 兼容并使用 Upkeep 服务。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钱包</title>
      <link href="/2022/12/11/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E9%92%B1%E5%8C%85/"/>
      <url>/2022/12/11/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E9%92%B1%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>钱包用来存钱的，在区块链中，我们的数字资产都会对应到一个账户地址上， 只有拥有账户的钥匙（私钥）才可以对资产进行消费（用私钥对消费交易签名）。<br>私钥和地址的关系如下：<img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/img/9efa20eff737374479d9c6bb86db82b3.png!wl" alt="关系"></p><p><strong>私钥通过椭圆曲线生成公钥， 公钥通过对私钥进行哈希函数生成地址，这两个过程都是单向的。</strong></p><h2 id="如何创建账号"><a href="#如何创建账号" class="headerlink" title="如何创建账号"></a>如何创建账号</h2><p>创建账号关键是生成一个私钥， 私钥是一个32个字节的数， <strong>生成一个私钥在本质上在1到2^256之间选一个数字</strong>。<br>因此生成密钥的第一步也是最重要的一步，是要找到足够安全的熵源，即随机性来源，只要选取的结果是不可预测或不可重复的，那么选取数字的具体方法并不重要。从编程的角度来看，一般是通过在一个密码学安全的随机源(不建议大家自己去写一个随机数)中取出一长串随机字节，对其使用SHA256哈希算法进行运算，这样就可以方便地产生一个256位的数字。</p><blockquote><p>实际过程需要比较下是否小于n-1（n &#x3D; 1.158 * 10^77, 略小于2^256），我们就有了一个合适的私钥。否则，我们就用另一个随机数再重复一次。这样得到的私钥就可以根据上面的方法进一步生成公钥及地址。</p></blockquote><h2 id="BIP32"><a href="#BIP32" class="headerlink" title="BIP32"></a>BIP32</h2><p>钱包也是一个私钥的容器，按照上面的方法，我们可以生成一堆私钥（一个人也有很多账号的需求，可以更好保护隐私），而每个私钥都需要备份就特别麻烦的。</p><blockquote><p>最早期的比特币钱包就是就是这样，还有一个昵称：“Just a Bunch Of Keys(一堆私钥)“</p></blockquote><p>为了解决这种麻烦，就有了<a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP32 提议</a>： 根据一个随机数种子通过分层确定性推导的方式得到n个私钥，这样保存的时候，只需要保存一个种子就可以，私钥可以推导出来，如图：</p><img src="/noteimg/区块链/区块链其他/img/50.png" alt="推导" style="zoom: 67%;" />（图来自精通比特币）上图中的孙秘钥就可以用来签发交易。<blockquote><p>补充说明下 BIP: Bitcoin Improvement Proposals 比特币改进建议, bip32是第32个改进建议。<br>BIP32提案的名字是：Hierarchical Deterministic Wallets， 就是我们所说的HD钱包。</p></blockquote><p>来分析下这个分层推导的过程，第一步推导主秘钥的过程：<br><img src="/noteimg/区块链/区块链其他/img/40.jpeg" alt="推导主秘钥的过程" style="zoom:67%;" /></p><p>根种子输入到HMAC-SHA512算法中就可以得到一个可用来创造主私钥(m) 和 一个主链编码（ a master chain code)这一步生成的秘钥（由私钥或公钥）及主链编码再加上一个索引号，将作为HMAC-SHA512算法的输入继续衍生出下一层的私钥及链编码，如下图：<img src="/noteimg/区块链/区块链其他/img/40-16965572565772.jpeg" alt="衍生" style="zoom:67%;" /></p><blockquote><p>衍生推导的方案其实有两个：一个用父私钥推导（称为强化衍生方程），一个用父公钥推导。同时为了区分这两种不同的衍生，在索引号也进行了区分，索引号小于2^31用于常规衍生，而2^31到2^32-1之间用于强化衍生，为了方便表示索引号i’，表示2^31+i。</p></blockquote><p>因此增加索引（水平扩展）及 通过子秘钥向下一层（深度扩展）可以无限生成私钥。</p><p>注意， 这个推导过程是确定（相同的输入，总是有相同的输出）也是单向的，子密钥不能推导出同层级的兄弟密钥，也不能推出父密钥。如果没有子链码也不能推导出孙密钥。现在我们已经对分层推导有了认识。</p><p>一句话概括下BIP32就是：<strong>为了避免管理一堆私钥的麻烦提出的分层推导方案。</strong></p><h3 id="秘钥路径及BIP44"><a href="#秘钥路径及BIP44" class="headerlink" title="秘钥路径及BIP44"></a>秘钥路径及BIP44</h3><p>通过这种分层（树状结构）推导出来的秘钥，通常用路径来表示，每个级别之间用斜杠 &#x2F; 来表示，由主私钥衍生出的私钥起始以“m”打头。因此，第一个母密钥生成的子私钥是m&#x2F;0。第一个公共钥匙是M&#x2F;0。第一个子密钥的子密钥就是m&#x2F;0&#x2F;1，以此类推。</p><p>BIP44则是为这个路径约定了一个规范的含义(也扩展了对多币种的支持)，BIP0044指定了包含5个预定义树状层级的结构：<br><code>m / purpose&#39; / coin&#39; / account&#39; / change / address_index</code><br>m是固定的, Purpose也是固定的，值为44（或者 0x8000002C）<br><strong>Coin type</strong><br>这个代表的是币种，0代表比特币，1代表比特币测试链，60代表<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊</a><br>完整的币种列表地址：<a href="https://github.com/satoshilabs/slips/blob/master/slip-0044.md">https://github.com/satoshilabs/slips/blob/master/slip-0044.md</a><br><strong>Account</strong><br>代表这个币的账户索引，从0开始<br><strong>Change</strong><br>常量0用于外部(收款地址)，常量1用于内部（也称为找零地址）。外部用于在钱包外可见的地址（例如，用于接收付款）。内部链用于在钱包外部不可见的地址，用于返回交易变更。 (所以一般使用0)<br><strong>address_index</strong><br>这就是地址索引，从0开始，代表生成第几个地址，官方建议，每个account下的address_index不要超过20</p><p>根据 <a href="https://github.com/ethereum/EIPs/issues/85">EIP85提议的讨论</a>以太坊钱包也遵循BIP44标准，确定路径是<code>m/44&#39;/60&#39;/a&#39;/0/n</code><br>a 表示帐号，n 是第 n 生成的地址，60 是在 <a href="https://github.com/satoshilabs/slips/blob/master/slip-0044.md">SLIP44 提案</a>中确定的以太坊的编码。所以我们要开发以太坊钱包同样需要对比特币的钱包提案BIP32、BIP39有所了解。</p><p>一句话概括下BIP44就是：<strong>给BIP32的分层路径定义规范</strong></p><h2 id="BIP39"><a href="#BIP39" class="headerlink" title="BIP39"></a>BIP39</h2><p>BIP32 提案可以让我们保存一个随机数种子（通常16进制数表示），而不是一堆秘钥，确实方便一些，不过用户使用起来(比如冷备份)也比较繁琐，这就出现了<a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP39</a>，它是使用助记词的方式，生成种子的，这样用户只需要记住12（或24）个单词，单词序列通过 PBKDF2 与 HMAC-SHA512 函数创建出随机种子作为 BIP32 的种子。</p><p>可以简单的做一个对比，下面那一种备份起来更友好：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机数种子</span></span><br><span class="line"><span class="number">090</span>ABCB3A6e1400e9345bC60c78a8BE7</span><br><span class="line"><span class="comment">// 助记词种子</span></span><br><span class="line">candy maple cake sugar pudding cream honey rich smooth crumble sweet treat</span><br></pre></td></tr></table></figure><p>使用助记词作为种子其实包含2个部分：助记词生成及助记词推导出随机种子，下面分析下这个过程。</p><h3 id="生成助记词"><a href="#生成助记词" class="headerlink" title="生成助记词"></a>生成助记词</h3><p>助记词生成的过程是这样的：先生成一个128位随机数，再加上对随机数做的校验4位，得到132位的一个数，然后按每11位做切分，这样就有了12个二进制数，然后用每个数去查<a href="https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md">BIP39定义的单词表</a>，这样就得到12个助记词，这个过程图示如下：</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/img/70.png" alt="过程图"><br>（图来源于网络）</p><p>下面是使用bip39生成生成助记词的一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bip39 = <span class="built_in">require</span>(<span class="string">&#x27;bip39&#x27;</span>)</span><br><span class="line"><span class="comment">// 生成助记词</span></span><br><span class="line"><span class="keyword">var</span> mnemonic = bip39.<span class="title function_">generateMnemonic</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mnemonic)</span><br></pre></td></tr></table></figure><h3 id="助记词推导出种子"><a href="#助记词推导出种子" class="headerlink" title="助记词推导出种子"></a>助记词推导出种子</h3><p>这个过程使用密钥拉伸（Key stretching）函数，被用来增强弱密钥的安全性，PBKDF2是常用的密钥拉伸算法中的一种。<br>PBKDF2基本原理是通过一个为随机函数(例如 HMAC 函数)，把助记词明文和盐值作为输入参数，然后重复进行运算最终产生生成一个更长的（512 位）密钥种子。这个种子再构建一个确定性钱包并派生出它的密钥。</p><p>密钥拉伸函数需要两个参数：助记词和盐。盐可以提高暴力破解的难度。 盐由常量字符串 “mnemonic” 及一个可选的密码组成，注意使用不同密码，则拉伸函数在使用同一个助记词的情况下会产生一个不同的种子，这个过程图示图下:</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/img/80.png" alt="过程图"><br>（图来源于网络）</p><p>同样代码来表示一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hdkey = <span class="built_in">require</span>(<span class="string">&#x27;ethereumjs-wallet/hdkey&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">&#x27;ethereumjs-util&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> seed = bip39.<span class="title function_">mnemonicToSeed</span>(mnemonic, <span class="string">&quot;pwd&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> hdWallet = hdkey.<span class="title function_">fromMasterSeed</span>(seed);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> key1 = hdWallet.<span class="title function_">derivePath</span>(<span class="string">&quot;m/44&#x27;/60&#x27;/0&#x27;/0/0&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;私钥：&quot;</span>+util.<span class="title function_">bufferToHex</span>(key1.<span class="property">_hdkey</span>.<span class="property">_privateKey</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> address1 = util.<span class="title function_">pubToAddress</span>(key1.<span class="property">_hdkey</span>.<span class="property">_publicKey</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;地址：&quot;</span>+util.<span class="title function_">bufferToHex</span>(address1));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;校验和地址：&quot;</span>+ util.<span class="title function_">toChecksumAddress</span>(address1.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>)));</span><br></pre></td></tr></table></figure><p>校验和地址是<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md">EIP-55</a>中定义的对大小写有要求的一种地址形式。</p><p>密码可以作为一个额外的安全因子来保护种子，即使助记词的备份被窃取，也可以保证钱包的安全（也要求密码拥有足够的复杂度和长度），不过另外一方面，如果我们忘记密码，那么将无法恢复我们的数字资产。</p><p>一句话概括下BIP39就是：<strong>通过定义助记词让种子的备份更友好</strong></p><blockquote><p>（助记词 &lt;-&gt; seed -&gt; 私钥 -&gt; 公钥 -&gt; PubKeyHash &lt;-&gt; address, 其中&lt;-&gt;表可双向转换，-&gt;表单向转换，最后的PubKeyHash转换为address的时候用的是base58编码，base58编码的原理即辗转相除法）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 区块链其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大可提取价值MEV</title>
      <link href="/2022/12/08/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E6%9C%80%E5%A4%A7%E5%8F%AF%E6%8F%90%E5%8F%96%E4%BB%B7%E5%80%BCMEV/"/>
      <url>/2022/12/08/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E6%9C%80%E5%A4%A7%E5%8F%AF%E6%8F%90%E5%8F%96%E4%BB%B7%E5%80%BCMEV/</url>
      
        <content type="html"><![CDATA[<h1 id="最大可提取价值-MEV"><a href="#最大可提取价值-MEV" class="headerlink" title="最大可提取价值 (MEV)"></a>最大可提取价值 (MEV)</h1><p>最大可提取价值 (MEV) 是指通过在区块中添加和排除交易并更改区块中的交易顺序，可以从区块生产中提取的超过标准区块奖励和燃料费用的最大值。</p><h2 id="MEV-提取"><a href="#MEV-提取" class="headerlink" title="MEV 提取"></a>MEV 提取</h2><p><strong>从理论上讲，最大可提取价值完全属于验证者，因为他们是唯一可以保证执行有利可图的最大可提取价值机会的一方。</strong> 但实际上，大部分 MEV 是由称为“搜索人”的独立网络参与者提取的。 搜索人在区块链数据上运行复杂的算法来检测盈利的 MEV 机会，并且有机器人自动将这些盈利交易提交到网络。</p><p>无论如何，验证者确实会获得全部最大可提取价值金额的一部分，<strong>因为搜索者愿意支付高昂的燃料费用（这些费用将归验证者所有）</strong>，以换取将其有利可图的交易纳入一个区块的更高可能性。 假定搜索人在经济上是合理的。搜索人愿意支付的燃料费将是 MEV 的 100% 的金额（因为如果燃料费更高，搜索人将亏钱）。</p><blockquote><p> Flashbots 是一个独立项目，它通过一项服务扩展执行客户端，该服务允许搜索者将<strong>最大可提取价值交易提交给验证者</strong>，而无需将它们透露给公共内存池。 这就防止了交易被通用领跑者领跑。</p></blockquote><h2 id="MEV-相关案例"><a href="#MEV-相关案例" class="headerlink" title="MEV 相关案例"></a>MEV 相关案例</h2><p>最大可提取价值以几种方式出现在区块链上。</p><h3 id="去中心化交易所-DEX-套利"><a href="#去中心化交易所-DEX-套利" class="headerlink" title="去中心化交易所 (DEX) 套利"></a>去中心化交易所 (DEX) 套利</h3><p>去中心化交易所 (DEX) 套利是最简单和最著名的最大可提取价值机会。 因此，它也是竞争最激烈的。</p><p>它的作用原理就像这样：如果有两个去中心化交易所以两种不同的价格提供一种代币，有人可以通过一笔原子交易，<strong>在价格较低的去中心化交易所购买此代币，并在价格较高的去中心化交易所将其出售</strong>。 得益于区块链的机制，这是真实的无风险套利。</p><h3 id="清算"><a href="#清算" class="headerlink" title="清算"></a>清算</h3><p>借贷协议清算提供了另一个众所周知的最大可提取价值机会。</p><p>Maker 和 Aave 等借贷协议要求用户存入一些抵押品（例如以太币）。 然后将这些存入的抵押品借出给其他用户。</p><p>然后，用户可以根据他们的需要从其他人那里借入资产和代币（例如，如果你想在 MakerDAO 治理提案中投票，你可以借用 MKR），最高可达他们所存抵押品的一定比例。 例如，如果借款金额不超过 30%，则将 100 DAI 存入协议的用户最多可以借入价值 30 DAI 的另一种资产。 该协议确定了确切的借款能力百分比。</p><p>随着借款人抵押品价值的波动，他们的借款能力也会波动。 如果由于市场波动，借入资产的价值超过其抵押品价值的 30%（同样，准确的百分比由协议确定，协议通常允许任何人清算抵押品，立即偿还贷款人（这类似于传统金融中的 追加保证金通知(opens in a new tab)）。 <strong>如果清算，借款人通常必须支付大笔清算费，其中有些是流向变现人的——这是多 MEV 机会出现的地方。</strong></p><p>搜索人竞相以最快的速度解析区块链数据，以确定哪些借款人可以被清算，并成为第一个提交清算交易并自行收取清算费的人。</p><h3 id="夹心-三明治-交易"><a href="#夹心-三明治-交易" class="headerlink" title="夹心(三明治)交易"></a>夹心(三明治)交易</h3><p>夹心交易是另外一种 MEV 提取的常用方法。</p><p>为了实现夹心交易，搜索人会监视内存池内 DEX 的大额交易。 例如，有人想要在 Uniswap 上使用 DAI 购买 10,000 UNI。 这类大额交易会对 UNI&#x2F;DAI 对产生重大的影响，可能会显着提高 UNI 相对于 DAI 的价格。</p><p>搜索人可以计算该大额交易对 UNI&#x2F;DAI 对的大致价格影响，并<strong>在大额交易<em>之前</em>立即执行最优买单，低价买入 UNI，然后在大额交易<em>之后</em>立即执行卖单，以大额订单造成的更高价格卖出</strong>。</p><p>然而，<strong>夹心交易风险很高，因为它不是原子交易</strong>（不像上文所述的 DEX 套利），而且容易受到 <a href="https://github.com/Defi-Cartel/salmonella">salmonella 攻击(opens in a new tab)</a>。</p><h3 id="NFT-MEV"><a href="#NFT-MEV" class="headerlink" title="NFT MEV"></a>NFT MEV</h3><p>NFT 领域的 MEV 是一种新兴现象，而且不一定能赚钱。</p><p>然而，由于 NFT 交易发生在所有其他以太坊交易共享的同一个区块链上，搜寻者也可以在 NFT 市场上使用与传统 MEV 机会类似的技术。</p><p>例如，如果有一个流行的 NFT 下降，并且搜索者想要某个 NFT 或一组 NFT，他们可以写一个交易，使他们成为第一个排队购买 NFT 的人，或者他们可以在一个交易中购买整个 NFT 组合。 或者，如果一个 NFT 被<a href="https://www.theblockcrypto.com/post/113546/mistake-sees-69000-cryptopunk-sold-for-less-than-a-cent">错误地以低价挂出(opens in a new tab)</a>，搜寻者就可以抢在其他购买者前面，低价抢购。</p><p>NFT MEV 的一个显著例子发生在一个搜寻者花费 700 万美元来<a href="https://etherscan.io/address/0x650dCdEB6ecF05aE3CAF30A70966E2F395d5E9E5">购买(opens in a new tab)↗</a>价格底线的每一个 Cryptopunk。 一位区块链研究员<a href="https://twitter.com/IvanBogatyy/status/1422232184493121538">在 Twitter(opens in a new tab)↗</a>上解释了买家是如何与 MEV 供应商合作以保持其购买的秘密。</p><h2 id="MEV-的影响"><a href="#MEV-的影响" class="headerlink" title="MEV 的影响"></a>MEV 的影响</h2><p>MEV 并不都是坏事 - 以太坊的 MEV 既有积极的作用，也有消极的影响。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>许多 <strong>DeFi 项目</strong>依靠经济上的理性行为者，来<strong>确保其协议的有用性和稳定性</strong>。 例如，DEX 套利确保用户为他们的代币获得最好、最正确的价格，而借贷协议在借款人低于抵押率时依靠快速清算来确保贷款人得到回报。如果没有理性的搜索者寻求和修复经济上的低效率，并利用协议的经济激励，DeFi 协议和一般的 dapps 可能不会像今天这样强大。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>在应用层，某些形式的 MEV，如夹心交易，会<strong>导致用户的体验明显变差。 被夹在中间的用户面临更高的滑点和更差的交易执行。</strong></p><p>在网络层，一般的抢跑者和他们经常参与的矿工费拍卖（当两个或更多的先行者通过逐步提高自己交易的矿工费，从而使他们的交易被打包到下一个区块），<strong>导致网络拥堵和试图运行正常交易的其他人的高矿工费。</strong></p><p>除了区块<em>内</em>发生的，MEV 也可能会在区块间产生有害的影响。 <strong>如果</strong>区块中可用的<strong>最大可提取价值大幅超过标准区块奖励</strong>，验证者可能会被激励重组区块并为自己捕获最大可提取价值，从而<strong>导致区块链重组和共识不稳定</strong>。</p><h2 id="以太坊权益证明-POS-机制下的最大可提取价值"><a href="#以太坊权益证明-POS-机制下的最大可提取价值" class="headerlink" title="以太坊权益证明 (POS) 机制下的最大可提取价值"></a>以太坊权益证明 (POS) 机制下的最大可提取价值</h2><p>如上所述，最大可提取价值对用户综合体验和共识层安全性产生了不利影响。 但以太坊向权益证明共识的过渡（称为“合并”）还可能带来与最大可提取价值有关的新风险：</p><h3 id="验证者中心化"><a href="#验证者中心化" class="headerlink" title="验证者中心化"></a>验证者中心化</h3><p>更大的质押池可能会有更多的资源投资进行必要的优化，以抓住最大可提取价值机会。 这些质押池提取的最大可提取价值越多，它们用来提升最大可提取价值提取能力（并增加总收入）的资源就越多，这在本质上形成了规模经济(opens in a new tab)。由于可支配的资源较少，单独质押人可能无法从最大可提取价值机会中获利。 这种情况可能会<strong>增加独立验证者加入强大的质押池以提高收益的压力</strong>，从而<strong>削弱以太坊的去中心化</strong>。</p><h3 id="许可内存池"><a href="#许可内存池" class="headerlink" title="许可内存池"></a>许可内存池</h3><p>为了应对三明治攻击和抢先交易攻击，<strong>交易者可能会开始与验证者进行链下交易以确保交易隐私</strong>。 <strong>交易者将潜在的最大可提取价值交易直接发送给验证者而非公共内存池，验证者将交易添加到区块中并与交易者分配利润。</strong></p><p>“暗池”扩展了这种模式，是一种只供访问的许可内存池，对愿意支付一定费用的用户开放。 这一趋势将<strong>弱化以太坊的无许可和免信任特性</strong>，并有可能将区块链转变成一种有利于最高出价者的“付费参与”机制。</p><p>许可内存池还会增加上一节中描述的中心化风险。 运行多个验证者的大型池可能会受益于为交易者和用户提供交易隐私，增加其最大可提取价值收入。</p><p>在合并后的以太坊中解决这些与最大可提取价值相关的问题是一个核心研究领域。 迄今为止，为了减少最大可提取价值对合并后以太坊去中心化和安全性的负面影响，提出了两种解决方案：<strong>提议者-构建者分离 (PBS)</strong> 和<strong>构建者应用程序接口</strong>。</p><h3 id="提议者-构建者分离"><a href="#提议者-构建者分离" class="headerlink" title="提议者-构建者分离"></a>提议者-构建者分离</h3><p>PBS旨在减轻最大可提取价值的影响，尤其是对共识层的影响。 提议者-构建者分离的主要特点是区块生产者和区块提议者规则的分离。 验证者仍然负责提出区块并投票，但有一类新的特别实体（称为<strong>区块构建者</strong>），其任务是对交易排序和构建区块。</p><p>在提议者-构建者分离解决方案下，区块构建者创建一个交易包并出价将其包含在信标链区块中（作为“执行有效负载”）。 选中提出下一个区块的验证者随后查看不同的出价，并选择费用最高的交易包。 提议者-构建者分离实际上创建了一个拍卖市场，让构建者和出售区块空间的验证者谈判。</p><p>当前，提议者-构建者分离设计采用一种<a href="https://gitcoin.co/blog/commit-reveal-scheme-on-ethereum/">提交-披露方案(opens in a new tab)↗</a>，即构建者仅发布对区块内容（区块头）的加密承诺及他们的出价。 在接受成交出价后，提议者创建一个包括区块头的签名区块提案。 区块构建者在看到签名区块提案后可能会发布整个区块体，并且它必须还要从验证者那里获得足够多的<a href="https://ethereum.org/zh/glossary/#attestation">认证</a>后才能最终确定区块。</p><h4 id="提议者-构建者分离如何减弱最大可提取价值的影响？"><a href="#提议者-构建者分离如何减弱最大可提取价值的影响？" class="headerlink" title="提议者-构建者分离如何减弱最大可提取价值的影响？"></a>提议者-构建者分离如何减弱最大可提取价值的影响？</h4><p>协议内的提议者-构建者分离将最大可提取价值提取从验证者权限范围内移除，降低了最大可提取价值对共识的影响。 相反，运行专用硬件的区块构建者将抓住出现的最大可提取价值机会。</p><p>不过，这并没有完全杜绝验证者与最大可提取价值有关的收入，因为构建者必须出高价才能让验证者接受他们的区块。 然而，由于验证者不再直接关注如何尽可能提高最大可提取价值收入，时间盗贼攻击的威胁降低了。</p><p>提议者-构建者分离也降低了最大可提取价值中心化的风险。 例如，使用提交-披露方案，构建者就无需信任验证者不会窃取最大可提取价值机会或将其暴露给其他构建者。 这就降低了单独质押人从最大可提取价值获益的门槛，否则，构建者将倾向于支持有着链下声誉的大型池并与它们进行链下交易。</p><p>同样，验证者不必信任构建者不会隐藏区块体或者发布无效区块，因为付款是无条件的。 即使提出的区块不可用或被其他验证者宣称无效，验证者的费用依然会支付。 在后一种情况下，区块被直接丢弃，迫使区块构建者失去所有交易费和最大可提取价值收入。</p><h3 id="构建者应用程序接口"><a href="#构建者应用程序接口" class="headerlink" title="构建者应用程序接口"></a>构建者应用程序接口</h3><p>虽然提议者-构建者分离有望减弱最大可提取价值提取的影响，但实现它需要对共识协议进行更改。 具体而言，需要更新信标链的<a href="https://ethereum.org/zh/developers/docs/consensus-mechanisms/pos/#fork-choice">分叉选择</a>规则。 <a href="https://github.com/ethereum/builder-specs">构建者应用程序接口(opens in a new tab)↗</a>是一种临时解决方案，旨在有效实现提议者-构建者分离，然而信任假设更高。</p><p>构建者应用程序接口是一种改良版的<a href="https://github.com/ethereum/execution-apis/blob/main/src/engine/common.md">引擎应用程序接口(opens in a new tab)↗</a>，共识层客户端使用它向执行层客户端请求执行有效负载。 正如<a href="https://github.com/ethereum/consensus-specs/blob/dev/specs/bellatrix/validator.md">诚实验证者规范(opens in a new tab)↗</a>中所述，选中承担区块提出职责的验证者向连接的执行客户端请求交易包，并将交易包添加到提出的信标链区块中。</p><p>构建者应用程序接口还充当验证者和执行层客户端之间的中间件；不同之处是，它允许信标链上的验证者从外部实体获取区块（而不是使用执行客户端在本地构建区块）。</p><p>下面简述构建者应用程序接口如何运作：</p><ol><li>构建者应用程序接口将验证者连接到由运行执行层客户端的区块构建者组成的网络。 与提议者-构建者分离一样，构建者专注于投资资源密集型区块构建活动，并利用不同的策略最大程度提高从最大可提取价值 + 优先费中赚取的收入。</li><li>验证者（运行共识层客户端）向构建者网络请求执行有效负载及出价。 构建者的出价将包含执行有效负载标头（对有效负载内容的加密承诺）和向验证者支付的费用。</li><li>验证者查看收到的出价并选择费用最高的执行有效负载。 使用构建者应用程序接口，验证者创建一个仅包括其签名和执行有效负载标头的“盲”信标区块提案并发送给构建者。</li><li>在看到盲区块提案时，运行构建者应用程序接口的构建者可能会用完整的执行有效负载响应。 这样，验证者可以创建一个“已签名”信标区块并在整个网络中传播。</li><li>如果区块构建者未能及时响应，使用构建者应用程序接口的验证者仍有可能在本地构建区块，这样他们就不会错过区块提出奖励。 然而，验证者不能使用当前披露的交易或另一个集合创建另一个区块，因为这相当于<em>模棱两可</em>（对同一时隙内的两个区块签名），这是一种可受到惩罚的恶行。</li></ol><p>构建者应用程序接口的一个示例实现是 <a href="https://github.com/flashbots/mev-boost">MEV Boost(opens in a new tab)↗</a>，它是对 <a href="https://docs.flashbots.net/Flashbots-auction/overview/">Flashbots 拍卖机制(opens in a new tab)↗</a>的改进，旨在抑制最大可提取价值在以太坊上的负面外部性。 Flashbots 拍卖允许工作量证明下的矿工将构建可获利区块的工作外包给专门的参与方，即<strong>搜索者</strong>。</p><p>搜索者寻找利润丰厚的最大可提取价值机会，并向矿工发送交易包以及<a href="https://en.wikipedia.org/wiki/First-price_sealed-bid_auction">价格密封出价(opens in a new tab)↗</a>，以将交易包添加到区块中。 运行 mev-geth（go-ethereum (Geth) 客户端的分叉版本）的矿工只需要选择利润最高的交易包，并将其作为新区块的一部分开采。 为了避免矿工收到垃圾交易和无效交易，交易包先通过<strong>中继者</strong>验证然后在到达矿工处。</p><p>MEV Boost 运行机制与原来的 Flashbots 拍卖相同，但增加了一些针对以太坊向权益证明过渡的新功能。 搜索者仍然寻找有利润的交易以便添加到区块中，但一类新的名为<strong>构建者</strong>的专门参与方负责将交易聚合并打包到区块中。 构建者接受搜索者提供的价格密封出价，并进行优化以找到利润最大的排序。</p><p>中继者仍然负责验证交易包并将它们传送给提议者。 然而，MEV Boost 通过存储构建者发送的区块体和验证者发送的区块头，引入了负责提供<a href="https://ethereum.org/zh/developers/docs/data-availability/">数据可用性</a>的<strong>托管</strong>。 对于托管，连接到中继的验证者请求可用的执行有效负载，并使用 MEV Boost 的排序算法选择出价 + 最大可提取价值小费最高的有效负载标头。</p><h4 id="构建者应用程序接口如何减弱最大可提取价值的影响？"><a href="#构建者应用程序接口如何减弱最大可提取价值的影响？" class="headerlink" title="构建者应用程序接口如何减弱最大可提取价值的影响？"></a>构建者应用程序接口如何减弱最大可提取价值的影响？</h4><p>构建者应用程序接口的核心优势在于，它有可能让参与者平等获得最大可提取价值机会。 使用提交-披露方案消除了信任假设，降低了寻求从最大可提取价值中获益的验证者的进入门槛。 这应该可以减轻单独质押人加入大型质押池以提高最大可提取价值利润的压力。</p><p>构建者应用程序接口的广泛实现将鼓励区块构建者之间进行更激烈的竞争，这会增强抗审查能力。 验证者审查多个构建者的出价时，有意审查一笔或多笔用户交易的构建者必须出价高于所有其他不审查的构建者才能成功。 这大大增加了审查用户的成本并对审查有所限制。</p><p>一些项目（如 MEV Boost）将构建者应用程序接口作为整体结构的一部分，旨在为某些参与方（例如试图避免抢先交易攻击或三明治攻击的交易者）提供交易隐私。 这是通过在用户和区块构建者之间提供一条私密通信通道来实现的。 与前面描述的许可内存池不同，这种方法是有益处的，原因如下：</p><ol><li>市场上有多种构建者存在，使得审查变得不切实际，这是有利于用户的。 相比之下，基于信任的中心化暗池的存在将权力集中在少数区块构建者手中，增加了审查的可能性。</li><li>构建者应用程序接口软件是开源的，允许任何人提供区块构建者服务。 这意味着用户不会被迫使用任何特定的区块构建者，并提高了以太坊的中立和无许可特性。 此外，寻求最大可提取价值的交易者不会由于使用私密交易渠道而无意中促进中心化。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 区块链其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据可用性</title>
      <link href="/2022/12/06/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E6%95%B0%E6%8D%AE%E5%8F%AF%E7%94%A8%E6%80%A7/"/>
      <url>/2022/12/06/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E6%95%B0%E6%8D%AE%E5%8F%AF%E7%94%A8%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="数据可用性"><a href="#数据可用性" class="headerlink" title="数据可用性"></a>数据可用性</h1><p>免信任是公共区块链的大前提（“不信任，就验证”）。 以太坊减少信任假设的方法之一是强制执行数据可用性相关规则。 区块生产者需要发布每个区块的数据，参与以太坊共识的节点在本地存储这些数据。</p><h2 id="什么是数据可用性？"><a href="#什么是数据可用性？" class="headerlink" title="什么是数据可用性？"></a>什么是数据可用性？</h2><p>数据可用性<strong>保证区块提议者发布区块的所有交易数据并且交易数据对于其他网络参与者可用。</strong> 以太坊交易在<a href="https://ethereum.org/zh/developers/docs/blocks/">区块</a>中处理。 这些区块连接在一起形成“区块链”。</p><p>每个区块有两个主要部分：</p><ul><li><strong>区块头</strong>：包含关于区块的一般信息（元数据），例如时间戳、区块哈希、区块编号等。</li><li><strong>区块体</strong>：包含作为区块的一部分处理的实际交易。</li></ul><p>提出新区块时，区块生产者必须发布整个区块，包括交易数据（包含在区块体中）。 然后，参与共识的节点可以下载区块的数据并重新执行交易以确认其有效性。 如果没有验证交易的节点，区块提议者可以在区块中插入恶意交易并逃脱惩罚。</p><h3 id="数据可用性问题"><a href="#数据可用性问题" class="headerlink" title="数据可用性问题"></a>数据可用性问题</h3><p>我们可以把数据可用性难题概括为一个问题：“我们如何验证一个新产生区块的数据是否可用？”。 <strong>数据可用性非常重要，因为以太坊的安全在于假设全节点可以获取区块数据。</strong></p><p>如果区块生产者在并非所有数据可用的情况下提出了一个区块，区块可以达成最终确定性但会包含无效交易。 即使区块是有效的，但那些不能完全进行验证的区块数据将对用户和网络的功能造成负面影响。</p><p>数据可用性问题也和<a href="https://ethereum.org/zh/developers/docs/scaling/">扩容解决方案</a>相关，如卷叠。 <strong>这些协议通过在以太坊主网线下执行交易来增加吞吐量。</strong> <strong>然而，为了可以从以太坊获得安全性，这些协议必须在主网发布交易数据，让任何人能够验证在主链外执行的计算的正确性。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 区块链其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用场地</title>
      <link href="/2022/12/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E5%BA%94%E7%94%A8%E5%9C%BA%E5%9C%B0/"/>
      <url>/2022/12/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E5%BA%94%E7%94%A8%E5%9C%BA%E5%9C%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="金融服务"><a href="#金融服务" class="headerlink" title="金融服务"></a>金融服务</h2><p>金融服务其实是一个很大的范畴，涉及货币、证券、债券、保险、抵押等诸多行业，不过总结来说处理的是各种交易，这是区块链最擅长的领域。 而且加密货币天生接近金融的特性，因此区块链在金融服务中也开始逐渐扮演越来越重要的角色。</p><p>在传统金融交易中，为了确保可靠性，很多时候需要第三方机构担保，多了一方，就会给交易带来更多的摩擦：更复杂的流程、更长的时间周期、更高的资金成本、更多出错的环节。因此，金融领域使用区块链技术会大大提高交易效率。</p><h3 id="跨境支付-结算"><a href="#跨境支付-结算" class="headerlink" title="跨境支付&#x2F;结算"></a>跨境支付&#x2F;结算</h3><p>加密货币不再依赖于任何机构，自身就在去中心化的全世界的网络中运行，是天然的全球性资产，尤其在<strong>区块链网络上的发行的稳定币（Token</strong>），涵括了加密货币与发币的特性，非常适合在跨境支付与结算。</p><p>以 USDT 稳定币为例，USDT是最早的一种由美元储备支撑的稳定币，发行方Tether承诺与美元的一对一转换比率，当下逆全球化在抬头，美国仰仗其霸权利用 SWIFT 等跨境结算体系对一些国家、企业、个人进行制裁，对被制裁者跨境交易上造成重大打击。而 USDT 作为链上资产，基于匿名性、抗审查、且在7*24小时运行在一个公开无准入的分布式平台上，让 USDT 称为重要的资产交易媒介。 例如在俄罗斯经营的中国商人用卢布在交易市场中购买USDT，随后用USDT进行自由跨境。</p><p>多国政府也在积极推动使用区块链技术进行跨境交易，例如：中国人民银行、国际清算银行（香港）、香港金管局、泰国中央银行、阿联酋中央银行联合建设的多边央行数字货币桥（mBridge），就使用了区块链技术。</p><h3 id="资产数字化-代币化"><a href="#资产数字化-代币化" class="headerlink" title="资产数字化&#x2F;代币化"></a>资产数字化&#x2F;代币化</h3><p>Token ，中文主要称为代币，也有一部分人称为通证，它是一个智能合约的标准（ ERC20），我们可以<strong>使用这个标准来定义几乎任何可以用数字表达的东西</strong>，如公司的<strong>股份、股息、房产、货币、一盎司黄金、积分、权益、门票，这里统称为资产</strong>，当资产通过 Token 的形式数字化，会极大提高资产使用效率及透明度。</p><p>例如，公司股票转换为区块链代币后，可以<strong>获得更大的流动性</strong>，传统股票交易有很大的地域性，无法全球交易，代币化之后，可以吸引全球的投资者。另一个例子是，可以对房产进行代币化，转换为多个代币，可实现对<strong>资产所有权拆分</strong>，对于没有足够的资金购买单套房产的投资者，可以持有房产一部分房产。</p><h2 id="DeFi"><a href="#DeFi" class="headerlink" title="DeFi"></a>DeFi</h2><p>DeFi，Decentralized Finance（去中心化金融）的缩写， 利用区块链智能合约在链上完成资产兑换、借贷、杠杆、期货等交易。</p><p>去中心化金融相比传统金融服务有很多好处：</p><ol><li>去中心化金融无审查、对任何人开放</li><li>资金转移效率高，在一个交易内完成（传统金融服务可能是几天）</li><li>资金有自己控制，而不是机构控制</li><li>可以 24 小时不间断交易</li><li>交易规则透明</li></ol><p>同时去中心化金融诞生了很多传统金融无法实现的特性，例如： 不同的金融协议衍生品可以组合在一起交易，从而实现如：无抵押借款、无风险套利。</p><h3 id="其他金融服务"><a href="#其他金融服务" class="headerlink" title="其他金融服务"></a>其他金融服务</h3><p>金融服务领域可以广泛使用区块链技术，还有其他的场景，如：供应链金融，众筹融资、预付款等。</p><h2 id="DAO-组织"><a href="#DAO-组织" class="headerlink" title="DAO 组织"></a>DAO 组织</h2><p>DAO全称是Decentralized Autonomous Organization，即<strong>去中心化自治组织</strong>，DAO是一种<strong>将组织的管理和运行规则以智能合约代码的形式编码在区块链上</strong>，<strong>DAO的决策基于组织成员持有的代币进行投票进行</strong>，投票通过的提案自动执行。<strong>这是一种全新的组织形态</strong>。相较于传统企业而言，DAO不存在中心化的节点与层级化的管理架构，DAO有一个民主化的组织，更加透明，管理也较扁平。</p><p>DAO 是一种平等、透明的组织，能让互联网上的陌生人合作更加可信和安全，方便让全世界志同道合的人开展合作，因此 DAO 有望打破传统的公司制架构，颠覆多种商业模式。</p><h2 id="数字存证-防伪"><a href="#数字存证-防伪" class="headerlink" title="数字存证&#x2F;防伪"></a>数字存证&#x2F;防伪</h2><p>区块链可以通过哈希时间戳证明某个文件或者数字内容在特定时间的存在，加之<strong>其公开、不可篡改、可溯源等特性</strong>。可以应用于<strong>产权、版权等所有权的管理和追踪，以及身份证明，司法鉴证，防伪溯源等相关领域。</strong></p><p>通过对文字、图片、音频视频等作品内容使用区块链技术在链上进行存证或数字签名，可以实现对作品的确权，并且版权权益也可以代币化，让版权交易更容易。 还有一些应用是在防伪溯源领域，通过供应链中应用区块链技术进行跟踪，可以应用如食品医药、农产品、酒类、奢侈品等商品的溯源。</p><p>基于<strong>存证特性</strong>，在数字政务也有很多应用，如：税务部门推出区块链电子发票“税链”平台，税务部门、开票方、受票方通过独一无二的数字身份加入“税链”网络，有效解决数据篡改、一票多报、偷税漏税等问题。</p><h2 id="NFT-数字艺术品"><a href="#NFT-数字艺术品" class="headerlink" title="NFT&#x2F;数字艺术品"></a>NFT&#x2F;数字艺术品</h2><p><strong>NFT（Non Fungible Token）非同质化代币</strong>，与 Token 一样也是智能合约的标准，Token 用来表达相同的东西不同，NFT 用来表达具有独特特性的东西（两个东西不能互换）。例如：可以<strong>用 NFT 表示有编号的彩票、收藏品、音乐、域名、指纹、座位编号、武器等</strong>。</p><p><strong>NFT 具有唯一性、稀缺性、可交易性，当 NFT 与艺术品相结合，给艺术行业带来了很多新的变化和影响。</strong></p><ol><li>传统数字格式艺术文件，由于易于复制、拷贝，版权难以界定让，通过 NFT 可使从产生到交易都可追溯，版权的保护变得更加方便。</li><li>拓展了数字艺术品的金融与社交属性，艺术品由于其稀缺性、文化价值、独特性等特征带有金融属性。NFT为艺术品提供了灵活多样的流通方式与交易场景。</li><li>让数字艺术容易实现组合创作、二次创作。</li></ol><h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><p>2017年11月，<strong>基于 NFT 的以太猫（CryptoKitties）游戏在以太坊上线</strong>。用户<strong>可以通过以太币购买虚拟的以太猫</strong>，<strong>然后繁育下一代</strong>，同时也可以出售自己拥有的以太猫。 以太猫和传统游戏不同的是，<strong>以太猫的拥有权完全在用户手里。每一个以太猫就是一个以太坊上的数字，而这个数字和一个以太坊的地址绑定，拥有这个地址的用户就完全拥有这只以太猫，</strong>这款游戏带来了很多狂热的粉丝，一度长时间给以太坊带来拥堵，也让大家意识到，使用区块链的游戏可以带来很多有趣的变化。</p><p>区块链游戏让更多的权力交还给了玩家，可以提供公平和安全的游戏环境，改善游戏的可信度。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>区块链技术还可以应用于如：共享经济、创作者经济、物联网、公共服务网络、众包、法律。 这些应用场景展现了区块链技术所具有的巨大市场潜力。</p><p>不过，区块链技术尽管仍处在早期阶段，还有需要有很多的问题待解决，例如：区块链合约在执行时线下需要有怎样的机制配合，如何监管链上的一些违规违法行为，链下的数据如何高效、可信的映射到链上。 这些问题还需要我们继续探索。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链底层</title>
      <link href="/2022/11/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82/"/>
      <url>/2022/11/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="以太坊底层："><a href="#以太坊底层：" class="headerlink" title="以太坊底层："></a>以太坊底层：</h1><ol><li><p><strong>区块链结构：</strong>以太坊是基于区块链技术构建的。它的<strong>区块链结构是一个有序的、包含交易记录的区块链。每个区块包含一组交易，以及前一个区块的哈希值，形成了一个不断增长的链。</strong></p></li><li><p><strong>以太坊虚拟机（EVM）</strong>：以太坊虚拟机是以太坊的核心组件之一。它是<strong>一个可执行智能合约的运行环境</strong>，为开发者提供了一个统一的平台。EVM可以在不同的节点上运行，确保在整个网络中执行结果的一致性。</p></li><li><p><strong>账户：</strong>以太坊有两种类型的账户：外部账户（Externally Owned Account，EOA）和合约账户（Contract Account）。</p><ul><li>外部账户（EOA）：外部账户是由公钥和私钥对来表示的账户，类似于传统的加密货币账户。外部账户由用户控制，用于管理和转移以太币和代币资产。外部账户可以通过私钥签名交易，并通过公钥验证身份。</li><li>合约账户（Contract Account）：合约账户是由智能合约代码控制的特殊类型账户。合约账户没有私钥，它们由智能合约代码定义的规则和逻辑控制。合约账户可以接收和处理交易，执行与合约相关的操作，并根据预设的规则管理资产。</li></ul></li><li><p><strong>以太币（Ether）：以太坊的本地加密货币称为以太币</strong>（Ether，简称ETH）。以太币在以太坊网络中具有多种用途。首先，它用作支付智能合约执行的燃料费用。其次，以太币也可用作加密货币进行交易和价值储存。</p></li><li><p><strong>共识机制：</strong>以太坊采用了Pos共识机制，并获得以太币作为奖励。这种共识机制确保了网络的安全性和去中心化。</p></li><li><p><strong>网络：</strong>区块链底层通常采用P2P（peer-to-peer）网络，实现点对点的数据传输和交互。P2P网络需要解决节点发现、网络拓扑架构、数据同步等问题。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 区块链其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公司</title>
      <link href="/2022/11/25/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E5%85%AC%E5%8F%B8/"/>
      <url>/2022/11/25/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/%E5%85%AC%E5%8F%B8/</url>
      
        <content type="html"><![CDATA[<p>币安，火币，欧科，分布，趣链，微众，登链，阿里，腾讯，华为，通付盾，巴比特，秘猿，布比，万向，绿盟，安恒，长亭 ，百度</p><table><thead><tr><th align="left">公司</th><th>官网</th><th></th></tr></thead><tbody><tr><td align="left">火币</td><td></td><td></td></tr><tr><td align="left">欧科</td><td><a href="https://app.mokahr.com/campus-recruitment/okgroup/72016#/">https://app.mokahr.com/campus-recruitment/okgroup/72016#/</a></td><td></td></tr><tr><td align="left">分布科技</td><td><a href="https://app.mokahr.com/recommendation-apply/onchain/40661#/">https://app.mokahr.com/recommendation-apply/onchain/40661#/</a></td><td></td></tr><tr><td align="left">neo</td><td><a href="http://zhangzihan@ngd.neo.org/">zhangzihan@ngd.neo.org</a>（邮箱）</td><td></td></tr><tr><td align="left">趣链</td><td><a href="https://recruit.hyperchain.cn/social-recruitment/qulian/56024/#/job/b9625c06-f688-413a-b4e3-4456c8b75650">https://recruit.hyperchain.cn/social-recruitment/qulian/56024/#/job/b9625c06-f688-413a-b4e3-4456c8b75650</a></td><td></td></tr><tr><td align="left">微众</td><td></td><td></td></tr><tr><td align="left">登链</td><td></td><td></td></tr><tr><td align="left">阿里</td><td></td><td></td></tr><tr><td align="left">腾讯</td><td></td><td></td></tr><tr><td align="left">华为</td><td></td><td></td></tr><tr><td align="left">通付盾</td><td><a href="https://www.tongfudun.com/joinus">https://www.tongfudun.com/joinus</a></td><td></td></tr><tr><td align="left">巴比特</td><td><a href="https://www.zhipin.com/gongsir/825d58d7bf3afcd41nV-3tW_.html">https://www.zhipin.com/gongsir/825d58d7bf3afcd41nV-3tW_.html</a></td><td></td></tr><tr><td align="left">秘猿</td><td><a href="https://cryptape.com/join#/joinUs">https://cryptape.com/join#/joinUs</a></td><td></td></tr><tr><td align="left">布比</td><td><a href="https://www.bubi.cn/join.html">https://www.bubi.cn/join.html</a></td><td></td></tr><tr><td align="left">绿盟</td><td><a href="https://app.mokahr.com/campus_apply/nsfocus/40020#/">https://app.mokahr.com/campus_apply/nsfocus/40020#/</a></td><td></td></tr><tr><td align="left">安恒</td><td><a href="https://ahzp.dbappsecurity.com.cn/">https://ahzp.dbappsecurity.com.cn/</a></td><td></td></tr><tr><td align="left">长亭</td><td><a href="https://app.mokahr.com/apply/chaitin/4561#/?anchorName=default_joblist&sourceToken=">https://app.mokahr.com/apply/chaitin/4561#/?anchorName=default_joblist&amp;sourceToken=</a></td><td></td></tr><tr><td align="left">conflux</td><td></td><td></td></tr><tr><td align="left">万向</td><td><a href="http://www.wanxiang.com.cn/index.php/join">http://www.wanxiang.com.cn/index.php/join</a></td><td></td></tr><tr><td align="left">网易雷火</td><td><a href="http://leihuo.163.com/joinus.html">http://leihuo.163.com/joinus.html</a></td><td></td></tr><tr><td align="left">慢雾</td><td></td><td></td></tr><tr><td align="left">创宇</td><td><a href="https://knownsec.zhiye.com/campus/jobs">https://knownsec.zhiye.com/campus/jobs</a></td><td></td></tr><tr><td align="left">云中戏</td><td></td><td></td></tr><tr><td align="left">小红书</td><td></td><td></td></tr><tr><td align="left">百度</td><td></td><td></td></tr><tr><td align="left">b站</td><td></td><td></td></tr><tr><td align="left">blocksec(安节)</td><td></td><td></td></tr><tr><td align="left">欢乐互娱</td><td></td><td></td></tr><tr><td align="left">魔珐科技（虚拟人方向</td><td></td><td></td></tr><tr><td align="left">寺信</td><td></td><td></td></tr><tr><td align="left">trlab</td><td></td><td></td></tr><tr><td align="left">比特大陆</td><td></td><td></td></tr><tr><td align="left">嘉楠</td><td></td><td></td></tr><tr><td align="left">云中戏</td><td></td><td></td></tr><tr><td align="left">独立开发者联盟（四川虫网科技有限公司）</td><td></td><td></td></tr><tr><td align="left">联通数科</td><td></td><td></td></tr><tr><td align="left">中信银行</td><td></td><td></td></tr><tr><td align="left">兴业银行</td><td></td><td></td></tr><tr><td align="left">中国工商银行总行</td><td></td><td></td></tr><tr><td align="left">成都链安</td><td></td><td></td></tr><tr><td align="left">鹏城实验室</td><td></td><td></td></tr><tr><td align="left">元象</td><td></td><td></td></tr><tr><td align="left">金证科技</td><td></td><td></td></tr><tr><td align="left">天河国云（联盟链）</td><td></td><td></td></tr><tr><td align="left">中国电信 翼支付</td><td><a href="http://campus.51job.com/yzf2022/jobs.html">http://campus.51job.com/yzf2022/jobs.html</a></td><td></td></tr><tr><td align="left">铂数信息</td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 区块链其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>op库_th常见命令</title>
      <link href="/2022/11/22/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/op%E5%BA%93_th%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/11/22/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/op%E5%BA%93_th%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="OP一些安全库"><a href="#OP一些安全库" class="headerlink" title="OP一些安全库"></a>OP一些安全库</h1><ol><li><code>SafeMath</code>：这个库提供了一些数学函数，比如加、减、乘和除法等，可以帮助避免 Solidity 整数溢出漏洞。</li><li><code>Ownable</code>：这个库允许合约拥有者控制某些功能，比如管理员权限或合约销毁功能等。</li><li><code>ERC20</code>：这个库提供了一个标准的 ERC20 代币合约，可用于创建自己的代币。</li><li><code>ERC721</code>：这个库提供了一个标准的 ERC721 非同质化代币合约，可用于创建自己的非同质化代币。</li><li><code>ReentrancyGuard</code>：这个库帮助防止重入攻击，其中一个函数锁定重入攻击，防止同一个函数在同一时间被再次调用。</li><li><code>Pausable</code>：这个库提供了一个暂停机制，使合约可以被暂停或恢复，以处理紧急情况或停止某些操作。</li><li><code>AccessControl</code>：这个库提供了一个灵活的角色权限管理系统，允许合约拥有者分配和管理不同角色的权限。</li><li><code>SafeERC20</code>：这个库提供了对 ERC20 代币的安全操作，包括安全的代币转账和安全的代币批准操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 区块链其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPFS</title>
      <link href="/2022/11/19/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/IPFS/"/>
      <url>/2022/11/19/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/IPFS/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是IPFS"><a href="#什么是IPFS" class="headerlink" title="什么是IPFS"></a>什么是IPFS</h2><p>IPFS，是点到点的超媒体协议，它让网络更快、更安全、更开放。说简单一点，它就是一个去中心化互联网。说技术一点，它是一个基于分布式哈希表DHT进行内容寻址的，基于git模型版本管理的，基于默克尔对象关联的，基于点对点技术的，基于全球化命名空间IPNS的，基于各种技术的，一种分布式文件系统。</p><h2 id="为什么需要IPFS"><a href="#为什么需要IPFS" class="headerlink" title="为什么需要IPFS"></a>为什么需要IPFS</h2><p>现代社会中互联网对我们非常重要，它是我们生活、工作、学习、消费、娱乐和社交不可获取的媒介，但当下中心化的互联网有很多问题。</p><p><img src="/./img/v2-9322a329ae16fdafd91325a655a085e9_720w.webp" alt="img"></p><ul><li><em>中心化互联网效率低，成本高，HTTP是一个请求响应式协议，大家从一个中心服务商索取数据，服务器商构建大规模的服务器集群，服务全世界的用户。这，在高峰期，服务阻塞延迟，低峰期，大量资源闲置浪费。IPFS是通过激励，发动大量用户共享存储和带宽，资源分享和获取都在一个闭环的生态。因为网络带宽都被大文件消耗了，比如视频文件，很多都是重复数据，IPFS能有效的去重文件，消除冗余。所以IPFS能更高效的利用带宽，降低成本。</em></li><li><em>目前互联网特别容易丢失数据，IPFS能永远保存有价值的数据。</em></li><li><em>今天的互联网严重依赖主干网，一旦主干网发生故障，就会出现大规模服务中段或延迟，IPFS不依赖主干网，即便是网络不发达的地区，或者发生了灾害的地区，IPFS也能有很好的表现。</em></li><li><em>中心化的网络非常容易引入审查机制，每个government都很容易干掉某个网站或者app。</em></li></ul><p>现在，用户对互联网服务性能要求越来越高，响应快、低延迟、4K无码高清视频，大的中心化公司，能快速集中资金，做出用户体验更好的产品，但这些成本是通过广告费、会员费和竞价搜索排名转嫁到消费者头上。用户是没有选择权的。</p><p><img src="/./img/v2-e7ef02c8dff5da578f69cb78c032f63d_720w.webp" alt="img"></p><p>IPFS希望超越HTTP协议，并构建一个更好的互联网生态。</p><p>从技术角度看，IPFS是一个协议，它借鉴了许多技术，（P2P+BitTorrent+Git+Hash+kademlia DHT+SFS+Merkel  DAG等等）。通过这些技术，IPFS能将网站、应用、文件和各种数据，建立在点对点分布式网络上，并且高效的索引，这种高效的核心在于它是基于内容寻址的。</p><p>互联网上任何一个资源，都需要地址来找到它们，可能是IP地址、域名、文件的系统路径或者Nginx反向代理的路径。</p><p><img src="/./img/v2-5ebc25db00f09fe77c3b44c4edda28d0_720w.webp" alt="img"></p><p>总之得有一个地址，这个地址指向哪个资源，就返回什么资源，如果资源的地址变了，或者给的地址失效了，就无法获取资源。但我们如果真的很需要这个资源，恰好之前有人下载过这个资源，并存在他的电脑上，我们很想找到这个人，因为我们并不在乎资源在什么位置，我们只在乎这个资源的内容是不是我们想要的，那这种基于位置，也就是location的寻址就没用了，我们需要一种新的寻址模式，基于内容content的寻址，IPFS就是基于内容的寻址，它的地址长这样↓</p><p><img src="/./img/v2-507b54458be1a9478ea84a2023fb4664_720w.webp" alt="img"></p><h2 id="IPFS实现内容寻址的工作原理"><a href="#IPFS实现内容寻址的工作原理" class="headerlink" title="IPFS实现内容寻址的工作原理"></a>IPFS实现内容寻址的工作原理</h2><p><strong>第一步：将文件分割成一些小块blocks，并且分别打上hash指纹，hash指纹是一串字符，能够跟它的数据块一一对应，相当于我们每个人和自己指纹的关系。通过这个hash可以找到这个文件数据。</strong></p><p><img src="/./img/v2-d642fd2ac7420487fdbeaa75b36e81e7_720w.webp" alt="img"></p><p><strong>第二步：IPFS去除重复文件，因为每个文件有了对应的哈希值，可以非常方便的找到重复的文件，最终只保留一个对象，当然每个节点都可以保留，这个文件对象的备份。</strong></p><p><img src="/./img/v2-32df01b765b4d68e4fb66a9fcf1a2a82_720w.webp" alt="img"></p><p><strong>第三步：每个IPFS网络节点都去存储它需要的数据，用一个叫DHT的表，来记录每个节点存储了哪些数据。</strong></p><p><img src="/./img/v2-1772e85304355f0f60886ced5d3b2982_720w.webp" alt="img"></p><p>下图左边Key代表文件内容的Hash（CID），右边的Value代表内容所在的节点（PeerID），这一条DHT数据表示，CID是QmCheese的数据块，存在QmRichard这个用户的设备上。</p><p><img src="/./img/v2-e8f8780fcfb6ff7d926d3fb817dc0379_720w.webp" alt="img"></p><p><strong>第四步：当我们寻找或下载一个文件时，我们先计算这个文件的Hash指纹，通过指纹向其他节点寻找文件，当然获取他人的资源是需要成本的，别人给我分享资源也将得到回报，这种激励模式叫BitSwap。</strong></p><p><img src="/./img/v2-d8028e2251f3a021644335b3b9e8b1d1_720w.webp" alt="img"></p><h2 id="IPFS文件时如何存储和共享的"><a href="#IPFS文件时如何存储和共享的" class="headerlink" title="IPFS文件时如何存储和共享的"></a>IPFS文件时如何存储和共享的</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IPFS  object</span><br><span class="line">DATA  &quot;Hello World&quot;</span><br><span class="line">Links []</span><br></pre></td></tr></table></figure><p>IPFS的文件都是通过对象的结构来存储的，每个对象包含数据Data项和连接Links数组，Data不超过256K，Data是一串文本“Hello  World”，如果数据大于256K，比如图片或者视频，我们将拆分多个对象，都不超过256K，然后再建立一个更上层的对象，将他们归纳起来，就像一个文件夹，所以IPFS的文件结构，很想UNIX文件系统。</p><p><img src="/./img/v2-3aab9b542c2fc5f4ea5fce896dee957f_720w.webp" alt="img"></p><p>还有一个问题，这些寻址链接都是通过内容查找的，如果一个文件更新了内容，那么Hash就变了，之前的索引就失效了，所以类似区块链一样，IPFS数据是不可变的，为了追踪文件的更新，IPFS引入了版本控制模型，IPFS版本控制模型和Git基本一致，Git是常用的版本控制系统，用来记录、追踪和同步文件的版本更新，每次更新的版本快照我们叫commit。</p><p><img src="/./img/v2-540fdb1954e1addb14669b116a184f08_720w.webp" alt="img"></p><p>IPFS最大大问题是不能保证文件始终有资源，比如一个文件在4个节点有备份，如果这4个节点离线或断开，我们就无法获取这个文件数据，类似BT下载就没有种子了。</p><p>我们有2种方案解决这个问题：</p><ul><li><em>增加激励机制，鼓励节点多多存储文件，并在长期在线分享。</em></li><li><em>主动分发文件，保证一直有足够量的在线备份，这是Filecoin要做的事。</em></li></ul><p>Filecoin和IPFS是同一个团队开发的，他是搭建在IPFS上的一个区块链应用。Filecoin构建了去中心化的存储市场，如果你有空闲的存储空间，可以通过Filecoin分享给别人，赚取收益，Filecoin也用奖励，来激励用户尽可能多的保持节点在线，并且保证文件有足够多的备份。</p><p>IPFS已经建立了相对成熟的技术架构，他是去中心化产品开发者的首选存储技术方案，</p><p><img src="/./img/v2-1a8b0331c622c0434d6a863bf8efffa1_720w.webp" alt="img"></p><p>这些应用都在用IPFS技术，这里大多数是去中心化应用。IPFS还有一个经典案例，2017年土耳其政府block了维基百科，开发者在IPFS上搭建了一个去中心化的维基百科镜像，因为IPFS没有中心服务器，节点就像星星之火分布在世界各地，土耳其政府就无法再墙掉这个网站了。</p><p><img src="/./img/v2-f91617bd0b2bfd687d9ad4b6cb92419b_720w.webp" alt="img"></p><p>IPFS星际文件系统，一个如此带有科幻感和未来感的名字！</p><p>他是一个适合跨越“星际”间使用的文件系统，在星球之间传输信号，延迟是比较大的，比如火星和地球之间，传输信号的时间在4~24分钟，那么我们要是在火星上访问地球上的网页，最快8分钟，最慢48分钟。</p><p>如果有了IPFS系统，火星上查看了地球上的网页后，把网页数据存储下来，可以作为一个节点分享给其他火星人，这样，火星人的上网体验就快多了，所以我们给IPFS起名星际文件系统，一个去中心化的互联网文件分发协议，他会让互联网更快、更安全、更开放！</p>]]></content>
      
      
      <categories>
          
          <category> 区块链其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dao治理</title>
      <link href="/2022/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/Dao%E6%B2%BB%E7%90%86/"/>
      <url>/2022/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B6%E4%BB%96/Dao%E6%B2%BB%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Dao治理"><a href="#Dao治理" class="headerlink" title="Dao治理"></a>Dao治理</h1><p>DAO治理是基于去中心化自治组织（DAO）的决策过程。DAO是一种由智能合约和区块链技术支持的组织形式，它可以在无需信任中介的情况下实现透明、开放和民主的决策过程。</p><p>在DAO治理中，持有Token的用户可以通过投票来决定组织的事务和方向。这些事务可以包括跨链治理、协议改进、新增功能、经济模型、财务预算等。持有Token的用户可以提出提案并进行投票。除此之外，DAO还可能吸引外部代表、专家、投资者等参与到组织治理中来。</p><p>DAO治理的最大优势是去中心化，使得决策过程更加透明、团队更富有民主性，从而提高了决策的质量。同样，由于DAO无法被单一实体控制，其操作和治理决策也非常自由和民主。</p><p>一些常见的DAO治理项目包括Compound、MakerDAO和Uniswap等。这些DAO项目通过去中心化的组织结构，吸引了更多人来参与其中，推动了Defi市场的快速成长。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ol><li>投票治理：投票治理是DAO中最常见的一种治理方法，持有Token的用户可以投票决定在治理计划中的提案。这种治理方法对于少数股东具有很大的控制力，也会出现“多数派专政”的问题。</li><li>贡献度治理：贡献度治理是一种根据用户对项目的贡献来赋予其治理权的方法，持有Token的用户可以回答提出的问题或完成一些任务来提高其贡献度，并最终获得投票权。这种治理方法纠正了少数股东掌握大权的情况，但也会出现恶意行为，如伪造贡献度。</li><li>代表治理：代表治理是将治理权委托给一些信任的代表来投票决定，这些代表是由DAO社区自己选出的。虽然代表治理可以让个人更容易参与决策过程，但无法彻底消除上述“多数派专政”的问题。</li><li>资产管理治理：资产管理治理是一种将资产管理和投票权挂钩的治理方法，基于投票权与锁定资产的数量进行挂钩，锁定资产数量更多的用户将具有更大的投票权。这种方法纠正了少数股东掌握大权的情况，同时也鼓励长期参与。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 区块链其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09-solidity_Instructions</title>
      <link href="/2022/11/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/09-solidity_Instructions/"/>
      <url>/2022/11/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/09-solidity_Instructions/</url>
      
        <content type="html"><![CDATA[<h1 id="Solidity"><a href="#Solidity" class="headerlink" title="Solidity"></a>Solidity</h1><h2 id="Instructions"><a href="#Instructions" class="headerlink" title="Instructions"></a>Instructions</h2><p><strong>EVM类似汇编器，负责把合约汇编成更底层的指令(instruction)<strong>。每条指令表示了一些基础或者原子行逻辑操作，例如opCreate用于在State Database上创建一个新的Contract，opBalance用于从State Database中获取某个State Object的balance。这些</strong>指令的的具体的代码实现位于core&#x2F;vm&#x2F;instructions.go 文件中。</strong></p><p>值得注意的是，<strong>这些指令仍然会调用go-ethereum中其他package所提供的API，而不是直接对更底层的数据进行操作</strong>。比如，opSstore与opSload指令用于从Storage层存储和读取数据。这两个指令直接调用了StateDB(core&#x2F;state&#x2F;statedb.go)与StateObject(core&#x2F;state&#x2F;state_object.go)提供的API。</p><h3 id="opSload"><a href="#opSload" class="headerlink" title="opSload"></a>opSload</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/vm/instructions.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">opSload</span><span class="params">(pc *<span class="type">uint64</span>, interpreter *EVMInterpreter, scope *ScopeContext)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">loc := scope.Stack.peek()</span><br><span class="line">hash := common.Hash(loc.Bytes32())</span><br><span class="line">val := interpreter.evm.StateDB.GetState(scope.Contract.Address(), hash)</span><br><span class="line">loc.SetBytes(val.Bytes())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="opSstore"><a href="#opSstore" class="headerlink" title="opSstore"></a>opSstore</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">opSstore</span><span class="params">(pc *<span class="type">uint64</span>, interpreter *EVMInterpreter, scope *ScopeContext)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> interpreter.readOnly &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrWriteProtection</span><br><span class="line">&#125;</span><br><span class="line">loc := scope.Stack.pop()</span><br><span class="line">val := scope.Stack.pop()</span><br><span class="line">interpreter.evm.StateDB.SetState(scope.Contract.Address(), loc.Bytes32(), val.Bytes32())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意到，opSstore指令中向合约中的写入逻辑是调用了StateDB中的SetState函数。<strong>SetState函数有三个参数作为input，分别是目标合约的地址，目标storage object的has，以及其更新后的value</strong>。其代码如下所示。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/state/statedb.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> SetState(addr common.Address, key, value common.Hash) &#123;</span><br><span class="line">stateObject := s.GetOrNewStateObject(addr)</span><br><span class="line"><span class="keyword">if</span> stateObject != <span class="literal">nil</span> &#123;</span><br><span class="line">stateObject.SetState(s.db, key, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SetState 函数通过调用StateObject的SetState函数来修改Storage的值。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stateObject)</span></span> SetState(db Database, key, value common.Hash) &#123;</span><br><span class="line"><span class="comment">// 如果新值与旧值相同，则不设置</span></span><br><span class="line">prev := s.GetState(db, key)</span><br><span class="line"><span class="keyword">if</span> prev == value &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新值不同，更新并记录更改</span></span><br><span class="line">s.db.journal.<span class="built_in">append</span>(storageChange&#123;</span><br><span class="line">account:  &amp;s.address,</span><br><span class="line">key:      key,</span><br><span class="line">prevalue: prev,</span><br><span class="line">&#125;)</span><br><span class="line">s.setState(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stateObject)</span></span> setState(key, value common.Hash) &#123;</span><br><span class="line">s.dirtyStorage[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里的dirtStorage起到了一个cache的作用</strong>。之后<strong>在updated storage root的时候会基于当前dirtyStorage中的信息，在commit函数中统一更新root的值。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 以太坊源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08-Bloom Filter布隆过滤器</title>
      <link href="/2022/11/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/08-Bloom%20Filter%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2022/11/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/08-Bloom%20Filter%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h1><p><strong>Bloom Filter 是一种可以快速检索的工具</strong>。Bloom Filter 本身由<strong>是一个长度为m的bit array，k个不相同的hash函数和源dataset组成</strong>。具体的说，Bloom Filter是由k个不同的hash function将源dataset hash到m位的bit array构成。<strong>通过Bloom Filter，我们可以快速检测出一个data是不是在源dataset中</strong>（O(k) time）。</p><p><strong>Bloom Filter不保证完全的正确性</strong>：如果被检索的data得到了false的反馈那他一定不在源data之中，true不一定在</p><p>在文件的起始位置，定义了两个常量BloomByteLength 和 BloomBitLength</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/types/bloom9.go”</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">BloomByteLength = <span class="number">256</span></span><br><span class="line">BloomBitLength = <span class="number">8</span> * BloomByteLength</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在Ethereum中的Bloom Filter是一个长度为256的byte数组组成的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bloom represents a 2048 bit bloom filter</span></span><br><span class="line"><span class="keyword">type</span> Bloom [BloomByteLength]<span class="type">byte</span></span><br></pre></td></tr></table></figure><p>Ethereum 中Bloom Filter使用的SHA Hash Function.</p><p>基本的思想是，使用三个value的值来判断log是否存在。<br>首先对data使用SHA function进行求值。选择hash后的<br>这三个value的选择[0,1],[2,3],[4,5]的值对2048取模得到目标位置的下标，并把这几个位置设为1.</p><p>对待判断的log进行相同的操作。</p>]]></content>
      
      
      <categories>
          
          <category> 以太坊源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07-Txpool交易池</title>
      <link href="/2022/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/07-Txpool%E4%BA%A4%E6%98%93%E6%B1%A0/"/>
      <url>/2022/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/07-Txpool%E4%BA%A4%E6%98%93%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>txpool主要用来存放当前提交的等待写入区块的交易</p><p>Transaction Pool 里主要是Subpool结构，里面的 Pending 为当前可处理的交易</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/txpool/txpool.go</span></span><br><span class="line"><span class="keyword">type</span> TxPool <span class="keyword">struct</span> &#123;</span><br><span class="line">subpools []SubPool               <span class="comment">// 用于专门交易处理的子池列表</span></span><br><span class="line">subs     event.SubscriptionScope <span class="comment">// 关闭时取消所有订阅的订阅范围</span></span><br><span class="line">quit     <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="type">error</span>         <span class="comment">// 退出频道以拆除head更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SubPool 代表一个独立存在的专用事务池（例如 blob 池），由于与我们拥有多少个专用池无关，它们确实需要同步更新并组装成一个连贯的视图以进行块生产，因此该接口定义了允许主交易池管理子池的通用方法。</span></span><br><span class="line"><span class="keyword">type</span> SubPool <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Filter 是一个选择器，用于决定是否将交易添加到该特定子池中</span></span><br><span class="line">Filter(tx *types.Transaction) <span class="type">bool</span></span><br><span class="line"><span class="comment">// Init 设置子池的基本参数</span></span><br><span class="line">Init(gasTip *big.Int, head *types.Header) <span class="type">error</span></span><br><span class="line">Close() <span class="type">error</span></span><br><span class="line"><span class="comment">// 重置检索区块链的当前状态，并确保交易池的内容对于链状态而言是有效的。</span></span><br><span class="line">Reset(oldHead, newHead *types.Header)</span><br><span class="line"><span class="comment">// 更新子池对新交易所需的最低价格，并将所有交易降低到低于此阈值。</span></span><br><span class="line">SetGasTip(tip *big.Int)</span><br><span class="line"><span class="comment">// 返回子池是否具有使用给定哈希缓存的事务的指示符。</span></span><br><span class="line">Has(hash common.Hash) <span class="type">bool</span></span><br><span class="line">Get(hash common.Hash) *Transaction</span><br><span class="line"><span class="comment">// 如果一批交易有效，则 Add 将其放入池中。 由于交易波动较大，add 可能会推迟将交易完全集成到稍后的时间点，以便将多个交易批量   处理在一起。</span></span><br><span class="line">Add(txs []*Transaction, local <span class="type">bool</span>, sync <span class="type">bool</span>) []<span class="type">error</span></span><br><span class="line"><span class="comment">// Pending 检索所有当前可处理的交易，按原始帐户分组并按随机数排序。</span></span><br><span class="line">Pending(enforceTips <span class="type">bool</span>) <span class="keyword">map</span>[common.Address][]*types.Transaction</span><br><span class="line">SubscribeTransactions(ch <span class="keyword">chan</span>&lt;- core.NewTxsEvent) event.Subscription</span><br><span class="line"><span class="comment">// Nonce 返回帐户的下一个随机数，池中可执行的所有交易都已应用于顶部。</span></span><br><span class="line">Nonce(addr common.Address) <span class="type">uint64</span></span><br><span class="line">Stats() (<span class="type">int</span>, <span class="type">int</span>)</span><br><span class="line"><span class="comment">// Content 检索交易池的数据内容，返回所有待处理和排队的交易，按帐户分组并按随机数排序。</span></span><br><span class="line">Content() (<span class="keyword">map</span>[common.Address][]*types.Transaction, <span class="keyword">map</span>[common.Address][]*types.Transaction)</span><br><span class="line"><span class="comment">// ContentFrom 检索交易池的数据内容，返回该地址的待处理交易以及排队交易，并按随机数分组。</span></span><br><span class="line">ContentFrom(addr common.Address) ([]*types.Transaction, []*types.Transaction)</span><br><span class="line"><span class="comment">// Locals 检索当前被池视为本地的帐户.</span></span><br><span class="line">Locals() []common.Address</span><br><span class="line"><span class="comment">// Status 返回由哈希值标识的事务的已知状态（未知/待处理/排队）</span></span><br><span class="line">Status(hash common.Hash) TxStatus</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 以太坊源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06-Sync同步</title>
      <link href="/2022/11/07/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/06-Sync%E5%90%8C%E6%AD%A5/"/>
      <url>/2022/11/07/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/06-Sync%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p> 在前面的章节中，我们已经讨论了在以太坊中 Transactions 是从 Transaction Pool 中，被 Validator&#x2F;Miner 们验证打包，最终被保存在区块链中。那么，接下来的问题是，<strong>Transaction 是怎么被进入到 Transaction Pool 中的呢？</strong>基于同样的思考方式，那么一个刚刚在某个节点被打包好的 Block，它又将<strong>怎么传输到区块链网络中的其他节点</strong>那里，并<strong>最终实现 Blockchain 长度是一致</strong>的呢？在本章中，我们就来探索一下，节点是如何发送和接收 Transaction 和 Block 的。</p><h2 id="syncs-Transactions：同步交易状态"><a href="#syncs-Transactions：同步交易状态" class="headerlink" title="syncs Transactions：同步交易状态"></a>syncs Transactions：同步交易状态</h2><h2 id="syncs-Blocks：同步区块状态"><a href="#syncs-Blocks：同步区块状态" class="headerlink" title="syncs Blocks：同步区块状态"></a>syncs Blocks：同步区块状态</h2>]]></content>
      
      
      <categories>
          
          <category> 以太坊源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05-Worker工作者</title>
      <link href="/2022/11/03/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/05-Worker%E5%B7%A5%E4%BD%9C%E8%80%85/"/>
      <url>/2022/11/03/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/05-Worker%E5%B7%A5%E4%BD%9C%E8%80%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Mining：挖矿"><a href="#Mining：挖矿" class="headerlink" title="Mining：挖矿"></a>Mining：挖矿</h1><h2 id="Block-Reward：区块奖励"><a href="#Block-Reward：区块奖励" class="headerlink" title="Block Reward：区块奖励"></a>Block Reward：区块奖励</h2><h2 id="How-to-Seal-Block：组装区块"><a href="#How-to-Seal-Block：组装区块" class="headerlink" title="How to Seal Block：组装区块"></a>How to Seal Block：组装区块</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miner/worker.go</span></span><br><span class="line"><span class="comment">// Worker是负责向共识引擎提交新工作的主要对象和收集密封结果。</span></span><br><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> &#123;</span><br><span class="line">config      *Config</span><br><span class="line">chainConfig *params.ChainConfig</span><br><span class="line">engine      consensus.Engine</span><br><span class="line">eth         Backend<span class="comment">// eth的协议</span></span><br><span class="line">chain       *core.BlockChain<span class="comment">// 区块链</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Feeds</span></span><br><span class="line">pendingLogsFeed event.Feed</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscriptions</span></span><br><span class="line">mux          *event.TypeMux</span><br><span class="line">txsCh        <span class="keyword">chan</span> core.NewTxsEvent</span><br><span class="line">txsSub       event.Subscription</span><br><span class="line">chainHeadCh  <span class="keyword">chan</span> core.ChainHeadEvent</span><br><span class="line">chainHeadSub event.Subscription</span><br><span class="line"></span><br><span class="line"><span class="comment">// Channels</span></span><br><span class="line">newWorkCh          <span class="keyword">chan</span> *newWorkReq</span><br><span class="line">getWorkCh          <span class="keyword">chan</span> *getWorkReq</span><br><span class="line">taskCh             <span class="keyword">chan</span> *task</span><br><span class="line">resultCh           <span class="keyword">chan</span> *types.Block</span><br><span class="line">startCh            <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">exitCh             <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">resubmitIntervalCh <span class="keyword">chan</span> time.Duration</span><br><span class="line">resubmitAdjustCh   <span class="keyword">chan</span> *intervalAdjust</span><br><span class="line"></span><br><span class="line">wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">current *environment <span class="comment">// 当前运行循环的环境。</span></span><br><span class="line"></span><br><span class="line">mu       sync.RWMutex <span class="comment">// 用于保护coinbase和额外字段的锁</span></span><br><span class="line">coinbase common.Address<span class="comment">// coinbase的地址</span></span><br><span class="line">extra    []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">pendingMu    sync.RWMutex</span><br><span class="line">pendingTasks <span class="keyword">map</span>[common.Hash]*task</span><br><span class="line"></span><br><span class="line">snapshotMu       sync.RWMutex <span class="comment">// 快照 RWMutex（快照读写锁）</span></span><br><span class="line">snapshotBlock    *types.Block</span><br><span class="line">snapshotReceipts types.Receipts</span><br><span class="line">snapshotState    *state.StateDB <span class="comment">// 快照StateDB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原子状态计数器</span></span><br><span class="line">running atomic.Bool  <span class="comment">// The indicator whether the consensus engine is running or not.</span></span><br><span class="line">newTxs  atomic.Int32 <span class="comment">// New arrival transaction count since last sealing work submitting.</span></span><br><span class="line">syncing atomic.Bool  <span class="comment">// The indicator whether the node is still syncing.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// newpayloadTimeout是创建有效负载的最大超时。</span></span><br><span class="line"><span class="comment">//默认值为2秒，但节点操作符可以将其设置为任意大的值。过大的超时允许可能导致Geth无法在指定的时间内创建非空负载，并且在txpool  中存在一些计算开销较大的事务的情况下最终错过插槽。</span></span><br><span class="line">newpayloadTimeout time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新提交是在权益证明阶段重新创建密封工作或重新构建有效载荷的时间间隔。</span></span><br><span class="line">recommit time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// External functions</span></span><br><span class="line">    <span class="comment">//用于确定指定块是否被本地矿工挖掘的函数。</span></span><br><span class="line">isLocalBlock <span class="function"><span class="keyword">func</span><span class="params">(header *types.Header)</span></span> <span class="type">bool</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// Test hooks</span></span><br><span class="line">newTaskHook  <span class="function"><span class="keyword">func</span><span class="params">(*task)</span></span>                        <span class="comment">//接收到新的封装任务时调用的方法</span></span><br><span class="line">skipSealHook <span class="function"><span class="keyword">func</span><span class="params">(*task)</span></span> <span class="type">bool</span>                   <span class="comment">//决定是否跳过密封的方法。</span></span><br><span class="line">fullTaskHook <span class="function"><span class="keyword">func</span><span class="params">()</span></span>                             <span class="comment">//在推送完全密封任务之前调用的方法。</span></span><br><span class="line">resubmitHook <span class="function"><span class="keyword">func</span><span class="params">(time.Duration, time.Duration)</span></span> <span class="comment">//更新重新提交间隔时调用的方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中一个关键的函数是<code>miner/worker.go</code>中的<code>fillTransactions()</code>函数。</p><p>也就说如果我们希望修改Block中Transaction的打包顺序和从Transaction Pool选择Transactions的策略的话，我们可以通修改<code>fillTransactions()</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miner/worker.go</span></span><br><span class="line"><span class="comment">// 从txpool中检索待处理的交易，并将它们填充到给定的密封块中，交易选择和排序策略可以在将来使用插件进行定制。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> fillTransactions(interrupt *atomic.Int32, env *environment) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 用所有可用的待定交易填充块。</span></span><br><span class="line"><span class="comment">// 将待处理交易拆分为本地和远程交易</span></span><br><span class="line">pending := w.eth.TxPool().Pending(<span class="literal">true</span>)</span><br><span class="line">localTxs, remoteTxs := <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address][]*types.Transaction), pending</span><br><span class="line"><span class="keyword">for</span> _, account := <span class="keyword">range</span> w.eth.TxPool().Locals() &#123;</span><br><span class="line"><span class="keyword">if</span> txs := remoteTxs[account]; <span class="built_in">len</span>(txs) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(remoteTxs, account)</span><br><span class="line">localTxs[account] = txs</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//首先处理Local Pool中的交易</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(localTxs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//按照GasPrice和Nonce的顺序进行排序形成新的txs并传递给commitTransactions()函数</span></span><br><span class="line">txs := types.NewTransactionsByPriceAndNonce(env.signer, localTxs, env.header.BaseFee)</span><br><span class="line"><span class="keyword">if</span> err := w.commitTransactions(env, txs, interrupt); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//然后再处理从网络中接受到的远程交易。</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(remoteTxs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">txs := types.NewTransactionsByPriceAndNonce(env.signer, remoteTxs, env.header.BaseFee)</span><br><span class="line"><span class="keyword">if</span> err := w.commitTransactions(env, txs, interrupt); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>commitTransactions()</code>函数的主体是一个for循环体。在这个for循环中，函数会从txs中不断拿出头部的tx进行调用<code>commitTransaction()</code>函数进行处理。在Transaction那一个Section我们提到的<code>commitTransaction()</code>函数会将成功执行的Transaction保存在<code>env.txs</code>中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> commitTransactions(env *environment, txs *types.TransactionsByPriceAndNonce, interrupt *atomic.Int32) <span class="type">error</span> &#123;</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">.....</span><br><span class="line">logs, err := w.commitTransaction(env, tx)</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> commitTransaction(env *environment, tx *types.Transaction) ([]*types.Log, <span class="type">error</span>) &#123;</span><br><span class="line">.....</span><br><span class="line">    <span class="comment">//ApplyTransaction尝试将交易应用到给定的状态数据库，并使用其环境的输入参数。</span></span><br><span class="line">    <span class="comment">//它返回交易的收据、使用的gas，如果交易失败则返回一个错误，表明该区块无效。</span></span><br><span class="line">receipt, err := core.ApplyTransaction(w.chainConfig, w.chain, &amp;env.coinbase, env.gasPool, env.state, env.header, tx, &amp;env.header.GasUsed, *w.chain.GetVMConfig())</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">return</span> receipt.Logs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 以太坊源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-Blockchain区块链</title>
      <link href="/2022/10/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/04-Blockchain%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
      <url>/2022/10/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/04-Blockchain%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="Blockchain"><a href="#Blockchain" class="headerlink" title="Blockchain"></a>Blockchain</h1><h2 id="Block区块数据结构"><a href="#Block区块数据结构" class="headerlink" title="Block区块数据结构"></a>Block区块数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/types/block.go</span></span><br><span class="line"><span class="comment">// Block代表以太坊区块链中的整个区块</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">header       *Header</span><br><span class="line">uncles       []*Header</span><br><span class="line">transactions Transactions</span><br><span class="line"><span class="comment">// 缓存</span></span><br><span class="line">hash atomic.Value</span><br><span class="line">size atomic.Value</span><br><span class="line"><span class="comment">//这些字段被包eth用来跟踪</span></span><br><span class="line"><span class="comment">//点间块中继</span></span><br><span class="line">ReceivedAt   time.Time</span><br><span class="line">ReceivedFrom <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Header表示以太坊区块链中的区块头</span></span><br><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">ParentHash  common.Hash    <span class="string">`json:&quot;parentHash&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">UncleHash   common.Hash    <span class="string">`json:&quot;sha3Uncles&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">Coinbase    common.Address <span class="string">`json:&quot;miner&quot;`</span></span><br><span class="line">Root        common.Hash    <span class="string">`json:&quot;stateRoot&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">TxHash      common.Hash    <span class="string">`json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">ReceiptHash common.Hash    <span class="string">`json:&quot;receiptsRoot&quot;     gencodec:&quot;required&quot;`</span></span><br><span class="line">Bloom       Bloom          <span class="string">`json:&quot;logsBloom&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">Difficulty  *big.Int       <span class="string">`json:&quot;difficulty&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">Number      *big.Int       <span class="string">`json:&quot;number&quot;           gencodec:&quot;required&quot;`</span></span><br><span class="line">GasLimit    <span class="type">uint64</span>         <span class="string">`json:&quot;gasLimit&quot;         gencodec:&quot;required&quot;`</span></span><br><span class="line">GasUsed     <span class="type">uint64</span>         <span class="string">`json:&quot;gasUsed&quot;          gencodec:&quot;required&quot;`</span></span><br><span class="line">Time        <span class="type">uint64</span>         <span class="string">`json:&quot;timestamp&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">Extra       []<span class="type">byte</span>         <span class="string">`json:&quot;extraData&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">MixDigest   common.Hash    <span class="string">`json:&quot;mixHash&quot;`</span></span><br><span class="line">Nonce       BlockNonce     <span class="string">`json:&quot;nonce&quot;`</span></span><br><span class="line"><span class="comment">// BaseFee由EIP-1559添加，在遗留的报头中被忽略</span></span><br><span class="line">BaseFee *big.Int <span class="string">`json:&quot;baseFeePerGas&quot; rlp:&quot;optional&quot;`</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Blockchain区块链数据结构"><a href="#Blockchain区块链数据结构" class="headerlink" title="Blockchain区块链数据结构"></a>Blockchain区块链数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/blockchain.go</span></span><br><span class="line"><span class="comment">// 区块链还有助于从数据库中包含的任何链中返回块，以及代表规范链的块。值得注意的是，GetBlock可以返回任何块，而不需要包含在规范块中，因为GetBlockByNumber总是代表规范链。</span></span><br><span class="line"><span class="keyword">type</span> BlockChain <span class="keyword">struct</span> &#123;</span><br><span class="line">chainConfig *params.ChainConfig <span class="comment">// 链和网络配置</span></span><br><span class="line">cacheConfig *CacheConfig        <span class="comment">// 缓存配置修剪</span></span><br><span class="line">db            ethdb.Database                   <span class="comment">// 用于存储最终内容的底层持久数据库</span></span><br><span class="line">snaps         *snapshot.Tree                   <span class="comment">// 快照树快速单词查找树的叶子的访问</span></span><br><span class="line">triegc        *prque.Prque[<span class="type">int64</span>, common.Hash] <span class="comment">// 优先级队列映射块编号到尝试gc</span></span><br><span class="line">gcproc        time.Duration                    <span class="comment">// Trie转储的累积规范块处理</span></span><br><span class="line">lastWrite     <span class="type">uint64</span>                           <span class="comment">// 刷新状态时的最后一个块</span></span><br><span class="line">flushInterval atomic.Int64                     <span class="comment">// 刷新状态的时间间隔(处理时间)</span></span><br><span class="line">triedb        *trie.Database                   <span class="comment">// 用于维护trie节点的数据库处理程序。</span></span><br><span class="line">stateCache    state.Database                   <span class="comment">// 要在导入之间重用的状态数据库（包含状态缓存）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// txlookupllimit是从head中保留tx索引的最大块数:</span></span><br><span class="line">    <span class="comment">// * 0:表示没有限制，并重新生成任何缺失的索引</span></span><br><span class="line">    <span class="comment">// * N:表示N块限制[HEAD-N+1, HEAD]，并删除多余的索引</span></span><br><span class="line">    <span class="comment">// * nil:禁用tx索引器/删除器，但仍然索引新的块</span></span><br><span class="line">txLookupLimit <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">hc            *HeaderChain<span class="comment">// 只包含了区块头的区块链</span></span><br><span class="line">rmLogsFeed    event.Feed  <span class="comment">// 下面是很多消息通知的组件</span></span><br><span class="line">chainFeed     event.Feed</span><br><span class="line">chainSideFeed event.Feed</span><br><span class="line">chainHeadFeed event.Feed</span><br><span class="line">logsFeed      event.Feed</span><br><span class="line">blockProcFeed event.Feed</span><br><span class="line">scope         event.SubscriptionScope</span><br><span class="line">genesisBlock  *types.Block<span class="comment">// 创世区块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同步互斥锁链的写操作。</span></span><br><span class="line"><span class="comment">//读者不需要拿，他们可以直接读取数据库。</span></span><br><span class="line">chainmu *syncx.ClosableMutex</span><br><span class="line"></span><br><span class="line">currentBlock      atomic.Pointer[types.Header] <span class="comment">// 当前链头</span></span><br><span class="line">currentSnapBlock  atomic.Pointer[types.Header] <span class="comment">// 当前快照同步头</span></span><br><span class="line">currentFinalBlock atomic.Pointer[types.Header] <span class="comment">// 最新(共识)完成的区块</span></span><br><span class="line">currentSafeBlock  atomic.Pointer[types.Header] <span class="comment">// 最新的(共识)安全的块</span></span><br><span class="line"></span><br><span class="line">bodyCache     *lru.Cache[common.Hash, *types.Body]</span><br><span class="line">bodyRLPCache  *lru.Cache[common.Hash, rlp.RawValue]</span><br><span class="line">receiptsCache *lru.Cache[common.Hash, []*types.Receipt]</span><br><span class="line">blockCache    *lru.Cache[common.Hash, *types.Block]</span><br><span class="line">txLookupCache *lru.Cache[common.Hash, *rawdb.LegacyTxLookupEntry]</span><br><span class="line"></span><br><span class="line"><span class="comment">//未来块是为以后的处理添加的块</span></span><br><span class="line">futureBlocks *lru.Cache[common.Hash, *types.Block]</span><br><span class="line"></span><br><span class="line">wg            sync.WaitGroup </span><br><span class="line">quit          <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;  <span class="comment">//关闭信号，在停止中关闭。</span></span><br><span class="line">stopping      atomic.Bool    <span class="comment">//如果链正在运行则为false，停止时为true</span></span><br><span class="line">procInterrupt atomic.Bool    <span class="comment">//块处理的中断信号</span></span><br><span class="line"></span><br><span class="line">engine     consensus.Engine <span class="comment">// 一致性引擎</span></span><br><span class="line">validator  Validator <span class="comment">// 块和状态验证者接口</span></span><br><span class="line">prefetcher Prefetcher</span><br><span class="line">processor  Processor <span class="comment">// 块交易处理程序接口</span></span><br><span class="line">forker     *ForkChoice</span><br><span class="line">vmConfig   vm.Config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><p>NewBlockChain：返回一个使用数据库中可用信息的完全初始化的区块链。它初始化了默认的以太坊验证器和处理器。</p><p>loadLastState：从数据库中加载最后一个已知的链状态。此方法假定持有链管理器互斥锁。</p><p>Reset：清除整个区块链，将其恢复到初始状态。</p><p>SetHead：将本地链倒回到一个新的头。根据节点是快速同步还是完全同步以及处于哪种状态，该方法将尝试从磁盘中删除最小的数据，同时保持链的一致性。</p><p>InsertChain：尝试将给定批次的块插入到规范链中，否则，创建一个分叉。如果返回一个错误，它将返回失败块的索引号以及描述错误的错误。插入完成后，将触发所有累积的事件。</p><p>insertChain：是InsertChain的内部实现，它假设链是连续的，且 链互斥锁被持有。这个方法被分离出来，这样需要重新注入历史块的导入批可以在不释放锁的情况下完成，否则会导致不稳定的行为。如果侧链导入正在进行中，并且导入了历史状态，但是在实际侧链完成之前添加了新的canon-head，则可以再次修剪历史状态</p><p>writeblockandsehead将给定块和所有相关状态写入数据库，并应用该块作为新的链头。</p><p>reorg：获取两个区块，一个旧链和一个新链，并将重建区块并将它们插入到新的规范链中，并积累潜在的缺失交易并发布关于它们的事件。注意，这里不会处理新的头部块，调用者需要在外部处理它。</p>]]></content>
      
      
      <categories>
          
          <category> 以太坊源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-Transaction交易</title>
      <link href="/2022/10/27/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/03-Transaction%E4%BA%A4%E6%98%93/"/>
      <url>/2022/10/27/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/03-Transaction%E4%BA%A4%E6%98%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Transaction-一个交易的生老病死"><a href="#Transaction-一个交易的生老病死" class="headerlink" title="Transaction: 一个交易的生老病死"></a>Transaction: 一个交易的生老病死</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们知道，<strong>Ethereum的基本模型是基于交易的状态机模型</strong>(Transaction-based State Machine)，Transaction是Ethereum执行数据操作的媒介，它主要起到下面的几个作用:</p><ol><li>在Layer-1网络上的Account之间进行Native Token的转账。</li><li>创建新的Contract。</li><li>调用Contract中会修改目标Contract中持久化数据或者间接修改其他Account&#x2F;Contract数据的函数。</li></ol><p>这里我们对Transaction的功能性的细节再进行一些额外的补充。首先，<strong>Transaction只能创建Contract账户，而不能用于创建外部账户</strong>(EOA)。第二，<strong>如果调用Contract中的只读函数，是不需要构造Transaction</strong>的。相对的，所有参与Account&#x2F;Contract数据修改的操作都需要通过Transaction来进行。第三，广义上的Transaction只能由外部账户(EOA)构建。Contract是没有办法显式构造Layer-1层面的交易的。在某些合约函数的执行过程中，Contract在可以通过构造internal transaction来与其他的合约进行交互，但是这种Internal transaction与我们提到的Layer-1层面的交易有所不同，我们会在之后的章节介绍。</p><h2 id="LegacyTx-AccessListTX-DynamicFeeTx"><a href="#LegacyTx-AccessListTX-DynamicFeeTx" class="headerlink" title="LegacyTx &amp; AccessListTX &amp; DynamicFeeTx"></a>LegacyTx &amp; AccessListTX &amp; DynamicFeeTx</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/types/transaction.go</span></span><br><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line"> inner TxData    <span class="comment">// 交易的共识内容</span></span><br><span class="line"> time  time.Time <span class="comment">// 首次在本地看到的时间(避免垃圾邮件)</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 缓存</span></span><br><span class="line"> hash atomic.Value</span><br><span class="line"> size atomic.Value</span><br><span class="line"> from atomic.Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们需要重点关注一下<code>inner</code>这个变量。目前与Transaction直接相关的数据都由这个变量来维护。</p><p>目前，<code>TxData</code>类型是一个接口，它的定义如下面的代码所示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TxData <span class="keyword">interface</span> &#123;</span><br><span class="line">txType() <span class="type">byte</span> <span class="comment">// returns the type ID</span></span><br><span class="line"><span class="built_in">copy</span>() TxData <span class="comment">// 创建一个深拷贝和初始化所有字段</span></span><br><span class="line"></span><br><span class="line">chainID() *big.Int</span><br><span class="line">accessList() AccessList</span><br><span class="line">data() []<span class="type">byte</span></span><br><span class="line">gas() <span class="type">uint64</span></span><br><span class="line">gasPrice() *big.Int</span><br><span class="line">gasTipCap() *big.Int</span><br><span class="line">gasFeeCap() *big.Int</span><br><span class="line">value() *big.Int</span><br><span class="line">nonce() <span class="type">uint64</span></span><br><span class="line">to() *common.Address</span><br><span class="line">blobGas() <span class="type">uint64</span></span><br><span class="line">blobGasFeeCap() *big.Int</span><br><span class="line">blobHashes() []common.Hash</span><br><span class="line"></span><br><span class="line">rawSignatureValues() (v, r, s *big.Int)</span><br><span class="line">setSignatureValues(chainID, v, r, s *big.Int)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在给定包含区块baseFee的情况下，计算交易支付的gas价格。</span></span><br><span class="line">    <span class="comment">//不像其他TxData方法，返回*大。Int应该是计算值的独立副本，即允许调用者改变结果。</span></span><br><span class="line">    <span class="comment">//方法实现可以使用&#x27;dst&#x27;来存储结果。</span></span><br><span class="line">effectiveGasPrice(dst *big.Int, baseFee *big.Int) *big.Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来的TxData现在被声明成了一个interface，是为了后续版本的更新中可以对Transaction类型进行更加灵活的修改。目前，在Ethereum中定义了三种类型的Transaction来实现TxData这个接口。按照时间上的定义顺序来说，这三种类型的Transaction分别是，LegacyT，AccessListTx，TxDynamicFeeTx。</p><p>LegacyTx：是原始的Ethereum的Transaction设计</p><p>AccessListTX：是基于EIP-2930(Berlin分叉)的Transaction。</p><p>DynamicFeeTx：是<a href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559</a>(伦敦分叉)生效之后的默认的Transaction。</p><h3 id="LegacyTx"><a href="#LegacyTx" class="headerlink" title="LegacyTx"></a>LegacyTx</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LegacyTx <span class="keyword">struct</span> &#123;</span><br><span class="line"> Nonce    <span class="type">uint64</span>          <span class="comment">// nonce of sender account</span></span><br><span class="line"> GasPrice *big.Int        <span class="comment">// wei per gas</span></span><br><span class="line"> Gas      <span class="type">uint64</span>          <span class="comment">// gas limit</span></span><br><span class="line"> To       *common.Address <span class="string">`rlp:&quot;nil&quot;`</span> <span class="comment">// nil means contract creation</span></span><br><span class="line"> Value    *big.Int        <span class="comment">// wei amount</span></span><br><span class="line"> Data     []<span class="type">byte</span>          <span class="comment">// contract invocation input data</span></span><br><span class="line"> V, R, S  *big.Int        <span class="comment">// signature values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AccessListTX"><a href="#AccessListTX" class="headerlink" title="AccessListTX"></a>AccessListTX</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AccessListTx <span class="keyword">struct</span> &#123;</span><br><span class="line"> ChainID    *big.Int        <span class="comment">// destination chain ID</span></span><br><span class="line"> Nonce      <span class="type">uint64</span>          <span class="comment">// nonce of sender account</span></span><br><span class="line"> GasPrice   *big.Int        <span class="comment">// wei per gas</span></span><br><span class="line"> Gas        <span class="type">uint64</span>          <span class="comment">// gas limit</span></span><br><span class="line"> To         *common.Address <span class="string">`rlp:&quot;nil&quot;`</span> <span class="comment">// nil means contract creation</span></span><br><span class="line"> Value      *big.Int        <span class="comment">// wei amount</span></span><br><span class="line"> Data       []<span class="type">byte</span>          <span class="comment">// contract invocation input data</span></span><br><span class="line"> AccessList AccessList      <span class="comment">// EIP-2930 access list</span></span><br><span class="line"> V, R, S    *big.Int        <span class="comment">// signature values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DynamicFeeTx"><a href="#DynamicFeeTx" class="headerlink" title="DynamicFeeTx"></a>DynamicFeeTx</h3><p>如果我们观察DynamicFeeTx就会发现，DynamicFeeTx的定义其实就是在LegacyTx&#x2F;AccessListTX的定义的基础上额外的增加了GasTipCap与GasFeeCap这两个字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DynamicFeeTx <span class="keyword">struct</span> &#123;</span><br><span class="line"> ChainID    *big.Int</span><br><span class="line"> Nonce      <span class="type">uint64</span></span><br><span class="line"> GasTipCap  *big.Int <span class="comment">// a.k.a. maxPriorityFeePerGas</span></span><br><span class="line"> GasFeeCap  *big.Int <span class="comment">// a.k.a. maxFeePerGas</span></span><br><span class="line"> Gas        <span class="type">uint64</span></span><br><span class="line"> To         *common.Address <span class="string">`rlp:&quot;nil&quot;`</span> <span class="comment">// nil means contract creation</span></span><br><span class="line"> Value      *big.Int</span><br><span class="line"> Data       []<span class="type">byte</span></span><br><span class="line"> AccessList AccessList</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Signature values</span></span><br><span class="line"> V *big.Int <span class="string">`json:&quot;v&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line"> R *big.Int <span class="string">`json:&quot;r&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line"> S *big.Int <span class="string">`json:&quot;s&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Transaction的执行流程"><a href="#Transaction的执行流程" class="headerlink" title="Transaction的执行流程"></a>Transaction的执行流程</h2><p>Transaction的执行主要在发生在两个Workflow中:</p><ol><li><strong>Miner在打包新的Block时。此时Miner会按Block中Transaction的打包顺序来执行其中的Transaction。</strong></li><li><strong>其他节点添加Block到Blockchain时</strong>。当<strong>节点从网络中监听并获取到新的Block时，它们会执行Block中的Transaction</strong>，来更新本地的State Trie的 Root，并与Block Header中的State Trie Root进行比较，来验证Block的合法性。</li></ol><p>一条Transaction执行，可能会涉及到多个Account&#x2F;Contract的值的变化，最终造成一个或多个Account的State的发生转移。在<strong>Byzantium分叉之前的Geth版本中，在每个Transaction执行之后，都会计算一个当前的State Trie Root，并写入到对应的Transaction Receipt中。</strong>这符合以太坊黄皮书中的原始设计。即交易是使得Ethereum状态机发生状态状态转移的最细粒度单位。读者们可能已经来开产生疑惑了，“每个Transaction都会重算一个State Trie Root”的方式岂不是会带来大量的计算(重算一次一个MPT Path上的所有Node)和读写开销(新生成的MPT Node是很有可能最终被持久化到LevelDB中的)？结论是显然的。因此<strong>在Byzantium分叉之后，在一个Block的验证周期中只会计算一次的State Root。</strong>我们仍然可以在<code>state_processor.go</code>找寻到早年代码的痕迹。最终，一个Block中所有Transaction执行的结果使得World State发生状态转移。下面我们就来根据geth代码库中的调用关系，从Miner的视角来探索一个Transaction的生命周期。</p><h3 id="Native-Token-Transferring-Transaction"><a href="#Native-Token-Transferring-Transaction" class="headerlink" title="Native Token Transferring Transaction"></a>Native Token Transferring Transaction</h3><h3 id="Transaction修改Contract的持久化存储的"><a href="#Transaction修改Contract的持久化存储的" class="headerlink" title="Transaction修改Contract的持久化存储的"></a>Transaction修改Contract的持久化存储的</h3><p>在Ethereum中，当Miner开始构造新的区块的时候，首先会启动 <code>mainLoop()</code>函数。具体的函数如下所示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miner/worker.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> mainLoop() &#123;</span><br><span class="line">    ....</span><br><span class="line">    txs := <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]types.Transactions)</span><br><span class="line">    <span class="keyword">for</span> _, tx := <span class="keyword">range</span> ev.Txs &#123;</span><br><span class="line">        acc, _ := types.Sender(w.current.signer, tx)</span><br><span class="line">        txs[acc] = <span class="built_in">append</span>(txs[acc], tx)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里看到，通过NewTransactionsByPriceAndNonce获取一部分的Tx并打包</span></span><br><span class="line">    txset := types.NewTransactionsByPriceAndNonce(w.current.signer, txs, w.current.header.BaseFee)</span><br><span class="line">    tcount := w.current.tcount</span><br><span class="line">    <span class="comment">//提交打包任务</span></span><br><span class="line">    w.commitTransactions(w.current, txset, <span class="literal">nil</span>)        </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Mining新区块前，<strong>Worker首先需要决定，哪些Transaction会被打包到新的Block中</strong>。这里选取Transaction其实经历了两个步骤。首先，**<code>txs</code>变量保存了从Transaction Pool中拿到的合法的交易，以及准备好被打包的交易。**这里举一个例子，来说明什么是准备好被打包的交易，比如Alice先后发了新三个交易到网络中，对应的Nonce分别是100和101，102。假如Miner只收到了100和102号交易。那么对于此刻的Transaction Pool来说Nonce 100的交易就是准备好被打包的交易，交易Nonce 是102需要等待Nonce 101的交易被确认之后才能提交。</p><p>在<strong>Worker会从Transaction Pool中拿出若干的transaction, 赋值给<em>txs</em></strong>之后, 然后<strong>调用<code>NewTransactionsByPriceAndNonce</code>函数按照Gas Price和Nonce对<em>txs</em>进行排序，并将结果赋值给<em>txset</em></strong>。此外在Worker的实例中，还存在<code>fillTransactions</code>函数，为了未来定制化的给Transaction的执行顺序进行排序。</p><p>在<strong>拿到<em>txset</em>之后，mainLoop函数会调用<code>commitTransactions</code>函数，正式进入Mining新区块的流程</strong>。<code>commitTransactions</code>函数如下所示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> commitTransactions(env *environment,txs *types.TransactionsByPriceAndNonce,interrupt *atomic.Int32) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 首先给Block设置最大可以使用的Gas的上限</span></span><br><span class="line">    gasLimit := env.header.GasLimit</span><br><span class="line">    <span class="keyword">if</span> env.gasPool == <span class="literal">nil</span> &#123;</span><br><span class="line">env.gasPool = <span class="built_in">new</span>(core.GasPool).AddGas(gasLimit)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 函数的主体是一个For循环</span></span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">    .....</span><br><span class="line">        <span class="comment">// 如果我们没有足够的gas进行任何进一步的交易，循环结束</span></span><br><span class="line"><span class="keyword">if</span> env.gasPool.Gas() &lt; params.TxGas &#123;</span><br><span class="line">log.Trace(<span class="string">&quot;Not enough gas for further transactions&quot;</span>, <span class="string">&quot;have&quot;</span>, env.gasPool, <span class="string">&quot;want&quot;</span>, params.TxGas)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">        tx := txs.Peek()</span><br><span class="line">        <span class="keyword">if</span> tx == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">// 开始执行交易</span></span><br><span class="line">        env.state.SetTxContext(tx.Hash(), env.tcount)</span><br><span class="line">        logs, err := w.commitTransaction(env, tx)</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>commitTransactions</code>函数的主体是一个for循环，<strong>每次获取结构体切片头部的txs.Peek()的transaction</strong>，并作为参数调用函数miner&#x2F;worker.go的<code>commitTransaction()</code>。<code>commitTransaction()</code>函数如下所示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> commitTransaction(env *environment, tx *types.Transaction) ([]*types.Log, <span class="type">error</span>)&#123;</span><br><span class="line">    <span class="comment">// 在每次commitTransaction执行前都要记录当前StateDB的Snapshot,一旦交易执行失败则基于这个Snapshot进行回滚。</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">snap = env.state.Snapshot()</span><br><span class="line">gp   = env.gasPool.Gas()</span><br><span class="line">)</span><br><span class="line">    <span class="comment">// 调用执行Transaction的函数</span></span><br><span class="line">    receipt, err := core.ApplyTransaction(w.chainConfig, w.chain, &amp;env.coinbase, env.gasPool, env.state, env.header, tx, &amp;env.header.GasUsed, *w.chain.GetVMConfig())</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Blockchain系统中的<strong>Transaction</strong>和DBMS中的Transaction一样，<strong>要么完成要么失败</strong>。所以在调用执行Transaction的函数前，<strong>首先记录了一下当前world state的Snapshot，用于交易失败时回滚操作</strong>。之后调用ApplyTransaction()函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/state_processor.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ApplyTransaction</span><span class="params">(config *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.StateDB, header *types.Header, tx *types.Transaction, usedGas *<span class="type">uint64</span>, cfg vm.Config)</span></span> (*types.Receipt, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 将Transaction 转化为Message的形式</span></span><br><span class="line">    msg, err := TransactionToMessage(tx, types.MakeSigner(config, header.Number, header.Time), header.BaseFee)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建要在EVM环境中使用的新上下文</span></span><br><span class="line">    blockContext := NewEVMBlockContext(header, bc, author)</span><br><span class="line">    vmenv := vm.NewEVM(blockContext, vm.TxContext&#123;&#125;, statedb, config, cfg)</span><br><span class="line">    <span class="comment">// 调用执行Contract的函数</span></span><br><span class="line">    <span class="keyword">return</span> applyTransaction(msg, config, gp, statedb, header.Number, header.Hash(), tx, usedGas, vmenv)</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p><strong>在 ApplyTransaction()函数中首先Transaction会被转换成Message的形式。</strong>在执行每一个Transaction的时候，<strong>都会生成一个新的EVM来执行</strong>。之后调用applyTransaction()函数来执行Message。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/state_processor.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applyTransaction</span><span class="params">(msg *Message, config *params.ChainConfig, gp *GasPool, statedb *state.StateDB, blockNumber *big.Int, blockHash common.Hash, tx *types.Transaction, usedGas *<span class="type">uint64</span>, evm *vm.EVM)</span></span> (*types.Receipt, <span class="type">error</span>) &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 将交易应用到当前状态(包含在环境中)。</span></span><br><span class="line">    result, err := ApplyMessage(evm, msg, gp)</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>之后调用ApplyMessage()函数。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/state_transition.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ApplyMessage</span><span class="params">(evm *vm.EVM, msg Message, gp *GasPool)</span></span> (*ExecutionResult, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> NewStateTransition(evm, msg, gp).TransitionDb()</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p><strong>之后调用TransitionDb()函数。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/state_transition.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *StateTransition)</span></span> TransitionDb() (*ExecutionResult, <span class="type">error</span>) &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">var</span> contractCreation = msg.To == <span class="literal">nil</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">if</span> contractCreation &#123;</span><br><span class="line">        <span class="comment">//创建合约</span></span><br><span class="line">ret, _, st.gasRemaining, vmerr = st.evm.Create(sender, msg.Data, st.gasRemaining, msg.Value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 增加下一个交易的nonce</span></span><br><span class="line">st.state.SetNonce(msg.From, st.state.GetNonce(sender.Address())+<span class="number">1</span>)</span><br><span class="line">ret, st.gasRemaining, vmerr = st.evm.Call(sender, st.to(), msg.Data, st.gasRemaining, msg.Value)</span><br><span class="line">&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>之后调用Call()函数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/vm/evm.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(evm *EVM)</span></span> Call(caller ContractRef, addr common.Address, input []<span class="type">byte</span>, gas <span class="type">uint64</span>, value *big.Int) (ret []<span class="type">byte</span>, leftOverGas <span class="type">uint64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 执行合约</span></span><br><span class="line">    ret, err = evm.interpreter.Run(contract, input, <span class="literal">false</span>)</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>之后调用Run()函数。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/vm/interpreter.go</span></span><br><span class="line"><span class="comment">// Run循环并使用给定的输入数据计算合约代码，并返回返回的字节片，如果发生错误则返回一个错误。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(in *EVMInterpreter)</span></span> Run(contract *Contract, input []<span class="type">byte</span>, readOnly <span class="type">bool</span>) (ret []<span class="type">byte</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    ....</span><br><span class="line">    op = contract.GetOp(pc)</span><br><span class="line">    operation := in.cfg.JumpTable[op]</span><br><span class="line">    cost = operation.constantGas <span class="comment">// For tracing</span></span><br><span class="line">    <span class="comment">// UseGas 函数：当前剩余的gas减去操作所需gas</span></span><br><span class="line">    <span class="comment">// 剩余的gas小于input直接返回false</span></span><br><span class="line">    <span class="comment">// 否则当前的gas减去操作所需gas并返回true</span></span><br><span class="line">    <span class="keyword">if</span> !contract.UseGas(cost) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrOutOfGas</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">    res, err = operation.execute(&amp;pc, in, callContext)</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在更细粒度的层面<strong>，每个opcode循环调用core&#x2F;vm&#x2F;jump_table.go中的execute函数</strong>。这里值得一提的是，获取Contract中每条Operate的方式，是从Contact中的code数组中按照第n个拿取。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/vm/contract.go</span></span><br><span class="line"><span class="comment">// GetOp返回合约字节数组中的第n个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Contract)</span></span> GetOp(n <span class="type">uint64</span>) OpCode &#123;</span><br><span class="line"> <span class="keyword">return</span> OpCode(c.GetByte(n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>OPCODE的具体实现代码位于core&#x2F;vm&#x2F;instructor.go文件中</strong>。比如，<strong>对Contract中持久化数据修改的OPSSTORE指令的实现位于opStore()函数中</strong>。而<strong>opStore的函数的具体操作又是调用了StateDB中的SetState函数</strong>，将Go-ethereum中的几个主要的模块串联了起来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">opSstore</span><span class="params">(pc *<span class="type">uint64</span>, interpreter *EVMInterpreter, scope *ScopeContext)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    loc := scope.Stack.pop()</span><br><span class="line">    val := scope.Stack.pop()</span><br><span class="line">    <span class="comment">//根据指令跟地址来修改StateDB中某一存储位置的值。</span></span><br><span class="line">    interpreter.evm.StateDB.SetState(scope.Contract.Address(),loc.Bytes32(), val.Bytes32())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//core/state/stateDB</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> SetState(addr common.Address, key, value common.Hash) &#123;</span><br><span class="line">    stateObject := s.GetOrNewStateObject(addr)</span><br><span class="line">    <span class="keyword">if</span> stateObject != <span class="literal">nil</span> &#123;</span><br><span class="line">    stateObject.SetState(s.db, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于一条调用合约函数的交易，其中必然会存在修改StateDB的操作。通过上述的函数调用关系，我们就完成了在一个新区块的形成过程中，Transaction如何修改StateDB的Workflow。</p></blockquote><p>commitTransactions –&gt; commitTransaction –&gt; ApplyTransaction –&gt; applyTransaction –&gt;  ApplyMessage –&gt; TransactionDB –&gt; Call –&gt; Run –&gt; opSstore –&gt; StateDB –&gt; StateObject –&gt; Key-Value-Trie</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">commitTransactions --&gt; commitTransaction --&gt; ApplyTransaction --&gt; applyTransaction --&gt;  ApplyMessage --&gt; TransactionDB --&gt; Call --&gt; Run --&gt; opSstore --&gt; StateDB --&gt; StateObject --&gt; Key-Value-Trie</span><br></pre></td></tr></table></figure><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/img/tx_exec_calls.png" alt="Transaction Execution stack Flow"></p><h2 id="Validator-验证节点如何执行Transaction并更新World-State"><a href="#Validator-验证节点如何执行Transaction并更新World-State" class="headerlink" title="[Validator] 验证节点如何执行Transaction并更新World State"></a>[Validator] 验证节点如何执行Transaction并更新World State</h2><p>而<strong>对于不参与Mining的节点，他们执行Block中Transaction的入口是在core&#x2F;blockchain.go中的InsertChain()函数</strong>。InsertChain函数通过<strong>调用内部函数insertChain</strong>，其中<strong>调用中的core&#x2F;state_processor.go中的Process()函数</strong>。<strong>Process函数的核心在于循环遍历Block中的Transaction</strong>，调<strong>用上述的applyTransaction函数。从这里开始更底层的调用关系就与Mining Workflow中的调用关系相同。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *StateProcessor)</span></span> Process(block *types.Block, statedb *state.StateDB, cfg vm.Config) (types.Receipts, []*types.Log, <span class="type">uint64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">for</span> i, tx := <span class="keyword">range</span> block.Transactions() &#123;</span><br><span class="line">msg, err := TransactionToMessage(tx, signer, header.BaseFee)</span><br><span class="line">statedb.SetTxContext(tx.Hash(), i)</span><br><span class="line">receipt, err := applyTransaction(msg, p.config, gp, statedb, blockNumber, blockHash, tx, usedGas, vmenv)</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="State-based-Blockchain：基于状态的区块链"><a href="#State-based-Blockchain：基于状态的区块链" class="headerlink" title="State-based Blockchain：基于状态的区块链"></a>State-based Blockchain：基于状态的区块链</h2><ul><li>State-based Blockchain 的数据主要由两部分的数据管理模块组成：World State 和 Blockchain。</li><li>State Object是系统中基于K-V结构的基础数据元素。在Ethereum中，State Object是Account。</li><li>World State表示了System中所有State Object的最新值的一个Snapshot，。</li><li>Blockchain是以块为单位的数据结构，每个块中包含了若干Transaction。Blockchain 可以被视为历史交易数据的组合。</li><li>Transaction是Blockchain System中与承载数据更新的载体。通过Transaction，State Object从当前状态切换到另一个状态。</li><li>World State的更新是以Block为单位的。</li></ul><h2 id="Read-Transaction-from-Database：从数据库读取交易"><a href="#Read-Transaction-from-Database：从数据库读取交易" class="headerlink" title="Read Transaction from Database：从数据库读取交易"></a>Read Transaction from Database：从数据库读取交易</h2><p>当我们想要通过Transaction的Hash查询一个Transaction具体的数据的时候，上层的API会调用<code>eth/api_backend.go</code>中的<code>GetTransaction()</code>函数，并最终调用了<code>core/rawdb/accessors_indexes.go</code>中的<code>ReadTransaction()</code>函数来查询。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eth/api_backend.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *EthAPIBackend)</span></span> GetTransaction(ctx context.Context, txHash common.Hash) (*types.Transaction, common.Hash, <span class="type">uint64</span>, <span class="type">uint64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">tx, blockHash, blockNumber, index := rawdb.ReadTransaction(b.eth.ChainDb(), txHash)</span><br><span class="line"><span class="keyword">return</span> tx, blockHash, blockNumber, index, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里值得注意的是，在读取Transaction的时候，<code>ReadTransaction()</code>函数<strong>首先获取了保存该Transaction的函数block body</strong>，并<strong>循环遍历该Block Body中获取到对应的Transaction</strong>。这是因为，虽然<strong>Transaction是作为一个基本的数据结构</strong>(Transaction Hash可以保证Transaction的唯一性)，但是<strong>在写入数据库的时候就是被按照Block Body的形式被整个的打包写入到Database中</strong>的。具体的可以查看<code>core/rawdb/accesssor_chain.go</code>中的<code>WriteBlock()</code>和<code>WriteBody()</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadTransaction</span><span class="params">(db ethdb.Reader, hash common.Hash)</span></span> (*types.Transaction, common.Hash, <span class="type">uint64</span>, <span class="type">uint64</span>) &#123;</span><br><span class="line">blockNumber := ReadTxLookupEntry(db, hash)</span><br><span class="line"><span class="keyword">if</span> blockNumber == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, common.Hash&#123;&#125;, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">blockHash := ReadCanonicalHash(db, *blockNumber)</span><br><span class="line"><span class="keyword">if</span> blockHash == (common.Hash&#123;&#125;) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, common.Hash&#123;&#125;, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 保存该Transaction的函数block body</span></span><br><span class="line">body := ReadBody(db, blockHash, *blockNumber)</span><br><span class="line"><span class="keyword">if</span> body == <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">&quot;Transaction referenced missing&quot;</span>, <span class="string">&quot;number&quot;</span>, *blockNumber, <span class="string">&quot;hash&quot;</span>, blockHash)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, common.Hash&#123;&#125;, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> txIndex, tx := <span class="keyword">range</span> body.Transactions &#123;</span><br><span class="line"><span class="keyword">if</span> tx.Hash() == hash &#123;</span><br><span class="line"><span class="keyword">return</span> tx, blockHash, *blockNumber, <span class="type">uint64</span>(txIndex)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">log.Error(<span class="string">&quot;Transaction not found&quot;</span>, <span class="string">&quot;number&quot;</span>, *blockNumber, <span class="string">&quot;hash&quot;</span>, blockHash, <span class="string">&quot;txhash&quot;</span>, hash)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, common.Hash&#123;&#125;, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 以太坊源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-状态管理</title>
      <link href="/2022/10/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/02-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/02-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="状态管理一-StateDB"><a href="#状态管理一-StateDB" class="headerlink" title="状态管理一: StateDB"></a>状态管理一: StateDB</h1><p> Ethereum State 管理模块中最重要的几个数据结构：<strong>StateDB, Trie，StateTrie，以及 StackTrie</strong>。我们将通过分析Ethereum中的主workflow的方式来深入理解这三个数据结构的使用场景，以及设计上的不同。</p><p>首先，<strong>StateDB是这三个数据结构中最高层的封装</strong>，它是<strong>直接提供了与StateObject (Account，Contract)相关的 CURD 的接口</strong>给其他的模块，比如：</p><ul><li>Mining 模块，执行新 Blockchain 中的交易形成新的 world state。</li><li>Block 同步模块，执行新 Blockchain 中的交易形成新的 world state，与header中的 state root 进行比较验证。</li><li>EVM 中的两个与 Contract 中的持久化存储相关的两个 opcode, sStore, sSload.</li></ul><h2 id="StateDB：状态数据库"><a href="#StateDB：状态数据库" class="headerlink" title="StateDB：状态数据库"></a>StateDB：状态数据库</h2><p>我们可以在 genesis block 创建的相关代码中，找到直接相关的例子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">statedb.Commit(<span class="literal">false</span>)</span><br><span class="line">statedb.Database().TrieDB().Commit(root,<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>具体 World State 的更新顺序是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">StateDB --&gt; Memory_Trie_Database --&gt; LevelDB</span><br></pre></td></tr></table></figure><p>StateDB 调用 <code>Commit</code> 的时候并没有同时触发 <code>TrieDB</code> 的 Commit 。</p><p>在Block被插入到 Blockchain 的这个Workflow中，<strong>stateDB的commit首先在<code>writeBlockWithState</code>函数中被调用了</strong>。之后<code>writeBlockWithState</code>函数会判断 <code>GC</code> 的状态来决定在本次调用中，<strong>是否需要向 <code>Disk Database</code> 写入数据</strong>。</p><h3 id="From-Memory-to-Disk：存储到硬盘"><a href="#From-Memory-to-Disk：存储到硬盘" class="headerlink" title="From Memory to Disk：存储到硬盘"></a>From Memory to Disk：存储到硬盘</h3><p>当新的Block被添加到Blockchain时，State 的数据并不一会立即被写入到 Disk Database 中。在<code>writeBlockWithState</code>函数中，函数会判断 <code>gc</code> 条件，<strong>只有满足一定的条件</strong>，才<strong>会在此刻调用 TrieDB 中的 <code>Cap</code> 或者 <code>Commit</code> 函数将数据写入Disk Database中</strong>。</p><h1 id="状态管理二-World-State-Trie-and-Storage-Trie"><a href="#状态管理二-World-State-Trie-and-Storage-Trie" class="headerlink" title="状态管理二: World State Trie and Storage Trie"></a>状态管理二: World State Trie and Storage Trie</h1><h2 id="Trie-概述"><a href="#Trie-概述" class="headerlink" title="Trie 概述"></a>Trie 概述</h2><p><strong>Trie 结构是 Ethereum 中用于管理数据的基本数据结构</strong>，它被广泛的运用在Ethereum 里的多个模块中，包括管理全局的 <strong>World State Trie</strong>，管理 <strong>Contract中持久化存储的Storage Trie</strong>，以及每个 Block 中的<strong>与交易相关的 Transaction Trie 和 Receipt Trie。</strong></p><p>在以太坊的体系中，广义上的 <strong>Trie 的指的是 Merkel Patricia Trie(MPT)<strong>这种数据结构。在实际的实现中，根据业务功能的不同，在 go-ethereum 中</strong>一共实现了三种不同的MPT的instance</strong>，分别是，<code>Trie</code>，<code>State Trie</code>(<code>Secure Trie</code>) 以及<code>Stack Trie</code>.</p><p>这些Trie在具体实现上的不同点在于，<strong>Transaction Trie本质上并没有使用Trie来管理Transaction的数据</strong>，而是<strong>依赖于MPT的根来快速验证</strong>，具体可以参考<strong>core&#x2F;types&#x2F;hashing.go&#x2F;DeriveSha()函数</strong>来了解Transaction Trie 的<strong>root是如何产生的</strong>，这里的Trie使用的是Stack Trie。</p><p>从调用关系上看 <code>Trie</code> 是最底层的核心结构，它<strong>用于之间负责 StateObject 数据的保存</strong>，以及提<strong>供相应的 CURD 函数</strong>。它的定义在trie&#x2F;trie.go文件中。</p><p><strong>State Trie 结构本质上是对 Trie 的一层封装</strong>。它具体的CURD操作的实现都是通过<code>Trie</code>中定义的函数来执行的。它的定义在<code>trie/secure_trie.go</code>文件中。这个 Trie 也就是我们常说的World State Trie，它是<strong>唯一的一个全局 Trie 结构</strong>。与 Trie 不同的是，<strong>Secure Trie要求新加入的Key-Value pair中的Key 的数据都是Sha过的。</strong>这是为了防止恶意的构造Key来增加MPT的高度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StateTrie <span class="keyword">struct</span> &#123;</span><br><span class="line"> trie             Trie</span><br><span class="line"> preimages        *preimageStore</span><br><span class="line"> hashKeyBuf       [common.HashLength]<span class="type">byte</span></span><br><span class="line"> secKeyCache      <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">byte</span></span><br><span class="line"> secKeyCacheOwner *StateTrie <span class="comment">// 指向self的指针，在不匹配时替换键缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不管是Secure Trie还是Trie，他们的创建的前提是: 更下层的db的实例已经创建成功了，否则就会报错</strong>。</p><p>值得注意的是一个<strong>关键函数Prove(证明构造merkle关键证据。结果包含所有编码节点的路径在关键的值。价值本身也包含在最后一个节点,可以通过验证证明检索)的实现</strong>，并不在这两个Trie的定义文件中，而是位于<code>trie/proof.go</code>文件中。</p><h2 id="Trie-运用"><a href="#Trie-运用" class="headerlink" title="Trie 运用"></a>Trie 运用</h2><h3 id="Read-Operation：读写行动"><a href="#Read-Operation：读写行动" class="headerlink" title="Read Operation：读写行动"></a>Read Operation：读写行动</h3><h3 id="Insert：插入"><a href="#Insert：插入" class="headerlink" title="Insert：插入"></a>Insert：插入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> insert(n node, prefix, key []<span class="type">byte</span>, value node) (<span class="type">bool</span>, node, <span class="type">error</span>) &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Update：更新"><a href="#Update：更新" class="headerlink" title="Update：更新"></a>Update：更新</h3><h3 id="Delete：删除"><a href="#Delete：删除" class="headerlink" title="Delete：删除"></a>Delete：删除</h3><h3 id="Finalize-And-Commit-to-Disk：存储到硬盘"><a href="#Finalize-And-Commit-to-Disk：存储到硬盘" class="headerlink" title="Finalize And Commit to Disk：存储到硬盘"></a>Finalize And Commit to Disk：存储到硬盘</h3><ul><li>在leveldb中保存的是Trie中的节点。</li><li>&lt;hash, node.rlprawdata&gt;</li></ul><p>在Geth中，Trie并不是实时更新的，而是依赖于Committer和Database两个额外的辅助单位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">Trie.Commit --&gt; Committer.Commit --&gt; trie/Database.insert</span><br></pre></td></tr></table></figure><p>我们可以看到Trie的Commit并不会真的对Disk Database的值进行修改。</p><p>Trie真正更新到Disk Database的，是依赖于<code>trie/Database.Commit</code>函数的调用。我们可以在诸多函数中找到这个函数的调用比如。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateChain</span><span class="params">(config *params.ChainConfig, parent *types.Block, engine consensus.Engine, db ethdb.Database, n <span class="type">int</span>, gen <span class="keyword">func</span>(<span class="type">int</span>, *BlockGen)</span></span>) ([]*types.Block, []types.Receipts) &#123;</span><br><span class="line">  ...</span><br><span class="line">   <span class="comment">// Write state changes to db</span></span><br><span class="line">   root, err := statedb.Commit(config.IsEIP158(b.header.Number))</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;state write error: %v&quot;</span>, err))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := statedb.Database().TrieDB().Commit(root, <span class="literal">false</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;trie write error: %v&quot;</span>, err))</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StackTrie"><a href="#StackTrie" class="headerlink" title="StackTrie"></a>StackTrie</h2><p>StackTrie虽然也是MPT结构，但是它与另外的两个Trie最大的不同在于，其<strong>主要作用不是用于存储数据</strong>，而是<strong>用于给一组数据生成证明。</strong>比如，在Block中的Transaction Hash以及Receipt Hash都是基于StackTrie生成的。这里我们使用一个更直观的例子。这个部分的代码位于<em>core&#x2F;block_validator.go</em>中。在block_validator中定义了一系列验证用的函数, 比如<code>ValidateBody</code>和 <code>ValidateState</code>函数。我们选取了这两个函数的其中一部分，如下所示。为了验证Block的合法性，ValidateBody和ValidateState函数分别在本地基于Block中提供的数据来构造Transaction和Receipt的哈希来与Header中的TxHash与ReceiptHash。我们可以发现，<strong>函数<code>types.DeriveSha</code>需要一个<code>TrieHasher</code>类型的参数</strong>。但是在具体调用的时候，<strong>却传入了了一个<code>trie.NewStackTrie</code>类型的变量</strong>。这是因为StackTrie实现了TrieHasher接口所需要的三个函数，所以这种调用是合法的。我们可以在<em>core&#x2F;types&#x2F;hashing.go</em>中找到TrieHasher的定义。这里**<code>DeriveSha</code>不断的向StackTrie中添加数据，并最终返回StackTrie的Root哈希值**。</p><p>同时，我们可以发现，在<strong>调用DeriveSha函数</strong>的时候，我们<strong>每次都会new一个新的StackTrie</strong>作为参数。这也反映出了，<strong>StackTrie的主要作用就是生成验证用的Proof，而不是存储数据。</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *BlockValidator)</span></span> ValidateBody(block *types.Block) <span class="type">error</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">if</span> hash := types.DeriveSha(block.Transactions(), trie.NewStackTrie(<span class="literal">nil</span>)); hash != header.TxHash &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;transaction root hash mismatch: have %x, want %x&quot;</span>, hash, header.TxHash)</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *BlockValidator)</span></span> ValidateState(block *types.Block, statedb *state.StateDB, receipts types.Receipts, usedGas <span class="type">uint64</span>) <span class="type">error</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">// Tre receipt Trie&#x27;s root (R = (Tr [[H1, R1], ... [Hn, Rn]]))</span></span><br><span class="line"> receiptSha := types.DeriveSha(receipts, trie.NewStackTrie(<span class="literal">nil</span>))</span><br><span class="line"> <span class="keyword">if</span> receiptSha != header.ReceiptHash &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid receipt root hash (remote: %x local: %x)&quot;</span>, header.ReceiptHash, receiptSha)</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="State-Trie的更新是什么时候发生的？"><a href="#State-Trie的更新是什么时候发生的？" class="headerlink" title="State Trie的更新是什么时候发生的？"></a>State Trie的更新是什么时候发生的？</h2><p><strong>State Trie的更新</strong>，通常是<strong>指的是基于State Trie中节点值的变化从而重新计算State Trie的Root的Hash值的过程</strong>。目前这一过程是<strong>通过调用StateDB中的<code>IntermediateRoot</code>函数来完成的。</strong></p><p>  我们从三个粒度层面来看待State Trie更新的问题。</p><ul><li>Block 层：<br><strong>在一个新的Block Insert到Blockchain的过程中，State Trie可能会发生多次的更新</strong>。比如，在每次Transaction被执行之后，**<code>IntermediateRoot</code>函数都会被调用<strong>。同时，</strong>更新后的 State Trie的Root值，会被写入到Transaction对应的Receipt中<strong>。请注意，</strong>在调用<code>IntermediateRoot</code>函数时，更新后的值在此时并没有被立刻写入到Disk Database中<strong>。此时的State Trie Root只是基于内存中的数据计算出来的。</strong>真正的Trie数据写盘，需要等到<code>trieDB.Commit</code>函数的执行。**</li><li>Transaction 层：<br>如上面提到的，在每次Transaction执行完成后，系统都会调用一次StateDB的<code>IntermediateRoot</code>函数，来更新State Trie。并且会将更新后的Trie的Root Hash写入到该Transaction对应的Receipt中。这里提一下关于<code>IntermediateRoot</code>函数细节。在<code>IntermediateRoot</code>函数调用时，会<strong>首先更新被修改的Contract的Storage Trie的Root。</strong></li><li>Instruction 层：<br>执行Contract的Instruction，并不会直接的引发State Trie的更新。比如，我们知道，<strong>EVM指令<code>OpSstore</code>会修改Contract中的持久化存储</strong>。这个<strong>指令调用了StateDB中的<code>SetState</code>函数</strong>，并最终<strong>调用了对应的StateObject中的<code>setState</code>函数</strong>。StateObject中的<code>setState</code> 函数并没有直接对Contract的Storage Trie进行更新，而是<strong>将修改的存储对象保存在了StateObject中的<em>dirtyStorage</em> 中</strong>(<em>dirtyStorage</em>是用于缓存Storage Slot数据的Key-Value Map). <strong>Storage Trie的更新是由更上层的函数调用所触发的，比如<code>IntermediateRoot</code>函数，以及<code>StateDB.Commit</code>函数。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 以太坊源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-Accounts账户</title>
      <link href="/2022/10/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/01-Accounts%E8%B4%A6%E6%88%B7/"/>
      <url>/2022/10/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/01-Accounts%E8%B4%A6%E6%88%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="账户"><a href="#账户" class="headerlink" title="账户"></a>账户</h1><p>Accounts包实现了以太坊客户端的<strong>钱包和账户管理</strong>，以太坊的钱包<strong>提供了keyStore模式和usb两种钱包</strong>，在以太坊中，有两种类型的Account，<strong>分别是外部账户(EOA)以及合约账户(Contract)<strong>。在以太坊中，</strong>State 对应的基本数据结构，称为 StateObject</strong>。当StateObject 的值发生了变化时，我们称为<strong>状态转移</strong>。在 Ethereum 的运行模型中，<strong>StateObject 所包含的数据会因为 Transaction 的执行引发数据更新&#x2F;删除&#x2F;创建，引发状态转移</strong>，我们说：StateObject 的状态从当前的 State 转移到另一个 State。</p><h2 id="账号"><a href="#账号" class="headerlink" title="账号"></a>账号</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// accounts/accounts.go</span></span><br><span class="line"><span class="comment">// 一个账号是20个字节的数据。 URL是可选的字段。</span></span><br><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">Address common.Address <span class="string">`json:&quot;address&quot;`</span> <span class="comment">// 从密钥导出的以太坊账户地址</span></span><br><span class="line">URL     URL            <span class="string">`json:&quot;url&quot;`</span>     <span class="comment">// 后端中的可选资源定位器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际代码中，这两种 Account 都是由<code>stateObject</code>这一数据结构定义的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/state/state_object.go</span></span><br><span class="line"><span class="comment">// statobject代表一个正在被修改的以太坊账户</span></span><br><span class="line"><span class="comment">//使用模式如下:首先你需要获取一个状态对象--&gt;通过对象访问和修改帐户值--&gt;调用commit将修改后的存储树写入数据库</span></span><br><span class="line"><span class="keyword">type</span> stateObject <span class="keyword">struct</span> &#123;</span><br><span class="line">address  common.Address <span class="comment">// 对应了一个20字节长的byte类型数组</span></span><br><span class="line">addrHash common.Hash <span class="comment">// ethereum的散列地址的帐户,一个32字节长的byte类型数组</span></span><br><span class="line">data     types.StateAccount</span><br><span class="line">db       *StateDB</span><br><span class="line"><span class="comment">// 写缓存</span></span><br><span class="line">trie Trie <span class="comment">// 存储Tire，在第一次访问时变为非nil</span></span><br><span class="line">code Code <span class="comment">// 合同的字节码,加载时设置代码</span></span><br><span class="line"> <span class="comment">// 这里的Storage 是一个 map[common.Hash]common.Hash</span></span><br><span class="line">originStorage  Storage <span class="comment">// 存储缓存原始条目dedup重写,重置为每笔交易</span></span><br><span class="line">pendingStorage Storage <span class="comment">// 存储条目,需要刷新到磁盘,在整个区块结束后</span></span><br><span class="line">dirtyStorage   Storage <span class="comment">// 存储条目,修改当前交易执行</span></span><br><span class="line"><span class="comment">// 缓存标志.</span></span><br><span class="line"><span class="comment">// 当一个对象标记为自杀,那么它将从单词查找树中删除</span></span><br><span class="line"><span class="comment">// 在“更新”阶段的状态转换</span></span><br><span class="line">dirtyCode <span class="type">bool</span> <span class="comment">// 如果代码已更新，则为True</span></span><br><span class="line">suicided  <span class="type">bool</span></span><br><span class="line">deleted   <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/types.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">HashLength    = <span class="number">32</span></span><br><span class="line">AddressLength = <span class="number">20</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address [AddressLength]<span class="type">byte</span></span><br><span class="line"><span class="keyword">type</span> Hash [HashLength]<span class="type">byte</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/types/state_account.go</span></span><br><span class="line"><span class="keyword">type</span> StateAccount <span class="keyword">struct</span> &#123;</span><br><span class="line">  Nonce    <span class="type">uint64</span><span class="comment">// 该账户发送的交易序号</span></span><br><span class="line">  Balance  *big.Int<span class="comment">// 该账户的余额</span></span><br><span class="line">  Root     common.Hash  <span class="comment">// 当前账户的下Storage层的MPT的Root,管理合约中持久化变量,对于EOA账户这个部分为空值</span></span><br><span class="line">  CodeHash []<span class="type">byte</span><span class="comment">// 该账户的Contract代码的哈希值,对于 EOA账户这个部分为空值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DB:<strong>db这个变量保存了一个 <code>StateDB</code> 类型的指针</strong>。这是<strong>为了方便调用 <code>StateDB</code> 相关的API对Account所对应的 <code>stateObject</code> 进行操作</strong>。StateDB本质上是用于管理<code>stateObject</code>信息的而<strong>抽象出来的内存数据库</strong>。<strong>所有的Account 数据的更新，检索都会使用 StateDB 提供的API。</strong></p><p>Cache:对于剩下的成员变量，它们的<strong>主要用于内存Cache</strong>。<strong>trie用于保存和管理合约账户中的持久化变量存储的数据</strong>，<strong>code用于缓存合约中的代码段到内存中，它是一个byte数组</strong>。剩下的四个Storage 字段主要<strong>在执行 Transaction 的时候缓存合约修改的持久化数据</strong>，比如dirtyStorage 就用于缓存在 Block 被 Finalize 之前，<strong>Transaction所修改的合约中的持久化存储数据</strong>。对于<strong>外部账户，由于没有代码字段，所以对应 stateObject 对象中的code 字段，以及三个 Storage 类型的字段对应的变量的值都为空</strong></p><h3 id="账户生成"><a href="#账户生成" class="headerlink" title="账户生成"></a>账户生成</h3><p>EOA账户的<strong>创建分为本地创建和链上注册</strong>两个部分。当我们使用诸如 Metamask 等钱包工具创建账户的时候，在区块链上并没有同步注册账户信息。<strong>链上账户的创建和管理都是通过<code>StateDB</code>模块来操作的</strong>，因此我们将<code>geth</code>中账户管理部分的代码整合到<code>StateDB</code>模块章节来一起讲述。而<strong>合约账户需要通过 EOA 账户构造特定的交易生成</strong>的。</p><p>函数有一个string类型的passphrase参数，这个<strong>参数仅用于加密本地保存私钥的Keystore文件</strong>，与生成账户的私钥，地址的生成都无关</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// accounts/keystore/keystore.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ks *KeyStore)</span></span> NewAccount(passphrase <span class="type">string</span>) (accounts.Account, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 生成一个账户需要的私钥和公钥对(大量的椭圆曲线加密)</span></span><br><span class="line">   _, account, err := storeNewKey(ks.storage, crand.Reader, passphrase)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> accounts.Account&#123;&#125;, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 立即将帐户添加到缓存中</span></span><br><span class="line">   <span class="comment">// 然后等待文件系统通知来拾取它。</span></span><br><span class="line">   ks.cache.add(account)</span><br><span class="line">   ks.refreshWallets()</span><br><span class="line">   <span class="keyword">return</span> account, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="智能合约Contract"><a href="#智能合约Contract" class="headerlink" title="智能合约Contract"></a>智能合约Contract</h2><p>在外部账户对应的 stateObject 结构体的实例中，有三个 <strong>Storage 类型(<code>map[common.Hash]common.Hash</code>)<strong>的变量是空值，这三个变量是为Contract类型的账户准备的。相比与外部账户，</strong>合约账户额外保存了一个存储层(Storage)用于存储合约代码中持久化的变量的数据。</strong>StateObject 结构体中的声明的三个 <strong>Storage 类型的变量，作为 Contract Storage 层的内存缓存</strong>。</p><p><strong>每个合约都维护了自己的独立的存储空间，用于保存合约中的持久化变量，我们称为 Storage 层。</strong>Storage 层的<strong>基本组成单元称为槽 (Slot)<strong>，Contract 同样</strong>使用 MPT 作为索引树来管理 Storage 层的Slot</strong>。管理<strong>合约账户中 Storage 层 Storage Trie 的根数据被保存在 StateAccount 结构体中的 Root 变量中</strong>，<strong>Storage 层的数据读取和修改是在执行相关 Transaction 的时候</strong>，通过调用 EVM 中的两个专用的<strong>指令<em>OpSload</em>和<em>OpSstore</em>来实际执行</strong>的。关于这两个指令的具体实现原理，我们会在后续的 EVM 章节进行详细的解读。</p><h1 id="钱包"><a href="#钱包" class="headerlink" title="钱包"></a>钱包</h1><ul><li>KeyStore</li><li>Private Key</li><li>助记词</li></ul><p>钱包应该是这里面最重要的一个接口了，具体的钱包也是实现了这个接口，钱包又有所谓的<strong>分层确定性钱包和普通钱包</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// accounts/accounts.go</span></span><br><span class="line"><span class="comment">// Wallet 是指包含了一个或多个账户的软件钱包或者硬件钱包</span></span><br><span class="line"><span class="keyword">type</span> Wallet <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// URL 用来获取这个钱包可以访问的规范路径。 它会被上层使用用来从所有的后端的钱包来排序。</span></span><br><span class="line">URL() URL</span><br><span class="line"><span class="comment">// 用来返回一个文本值用来标识当前钱包的状态。 同时也会返回一个error用来标识钱包遇到的任何错误。</span></span><br><span class="line">Status() (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line"><span class="comment">// Open 初始化对钱包实例的访问。这个方法并不意味着解锁或者解密账户，而是简单地建立与硬件钱包的连接和/或访问衍生种子。.</span></span><br><span class="line"><span class="comment">// passphrase参数可能在某些实现中并不需要。 没有提供一个无passphrase参数的Open方法的原因是为了提供一个统一的接口。 </span></span><br><span class="line"><span class="comment">// 请注意，如果你open了一个钱包，你必须close它。不然有些资源可能没有释放。 特别是使用硬件钱包的时候需要特别注意。</span></span><br><span class="line">Open(passphrase <span class="type">string</span>) <span class="type">error</span></span><br><span class="line"><span class="comment">// Close 释放由Open方法占用的任何资源。</span></span><br><span class="line">Close() <span class="type">error</span></span><br><span class="line"><span class="comment">// Accounts用来获取钱包发现了账户列表。 对于分层次的钱包， 这个列表不会详尽的列出所有的账号， 而是只包含在帐户派生期间明确固定的帐户。</span></span><br><span class="line">Accounts() []Account</span><br><span class="line"><span class="comment">// Contains 返回一个账号是否属于本钱包。</span></span><br><span class="line">Contains(account Account) <span class="type">bool</span></span><br><span class="line"><span class="comment">// Derive尝试在指定的派生路径上显式派生出分层确定性帐户。 如果pin为true，派生帐户将被添加到钱包的跟踪帐户列表中。</span></span><br><span class="line">Derive(path DerivationPath, pin <span class="type">bool</span>) (Account, <span class="type">error</span>)</span><br><span class="line"><span class="comment">// SelfDerive设置一个基本帐户导出路径，从中钱包尝试发现非零帐户，并自动将其添加到跟踪帐户列表中。</span></span><br><span class="line"><span class="comment">// 注意，SelfDerive将递增指定路径的最后一个组件，而不是下降到子路径，以允许从非零组件开始发现帐户。</span></span><br><span class="line"><span class="comment">// 你可以通过传递一个nil的ChainStateReader来禁用自动账号发现。</span></span><br><span class="line">SelfDerive(base DerivationPath, chain ethereum.ChainStateReader)</span><br><span class="line">SignDataWithPassphrase(account Account, passphrase, mimeType <span class="type">string</span>, data []<span class="type">byte</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">SignText(account Account, text []<span class="type">byte</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"><span class="comment">// SignTextWithPassphrase Signtext相同,但是也需要一个密码</span></span><br><span class="line">SignTextWithPassphrase(account Account, passphrase <span class="type">string</span>, hash []<span class="type">byte</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"><span class="comment">// SignTx 请求钱包对指定的交易进行签名。</span></span><br><span class="line">SignTx(account Account, tx *types.Transaction, chainID *big.Int) (*types.Transaction, <span class="type">error</span>)</span><br><span class="line"><span class="comment">// SignHashWithPassphrase请求钱包使用给定的passphrase来签名给定的transaction</span></span><br><span class="line">SignTxWithPassphrase(account Account, passphrase <span class="type">string</span>, tx *types.Transaction, chainID *big.Int) (*types.Transaction, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// accounts/accounts.go</span></span><br><span class="line"><span class="comment">// Backend是一个钱包提供器。 可以包含一批账号。他们可以根据请求签署交易，这样做。</span></span><br><span class="line"><span class="keyword">type</span> Backend <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Wallets获取当前能够查找到的钱包</span></span><br><span class="line"><span class="comment">// 返回的钱包默认是没有打开的。 </span></span><br><span class="line"><span class="comment">//所产生的钱包列表将根据后端分配的内部URL按字母顺序排序。 由于钱包（特别是硬件钱包）可能会打开和关闭，所以在随后的检索过程中，相同的钱包可能会出现在列表中的不同位置。</span></span><br><span class="line">Wallets() []Wallet</span><br><span class="line"><span class="comment">// 订阅创建异步订阅，以便在后端检测到钱包的到达或离开时接收通知。</span></span><br><span class="line">Subscribe(sink <span class="keyword">chan</span>&lt;- WalletEvent) event.Subscription</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// accounts/manager.go</span></span><br><span class="line"><span class="comment">// Manager是一个包含所有东西的账户管理工具。 可以和所有的Backends来通信来签署交易。</span></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">config      *Config                    <span class="comment">// 配置</span></span><br><span class="line">backends    <span class="keyword">map</span>[reflect.Type][]Backend <span class="comment">// 当前注册的后端索引</span></span><br><span class="line">updaters []event.Subscription       <span class="comment">// 钱包更新订阅的所有Backend</span></span><br><span class="line">updates  <span class="keyword">chan</span> WalletEvent           <span class="comment">// Backend钱包更改的订阅接收器</span></span><br><span class="line">    newBackends <span class="keyword">chan</span> newBackendEvent<span class="comment">// 由manager跟踪的传入Backend</span></span><br><span class="line">wallets  []Wallet                   <span class="comment">// 所有已经注册的Backends的钱包的缓存</span></span><br><span class="line">feed event.Feed <span class="comment">// 钱包到达和离开的通知</span></span><br><span class="line">quit <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="type">error</span><span class="comment">// 退出队列</span></span><br><span class="line">    term <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;<span class="comment">//通道在更新循环结束时关闭</span></span><br><span class="line">lock sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 以太坊源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-智能合约</title>
      <link href="/2022/10/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/10-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
      <url>/2022/10/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/10-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="详细学习solidity语言"><a href="#详细学习solidity语言" class="headerlink" title="详细学习solidity语言"></a>详细学习solidity语言</h1><h2 id="挖矿与智能合约执行"><a href="#挖矿与智能合约执行" class="headerlink" title="挖矿与智能合约执行"></a><strong>挖矿与智能合约执行</strong></h2><p><strong>假设全节点要打包一些交易到区块中，其中存在某些交易是对智能合约的调用。全节点应该先执行智能合约再挖矿，</strong></p><p><strong>还是先挖矿获得记账权后执行智能合约？</strong></p><p>挖矿导致三棵树数据结构改变，之前挖到的矿就无效了 所以，在以太坊系统中，必然是<strong>先执行智能合约，后挖矿</strong></p>]]></content>
      
      
      <categories>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11-TheDao</title>
      <link href="/2022/10/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/11-TheDao/"/>
      <url>/2022/10/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/11-TheDao/</url>
      
        <content type="html"><![CDATA[<h1 id="The-DAO"><a href="#The-DAO" class="headerlink" title="The DAO"></a><strong>The DAO</strong></h1><p>日常我们生活中无处不见中心化组织。2016年5月，出现一个致力于众筹投资的Dao——The DAO。该组织为众筹投资基金，只是其资金来源是通过区块链众筹方式得到，本质上就是一个运行在以太坊上的智能合约。</p><p>如果想要参与其众筹，可以将自己的以太币发送到该智能合约换回The DAO的代币。当需要决定投资哪一个项目时，由代币持有者进行投票表决，每位参与者投票的权重由代笔多少决定。 当投资获得收益，也根据参与者代币数进行分成。</p><p>考虑到投资者在投资过程中可能需要用钱，需要用代币换回以太币。在The DAO的设计中采用了“拆分(split DAO)”实现这一功能。其并非单纯取回收益，而是采用生成child DAO的方法。这样可以保证小部分人的意志不被大多数人所覆盖。小部分人可以通过拆分出自己的child DAO，从而从The DAO中独立出来，收回代币换回以太币转入相应子基金中，从而方便小众化人群进行期望的投资。极端方式下，child DAO中只有一个人，这个人将钱投资给自己从而取回自己的投资与收益。拆分前有7天的讨论期，大家可以讨论拆分是否好并决定是否加入拆分。拆分之后，有28天锁定期，28天后才能取出这些以太币。也正是这28天的锁定期，给了以太坊补救时间（惊变28天）。</p><p><strong>方案1：从发生攻击的区块前一个区块处进行分叉，使得新分支最终超越原有分支可行吗？</strong></p><img src="/noteimg/区块链/以太坊/img/image-20230107130834433.png" alt="image-20230107130834433" style="zoom:67%;" /> <p>如果这样做，上面那条链上黑客攻击的交易和其他合法交易都被回滚了，这就是代价，因此该方案不可行。</p><p><strong>方案2：锁定黑客账户，以太坊团队发布一个升级，要求凡是与The DAO基金账户相关的账户均不被允许进行任何交易。发布后，大多数矿工都升级了这一软件，接受了这一措施。</strong></p><p>然而升级后的软件存在一个与汽油费相关的bug：在收到一个区块发现其中包含与The DAO账户相关交易，那么还需要收取汽油费吗？直觉告诉我们似乎不应该要，以太坊社区这一升级也遵循了这一直觉，没有收取汽油费。这导致攻击者可以以极低的成本，发起大量的这类”非法交易“请求，导致矿工打包的区块频繁不被认可。</p><p><strong>方案3：设法从黑客账户中退回盗取的以太币</strong></p><p>以太坊发布了新的升级，将The DAO账户的资金强行转入到一个新的智能合约中，而该智能合约只有<strong>退钱</strong>这一功能。支持者与反对者进行了激烈争论。为此，开发团队开发了一个智能合约对此进行投票。最终结果是，大多数人支持进行硬分叉，大多数矿工也接受了这一升级，大家便开始等待挖出第192w个区块这一历史性时刻。</p><h2 id="后幕"><a href="#后幕" class="headerlink" title="后幕"></a>后幕</h2><p>硬分叉之后，原有的旧链并未消亡，仍然有许多矿工留在上面继续挖矿，与之前相比唯一区别就是算力大幅下降到不足原有的1&#x2F;10，而这也使得挖矿难度大大下降。</p><p>之后，一些交易所开始上市旧链上的以太币。未分叉之前以太币称为ETH，在硬分叉之后，新的链继承了”ETH“这一名称，而旧链上则称为”ETC“，即”以太坊经典“。在这条旧链上挖矿的人有因为难度下降而来的，也有因为信仰而坚持认为旧链才是根正苗红的去中心化以太坊者。以太坊上交易所后，由于以太坊开发团队支持新链，大多数人对ETC的前景并不看好——ETH还能存在多久？然而，两条链之后逐步通过chainId进行了区分，并共同存活了下去。</p>]]></content>
      
      
      <categories>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12-反思</title>
      <link href="/2022/10/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/12-%E5%8F%8D%E6%80%9D/"/>
      <url>/2022/10/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/12-%E5%8F%8D%E6%80%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="关于智能合约的反思"><a href="#关于智能合约的反思" class="headerlink" title="关于智能合约的反思"></a><strong>关于智能合约的反思</strong></h1><h3 id="❓-Is-smart-contract-really-smart？"><a href="#❓-Is-smart-contract-really-smart？" class="headerlink" title="❓ Is smart contract really smart？"></a><strong>❓ Is smart contract really smart？</strong></h3><p>智能合约与人工智能无关，其本质上是”自动合约“——以事先写好代码自动执行相应规则。因此，智能合约并不智能，写好之后就不可以再进行修改，实际上就相当于一个”代码合同“。</p><h3 id="反思一：smart-contract-is-anything-but-smart"><a href="#反思一：smart-contract-is-anything-but-smart" class="headerlink" title="反思一：smart contract is anything but smart"></a>反思一：smart contract is anything but smart</h3><p>正是区块链的不可篡改性，导致对The DAO中的bug也无法进行修改，最终酿就以太坊的硬分叉。设想你发现银行卡信息被盗，第一反应是通知银行将账户进行冻结。但如果在区块链上，你就只能眼睁睁看着账户中的钱被转移走。</p><p><strong>当时1&#x2F;3的钱被黑客转走后，除了联系以太坊团队还能怎么补救？</strong></p><p>由于无法阻止其他人继续调用智能合约，因此必须将智能合约中的钱转走。而智能合约并没有提供转走钱的方法，那就只能通过黑客的方法将剩余资金转移到新账户中。</p><h3 id="反思二：Irrevocability-is-a-double-edged-sword"><a href="#反思二：Irrevocability-is-a-double-edged-sword" class="headerlink" title="反思二：Irrevocability is a double edged sword"></a>反思二：Irrevocability is a double edged sword</h3><p>我们说不可篡改性是双刃剑，但真的有什么是不可篡改的吗？分叉攻击不就是一种篡改方式吗？以太坊团队通过软件升级强行修改账户状态，实现在未经他人许可下转走别人的钱。因此，不要迷信区块链的不可篡改性，毕竟，代码是死的，而人是活的。没有什么无法被修改。一般来说，区块链上内容难以篡改，但真正遇到类似The DAO这类重大事件，真正想要修改还是可以实现的。</p><h3 id="反思三：Nothing-is-irrevocability"><a href="#反思三：Nothing-is-irrevocability" class="headerlink" title="反思三：Nothing is irrevocability"></a>反思三：Nothing is irrevocability</h3><p>没有任何东西是不可篡改的</p><h1 id="关于语言设计的反思"><a href="#关于语言设计的反思" class="headerlink" title="关于语言设计的反思"></a><strong>关于语言设计的反思</strong></h1><p>为什么会出现”重入攻击“？某种意义上来说，solidity语言的特性是反人类直觉的。一般意义上，A给B转账，B不可能会反过来调用A。然而solidity语言中，A给B转账等于隐性调用了B的failback()函数，而B可以通过fallback()来反过来调用A。由于这与人类常识不符，便容易忽视掉这一漏洞。</p><p>有人提出，应该使用函数式的编程语言，因为函数式语言较为安全，不容易出现类似的安全漏洞，且长远来看，要实现对智能合约理论上正确性的证明。然而，虽然solidity设计存在缺陷，但是否需要采用函数式编程仍然有待探讨。</p><h3 id="反思四：Is-solidity-the-right-programming-language"><a href="#反思四：Is-solidity-the-right-programming-language" class="headerlink" title="反思四：Is solidity the right programming language?"></a>反思四：Is solidity the right programming language?</h3><p>比特币脚本语言简单、表达能力差，很多功能无法表达出现。而以太坊的编程语言是图灵完备的，凡是计算机程序可以完成的，solidity都可以将其实现。然而，图灵完备的表达能力是一种好事吗？</p><p>有人认为应该选择一种适中的语言，既不要比特币脚本语言那么简单，又不要solidity语言那样图灵完备，希望既可以实现智能合约想要实现的功能，但又不容易出现安全漏洞。然而，找到这样一种语言是困难的，因为设计之初我们无法预料到未来的所有应用场景和所有的安全攻击。</p><p>现实生活中是如何解决的？合同语言不够严谨导致执行出现纠纷，我们并未提供一种专门用于合同编写的专用语言，而是通过提供【模板】来解决。这可能是智能合约未来的发展方向，常用的智能合约可能会出现模板，也可能会出现专门编写智能合约的机构。</p><p><strong>反思五：智能合约的历史较短，未来会逐步走向成熟。</strong></p><h1 id="关于开源的反思"><a href="#关于开源的反思" class="headerlink" title="关于开源的反思"></a><strong>关于开源的反思</strong></h1><p>中心化系统经常是非开源的，好比BAT不会公开他们的软件架构一样。而去中心化需要其他人都执行一致的操作，就必然要开源自己的代码，否则不会被大家所信任。有人认为，开源还有一个好处——安全。因为开源代码被众人所审视，其中出现安全漏洞的可能不大。然而，我们已经观察到智能合约代码出现漏洞，其他领域诸多开源软件也出现了各种问题</p><p>这就引发我们思考：为什么全世界这么多人在看着这些代码，他们还是出现了这么多漏洞呢？（many eyeball fallacy）</p><p>理论上大家都可以去看，然而实际上真正有时间和精力查看的人很少，即使看，也不一定大多数人都又足够的专业知识看出其中隐藏的漏洞。有可能我们都认为世界上这么多人，别人肯定看过了，但实际上大家可能都这么想，没有几个人真正看过开源代码。所以：</p><h3 id="反思六：不要认为开源软件必然比非开源软件安全。"><a href="#反思六：不要认为开源软件必然比非开源软件安全。" class="headerlink" title="反思六：不要认为开源软件必然比非开源软件安全。"></a><strong>反思六：不要认为开源软件必然比非开源软件安全。</strong></h3><h1 id="关于去中心化的反思"><a href="#关于去中心化的反思" class="headerlink" title="关于去中心化的反思"></a><strong>关于去中心化的反思</strong></h1><p>追随区块链技术者，一般也都是去中心化理念的拥护者。这些人对于现实中中心化的弊端有所认识，便追随去中心化这一全新管理模式。这也就是为什么在以太坊推出硬分叉后引发巨大分歧的原因，因为仅凭开发团队通过一个软件升级就可以将别人账上钱强行转走了，这就回到了中心化的老路之上，甚至更加中心化，因为现实中要没收他人财产还需要经过司法程序，28天未必能完成。</p><p>但思考一下，硬分叉是单单依靠以太坊开发团队就可以完成吗？What does decentrtilization mean？</p><p>以太坊团队发布升级为什么最终能够成功？因为绝大多数矿工接受了升级软件，以行动支持了分叉方案。即使如此，以太坊团队仍然不能阻止另外一部分人从旧链转移到新链上来。因此，去中心化不意味着完全拒绝人的干预，不意味着完全不能修改，而是要用去中心化的方法来完成修改。</p><h1 id="关于分叉的反思"><a href="#关于分叉的反思" class="headerlink" title="关于分叉的反思"></a><strong>关于分叉的反思</strong></h1><p>一般认为，分叉是一件坏事，分叉导致原有一条链变成了两条。然而，分叉恰恰是去中心化的体现，在中心化系统中，用户是无法进行分叉的，只能选择放弃和接受。</p><p>关于以太坊为什么被V神创建的故事：</p><p>19岁时，喜爱玩魔兽游戏，然而魔兽世界将术士一个技能改掉了。他多次联系暴雪公司反馈，然而暴雪对此并未进行答复。因此，他放弃游戏并反思中心化的缺点，并决定创建去中心化平台，用户不满意就可以进行分叉。因此，存在分叉，恰恰是民主精神的体现。</p><h1 id="关于去中心化和分布式"><a href="#关于去中心化和分布式" class="headerlink" title="关于去中心化和分布式"></a><strong>关于去中心化和分布式</strong></h1><p>一个去中心化系统必然是分布式的，但分布式未必是去中心化。例如百度、阿里、google等都有着大量的分布式应用，依托于成千数万的服务器运行，但这些都掌握在公司自己手中，这仍然是中心化的。</p><p>比特币、以太坊都属于交易驱动的状态机。特点是使得系统中大量节点，通过付出大量代价共同维护相同的状态；然而常用的分布式是多台机器完成不同的工作，从而联合起来完成一个大的任务，从而实现大于单台机器的运算能力。而状态机是维护所有节点共同状态，多台机器完成同一组操作，即使其中一台机器宕机其余机器仍然可以对外提供完整服务，从而满足一些必须24小时对外提供服务的要求。代价是多态计算机合起来，效率反而小于一台计算机。因此，传统应用状态机场景，机器数量较少，从而减少状态对齐付出的代价。而比特币、以太坊这种控制大规模机器是前所未有的。基于此，可见比特币、以太坊并不适用于大规模计算和大规模存储。智能合约是编写控制逻辑的，只有在互不信任的单位之间需要建立共识的操作才需要写在智能合约中。</p>]]></content>
      
      
      <categories>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>00-geth</title>
      <link href="/2022/10/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/00-geth/"/>
      <url>/2022/10/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/00-geth/</url>
      
        <content type="html"><![CDATA[<h1 id="go-ethereum-的代码库结构"><a href="#go-ethereum-的代码库结构" class="headerlink" title="go-ethereum 的代码库结构"></a>go-ethereum 的代码库结构</h1><p>为了更好的从整体工作流的角度来理解 Ethereum，根据主要的业务功能，我们可以把 <code>go-ethereum</code> 划分成如下几个模块。</p><ul><li>Geth Client 模块</li><li>Core 数据结构模块</li><li>State Management 模块<ul><li>StateDB 模块</li><li>Trie 数据结构模块</li><li>State Optimization (Pruning)</li></ul></li><li>Mining 模块</li><li>EVM 模块</li><li>P2P 网络模块<ul><li>节点数据同步<ul><li>交易数据</li><li>区块数据</li><li>区块链数据</li></ul></li></ul></li><li>Storage 模块<ul><li>抽象数据库层</li><li>LevelDB 调用</li></ul></li><li>…</li></ul><p>目前，go-ethereum 代码库中的主要目录结构如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">cmd/ 以太坊基金会官方开发的一些 Command-line 程序。该目录下的每个子目录都是一个单独运行的 CLI 程序。</span><br><span class="line">   |── clef/ 以太坊官方推出的账户管理程序.</span><br><span class="line">   |── geth/ 以太坊官方的节点客户端。</span><br><span class="line">core/   以太坊核心模块，包括核心数据结构，statedb，EVM 等核心数据结构以及算法实现</span><br><span class="line">   |── rawdb/ db 相关函数的高层封装(在 ethdb 和更底层的 leveldb 之上的封装)</span><br><span class="line">      ├──accessors_state.go 从 Disk Level 读取/写入与 State 相关的数据结构。</span><br><span class="line">   |── state/</span><br><span class="line">      ├── statedb.go  StateDB 是管理以太坊 World State 最核心的代码，用于管理链上所有的 State 相关操作。</span><br><span class="line">      ├── state_object.go state_object 是以太坊账户(包括 EOA &amp; Contract)在 StateDB 具体的实现。</span><br><span class="line">   |── txpool        Transaction Pool 相关的代码。</span><br><span class="line">      |── txpool.go  Transaction Pool 的具体实现。</span><br><span class="line">   |── types/  以太坊中最核心的数据结构</span><br><span class="line">      |── block.go   以太坊 Block 的的数据结构定义与相关函数实现</span><br><span class="line">      |── bloom9.go  以太坊使用的一个 Bloom Filter 的实现</span><br><span class="line">      |── transaction.go 以太坊 Transaction 的数据结构定义与相关函数实现。</span><br><span class="line">      |── transaction_signing.go 用于对 Transaction 进行签名的函数的实现。</span><br><span class="line">      |── receipt.go  以太坊交易收据的实现，用于记录以太坊 Transaction 执行的结果</span><br><span class="line">   |── vm/            以太坊的核心中核心 EVM 相关的一些的数据结构的定义。</span><br><span class="line">      |── evm.go            EVM 数据结构和方法的定义</span><br><span class="line">      |── instructions.go   EVM 指令的具体的定义，核心中的核心中的核心文件。</span><br><span class="line">      |── logger.go   用于追踪 EVM 执行交易过程的日志接口的定义。具体的实现在eth/tracers/logger/logger.go 文件中。</span><br><span class="line">      |── opcode.go   EVM 指令和数值的对应关系。</span><br><span class="line">   |── genesis.go     创世区块相关的函数。每个 geth 客户端/以太坊节点初始化的都需要调用这个模块。</span><br><span class="line">   |── state_processor.go EVM 执行交易的核心代码模块。 </span><br><span class="line">console/</span><br><span class="line">   |── bridge.go</span><br><span class="line">   |── console.go  Geth Web3 控制台的入口</span><br><span class="line">eth/      Ethereum 节点/后端/客户端具体功能定义和实现。例如节点的启动关闭，P2P 网络中交易和区块的同步。</span><br><span class="line">ethdb/    Ethereum 本地存储的相关实现, 包括 leveldb 的调用</span><br><span class="line">   |── leveldb/   Go-Ethereum使用的与 Bitcoin Core version一样的Leveldb作为本机存储用的数据库</span><br><span class="line">internal/ 一些内部使用的工具库的集合，比如在测试用例中模拟 cmd 的工具。在构建 Ethereum 生态相关的工具时值得注意这个文件夹。</span><br><span class="line">miner/</span><br><span class="line">   |── miner.go   矿工模块的实现。</span><br><span class="line">   |── worker.go  Block generation 的实现，包括打包 transaction，计算合法的 Block</span><br><span class="line">p2p/     Ethereum 的P2P模块</span><br><span class="line">   |── params    Ethereum 的一些参数的配置，例如: bootnode 的 enode 地址</span><br><span class="line">   |── bootnodes.go  bootnode 的 enode 地址 like: aws 的一些节点，azure 的一些节点，Ethereum Foundation 的节点和 Rinkeby 测试网的节点</span><br><span class="line">rlp/     RLP的 Encode与 Decode的相关</span><br><span class="line">rpc/     Ethereum RPC客户端的实现</span><br><span class="line">les/     Ethereum light client 轻节点的实现</span><br><span class="line">trie/    Ethereum 中至关重要的数据结构 Merkle Patrica Trie(MPT) 的实现</span><br><span class="line">   |── committer.go    Trie 向 Memory Database 提交数据的工具函数。</span><br><span class="line">   |── database.go     Memory Database，是 Trie 数据和 Disk Database 提交的中间层。同时还实现了 Trie 剪枝的功能。**非常重要**</span><br><span class="line">   |── node.go         MPT中的节点的定义以及相关的函数。</span><br><span class="line">   |── secure_trie.go  基于 Trie 的封装的结构。与 trie 中的函数功能相同，不过secure_trie中的 key 是经过hashKey()函数hash过的，无法通过路径获得原始的 key值 </span><br><span class="line">   |── stack_trie.go   Block 中使用的 Transaction/Receipt Trie 的实现</span><br><span class="line">   |── trie.go         MPT 具体功能的函数实现。</span><br></pre></td></tr></table></figure><h2 id="如何启动Geth节点"><a href="#如何启动Geth节点" class="headerlink" title="如何启动Geth节点"></a>如何启动Geth节点</h2><h3 id="前奏-Geth-Console"><a href="#前奏-Geth-Console" class="headerlink" title="前奏: Geth Console"></a>前奏: Geth Console</h3><p>当我们想要部署一个 Ethereum 节点的时候，最直接的方式就是下载官方提供的发行版的 geth 客户端程序。<code>geth</code>是一个基于 CLI 的应用，启动 <code>geth</code> 和 调用 <code>geth</code> 的功能性 API 需要使用对应的指令来操作。<code>geth</code> 提供了一个相对友好的 console 来方便用户调用各种指令。当我第一次阅读 Ethereum 的文档的时候，我曾经有过这样的疑问，为什么<code>geth</code>是由 Go 语言编写的，但是在官方文档中的 Web3 的API却是基于 Javascript 的调用？</p><p>这是因为 <code>geth</code> 内置了一个 Javascript 的解释器: <em>Goja</em> (interpreter)，来作为用户与 <code>geth</code> 交互的 CLI Console。我们可以在<code>console/console.go</code> 中找到它的定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console/console.go</span></span><br><span class="line"><span class="comment">//控制台是一个JavaScript解释的运行时环境。它是一个完全成熟的JavaScript控制台，通过外部或进程内RPC客户端连接到正在运行的节点。</span></span><br><span class="line"><span class="keyword">type</span> Console <span class="keyword">struct</span> &#123;</span><br><span class="line">client   *rpc.Client         <span class="comment">// RPC client to execute Ethereum requests through</span></span><br><span class="line">jsre     *jsre.JSRE          <span class="comment">// JavaScript runtime environment running the interpreter</span></span><br><span class="line">prompt   <span class="type">string</span>              <span class="comment">// Input prompt prefix string</span></span><br><span class="line">prompter prompt.UserPrompter <span class="comment">// Input prompter to allow interactive user feedback</span></span><br><span class="line">histPath <span class="type">string</span>              <span class="comment">// Absolute path to the console scrollback history</span></span><br><span class="line">history  []<span class="type">string</span>            <span class="comment">// Scroll history maintained by the console</span></span><br><span class="line">printer  io.Writer           <span class="comment">// Output writer to serialize any display strings to</span></span><br><span class="line"></span><br><span class="line">interactiveStopped <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">stopInteractiveCh  <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">signalReceived     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">stopped            <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">wg                 sync.WaitGroup</span><br><span class="line">stopOnce           sync.Once</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="geth-节点的启动流程"><a href="#geth-节点的启动流程" class="headerlink" title="geth 节点的启动流程"></a>geth 节点的启动流程</h3><p>了解 Ethereum，我们首先要了解 Ethereum 客户端 Geth 是怎么运行的。 geth 程序的启动点位于 <code>cmd/geth/main.go/main()</code> 函数处，如下所示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cmd/geth/main.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">if</span> err := app.Run(os.Args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Fprintln(os.Stderr, err)</span><br><span class="line">  os.Exit(<span class="number">1</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到 <code>main()</code> 函数非常的简短，其主要功能就是<strong>启动一个解析 command line命令的工具</strong>: <code>gopkg.in/urfave/cli.v1</code>。继续深入，我们会发现<strong>在 cli app 初始化的时候会调用 <code>app.Action = geth</code></strong> ，来调用 <code>geth()</code> 函数。而 <code>geth()</code> 函数就是用于启动 Ethereum 节点的顶层函数，其代码如下所示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不运行特殊的子命令，geth是进入系统的主要入口点。</span></span><br><span class="line"><span class="comment">//它根据命令行参数创建一个默认节点，并以阻塞模式运行它，等待它被关闭。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">geth</span><span class="params">(ctx *cli.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> args := ctx.Args().Slice(); <span class="built_in">len</span>(args) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid command: %q&quot;</span>, args[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prepare(ctx)</span><br><span class="line">stack, backend := makeFullNode(ctx)</span><br><span class="line"><span class="keyword">defer</span> stack.Close()</span><br><span class="line"></span><br><span class="line">startNode(ctx, stack, backend, <span class="literal">false</span>)</span><br><span class="line">stack.Wait()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 <code>geth()</code> 函数中，有三个比较重要的函数调用，分别是：<code>prepare()</code>，<code>makeFullNode()</code>，以及 <code>startNode()</code>。</strong></p><p><strong><code>prepare()</code> 函数</strong>的实现就在当前的 <code>main.go</code> 文件中。它主要<strong>用于设置一些节点初始化需要的配置</strong>。比如，我们在节点启动时看到的这句话: <em>Starting Geth on Ethereum mainnet…</em> 就是在 <code>prepare()</code> 函数中被打印出来的。</p><p><strong><code>makeFullNode()</code> 函数</strong>的实现位于 <code>cmd/geth/config.go</code> 文件中。它会<strong>将 Geth 启动时的命令的上下文加载到配置中，并生成 <code>stack</code> 和<code>backend</code> 这两个实例</strong>。其中 <strong><code>stack</code> 是一个 Node 类型的实例</strong>，它是<strong>通过 <code>makeFullNode()</code> 函数调用 <code>makeConfigNode()</code> 函数来初始化</strong>的。**<code>Node</code> 是 geth 生命周期中最顶级的实例，它负责管理节点中的 P2P Server, Http Server, Database 等业务非直接相关的高级抽象**。关于 Node 类型的定义位于<code>node/node.go</code>文件中。</p><p>这里的 <strong><code>backend</code> 是一个 <code>ethapi.Backend</code> 类型的接口</strong>，<strong>提供了获取以太坊执行层运行时，所需要的基本函数功能</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// internal/ethapi/backend.go</span></span><br><span class="line"><span class="keyword">type</span> Backend <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// General Ethereum APIs对外提供了查询区块链节点管理对象的接口，例如 `ChainDb()` 返回当前节点的 DB 实例, `AccountManager()`; </span></span><br><span class="line">SyncProgress() ethereum.SyncProgress</span><br><span class="line"></span><br><span class="line">SuggestGasTipCap(ctx context.Context) (*big.Int, <span class="type">error</span>)</span><br><span class="line">FeeHistory(ctx context.Context, blockCount <span class="type">uint64</span>, lastBlock rpc.BlockNumber, rewardPercentiles []<span class="type">float64</span>) (*big.Int, [][]*big.Int, []*big.Int, []<span class="type">float64</span>, <span class="type">error</span>)</span><br><span class="line">ChainDb() ethdb.Database</span><br><span class="line">AccountManager() *accounts.Manager</span><br><span class="line">ExtRPCEnabled() <span class="type">bool</span></span><br><span class="line">RPCGasCap() <span class="type">uint64</span>            <span class="comment">// global gas cap for eth_call over rpc: DoS protection</span></span><br><span class="line">RPCEVMTimeout() time.Duration <span class="comment">// global timeout for eth_call over rpc: DoS protection</span></span><br><span class="line">RPCTxFeeCap() <span class="type">float64</span>         <span class="comment">// global tx fee cap for all transaction related APIs</span></span><br><span class="line">UnprotectedAllowed() <span class="type">bool</span>     <span class="comment">// allows only for EIP155 transactions.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Blockchain 相关的 APIs, 例如链上数据的查询(Block &amp; Transaction), `CurrentHeader(), BlockByNumber(), GetTransaction()`; </span></span><br><span class="line">SetHead(number <span class="type">uint64</span>)</span><br><span class="line">HeaderByNumber(ctx context.Context, number rpc.BlockNumber) (*types.Header, <span class="type">error</span>)</span><br><span class="line">HeaderByHash(ctx context.Context, hash common.Hash) (*types.Header, <span class="type">error</span>)</span><br><span class="line">HeaderByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*types.Header, <span class="type">error</span>)</span><br><span class="line">CurrentHeader() *types.Header</span><br><span class="line">CurrentBlock() *types.Header</span><br><span class="line">BlockByNumber(ctx context.Context, number rpc.BlockNumber) (*types.Block, <span class="type">error</span>)</span><br><span class="line">BlockByHash(ctx context.Context, hash common.Hash) (*types.Block, <span class="type">error</span>)</span><br><span class="line">BlockByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*types.Block, <span class="type">error</span>)</span><br><span class="line">StateAndHeaderByNumber(ctx context.Context, number rpc.BlockNumber) (*state.StateDB, *types.Header, <span class="type">error</span>)</span><br><span class="line">StateAndHeaderByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*state.StateDB, *types.Header, <span class="type">error</span>)</span><br><span class="line">PendingBlockAndReceipts() (*types.Block, types.Receipts)</span><br><span class="line">GetReceipts(ctx context.Context, hash common.Hash) (types.Receipts, <span class="type">error</span>)</span><br><span class="line">GetTd(ctx context.Context, hash common.Hash) *big.Int</span><br><span class="line">GetEVM(ctx context.Context, msg *core.Message, state *state.StateDB, header *types.Header, vmConfig *vm.Config, blockCtx *vm.BlockContext) (*vm.EVM, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span>)</span><br><span class="line">SubscribeChainEvent(ch <span class="keyword">chan</span>&lt;- core.ChainEvent) event.Subscription</span><br><span class="line">SubscribeChainHeadEvent(ch <span class="keyword">chan</span>&lt;- core.ChainHeadEvent) event.Subscription</span><br><span class="line">SubscribeChainSideEvent(ch <span class="keyword">chan</span>&lt;- core.ChainSideEvent) event.Subscription</span><br><span class="line"></span><br><span class="line"><span class="comment">// Transaction Pool 相关的APIs, 例如发送交易到本节点的 Transaction Pool, 以及查询交易池中的 Transactions, `GetPoolTransaction`。</span></span><br><span class="line">SendTx(ctx context.Context, signedTx *types.Transaction) <span class="type">error</span></span><br><span class="line">GetTransaction(ctx context.Context, txHash common.Hash) (*types.Transaction, common.Hash, <span class="type">uint64</span>, <span class="type">uint64</span>, <span class="type">error</span>)</span><br><span class="line">GetPoolTransactions() (types.Transactions, <span class="type">error</span>)</span><br><span class="line">GetPoolTransaction(txHash common.Hash) *types.Transaction</span><br><span class="line">GetPoolNonce(ctx context.Context, addr common.Address) (<span class="type">uint64</span>, <span class="type">error</span>)</span><br><span class="line">Stats() (pending <span class="type">int</span>, queued <span class="type">int</span>)</span><br><span class="line">TxPoolContent() (<span class="keyword">map</span>[common.Address][]*types.Transaction, <span class="keyword">map</span>[common.Address][]*types.Transaction)</span><br><span class="line">TxPoolContentFrom(addr common.Address) ([]*types.Transaction, []*types.Transaction)</span><br><span class="line">SubscribeNewTxsEvent(<span class="keyword">chan</span>&lt;- core.NewTxsEvent) event.Subscription</span><br><span class="line"></span><br><span class="line">ChainConfig() *params.ChainConfig</span><br><span class="line">Engine() consensus.Engine</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is copied from filters.Backend eth/filters needs to be initialized from this backend type, so methods needed by</span></span><br><span class="line"><span class="comment">// it must also be included here.</span></span><br><span class="line">GetBody(ctx context.Context, hash common.Hash, number rpc.BlockNumber) (*types.Body, <span class="type">error</span>)</span><br><span class="line">GetLogs(ctx context.Context, blockHash common.Hash, number <span class="type">uint64</span>) ([][]*types.Log, <span class="type">error</span>)</span><br><span class="line">SubscribeRemovedLogsEvent(ch <span class="keyword">chan</span>&lt;- core.RemovedLogsEvent) event.Subscription</span><br><span class="line">SubscribeLogsEvent(ch <span class="keyword">chan</span>&lt;- []*types.Log) event.Subscription</span><br><span class="line">SubscribePendingLogsEvent(ch <span class="keyword">chan</span>&lt;- []*types.Log) event.Subscription</span><br><span class="line">BloomStatus() (<span class="type">uint64</span>, <span class="type">uint64</span>)</span><br><span class="line">ServiceFilter(ctx context.Context, session *bloombits.MatcherSession)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前 Geth 代码库中，有两个 <code>ethapi.Backend</code> 接口的实现，分别是: 1. 位于 <code>eth\api_backend</code> 中的 <code>EthAPIBackend</code>; 2. 位于 <code>les\api_backend</code> 的 <code>LesApiBackend</code>; 顾名思义，**<code>EthAPIBackend</code> 提供了针对全节点的 Backend API 服务, 而 <code>LesApiBackend</code> 提供了轻节点的 Backend API 服务**。总结的来说，如果读者想定制一些新的 RPC API，可以在 <code>ethapi.Backend</code> 接口中定义函数，并给 <code>EthAPIBackend</code> 添加具体的实现。</p><p>读者可能会发现，<code>ethapi.Backend</code> 接口所提供的函数功能，主要读写本地的维护的数据结构(i.e. Transaction Pool, Blockchain)的为主。那么作为一个有网络连接的 Backend, 以太坊的 Backend 或者说 Node 是怎么管理以太坊执行层节点的网络连接，共识等功能模块的呢？</p><p>我们深入 <code>makeFullNode()</code> 函数可以发现，<strong>生成<code>ethapi.Backend</code> 接口的语句 <code>backend, eth := utils.RegisterEthService(stack, &amp;cfg.Eth)</code>, 还返回了另一个 <code>Ethereum</code> 类型的实例 <code>eth</code>。 这个 <code>Ethereum</code> 类型才是以太坊节点数结构中核心中的核心，它实现了以太坊全节点所需要的所有的 Service。</strong>它负责提供更为具体的以太坊的功能性 Service, 负责与以太坊业务直接相关的抽象，比如维护 Blockchain 的更新，共识算法，从 P2P 网络中同步区块，同步P2P节点远端的交易并放到交易池中，等业务功能。我们会在后续详细讲解 <code>Ethereum</code> 类型具体提供的服务。</p><p><code>Ethereum</code> 实例根据上下文的配置信息在调用 <code>utils.RegisterEthService()</code> 函数生成。<strong>在<code>utils.RegisterEthService()</code>函数中，首先会根据当前的config来判断需要生成的Ethereum backend 的类型，是 light node backend 还是 full node backend。</strong>我们可以在 <code>eth/backend/new()</code> 函数和 <code>les/client.go/new()</code> 中找到这两种 Ethereum backend 的实例是如何初始化的。Ethereum backend 的实例定义了一些更底层的配置，比如chainid，链使用的共识算法的类型等。这两种后端服务的一个典型的区别是 light node backend 不能启动 Mining 服务。<strong>在 <code>utils.RegisterEthService()</code> 函数的最后，调用了 <code>Nodes.RegisterAPIs()</code> 函数，将刚刚生成的 backend 实例注册到 <code>stack</code> 实例中。</strong></p><p>总结的说，**<code>api_backend</code> 主要是用于对外提供查询，或者与后端功能性生命周期无关的函数<strong>，</strong><code>Ethereum</code> 这类的节点层的后端，主要用于管理&#x2F;控制节点后端的生命周期**。</p><p>最后一个关键函数，**<code>startNode()</code> 的作用是正式的启动一个以太坊执行层的节点<strong>。它通过</strong>调用 <code>utils.StartNode()</code> 函数来触发 <code>stack.Start()</code> 函数来启动<code>Stack</code>实例(Node)<strong>。</strong>在 <code>stack.Start()</code> 函数中，会遍历 <code>Node.lifecycles</code> 中注册的后端实例，并启动它们<strong>。此外，在 <code>startNode()</code> 函数中，还是</strong>调用了<code>unlockAccounts()</code> 函数，并将解锁的钱包注册到 <code>stack</code> 中，以及通过 <code>stack.Attach()</code> 函数创建了与 local Geth 交互的 RPClient 模块。**</p><p><strong>在 <code>geth()</code> 函数的最后，函数通过执行 <code>stack.Wait()</code>，使得主线程进入了阻塞状态，其他的功能模块的服务被分散到其他的子协程中进行维护。</strong></p><h3 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h3><p>正如我们前面提到的，Node 类型在 geth 的生命周期性中属于顶级实例，它负责作为与外部通信的高级抽象模块的管理员，比如管理 rpc server，http server，Web Socket，以及 P2P Server外 部接口。同时，Node 中维护了节点运行所需要的后端的实例和服务 (<code>lifecycles  []Lifecycle</code>)，例如我们上面提到的负责具体 Service 的<code>Ethereum</code> 类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node/node.go</span></span><br><span class="line"><span class="comment">// Node是一个可以注册服务的容器。</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">eventmux      *event.TypeMux</span><br><span class="line">config        *Config</span><br><span class="line">accman        *accounts.Manager</span><br><span class="line">log           log.Logger</span><br><span class="line">keyDir        <span class="type">string</span>            <span class="comment">//密钥存储目录</span></span><br><span class="line">keyDirTemp    <span class="type">bool</span>              <span class="comment">//如果为true, key目录将被Stop删除</span></span><br><span class="line">dirLock       fileutil.Releaser <span class="comment">//防止并发使用实例目录</span></span><br><span class="line">stop          <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;     <span class="comment">//通道等待终止通知</span></span><br><span class="line">server        *p2p.Server       <span class="comment">//当前运行的P2P网络层</span></span><br><span class="line">startStopLock sync.Mutex        <span class="comment">//启动/停止由一个额外的锁保护</span></span><br><span class="line">state         <span class="type">int</span>               <span class="comment">//跟踪节点生命周期的状态</span></span><br><span class="line"></span><br><span class="line">lock          sync.Mutex</span><br><span class="line">lifecycles    []Lifecycle <span class="comment">//所有有生命周期的注册后端、服务和辅助服务</span></span><br><span class="line">rpcAPIs       []rpc.API   <span class="comment">//节点当前提供的API列表</span></span><br><span class="line">http          *httpServer <span class="comment">//</span></span><br><span class="line">ws            *httpServer <span class="comment">//</span></span><br><span class="line">httpAuth      *httpServer <span class="comment">//</span></span><br><span class="line">wsAuth        *httpServer <span class="comment">//</span></span><br><span class="line">ipc           *ipcServer  <span class="comment">//保存ipc http服务器信息</span></span><br><span class="line">inprocHandler *rpc.Server <span class="comment">//进程内RPC请求处理程序处理API请求</span></span><br><span class="line"></span><br><span class="line">databases <span class="keyword">map</span>[*closeTrackingDB]<span class="keyword">struct</span>&#123;&#125; <span class="comment">//所有打开的数据库</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关闭节点"><a href="#关闭节点" class="headerlink" title="关闭节点"></a>关闭节点</h4><p>在前面我们提到，整个程序的主线程因为调用了 <code>stack.Wait()</code> 而进入了阻塞状态。我们可以看到 <strong>Node 结构中声明了一个叫做 <code>stop</code> 的 channel。由于这个 Channel 一直没有被赋值，所以整个 geth 的主进程才进入了阻塞状态，持续并发的执行其他的业务协程。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待阻塞，直到节点关闭。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> Wait() &#123;</span><br><span class="line"> &lt;-n.stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当 <code>n.stop</code> 这个 Channel 被赋予值的时候，<code>geth</code> 主函数就会停止当前的阻塞状态，并开始执行相应的一系列的资源释放的操作</strong>。</p><p>值得注意的是，在目前的 go-ethereum 的 codebase 中，并没有直接通过给 <code>stop</code> 这个 channel 赋值方式来结束主进程的阻塞状态，而是使用一种更简洁粗暴的方式: 调用 <code>close()</code> 函数直接关闭 Channel。我们可以在 <code>node.doClose()</code> 找到相关的实现。<code>close()</code> 是 go 语言的原生函数，用于关闭 Channel 时使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// doClose释放New()获取的资源，收集错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> doClose(errs []<span class="type">error</span>) <span class="type">error</span> &#123;</span><br><span class="line">.....</span><br><span class="line"><span class="comment">// 解锁n.wait</span></span><br><span class="line"><span class="built_in">close</span>(n.stop)</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ethereum-后端设计"><a href="#Ethereum-后端设计" class="headerlink" title="Ethereum 后端设计"></a>Ethereum 后端设计</h3><p>我们可以在 <code>eth/backend.go</code> 中找到 <code>Ethereum</code> 这个结构体的定义。这个结构体包含的成员变量以及接收的方法实现了一个 Ethereum full node 所需要的全部功能和数据结构。我们可以在下面的代码定义中看到，Ethereum结构体中包含 <code>TxPool</code>，<code>Blockchain</code>，<code>consensus.Engine</code>，<code>miner</code>等最核心的几个数据结构作为成员变量，我们会在后面的章节中详细的讲述这些核心数据结构的主要功能，以及它们的实现的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现以太坊全节点服务</span></span><br><span class="line"><span class="keyword">type</span> Ethereum <span class="keyword">struct</span> &#123;</span><br><span class="line">config *ethconfig.Config</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handlers</span></span><br><span class="line">txPool *txpool.TxPool</span><br><span class="line"></span><br><span class="line">blockchain         *core.BlockChain</span><br><span class="line">handler            *handler</span><br><span class="line">ethDialCandidates  enode.Iterator</span><br><span class="line">snapDialCandidates enode.Iterator</span><br><span class="line">merger             *consensus.Merger</span><br><span class="line"></span><br><span class="line"><span class="comment">// DB interfaces</span></span><br><span class="line">chainDb ethdb.Database <span class="comment">// Block chain database</span></span><br><span class="line"></span><br><span class="line">eventMux       *event.TypeMux</span><br><span class="line">engine         consensus.Engine</span><br><span class="line">accountManager *accounts.Manager</span><br><span class="line"></span><br><span class="line">bloomRequests     <span class="keyword">chan</span> <span class="keyword">chan</span> *bloombits.Retrieval <span class="comment">//接收bloom数据检索请求的通道</span></span><br><span class="line">bloomIndexer      *core.ChainIndexer             <span class="comment">//在块导入期间运行Bloom索引器</span></span><br><span class="line">closeBloomHandler <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">APIBackend *EthAPIBackend</span><br><span class="line"></span><br><span class="line">miner     *miner.Miner</span><br><span class="line">gasPrice  *big.Int</span><br><span class="line">etherbase common.Address</span><br><span class="line"></span><br><span class="line">networkID     <span class="type">uint64</span></span><br><span class="line">netRPCService *ethapi.NetAPI</span><br><span class="line"></span><br><span class="line">p2pServer *p2p.Server</span><br><span class="line"></span><br><span class="line">lock sync.RWMutex <span class="comment">//保护可变字段(例如gas price和etherbase)</span></span><br><span class="line">shutdownTracker *shutdowncheck.ShutdownTracker <span class="comment">//跟踪节点是否正常关闭以及何时关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点启动和停止 Mining 的就是通过调用 <code>Ethereum.StartMining()</code> 和 <code>Ethereum.StopMining()</code> 实现的。设置 Mining 的收益账户是通过调用 <code>Ethereum.SetEtherbase()</code> 实现的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StartMining使用给定的CPU线程数启动miner。如果挖矿已经在运行，该方法会调整允许使用的线程数，并更新事务池所需的最小价格</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Ethereum)</span></span> StartMining() <span class="type">error</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">     <span class="comment">//如果矿工没有运行，初始化它</span></span><br><span class="line">     <span class="keyword">if</span> !s.IsMining() &#123;</span><br><span class="line">          ...</span><br><span class="line">      <span class="keyword">go</span> s.miner.Start(eb)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们额外关注一下 <code>handler</code> 这个成员变量。<code>handler</code> 的定义在 <code>eth/handler.go</code> 中。</p><p>我们从从宏观角度来看，一个节点的主工作流需要: 1.从网络中获取&#x2F;同步 Transaction 和 Block 的数据 2. 将网络中获取到 Block 添加到 Blockchain 中。而 <strong><code>handler</code> 就负责提供中同步区块和交易数据的功能</strong>，例如，**<code>downloader.Downloader</code> 负责从网络中同步 Block ，<code>fetcher.TxFetcher</code> 负责从网络中同步交易**。关于这些方法的具体实现，我们会在后续章节：数据同步中详细介绍。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> handler <span class="keyword">struct</span> &#123;</span><br><span class="line">networkID  <span class="type">uint64</span></span><br><span class="line">forkFilter forkid.Filter <span class="comment">// Fork ID filter, constant across the lifetime of the node</span></span><br><span class="line"></span><br><span class="line">snapSync  atomic.Bool <span class="comment">// Flag whether snap sync is enabled (gets disabled if we already have blocks)</span></span><br><span class="line">acceptTxs atomic.Bool <span class="comment">// Flag whether we&#x27;re considered synchronised (enables transaction processing)</span></span><br><span class="line"></span><br><span class="line">database ethdb.Database</span><br><span class="line">txpool   txPool</span><br><span class="line">chain    *core.BlockChain</span><br><span class="line">maxPeers <span class="type">int</span></span><br><span class="line"></span><br><span class="line">downloader   *downloader.Downloader</span><br><span class="line">blockFetcher *fetcher.BlockFetcher</span><br><span class="line">txFetcher    *fetcher.TxFetcher</span><br><span class="line">peers        *peerSet</span><br><span class="line">merger       *consensus.Merger</span><br><span class="line"></span><br><span class="line">eventMux      *event.TypeMux</span><br><span class="line">txsCh         <span class="keyword">chan</span> core.NewTxsEvent</span><br><span class="line">txsSub        event.Subscription</span><br><span class="line">minedBlockSub *event.TypeMuxSubscription</span><br><span class="line"></span><br><span class="line">requiredBlocks <span class="keyword">map</span>[<span class="type">uint64</span>]common.Hash</span><br><span class="line"></span><br><span class="line"><span class="comment">// channels for fetcher, syncer, txsyncLoop</span></span><br><span class="line">quitSync <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">chainSync *chainSyncer</span><br><span class="line">wg        sync.WaitGroup</span><br><span class="line">peerWG    sync.WaitGroup</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，我们就介绍了 <code>geth</code> 及其所需要的基本模块如何启动的和关闭。我们接下来将视角转入到各个模块中，用细粒度的角度深入探索 Ethereum 的具体实现。</p><h3 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h3><p>这里补充一个Go语言的语法知识: <strong>类型断言</strong>。在<code>Ethereum.StartMining()</code>函数中，出现了<code>if c, ok := s.engine.(*clique.Clique); ok</code> 的写法。这中写法是 Golang 中的语法糖，称为类型断言。具体的语法是 <code>value, ok := element.(T)</code>，它的含义是如果 <code>element</code> 是 <code>T</code> 类型的话，那么ok等于<code>True</code>, <code>value</code> 等于 <code>element</code> 的值。在 <code>if c, ok := s.engine.(*clique.Clique); ok</code> 语句中，就是在判断 <code>s.engine</code> 的是否为 <code>*clique.Clique</code> 类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cli *clique.Clique</span><br><span class="line"><span class="keyword">if</span> c, ok := s.engine.(*clique.Clique); ok &#123;</span><br><span class="line"> cli = c</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> cl, ok := s.engine.(*beacon.Beacon); ok &#123;</span><br><span class="line"> <span class="keyword">if</span> c, ok := cl.InnerEngine().(*clique.Clique); ok &#123;</span><br><span class="line">  cli = c</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 以太坊源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09-权益证明POS</title>
      <link href="/2022/10/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/09-%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8EPOS/"/>
      <url>/2022/10/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/09-%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8EPOS/</url>
      
        <content type="html"><![CDATA[<h2 id="POW机制能耗状况"><a href="#POW机制能耗状况" class="headerlink" title="POW机制能耗状况"></a>POW机制能耗状况</h2><p>比特币和以太坊目前采用的都是POW(工作量证明)机制，但这种方式一直为人所诟病，正在于其浪费电力资源的特点。</p><p><strong>“挖矿”过程消耗了大量的电力资源，这些能耗是必须的吗？</strong><br>矿工挖矿是为了取得出块奖励，获取收益。而系统给予出块奖励的目的是激励矿工参与区块链系统维护，进行记账，而<strong>挖矿本质上是看矿工投入资金来决定的(投入资金买设备-&gt;设备决定算力-&gt;算力比例决定收益)<strong>。<br>那么，为什么不直接拼“钱”呢？现状是用钱购买矿机维护系统稳定，</strong>为什么不大家都将钱投入到系统开发和维护中，而根据投入钱的多少来进行收益分配呢</strong>？这就是<strong>权益证明</strong>的基本思想。</p><h1 id="权益证明"><a href="#权益证明" class="headerlink" title="权益证明"></a>权益证明</h1><p>优点：</p><ol><li>省去了挖矿的过程，也避免了因此产生的能耗和对环境影响，减少了温室气体的排放。</li><li>维护区块链安全的资源形成闭环，而POW中维护其安全的资源需要通过现实中流通的货币购买矿机等设备进去区块链的，这也就导致只要有人想要攻击，只需要外部聚集足够资金就可以攻击成功(小型币种很容易被攻击，也就是在摇篮里就扼杀掉)。可见，POS机制可以有效防御这种情况。</li></ol><blockquote><p>有些币种根据持有币的权益进行挖矿难度调整(实际并不能这么简单设置，因为会导致“旱的旱死，涝的涝死”，需要添加一定限制)，也就是结合POW和POS。可见，POS与POW并不互斥。</p></blockquote><p>当然，权益证明这么好，为什么实际中并未得到大规模应用呢？<br>原因是其中仍然存在很多挑战，例如“双边下注”：</p><blockquote><p>区块链系统产生了分叉，存在两个区块A和B竞争主链时，采用权益证明的方法就是所有持币者对这两个区块投入币进行投票，从而决定哪一个区块成为最长合法链上的区块。假如有一个人，在A和B同时进行了下注。最终A区块胜出，那么他能够获得A区块相应收益，而在B区块进行投票放入的“筹码”也会被退还，这也就导致其每次都能获得收益。</p></blockquote><h2 id="以太坊拟采用的权益证明Casper-the-Friendly-Finality-Gadget-FFG"><a href="#以太坊拟采用的权益证明Casper-the-Friendly-Finality-Gadget-FFG" class="headerlink" title="以太坊拟采用的权益证明Casper the Friendly Finality Gadget(FFG)"></a>以太坊拟采用的权益证明Casper the Friendly Finality Gadget(FFG)</h2><p>Casper协议引入一个概念：Validator(验证者)，一个用户想要成为Validator，需要上交一笔“保证金”，这笔保证金会被系统锁定。</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230107113019330.png" alt="image-20230107113019330"> </p><p>矿工挖矿会获得出块奖励，而验证者也会得到相应奖励。当然，为了防止验证者的不良行为，规定其被发现时要受到处罚。例如某个验证者“行政不作为”，不参与投票导致系统迟迟无法达成共识，这时扣掉部门保证金；如果某个验证者“乱作为”，给两边都进行投票，被发现后没收全部保证金。没收的保证金被销毁，从而减少系统中货币总量。验证者存在“任期”，在任期结束后，进入“等待期”，在此期间等待其他节点检举揭发是否存在不良行为，若通过等待期，则可以取回保证金并获得一定投票奖励。</p>]]></content>
      
      
      <categories>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08-挖矿难度调整</title>
      <link href="/2022/10/05/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/08-%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/"/>
      <url>/2022/10/05/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/08-%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="以太坊难度调整"><a href="#以太坊难度调整" class="headerlink" title="以太坊难度调整"></a>以太坊难度调整</h1><p>比特币难度调整是每隔<strong>2016</strong>区块调整难度，达到维持出块时间15min的目标，而以太坊则与之不同，<strong>每个区块都有可能会进行难度调整</strong></p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230107110402987.png" alt="image-20230107110402987"> </p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230107110756590.png" alt="image-20230107110756590"> </p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230107110736725.png" alt="image-20230107110736725"> </p><h2 id="难度炸弹-迫使矿工从POW（工作量证明）转向POS（权益证明）"><a href="#难度炸弹-迫使矿工从POW（工作量证明）转向POS（权益证明）" class="headerlink" title="难度炸弹(迫使矿工从POW（工作量证明）转向POS（权益证明）)"></a>难度炸弹(迫使矿工从POW（工作量证明）转向POS（权益证明）)</h2><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230107111131519.png" alt="image-20230107111131519"> </p>]]></content>
      
      
      <categories>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07-算法伪代码</title>
      <link href="/2022/10/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/07-%E7%AE%97%E6%B3%95%E4%BC%AA%E4%BB%A3%E7%A0%81/"/>
      <url>/2022/10/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/07-%E7%AE%97%E6%B3%95%E4%BC%AA%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>生成16MB大小的Cache：每个元素产生时与上一个元素相关，Cache初始大小为16MB，每隔30000个块会重新生成seed(对原来的seed求哈希值)，重新生成时增大初始大小的1&#x2F;128—128k</p><img src="/noteimg/区块链/以太坊/img/image-20230106111656271.png" alt="image-20230106111656271" style="zoom:150%;" /> <p>通过Cache生产和曾大数据集第i个元素：初始大小为1G，每隔30000块更新，同时增大初始大小的1&#x2F;128—8M，先通过cache中的第i%cache_size个元素生成初始的mix，因为两个不同的dataset元素可能对应同一个cache中的元素，为了保证每个初始的mix都不同，注意到i也参与了哈希计算。<br>随后循环256次，每次通过get_int_from_item来根据当前的mix值求得下一个要访问的cache元素的下标，用这个cache元素和mix通过make item求得新的mix值。注意到由于初始的mix值都不同，所以访问cache的序列也都是不同的。<br>最终返回mix的哈希值，得到第i个dataset中的元素。</p><img src="/noteimg/区块链/以太坊/img/image-20230106112018841.png" alt="image-20230106112018841" style="zoom:150%;" /> <p>不断调用前边介绍的calc dataset item函数来依次生成dataset中全部full size个元素</p><img src="/noteimg/区块链/以太坊/img/image-20230106112729263.png" alt="image-20230106112729263" style="zoom:150%;" /> <p>矿工：通过区块头、nonce以及DAG求出一个与target比较的值</p><p>轻节点：通过header和nonce求出一个初始的mix然后进入64次循环，根据当前的mix值求出要访问的dataset的元素的下标，然后根据这个下标访问dataset中两个连续的的值</p><blockquote><p>轻节点是临时计算出用到的dataset的元素，而矿工是直接访存，也就是必须在内存里存着这个1G的dataset，</p></blockquote><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230106112856206.png" alt="image-20230106112856206"> </p><p>矿工挖矿的主循环：不断尝试nonce的过程</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230106113814897.png" alt="image-20230106113814897"> </p><p><strong>为何验证只需保存cache，而矿工需要保存大数组DAG?</strong><br>由于矿工需要验证非常多的nonce，如果每次都要从16M的cache中重新生成的话，那挖矿的效率就太低了，而且这里面有大量的重复计算: 随机选取的dataset的元素中有很多是重复的，可能是之前尝试别的nonce时用过的。所以，矿工采取以空间换时间的策略，把整个dataset保存下来。轻节点由于只验证一个nonce，验证的时候就直接生成要用到的dataset中的元素就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06-挖矿算法</title>
      <link href="/2022/09/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/06-%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/06-%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="LiteCoin-莱特币"><a href="#LiteCoin-莱特币" class="headerlink" title="LiteCoin(莱特币)"></a>LiteCoin(莱特币)</h1><p>ASIC Resistance(抗拒ASIC专用矿机)：ASIC芯片相对普通计算机来说，算力强但访问内存性能差距不大，因此常用的方法为Memory Hard Mining Puzzle，即增加对内存访问的需求。</p><blockquote><p>莱特币曾一度成为市值仅次于比特币的第二大货币。其基本设计大体上和比特币一致，但针对挖矿进行了修改。莱特币的puzzle基于Scrypt。Scrypt为一个对内存性能要求较高的哈希函数，之前多用于计算机安全密码学领域。</p></blockquote><h3 id="莱特币挖矿算法基本思想"><a href="#莱特币挖矿算法基本思想" class="headerlink" title="莱特币挖矿算法基本思想"></a>莱特币挖矿算法基本思想</h3><p>1.设置一个很大的数组，按照顺序填充伪随机数。</p><blockquote><p>因为哈希函数的输出我们并不能提前预料，所以看上去就像是一大堆随机的数据，因此称其为“伪随机数”。</p></blockquote><p>Seed为种子节点，通过Seed进行一些运算获得第一个数，之后每个数字都是通过前一个位置的值取哈希得到的。<br>可以看到，这样的数组中取值存在前后依赖关系</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230106105059962.png" alt="image-20230106105059962"> </p><p>2.在需要求解Puzzle的时候，按照伪随机顺序，从数组中读取一些数，每次读取位置与前一个数相关。例如：第一次，从A位置读取其中数据，根据A中数据计算获得下一次读取位置B；第二次,从B位置读取其中数据，根据B中数据计算获得下一次读取位置C；</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230106105248055.png" alt="image-20230106105248055"> </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果数组足够大，对于挖矿矿工来说，必须保存该数组以便查询，否则每次不仅计算位置，还要根据Seed计算整个数组数据，才能查询到对应位置的数据。这对于矿工来说，计算复杂度大幅度上升。<br>当然，矿工可以选择只保存一部分数据，例如：只保存奇数位置数据，偶数位置需要时再根据前一个奇数位置数据计算即可，从而对内存空间大小减少了一半(计算复杂度提高一点，但内存减少一半)。</p><blockquote><p>核心思想：不能仅仅进行运算，增加其对内存的访问，从而实现对ASIC芯片不友好。</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>该方法对Puzzle验证并不是很友好。想要验证该Puzzle，也需要存储该数组，因此对于轻节点来说，并不友好(系统中绝大多数节点为轻节点)，因此，莱特币真正应用来说，数组大小不敢设置太大。例如：对于计算机而言，1G毫无压力，而对于手机APP来说，1G占据空间就过大了。所以，实际中，莱特币系统设计的数组大小仅仅128K大小。</p><h1 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h1><p>以太坊的理念与莱特币相同，都是Memory Hard Mining Puzzle，但具体设计上与莱特币不同。</p><h3 id="以太坊挖矿算法基本思想"><a href="#以太坊挖矿算法基本思想" class="headerlink" title="以太坊挖矿算法基本思想"></a>以太坊挖矿算法基本思想</h3><p>设计了两个数据集（以太坊中这两个数组大小并不固定，因为考虑到计算机内存不断增大，因此该两个数组需要定期增大)，一大一小。小的为16MB的cache，大的数据集为1G的dataset(DAG)。其关系为，1G的数据集是通过16MB数据集生成而来的。</p><blockquote><p>为了便于进行验证，轻节点保存16MB的Cache进行验证即可，而矿工为了减少重复计算则需要存储1GB大小的大数据集。</p></blockquote><p>1.16MB的小Cache通过Seed进行一些运算获得第一个数，之后每个数字都是通过前一个位置的值取哈希获得的。</p><p>2.大的数组中每个元素都是从小数组中按照伪随机顺序读取一些元素，方法同莱特币中相同。如第一次读取A位置数据，对当前哈希值更新迭代算出下一次读取位置B，再进行哈希值更新迭代计算出C位置元素。如此来回迭代读取256次，最终算出一个数作为DAG中第一个元素，如此类推，DAG中每个元素生成方式都依次类推。</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230106105918282.png" alt="image-20230106105918282"> </p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>轻节点只保存小的cache，验证时进行计算即可。但对于挖矿来说，如果这样则大部分算力都花费在了通过Cache计算DAG上面，因此，其必须保存大的数组DAG以便于更快挖矿。</p><h3 id="以太坊挖矿过程："><a href="#以太坊挖矿过程：" class="headerlink" title="以太坊挖矿过程："></a>以太坊挖矿过程：</h3><p>根据区块block header和其中的Nonce值计算一个初始哈希，根据其映射到某个初始位置A，读取A位置的数及其相邻的后一个位置A’上的数,根据该两个数进行运算，算得下一个位置B，读取B和B’位置上的数，依次类推，迭代读取64次，共读取128个数。<br><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230106110057457.png" alt="image-20230106110057457"><br>最后，计算出一个哈希值与挖矿难度目标阈值比较，若不符合就重新更换Nonce，重复以上操作直到最终计算哈希值符合难度要求或当前区块已经被挖出。</p><blockquote><p>目前以太坊挖矿以GPU为主，可见其设计较为成功，当然，以太坊实现ASIC Resistance除了挖矿算法设计之外，还存在另外一个原因，即其预期从<strong>工作量证明(POW)<strong>转向</strong>权益证明(POS)</strong></p></blockquote><h3 id="权益证明-POS-Proof-of-State"><a href="#权益证明-POS-Proof-of-State" class="headerlink" title="权益证明(POS: Proof of State)"></a>权益证明(POS: Proof of State)</h3><p>按照所占权益投票进行共识达成，类似于股份制有限共识按照股份多少投票，权益证明不需要挖矿。但实际上，以太坊目前仍然是POW挖矿共识机制。在设计之初，以太坊开发者就设想要从POW转向POS，并为了防止有矿工不愿意转埋下了一颗“难度炸弹”。但截至目前，以太坊仍然基于POW共识机制。</p>]]></content>
      
      
      <categories>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05-GHOST协议</title>
      <link href="/2022/09/25/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/05-GHOST%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/09/25/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/05-GHOST%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="GHOST协议"><a href="#GHOST协议" class="headerlink" title="GHOST协议"></a>GHOST协议</h1><p>BTC系统中出块时间为10min，而以太坊中出块时间被降低到15s左右，虽然有效提高了系统反应时间和吞吐率，却也导致系统临时性分叉变成常态，且分叉数目更多。这对于共识协议来说，就存在很大挑战。在BTC系统中，不在最长合法链上的节点最后都是作废的，但如果在以太坊系统中，如果这样处理，由于系统中经常性会出现分叉，则矿工挖到矿很大可能会被废弃，这会大大降低矿工挖矿积极性。而对于个人矿工来说，和大型矿池相比更是存在天然劣势。<br>对此，以太坊设计了新的公式协议——<strong>GHOST协议</strong></p><h2 id="最初版本"><a href="#最初版本" class="headerlink" title="最初版本"></a>最初版本</h2><p>如图，假定以太坊系统存在以下情况，A、B、C、D在四个分支上，最后，随着时间推移B所在链成为最长合法链，因此A、C、D区块都作废，但为了补偿这些区块所属矿工所作的工作，给这些区块一些“补偿”，并称其为”Uncle Block”（叔父区块）。<br>规定E区块在发布时可以将A、C、D叔父区块包含进来，A、C、D叔父区块可以得到出块奖励的7&#x2F;8，而为了激励E包含叔父区块，规定E每包含一个叔父区块可以额外得到1&#x2F;32的出块奖励。为了防止E大量包含叔父区块，规定一个区块只能最多包含两个叔父区块，因此E在A、C、D中最多只能包含两个区块作为自己的出块奖励</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230105110213553.png" alt="image-20230105110213553"> </p><blockquote><p> 缺陷：</p><p>1.因为叔父区块最多只能包含两个，如图出现3个怎么办？</p><p>2.矿工自私，故意不包含叔父区块，导致叔父区块7&#x2F;8出块奖励没了，而自己仅仅损失1&#x2F;32。如果甲、乙两个大型矿池存在竞争关系，那么他们可以采用故意不包含对方的叔父区块，因为这样对自己损失小而对对方损失大。</p></blockquote><h2 id="新的版本"><a href="#新的版本" class="headerlink" title="新的版本"></a>新的版本</h2><p>F为E后面一个新的区块。因为规定E最多只能包含两个叔父区块，所以假定E包含了C和D。此时，F也可以将A认为自己的的叔父区块(实际上并非叔父辈的，而是爷爷辈的)。如果继续往下挖，F后的新区块仍然可以包含B同辈的区块(假定E、F未包含完)。这样，就有效地解决了上面提到的最初Ghost协议版本存在的缺陷。</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230105110346865.png" alt="image-20230105110346865"> </p><p>我们将“叔父”这个概念进行了扩展，但问题在于，<strong>“叔父”这一定义隔多少代才好呢</strong>？<br>如下图所示，M为该区块链上一个区块，F为其严格意义上的叔父，E为其严格意义上的“爷爷辈”。以太坊中规定，如果M包含F辈区块，则F获得7&#x2F;8出块奖励；如果M包含E辈区块，则F获得6&#x2F;8出块奖励，以此类推向前。直到包含A辈区块，A获得2&#x2F;8出块奖励，再往前的“叔父区块”，对于M来说就不再认可其为M的”叔父”了。<br>对于M来说，无论包含哪个辈分的“叔父”，得到的出块奖励都是1&#x2F;32出块奖励。<br>也就是说，叔父区块的定义是和当前区块在<strong>七代</strong>之内有共同祖先才可（合法的叔父只有6辈）。<br><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230105110531060.png" alt="image-20230105110531060"> </p><blockquote><p>ETH系统中规定，只认可A-F区块为叔父区块，给予其补偿，而其后的区块全部作废。</p></blockquote><p>这样，就方便了全节点进行记录，此外，也从协议上鼓励一旦出现分叉马上进行合并。</p>]]></content>
      
      
      <categories>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-状态树</title>
      <link href="/2022/09/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/03-%E7%8A%B6%E6%80%81%E6%A0%91/"/>
      <url>/2022/09/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/03-%E7%8A%B6%E6%80%81%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="以太坊采用基于账户的模式，系统中显式记录每个账户的余额。而以太坊这样一个大型分布式系统中，是采用的什么样的数据结构来实现对这些数据的管理的"><a href="#以太坊采用基于账户的模式，系统中显式记录每个账户的余额。而以太坊这样一个大型分布式系统中，是采用的什么样的数据结构来实现对这些数据的管理的" class="headerlink" title="以太坊采用基于账户的模式，系统中显式记录每个账户的余额。而以太坊这样一个大型分布式系统中，是采用的什么样的数据结构来实现对这些数据的管理的"></a>以太坊采用基于账户的模式，系统中显式记录每个账户的余额。而以太坊这样一个大型分布式系统中，是采用的什么样的数据结构来实现对这些数据的管理的</h3><p>首先，我们要实现从账户地址到账户状态的映射。在以太坊中，账户地址为160字节，表示为40个16进制数额。状态包含了余额(balance)、交易次数(nonce),合约账户中还包含了code(代码)、存储(stroge)。</p><ol><li>我们能否像BTC中，将哈希表的内容组织为Merkle Tree？<br>但当新区块发布，哈希表内容会改变，再次将其组织为新的Merkle Tree，实际中，发生变化的仅仅为很少一部分数据，我们每次重新构建Merkle Tree代价很大<br>需要注意的是，比特币系统中Merkle Tree记录的是交易，交易由区块管理，而区块包含上限为4000个交易左右，所以Merkle Tree不是无限增大的。而ETH中如果用Merkle Tree来组织账户信息，很明显其会越来越庞大。</li><li>那我们不要哈希表了，直接使用Merkle Tree，每次修改只需要修改其中一部分即可，这个可以吗？<br>实际中，Merkle Tree并未提供一个高效的查找和更新的方案。此外，将所有账户构建为一个大的Merkle Tree，为了保证所有节点的一致性和查找速度，必须进行排序。</li><li>那么经过排序，使用Sorted Merkle Tree可以吗？<br>新增账户，由于其地址随机，插入Merkle Tree时候很大可能在Tree中间，发现其必须进行重构。所以Sorted Merkle Tree插入、删除(实际上可以不删除)的代价太大。</li></ol><h2 id="简单的数据结构"><a href="#简单的数据结构" class="headerlink" title="简单的数据结构"></a>简单的数据结构</h2><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230104112918325.png" alt="image-20230104112918325"> <img src="image-20230104112945937.png" alt="image-20230104112945937" style="zoom:50%;" /></p><p>一：trie(字典树、前缀树)，trie的存储浪费。很多节点只存储一个key，但其“儿子”只有一个，过于浪费，引入<strong>Patricia tree&#x2F;trie</strong></p><p>二：Patricia trie就是进行了路径压缩的trie，需要注意的是，如果新插入单词，原本压缩的路径可能需要扩展开来。那么，需要考虑什么情况下路径压缩效果较好？树中插入的键值分布较为稀疏的情况下，可见路径压缩效果较好。</p><h1 id="以太坊采取的数据结构：MPT"><a href="#以太坊采取的数据结构：MPT" class="headerlink" title="以太坊采取的数据结构：MPT"></a>以太坊采取的数据结构：MPT</h1><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230104113456100.png" alt="image-20230104113456100"> </p><p>每次发布新区块，状态树中部分节点状态会改变。但改变并非在原地修改，而是新建一些分支，保留原本状态。如下图中，仅仅有新发生改变的节点才需要修改，其他未修改节点直接指向前一个区块中的对应节点。</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230104113752156.png" alt="image-20230104113752156"> </p><blockquote><p><strong>为什么要保留历史状态？不直接修改原数据？</strong></p><p>为了回滚，在ETH中分叉是常态，因此，需要维护这些历史记录。</p></blockquote><blockquote><p>状态树中保存Key-value对，key就是地址，而value状态通过RLP(Recursive Length Prefix，一种进行<strong>序列化</strong>的方法)编码序列号之后再进行存储。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-交易树和收据树</title>
      <link href="/2022/09/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/04-%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%91/"/>
      <url>/2022/09/23/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/04-%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="交易树和收据树"><a href="#交易树和收据树" class="headerlink" title="交易树和收据树"></a>交易树和收据树</h1><p>每次发布一个区块时，区块中的交易会形成一颗Merkle Tree，即交易树。此外，以太坊还添加了一个收据树，每个交易执行完之后形成一个收据，记录交易相关信息。也就是说，交易树和收据树上的节点是<strong>一一对应</strong>的。<br>由于以太坊智能合约执行较为复杂，通过增加收据树，便于快速查询执行结果。<br>交易树和收据树都是<strong>M(Merkle)PT</strong>，MPT的好处是支持查找操作，通过键值沿着树进行查找即可。对于状态树，查找键值为<strong>账户地址</strong>；对于交易树和收据树，查找键值为交易在发布的<strong>区块中的序号</strong>。</p><p>交易树和收据树只将当前区块中的交易组织起来，而状态树将所有账户的状态都包含进去，无论这些账户是否与当前区块中交易有关系。<br>多个区块状态树共享节点，而交易树和收据树依照区块独立。</p><blockquote><p>交易树和收据树的用途：</p><ol><li>向轻节点提供Merkle Proof。</li><li>更加复杂的查找操作(例如：查找过去十天的交易；过去十天的众筹事件等)</li></ol></blockquote><h1 id="Bloom-filter-布隆过滤器"><a href="#Bloom-filter-布隆过滤器" class="headerlink" title="Bloom filter(布隆过滤器)"></a>Bloom filter(布隆过滤器)</h1><p><strong>特点：有可能出现误报，但不会出现漏报。</strong></p><blockquote><p>例如：给定一个数据集，其中含义元素a、b、c，通过一个哈希函数H()对其进行计算，将其映射到一个其初始全为0的128位的向量的某个位置，将该位置置为1。将所有元素处理完，就可以得到一个向量，则称该向量为原集合的“摘要”。可见该“摘要”比原集合是要小很多的。<br>假定想要查询一个元素d是否在集合中，假设H(d)映射到向量中的位置处为0，说明d一定不在集合中；假设H(d)映射到向量中的位置处为1，有可能集合中确实有d，也有可能因为哈希碰撞产生误报。</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230105104403727.png" alt="image-20230105104403727"> </p></blockquote><p><strong>如果集合中删除元素该怎么操作？</strong><br><strong>无法操作</strong>。也就是说，简单的Bloom filter不支持删除操作。如果想要支持删除操作，需要将记录数不能为0和1，需要修改为一个计数器(需要考虑计数器是否会溢出)。</p><h3 id="以太坊中Bloom-filter的作用"><a href="#以太坊中Bloom-filter的作用" class="headerlink" title="以太坊中Bloom filter的作用"></a>以太坊中Bloom filter的作用</h3><p>每个交易完成后会产生一个收据，收据包含一个Bloom filter记录交易类型、地址等信息。在区块block header中也包含一个Bloom filter，其为该区块中所有交易的Bloom filter的一个并集。<br>所以，查找时候<strong>先查找块头中的Bloom filter</strong>，如果块头中包含。<strong>再查看区块中包含的交易的Bloom filter</strong>，如果存在，再查看交易进行确认；如果不存在，则说明发生了“碰撞”。<br>好处是通过Bloom filter这样一个结构，<strong>快速大量过滤掉大量无关区块，从而提高了查找效率。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-账户</title>
      <link href="/2022/09/19/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/02-%E8%B4%A6%E6%88%B7/"/>
      <url>/2022/09/19/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/02-%E8%B4%A6%E6%88%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="BTC和ETH模型对比"><a href="#BTC和ETH模型对比" class="headerlink" title="BTC和ETH模型对比"></a>BTC和ETH模型对比</h1><p>BTC系统是基于交易的账本，系统中并未显示记录账户有多少钱，只能通过UTXO进行推算，A转给B钱的时候，需要说明币的来源。实际中只需要存钱说明来源，花钱则不用。此外，账户中的钱在花的时候，必须一次性全部花出去。</p><p>例如：B收到A的10个BTC，他想要给C3个BTC，如果按照第一个方式，其余7个比特币会以交易费的形式给挖出区块的矿工。<br>因此，为了避免这种情况，便吸引采用第二个方式，将3个BTC转给C，将剩余7个BTC转到自己的另一账户D上面。</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230104103930214.png" alt="image-20230104103930214">               <img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/img/image-20230104103937937.png" alt="image-20230104103937937"></p><p>ETH系统则采用了基于账户的模型，与现实中银行账户相似。系统中显示记录每个账户以太币的数量，转账是否合法只需要查看转账者账户中以太币是否足够即可，同时也不需要每次全部转账。同时，这也也天然地防范了双花攻击。<br>当然，以太坊发这种模式也存在缺点，这种模式存在<strong>重放攻击</strong>的缺陷。A向B转账，过一段时间，B将A的交易重新发布，从而导致A账户被扣钱两次。</p><blockquote><p>为了防范重放攻击，给账户交易添加计数器记录该账户交易过多少次，转账时候将转账次数计入交易的内容中。<br>系统中全节点维护账户余额和该计数器的交易数，从而防止本地篡改余额或进行重放攻击。</p></blockquote><p>以太坊系统中存在两类账户：外部账户和合约账户。</p><ol><li>外部账户：类似于BTC系统中公私钥对。存在账户余额balance和计数器nonce</li><li>合约账户：并非通过公私钥对控制。(不能主动发起交易，只能接收到外部账户调用后才能发起交易或调用其他合约账户)其除了balance和nonce之外还有code(代码)、storage(相关状态-存储)</li></ol><p>创建合约时候会返回一个地址，就可以对其调用。调用过程中，代码不变但状态会发生改变。</p><p><strong>为什么要做以太坊，换基于账户的模型？</strong><br>比特币中支持每次更换账户，但以太坊是为了支持智能合约，而合约签订双方是需要明确且较少变化的。尤其是对于<strong>合约账户来说，需要保持稳定状态。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-概述</title>
      <link href="/2022/09/15/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/01-%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/09/15/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/01-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="BTC和ETH对比"><a href="#BTC和ETH对比" class="headerlink" title="BTC和ETH对比"></a>BTC和ETH对比</h1><p>BTC和ETH为最主要的两种加密货币，BTC称为区块链1.0，以太坊称为区块链2.0。之前文章中提出了比特币设计中存在某些不足，以太坊便对其进行了改进。例如：<strong>出块时间(10s)<strong>、</strong>共识协议(ghost)<strong>、mining puzzle（对内存要求高，反ASIC芯片使用）<br>未来，以太坊还将会用</strong>权益证明(POS)替代工作量证明(POW)</strong><br>此外，以太坊增加了对<strong>智能合约（smart contract）</strong>的支持。</p><h2 id="去中心化的合约"><a href="#去中心化的合约" class="headerlink" title="去中心化的合约"></a>去中心化的合约</h2><p>首先，讨论去中心化货币。货币本身由政府发行，政府公信力为其背书，BTC通过技术手段取代了政府的职能。<br>现实生活中，我们经常提到“契约”或“合约”。合约的有效性也是需要政府进行维护的，如果产生，需要针对合法性合同进行判决。ETH的设计目的就是，通过技术手段来实现取代政府对于合约的职能。<br>那么，去中心化的合约有什么好处？<br>若合同签署方并非一个国家，没有统一的司法部门（如：众筹）。如果可以编写无法修改的合约，所有人只能按照相关参与方执行，无法违约。</p><blockquote><p>以太坊则由于智能合约，升级成为了一个平台，用户可以依据该平台自行开发业务应用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-Web3.(_.net、bzz、shh、utils)</title>
      <link href="/2022/09/09/%E5%8C%BA%E5%9D%97%E9%93%BE/web3/6-Web3.(_.net%E3%80%81bzz%E3%80%81shh%E3%80%81utils)/"/>
      <url>/2022/09/09/%E5%8C%BA%E5%9D%97%E9%93%BE/web3/6-Web3.(_.net%E3%80%81bzz%E3%80%81shh%E3%80%81utils)/</url>
      
        <content type="html"><![CDATA[<h1 id="web3-net-获取网络属性"><a href="#web3-net-获取网络属性" class="headerlink" title="web3.*.net(获取网络属性)"></a>web3.*.net(获取网络属性)</h1><h2 id="1-1-getId"><a href="#1-1-getId" class="headerlink" title="1.1 getId"></a>1.1 getId</h2><p>获取当前的网络 ID.</p><p><strong>返回值(Promise):</strong>  Number,网络 ID.</p><h2 id="1-2-isListening"><a href="#1-2-isListening" class="headerlink" title="1.2 isListening"></a>1.2 isListening</h2><p>查看当前节点是否正在连接其它对等节点。</p><p><strong>返回值(Promise):</strong>  Boolean</p><h2 id="1-3-getPeerCount"><a href="#1-3-getPeerCount" class="headerlink" title="1.3 getPeerCount"></a>1.3 getPeerCount</h2><p>查看当前节点是否正在连接其它对等节点。</p><p><strong>返回值(Promise):</strong>  Number</p><h1 id="bzz-与swarm交互"><a href="#bzz-与swarm交互" class="headerlink" title="bzz(与swarm交互)"></a>bzz(与swarm交互)</h1><h1 id="shh-与-whisper-协议的交互进行消息广播"><a href="#shh-与-whisper-协议的交互进行消息广播" class="headerlink" title="shh(与 whisper 协议的交互进行消息广播)"></a>shh(与 whisper 协议的交互进行消息广播)</h1><h1 id="utils-工具性函数"><a href="#utils-工具性函数" class="headerlink" title="utils(工具性函数)"></a>utils(工具性函数)</h1><h2 id="4-1-randomHex"><a href="#4-1-randomHex" class="headerlink" title="4.1 randomHex"></a>4.1 randomHex</h2><p>来根据指定字节大小生成密码学强度的伪随机 16 进制字符串.</p><p><strong>参数:</strong><code>size</code> - <code>Number</code>: 16 进制字符串的字节大小, 比如 <code>32</code> 生成32 个字节大小的 16 进制字符串，以 “0x” 为前缀的 64 个字符来表示。</p><p>**返回值:(String): <strong>生成的 16 进制随机字符串.</strong></p><h2 id="4-2-BN"><a href="#4-2-BN" class="headerlink" title="4.2 BN"></a>4.2 BN</h2><p>为了在不同类型之间进行安全的类型转换, 包括 BigNumber.js 可以使用 utils.toBN</p><p><strong>参数:</strong><code>mixed</code> - <code>String|Number</code>: 要转换为 BN 对象的一个数字字符串或 16 进制字符串</p><p><strong>返回值(Object):</strong> BN.js实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">BN</span> = web3.<span class="property">utils</span>.<span class="property">BN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">BN</span>(<span class="number">1234</span>).<span class="title function_">toString</span>();</span><br><span class="line">&gt; <span class="string">&quot;1234&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">BN</span>(<span class="string">&#x27;1234&#x27;</span>).<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title function_">BN</span>(<span class="string">&#x27;1&#x27;</span>)).<span class="title function_">toString</span>();</span><br><span class="line">&gt; <span class="string">&quot;1235&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">BN</span>(<span class="string">&#x27;0xea&#x27;</span>).<span class="title function_">toString</span>();</span><br><span class="line">&gt; <span class="string">&quot;234&quot;</span></span><br></pre></td></tr></table></figure><h2 id="4-3-isBN"><a href="#4-3-isBN" class="headerlink" title="4.3 isBN"></a>4.3 isBN</h2><p>检测给定值是否为 BN.js 实例</p><p><strong>参数:</strong><code>bn</code> - <code>Object</code>: BN.js 实例.</p><p><strong>返回值(Boolean)</strong></p><h2 id="4-4-isBigNumber"><a href="#4-4-isBigNumber" class="headerlink" title="4.4 isBigNumber"></a>4.4 isBigNumber</h2><p>检测给定值是否为 BigNumber.js 实例</p><p><strong>参数:</strong><code>bignumber </code> - <code>Object</code>: BigNumber.js 实例.</p><p><strong>返回值(Boolean)</strong></p><h2 id="4-5-sha3"><a href="#4-5-sha3" class="headerlink" title="4.5 sha3"></a>4.5 sha3</h2><p>将计算输入参数的 sha3 值</p><blockquote><p>web3.utils.keccak256(string) &#x2F;&#x2F; 别名</p></blockquote><p><strong>参数:</strong><code>string</code> - <code>String</code>: 要进行哈希运算的字符串.</p><p>**返回值(String)**：计算所得哈希值.</p><blockquote><p>web3.utils.sha3Raw(string)</p><p>将计算输入字符串的 sha3 哈希值，如果传入的是空字符串，将返回空字符串的哈希值而不是 <code>null</code></p></blockquote><h2 id="4-6-soliditySha3"><a href="#4-6-soliditySha3" class="headerlink" title="4.6 soliditySha3"></a>4.6 soliditySha3</h2><p>使用和 solidity 同样的方式对输入参数进行 sha3 哈希运算。这意味着对这些参数在进行哈希运算之前先进行 ABI 转换和紧凑打包编码。</p><p><strong>参数:</strong><code>paramX</code> - <code>Mixed</code>: 任意类型，或者具有 <code>&#123;type: &#39;uint&#39;, value: &#39;123456&#39;&#125;</code> 或 <code>&#123;t: &#39;bytes&#39;, v: &#39;0xfff456&#39;&#125;</code> 的对象. 基本类型将按下面的规则进行自动检测:</p><ul><li><code>String</code> 非数字 UTF-8 字符串会被解析为 <code>string</code>.</li><li><code>String|Number|BN|HEX</code> 正数会被解析为 <code>uint256</code>.</li><li><code>String|Number|BN</code> 负数会被解析为 <code>int256</code>.</li><li><code>Boolean</code> 作为 <code>bool</code>.</li><li><code>String</code> 以 <code>0x</code> 开头的 16 进制字符串会被解析为 <code>bytes</code>.</li><li><code>HEX</code> 16 进制表示的数字会被解析为 <code>uint256</code>.</li></ul><p><strong>返回值(String)：</strong>哈希值</p><blockquote><p>web3.utils.soliditySha3Raw(param1 [, param2, …])</p><p> 和 <code>soliditySha3</code> 不同的是，如果传入的是空字符串，将返回空字符串的哈希值而不是 <code>null</code></p></blockquote><h2 id="4-7-isHex"><a href="#4-7-isHex" class="headerlink" title="4.7 isHex"></a>4.7 isHex</h2><p>判断给定的字符串是否是个 16 进制字符串</p><p><strong>参数:</strong><code>hex</code> - <code>String|HEX</code>: 给定的 16 进制字符串.</p><p><strong>返回值(Boolean)</strong></p><blockquote><p>web3.utils.isHexStrict(hex)</p><p> 和 <code>web3.utils.isHex()</code> 不同的是它要求 16 进制字符串必须以 <code>0x</code> 开头.</p></blockquote><h2 id="4-8-isAddress"><a href="#4-8-isAddress" class="headerlink" title="4.8 isAddress"></a>4.8 isAddress</h2><p>判断给定的地址是否是一个有效的以太坊地址。大小写混合的地址还会检测校验和。</p><p><strong>参数:</strong><code>address</code> - <code>String</code>: 地址字符串.</p><p><strong>返回值(Boolean)</strong></p><h2 id="4-9-toChecksumAddress"><a href="#4-9-toChecksumAddress" class="headerlink" title="4.9 toChecksumAddress"></a>4.9 toChecksumAddress</h2><p>将一个只有大写或小写字符的以太坊地址转换为一个校验和地址</p><p><strong>参数:</strong><code>address</code> - <code>String</code>: 地址字符串.</p><p><strong>返回值(String)：</strong>校验和地址</p><h2 id="4-10-checkAddressChecksum"><a href="#4-10-checkAddressChecksum" class="headerlink" title="4.10 checkAddressChecksum"></a>4.10 checkAddressChecksum</h2><p>检测给定地址的校验和. 非校验和地址同样会返回 false.</p><p><strong>参数:</strong><code>address</code> - <code>String</code>: 地址字符串.</p><p><strong>返回值(Boolean)：</strong>地址的校验和有效时返回 <code>true</code> , 地址不是一个校验和地址或者校验和无效时返回 <code>false</code>.</p><h2 id="4-11-toHex"><a href="#4-11-toHex" class="headerlink" title="4.11 toHex"></a>4.11 toHex</h2><p>自动将给定值转换为 16 进制。Number 字符串会被解析为数字。Text 字符串会被解析为 UTF8 字符串</p><p><strong>参数:</strong><code>mixed</code> - <code>String|Number|BN|BigNumber</code>: 要进行 16 进制转化的输入.</p><p><strong>返回值(String)：</strong>得到的 16 进制字符串.</p><blockquote><p>web3.utils.stripHexPrefix(string)</p><p>返回<code>String</code>:没有0x前缀的输入字符串。</p></blockquote><h2 id="4-12-toBN"><a href="#4-12-toBN" class="headerlink" title="4.12 toBN"></a>4.12 toBN</h2><p>将任何给定值安全转换为 (BigNumber.js 实例) 一个 BN.js 实例, 以便于在 JavaScript 中处理大数.</p><blockquote><p>如果只是 BN.js 类，可以直接使用 web3.utils.BN</p></blockquote><p><strong>参数:</strong><code>number</code> - <code>String|Number|HEX</code>: 要转换为大数类型的数字.</p><p><strong>返回值(Object)：</strong>BN.js实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">web3.<span class="property">utils</span>.<span class="title function_">toBN</span>(<span class="number">1234</span>).<span class="title function_">toString</span>();</span><br><span class="line">&gt; <span class="string">&quot;1234&quot;</span></span><br><span class="line"></span><br><span class="line">web3.<span class="property">utils</span>.<span class="title function_">toBN</span>(<span class="string">&#x27;1234&#x27;</span>).<span class="title function_">add</span>(web3.<span class="property">utils</span>.<span class="title function_">toBN</span>(<span class="string">&#x27;1&#x27;</span>)).<span class="title function_">toString</span>();</span><br><span class="line">&gt; <span class="string">&quot;1235&quot;</span></span><br><span class="line"></span><br><span class="line">web3.<span class="property">utils</span>.<span class="title function_">toBN</span>(<span class="string">&#x27;0xea&#x27;</span>).<span class="title function_">toString</span>();</span><br><span class="line">&gt; <span class="string">&quot;234&quot;</span></span><br></pre></td></tr></table></figure><h2 id="4-13-hexToNumberString"><a href="#4-13-hexToNumberString" class="headerlink" title="4.13 hexToNumberString"></a>4.13 hexToNumberString</h2><p>返回 16 进制字符串的数字表示</p><p><strong>参数:</strong><code>hexString</code> - <code>String|HEX</code>: 16 进制字符串</p><p><strong>返回值(String)：</strong>数字字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">web3.<span class="property">utils</span>.<span class="title function_">hexToNumberString</span>(<span class="string">&#x27;0xea&#x27;</span>);</span><br><span class="line">&gt; <span class="string">&quot;234&quot;</span></span><br></pre></td></tr></table></figure><h2 id="4-14-hexToNumber"><a href="#4-14-hexToNumber" class="headerlink" title="4.14 hexToNumber"></a>4.14 hexToNumber</h2><p>返回 16 进制字符串的数字表示</p><blockquote><p>这个对大数不适用, 大数应该使用 web3.utils.toBN.</p></blockquote><p><strong>参数:</strong><code>hexString</code> - <code>String|HEX</code>: 16 进制字符串</p><p><strong>返回值(Number)</strong></p><h2 id="4-15-numberToHex"><a href="#4-15-numberToHex" class="headerlink" title="4.15 numberToHex"></a>4.15 numberToHex</h2><p>返回给定数字的 16 进制表示</p><p><strong>参数:</strong><code>number</code> - <code>String|Number|BN|BigNumber</code>: 数字或数字字符串.</p><p><strong>返回值(String)：</strong>给定数字的 16 进制表示.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">web3.<span class="property">utils</span>.<span class="title function_">numberToHex</span>(<span class="string">&#x27;234&#x27;</span>);</span><br><span class="line">&gt; <span class="string">&#x27;0xea&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="4-16-hexToUtf8"><a href="#4-16-hexToUtf8" class="headerlink" title="4.16 hexToUtf8"></a>4.16 hexToUtf8</h2><p>返回给定 16 进制数字的 UTF-8 字符串表示</p><p><strong>参数:</strong><code>hex</code> - <code>String</code>: 要转换为 UTF-8 字符串的 16 进制字符串.</p><p><strong>返回值(String)：</strong>UTF-8 字符串.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">web3.<span class="property">utils</span>.<span class="title function_">hexToUtf8</span>(<span class="string">&#x27;0x49206861766520313030e282ac&#x27;</span>);</span><br><span class="line">&gt; <span class="string">&quot;I have 100€&quot;</span></span><br></pre></td></tr></table></figure><h2 id="4-17-hexToAscii"><a href="#4-17-hexToAscii" class="headerlink" title="4.17 hexToAscii"></a>4.17 hexToAscii</h2><p>返回给定 16 进制数字的 ASCII 码字符串表示</p><p><strong>参数:</strong><code>hex</code> - <code>String</code>: 要转换为 ASCII 码字符串的 16 进制字符串.</p><p><strong>返回值(String)：</strong>ASCII 码字符串.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">web3.<span class="property">utils</span>.<span class="title function_">hexToAscii</span>(<span class="string">&#x27;0x49206861766520313030e282ac&#x27;</span>);</span><br><span class="line">&gt; <span class="string">&quot;I have 100€&quot;</span></span><br></pre></td></tr></table></figure><h2 id="4-18-utf8ToHex"><a href="#4-18-utf8ToHex" class="headerlink" title="4.18 utf8ToHex"></a>4.18 utf8ToHex</h2><p>返回给定 UTF-8 字符串的 16 进制表示。</p><p><strong>参数:</strong><code>string</code> - <code>String</code>: 要转换为 16 进制字符串的 UTF-8 字符串.</p><p><strong>返回值(String)：</strong>16 进制字符串</p><h2 id="4-19-asciiToHex"><a href="#4-19-asciiToHex" class="headerlink" title="4.19 asciiToHex"></a>4.19 asciiToHex</h2><p>返回给定 ASCII 码字符串的 16 进制表示</p><p><strong>参数:</strong><code>string</code> - <code>String</code>: 要转换为 16 进制字符串的 ASCII 码字符串.</p><p><strong>返回值(String)：</strong>16 进制字符串</p><h2 id="4-20-hexToBytes"><a href="#4-20-hexToBytes" class="headerlink" title="4.20 hexToBytes"></a>4.20 hexToBytes</h2><p>返回给定 16 进制字符串的字节数组表示</p><p><strong>参数:</strong><code>hex</code> - <code>String|HEX</code>: 要进行转换的 16 进制串.</p><p><strong>返回值(Array)：</strong>字节数组</p><h2 id="4-21-bytesToHex"><a href="#4-21-bytesToHex" class="headerlink" title="4.21 bytesToHex"></a>4.21 bytesToHex</h2><p>返回一个字节数组的 16 进制字符串表示</p><p><strong>参数:</strong><code>byteArray</code> - <code>Array</code>: 要进行转换的字节数组.</p><p><strong>返回值(String)：</strong>16进制字符串</p><h2 id="4-22-toWei"><a href="#4-22-toWei" class="headerlink" title="4.22 toWei"></a>4.22 toWei</h2><p>将任意 ether 值转换为 wei.</p><p><strong>参数:</strong></p><ul><li><code>number</code> - <code>String|BN</code>: 要转换的数字.</li><li><code>unit</code> - <code>String</code> (optional, defaults to <code>&quot;ether&quot;</code>): 要转换的以太币单位. 支持的单位包括:<ul><li><code>noether</code>: ‘0’</li><li><code>wei</code>: ‘1’</li><li><code>kwei</code>: ‘1000’</li><li><code>Kwei</code>: ‘1000’</li><li><code>babbage</code>: ‘1000’</li><li><code>femtoether</code>: ‘1000’</li><li><code>mwei</code>: ‘1000000’</li><li><code>Mwei</code>: ‘1000000’</li><li><code>lovelace</code>: ‘1000000’</li><li><code>picoether</code>: ‘1000000’</li><li><code>gwei</code>: ‘1000000000’</li><li><code>Gwei</code>: ‘1000000000’</li><li><code>shannon</code>: ‘1000000000’</li><li><code>nanoether</code>: ‘1000000000’</li><li><code>nano</code>: ‘1000000000’</li><li><code>szabo</code>: ‘1000000000000’</li><li><code>microether</code>: ‘1000000000000’</li><li><code>micro</code>: ‘1000000000000’</li><li><code>finney</code>: ‘1000000000000000’</li><li><code>milliether</code>: ‘1000000000000000’</li><li><code>milli</code>: ‘1000000000000000’</li><li><code>ether</code>: ‘1000000000000000000’</li><li><code>kether</code>: ‘1000000000000000000000’</li><li><code>grand</code>: ‘1000000000000000000000’</li><li><code>mether</code>: ‘1000000000000000000000000’</li><li><code>gether</code>: ‘1000000000000000000000000000’</li><li><code>tether</code>: ‘1000000000000000000000000000000’</li></ul></li></ul><p><strong>返回值(String|BN)：</strong>给一个数字字符串就返回一个字符串, 否则返回一个 BN.js 实例.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;ether&#x27;</span>);</span><br><span class="line">&gt; <span class="string">&quot;1000000000000000000&quot;</span></span><br></pre></td></tr></table></figure><h2 id="4-23-fromWei"><a href="#4-23-fromWei" class="headerlink" title="4.23 fromWei"></a>4.23 fromWei</h2><p>将任意数量的 wei 转换为 ether.</p><p><strong>参数:<strong>参考</strong>web3.utils.toWei()</strong></p><p><strong>返回值(String)：</strong>数字字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">web3.<span class="property">utils</span>.<span class="title function_">fromWei</span>(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;ether&#x27;</span>);</span><br><span class="line">&gt; <span class="string">&quot;0.000000000000000001&quot;</span></span><br></pre></td></tr></table></figure><h2 id="4-24-unitMap"><a href="#4-24-unitMap" class="headerlink" title="4.24 unitMap"></a>4.24 unitMap</h2><p>显示所有的 ether 单位 和它们对应的 wei 数量.</p><p><strong>参数:<strong>参考</strong>web3.utils.toWei()</strong></p><p><strong>返回值(Object)：</strong>web3.utils.toWei()参数</p><h2 id="4-25-padLeft-padRight"><a href="#4-25-padLeft-padRight" class="headerlink" title="4.25 padLeft&#x2F;padRight"></a>4.25 padLeft&#x2F;padRight</h2><p>对一个字符串进行左&#x2F;右补齐, 在需要对 16 进制字符串进行填充是很有用.</p><p><strong>参数:</strong></p><ol><li><code>string</code> - <code>String</code>: 需要左&#x2F;右补齐的字符串.</li><li><code>characterAmount</code> - <code>Number</code>: 整个字符串所含有的字符数量.</li><li><code>sign</code> - <code>String</code> (可选): 要使用的字符符号, 默认为 <code>&quot;0&quot;</code>.</li></ol><p><strong>返回值(String)：</strong>补齐后的字符串.</p><h2 id="4-26-toTwosComplement"><a href="#4-26-toTwosComplement" class="headerlink" title="4.26 toTwosComplement"></a>4.26 toTwosComplement</h2><p>将一个负数转换为补码表示。</p><p><strong>参数:</strong><code>number</code> - <code>Number|String|BigNumber</code>: 需要进行转换的数字.</p><p><strong>返回值(String)：</strong>转换后的 16 进制字符串.</p>]]></content>
      
      
      <categories>
          
          <category> web3.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> web3.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-eth.(personal、ens、lban、abi)</title>
      <link href="/2022/09/05/%E5%8C%BA%E5%9D%97%E9%93%BE/web3/5-eth.(personal%E3%80%81ens%E3%80%81lban%E3%80%81abi)/"/>
      <url>/2022/09/05/%E5%8C%BA%E5%9D%97%E9%93%BE/web3/5-eth.(personal%E3%80%81ens%E3%80%81lban%E3%80%81abi)/</url>
      
        <content type="html"><![CDATA[<h1 id="personal-同节点上的账户进行交互"><a href="#personal-同节点上的账户进行交互" class="headerlink" title="personal(同节点上的账户进行交互)"></a>personal(同节点上的账户进行交互)</h1><h2 id="1-1-newAccount"><a href="#1-1-newAccount" class="headerlink" title="1.1 newAccount"></a>1.1 newAccount</h2><p>创建一个新的账户。</p><blockquote><p>永远不要通过不安全的 Websocket 或 HTTP 服务提供器来调用这些函数，因为你的密码是明文发送的！</p></blockquote><p><strong>参数：</strong><code>password</code> - <code>String</code>: 用来加密账户的密码。</p><p><strong>返回值(Promise<string>)：</strong>新创建账户地址</p><h2 id="1-2-sign"><a href="#1-2-sign" class="headerlink" title="1.2 sign"></a>1.2 sign</h2><p>该方法通过下面的方式计算一个以太坊特定签名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">sign</span>(<span class="title function_">keccak256</span>(<span class="string">&quot;\x19Ethereum Signed Message:\n&quot;</span> + dataToSign.<span class="property">length</span> + dataToSign)))</span><br></pre></td></tr></table></figure><p>在消息前加个前缀使得算出的签名可以被识别为以太坊特定签名。</p><p>如果你同时有原始消息和签名消息，就可以使用 web3.eth.personal.ecRecover 来恢复签名账户地址</p><blockquote><p>通过不安全的 HTTP RPC 连接发送帐户密码非常危险。</p></blockquote><p><strong>参数：</strong></p><ol><li><code>String</code> - 要签名的数据。 如果是字符串会使用 web3.utils.utf8ToHex 将其转换为 16 进制。</li><li><code>String</code> - 用来签名的账户地址。</li><li><code>String</code> - 用来签名的账户密码。</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为签名结果。</li></ol><p><strong>返回值(Promise<string>)：</strong>签名字符串</p><h2 id="1-3-ecRecover"><a href="#1-3-ecRecover" class="headerlink" title="1.3 ecRecover"></a>1.3 ecRecover</h2><p>恢复数据签名帐户</p><p><strong>参数:</strong></p><ol><li><code>String</code> - 被签名的数据。 如果是字符串会使用 web3.utils.utf8ToHex 将其转换为 16 进制。</li><li><code>String</code> - 签名。</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为签名结果。</li></ol><p><strong>返回值:</strong><code>Promise&lt;string&gt;</code> - 签名账户。</p><h2 id="1-4-signTransaction"><a href="#1-4-signTransaction" class="headerlink" title="1.4 signTransaction"></a>1.4 signTransaction</h2><p>对交易进行签名，账户必须先解锁。</p><blockquote><p>通过不安全的 HTTP RPC 连接发送帐户密码非常危险。</p></blockquote><p><strong>参数：</strong></p><ol><li><code>Object</code> - 要签名的交易数据，更多详情请看 web3.eth.sendTransaction() 。</li><li><code>String</code> - 用来签名交易的 <code>from</code> 账户密码。</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为签名结果。</li></ol><p><strong>返回值(Promise<Object>)：</strong>RLP 编码的交易对象，其 <code>raw</code> 属性可以用来通过 web3.eth.sendSignedTransaction 来发送交易。</p><h2 id="1-5-sendTransaction"><a href="#1-5-sendTransaction" class="headerlink" title="1.5 sendTransaction"></a>1.5 sendTransaction</h2><p>该方法用来通过账户管理 API 来发送交易。</p><blockquote><p>通过不安全的 HTTP RPC 连接发送帐户密码非常危险。</p></blockquote><p><strong>参数：</strong></p><ol><li><code>Object</code> - 交易对象属性</li><li><code>String</code> - 当前帐户的密码</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为签名结果。</li></ol><p><strong>返回值(Promise<string>)：</strong>交易哈希</p><h2 id="1-6-unlockAccount"><a href="#1-6-unlockAccount" class="headerlink" title="1.6 unlockAccount"></a>1.6 unlockAccount</h2><p>解锁账户</p><blockquote><p>通过不安全的 HTTP RPC 连接发送帐户密码非常危险。</p></blockquote><p><strong>参数：</strong></p><ol><li><code>address</code> - <code>String</code>: 要解锁的账户地址。</li><li><code>password</code> - <code>String</code> - 账户密码。</li><li><code>unlockDuration</code> - <code>Number</code> - 将帐户保持在解锁状态的持续时间。</li></ol><h2 id="1-7-lockAccount"><a href="#1-7-lockAccount" class="headerlink" title="1.7 lockAccount"></a>1.7 lockAccount</h2><p>锁定给定帐户。</p><blockquote><p>通过不安全的 HTTP RPC 连接发送帐户密码非常危险。</p></blockquote><p><strong>参数：</strong></p><ol><li><code>address</code> - <code>String</code>: 要锁的账户地址。</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为签名结果。</li></ol><p><strong>返回值(Promise<boolean>)</strong></p><h2 id="1-8-getAccounts"><a href="#1-8-getAccounts" class="headerlink" title="1.8 getAccounts"></a>1.8 getAccounts</h2><p>通过使用服务提供器并调用 RPC 方法 <code>personal_listAccounts</code> 返回节点控制的账户列表。使用 web3.eth.accounts.create() 创建的账户不会被添加到这个列表中。这方面的更多信息可以查看 web3.eth.personal.newAccount()。</p><p>结果和 web3.eth.getAccounts() 是一样的，只是它用的 RPC 方法是 <code>eth_accounts</code>。</p><p><strong>返回值(Promise<Array>)</strong>:节点控制地址数组</p><h2 id="1-9-importRawKey"><a href="#1-9-importRawKey" class="headerlink" title="1.9 importRawKey"></a>1.9 importRawKey</h2><p>将给定的私钥导入密钥存储区，并使用密码对其进行加密。返回和导入私钥对应的新账户地址。</p><blockquote><p>通过不安全的 HTTP RPC 连接发送帐户密码非常危险。</p></blockquote><p><strong>参数：</strong></p><ol><li><code>privateKey</code> - <code>String</code> - 为加密的私钥 (16 进制字符串)。</li><li><code>password</code> - <code>String</code> - 账户密码。</li></ol><p><strong>返回值(Promise<string>)</strong>:账户地址</p><h1 id="ens-与-ENS-进行交互"><a href="#ens-与-ENS-进行交互" class="headerlink" title="ens(与 ENS 进行交互)"></a>ens(与 ENS 进行交互)</h1><h1 id="lban-将以太坊地址和-IBAN-BBAN-地址之间相互转换"><a href="#lban-将以太坊地址和-IBAN-BBAN-地址之间相互转换" class="headerlink" title="lban(将以太坊地址和 IBAN&#x2F;BBAN 地址之间相互转换)"></a>lban(将以太坊地址和 IBAN&#x2F;BBAN 地址之间相互转换)</h1><h1 id="abi-解码及编码为-ABI用于EVM进行函数调用"><a href="#abi-解码及编码为-ABI用于EVM进行函数调用" class="headerlink" title="abi(解码及编码为 ABI用于EVM进行函数调用)"></a>abi(解码及编码为 ABI用于EVM进行函数调用)</h1>]]></content>
      
      
      <categories>
          
          <category> web3.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> web3.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-eth.(subscribe、Contract、accounts)</title>
      <link href="/2022/09/03/%E5%8C%BA%E5%9D%97%E9%93%BE/web3/4-eth.(subscribe%E3%80%81Contract%E3%80%81accounts)/"/>
      <url>/2022/09/03/%E5%8C%BA%E5%9D%97%E9%93%BE/web3/4-eth.(subscribe%E3%80%81Contract%E3%80%81accounts)/</url>
      
        <content type="html"><![CDATA[<h1 id="subscribe-订阅区块链中的指定事件"><a href="#subscribe-订阅区块链中的指定事件" class="headerlink" title="subscribe(订阅区块链中的指定事件)"></a>subscribe(订阅区块链中的指定事件)</h1><h2 id="1-1-clearSubscriptions"><a href="#1-1-clearSubscriptions" class="headerlink" title="1.1 clearSubscriptions"></a>1.1 clearSubscriptions</h2><p>重置订阅</p><p><strong>参数：</strong><code>Boolean</code>: 值为 <code>true</code> 则表示保持 <code>同步</code> 订阅</p><p><strong>返回值（Boolean）</strong>:是否同步订阅</p><h2 id="1-2-subscribe"><a href="#1-2-subscribe" class="headerlink" title="1.2 subscribe"></a>1.2 subscribe</h2><p>订阅区块链中的指定事件</p><p><strong>参数：</strong></p><ul><li><code>String</code> - 订阅类型</li><li><code>Mixed</code> - (可选) 依赖于订阅类型的可选额外参数</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为结果。该函数在每次订阅事件发生时都会被调用，订阅实例会作为第三个参数传递进来</li></ul><p><strong>返回值(EventEmitter)：</strong>一个订阅实例</p><ul><li><code>subscription.id</code>: 订阅 id 编号，用于标识一个订阅以及进行后续的取消订阅操作</li><li><code>subscription.subscribe([callback])</code>: 可用于使用相同的参数进行再次订阅</li><li><code>subscription.unsubscribe([callback])</code>: 取消订阅，如果成功取消的话，在回调函数中返回 TRUE</li><li><code>subscription.arguments</code>: 订阅参数，在重新订阅时使用</li><li><code>on(&quot;data&quot;)</code> 返回 <code>Object</code>: 每次有新的日志时都触发该事件，参数为日志对象</li><li><code>on(&quot;changed&quot;)</code> 返回 <code>Object</code>: 每次有日志从区块链上移除时触发该事件，被移除的日志对象将添加额外的属性： <code>&quot;removed: true&quot;</code></li><li><code>on(&quot;error&quot;)</code> 返回 <code>Object</code>: 当订阅发生错误时，触发此事件</li><li><code>on(&quot;connected&quot;)</code> 返回 <code>String</code>: 一旦订阅成功就会触发该事件，返回订阅 id</li></ul><p><strong>通知返回值：</strong><code>Mixed</code> - 取决于订阅具体是什么，可以参考后面提到的不同订阅获取更多相关信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">var</span> subscription = web3.<span class="property">eth</span>.<span class="title function_">subscribe</span>(<span class="string">&#x27;logs&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">address</span>: <span class="string">&#x27;0x123456..&#x27;</span>,</span><br><span class="line">    <span class="attr">topics</span>: [<span class="string">&#x27;0x12345...&#x27;</span>]</span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error, result</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line">subscription.<span class="title function_">unsubscribe</span>(<span class="keyword">function</span>(<span class="params">error, success</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(success)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Successfully unsubscribed!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="1-2-1-subscribe-“pendingTransactions”"><a href="#1-2-1-subscribe-“pendingTransactions”" class="headerlink" title="1.2.1 subscribe(“pendingTransactions”)"></a>1.2.1 subscribe(“pendingTransactions”)</h3><p>订阅 pending 状态的交易。</p><p><strong>参数：</strong></p><ol><li><code>String</code> - <code>&quot;pendingTransactions&quot;</code>, 订阅类型</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为结果。</li></ol><p><strong>返回值(EventEmitter)：</strong>一个订阅实例</p><ul><li><code>&quot;data&quot;</code> 返回 <code>String</code>: 当接收到 pending 状态的交易时触发并返回交易哈希</li><li><code>&quot;error&quot;</code> 返回 <code>Object</code>: 当订阅中发生错误时触发</li></ul><p><strong>通知返回值：</strong></p><ol><li><code>Object|Null</code> - 如果订阅失败第一个参数为错误对象</li><li><code>String</code> - 第二个参数为交易哈希</li></ol><h3 id="1-2-2-subscribe-“newBlockHeaders”"><a href="#1-2-2-subscribe-“newBlockHeaders”" class="headerlink" title="1.2.2 subscribe(“newBlockHeaders”)"></a>1.2.2 subscribe(“newBlockHeaders”)</h3><p>订阅新的区块头生成事件， 可用作检查链上变化的计时器。</p><p><strong>参数：</strong></p><ol><li><code>String</code> - <code>&quot;newBlockHeaders&quot;</code>, 订阅类型</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为结果。</li></ol><p><strong>返回值(EventEmitter)：</strong>一个订阅实例</p><ul><li><code>&quot;data&quot;</code> 返回 <code>Object</code>: 当收到新的区块头时触发<ul><li><code>number</code> - <code>Number</code>: 区块编号，对于 pending 状态的块该值为<code>null</code>。</li><li><code>hash</code> 32 Bytes - <code>String</code>: 块的哈希值，对于 pending 状态的块该值为<code>null</code>。</li><li><code>parentHash</code> 32 Bytes - <code>String</code>: 父区块哈希值。</li><li><code>nonce</code> 8 Bytes - <code>String</code>: 用来生成工作量证明的 nonce 值. 对于 pending 状态的块该值为<code>null</code>。</li><li><code>sha3Uncles</code> 32 Bytes - <code>String</code>: 区块中叔块数据的 sha3哈希值。</li><li><code>logsBloom</code> 256 Bytes - <code>String</code>: 区块日志数据的布隆过滤器。对于 pending 状态的块该值为<code>null</code>。</li><li><code>transactionsRoot</code> 32 Bytes - <code>String</code>: 区块中交易 trie 树的根节点。</li><li><code>stateRoot</code> 32 Bytes - <code>String</code>: 区块中状态 trie 树的根节点。</li><li><code>receiptsRoot</code> 32 Bytes - <code>String</code>: 收据根节点。</li><li><code>miner</code> - <code>String</code>: 接收挖矿奖励的矿工地址。</li><li><code>extraData</code> - <code>String</code>: 区块的额外数据字段。</li><li><code>gasLimit</code> - <code>Number</code>: 该块允许的最大 gas 用量。</li><li><code>gasUsed</code> - <code>Number</code>: 该块中所有交易使用的 gas 总量。</li><li><code>timestamp</code> - <code>Number</code>: 区块时间戳。</li></ul></li><li><code>&quot;error&quot;</code> 返回 <code>Object</code>: 当订阅中出现错误时触发</li><li><code>&quot;connected&quot;</code> 返回 <code>Number</code>: 订阅成功后触发，返回订阅 id</li></ul><p><strong>通知返回值：</strong></p><ol><li><code>Object|Null</code> - 如果订阅失败第一个参数为错误对象</li><li><code>Object</code> - 像上面那样的区块头对象</li></ol><h3 id="1-2-3-subscribe-“syncing”"><a href="#1-2-3-subscribe-“syncing”" class="headerlink" title="1.2.3 subscribe(“syncing”)"></a>1.2.3 subscribe(“syncing”)</h3><p>订阅同步事件。当节点正在同步数据时将返回一个同步对象，同步结束后返回 <code>FALSE</code>。</p><p><strong>参数：</strong></p><ol><li><code>String</code> - <code>&quot;syncing&quot;</code>, 订阅类型</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为结果。</li></ol><p><strong>返回值(EventEmitter)：</strong>一个订阅实例</p><ul><li><code>&quot;data&quot;</code> 返回 <code>Object</code>: 收到同步对象时触发(参考14.web3.eth.isSyncing()返回值)</li><li><code>&quot;changed&quot;</code> 返回 <code>Object</code>: 当同步状态由 <code>true</code> 变为 <code>false</code> 时触发</li><li><code>&quot;error&quot;</code> 返回 <code>Object</code>: 当订阅中出现错误时触发</li></ul><p><strong>通知返回值：</strong></p><ol><li><code>Object|Null</code> - 如果订阅失败第一个参数为错误对象</li><li><code>Object|Boolean</code> - 同步对象, 同步开始后返回 <code>true</code>，同步结束后返回 false</li></ol><h3 id="1-2-4-subscribe-“logs”"><a href="#1-2-4-subscribe-“logs”" class="headerlink" title="1.2.4 subscribe(“logs”)"></a>1.2.4 subscribe(“logs”)</h3><p>订阅日志，并按指定条件进行过滤。 如果一个有效的 <code>fromBlock</code> 属性被指定，Web3 会提取从这个点开始的日志，必要时回填返回值。<strong>参数：</strong></p><ul><li><code>&quot;logs&quot;</code> - <code>String</code>, 订阅类型</li><li><code>Object</code> - 订阅选项<ul><li><code>fromBlock</code> - <code>Number</code>: 最早区块编号， 默认为 <code>null</code>。</li><li><code>address</code> - <code>String|Array</code>: 地址或地址列表，仅订阅来自这些指定账户地址的日志。</li><li><code>topics</code> - <code>Array</code>: 一个主题数组，数组中每个元素都应出现在日志项中。 数组中主题的顺序是很重要的, 如果你不想监听某个主题可以用 <code>null</code> 值, 比如 <code>[null, &#39;0x00...&#39;]</code>. 你也可以为每个主题传入另外一个数组来表示主题选项， 比如 <code>[null, [&#39;option1&#39;, &#39;option2&#39;]]</code></li></ul></li><li><code>callback</code> - <code>Function</code>: (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为结果。每当有订阅事件发生时都会被调用。</li></ul><p><strong>返回值(EventEmitter)：</strong>一个订阅实例</p><ul><li><code>&quot;data&quot;</code> 返回 <code>Object</code>: 接收到新日志时触发，参数为日志对象(参考40. web3.eth.getPastEvents()返回值)</li><li><code>&quot;changed&quot;</code> 返回 <code>Object</code>: 日志从链上移除时触发，该日志同时带有附加属性 <code>&quot;removed: true&quot;</code></li><li><code>&quot;error&quot;</code> 返回 <code>Object</code>: 当订阅中出现错误时触发</li><li><code>&quot;connected&quot;</code> 返回 <code>Number</code>: 订阅成功后触发，返回订阅 id</li></ul><p><strong>通知返回值：</strong></p><ol><li><code>Object|Null</code> - 如果订阅失败第一个参数为错误对象</li><li><code>Object</code> - 日志对象，参考 40.web3.eth.getPastEvents()</li></ol><h1 id="Contract-与区块链上的智能合约交互"><a href="#Contract-与区块链上的智能合约交互" class="headerlink" title="Contract(与区块链上的智能合约交互)"></a>Contract(与区块链上的智能合约交互)</h1><h2 id="2-1-new-contract"><a href="#2-1-new-contract" class="headerlink" title="2.1 new contract"></a>2.1 new contract</h2><p>创建新的合约实例，并在其 json interface 对象中定义所有的方法和事件。</p><p><strong>参数：</strong></p><ul><li><code>jsonInterface</code> - <code>Object</code>: 所要实例化合约的 json 接口</li><li><code>address</code> - <code>String</code> （可选）: 要调用的智能合约地址</li><li><code>options</code> - <code>Object</code> （可选）: 合约配置选项。 其中某些选项被用作合约调用和交易的回调:<ul><li><code>from</code> - <code>String</code>: 交易发送方地址</li><li><code>gasPrice</code> - <code>String</code>: 为交易指定的 gas 价格，以 wei 为单位</li><li><code>gas</code> - <code>Number</code>: 交易可用的最大 gas 量（gas limit）。</li><li><code>data</code> - <code>String</code>: 合约字节码。当合约被 :ref:部署 <contract-deploy>时需要使用。</li></ul></li></ul><p><strong>返回值(Object)：</strong>带有所有方法和事件的合约实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">var</span> myContract = <span class="keyword">new</span> web3.<span class="property">eth</span>.<span class="title class_">Contract</span>([...], <span class="string">&#x27;0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">from</span>: <span class="string">&#x27;0x1234567890123456789012345678901234567891&#x27;</span>, <span class="comment">// 默认交易发送地址</span></span><br><span class="line">    <span class="attr">gasPrice</span>: <span class="string">&#x27;20000000000&#x27;</span> <span class="comment">// 以 wei 为单位的默认 gas 价格，当前价格为 20 gwei</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-2-options-选项属性"><a href="#2-2-options-选项属性" class="headerlink" title="2.2 options(选项属性)"></a>2.2 options(选项属性)</h2><ul><li><code>address</code> - <code>String</code>: 合约的部署地址。 见 options.address.</li><li><code>jsonInterface</code> - <code>Array</code>: 合同的 json 接口。见 options.jsonInterface.</li><li><code>data</code> - <code>String</code>: 合约字节码。 部署 合约时使用。</li><li><code>from</code> - <code>String</code>: 交易发起方地址。</li><li><code>gasPrice</code> - <code>String</code>: 用于交易的 gas 价格。以 wei 为单位。</li><li><code>gas</code> - <code>Number</code>: 可用于该交易的 gas 用量上限 (gas limit)。</li><li><code>handleRevert</code> - <code>Boolean</code>: 如果这里不设置，将使用 Eth 模块提供的默认值。 见 11.handleRevert.</li><li><code>transactionBlockTimeout</code> - <code>Number</code>: 如果这里不设置，将使用 Eth 模块提供的默认值。 见6. transactionBlockTimeout.</li><li><code>transactionConfirmationBlocks</code> - <code>Number</code>: 如果这里不设置，将使用 Eth 模块提供的默认值。 见 7.transactionConfirmationBlocks.</li><li><code>transactionPollingTimeout</code> - <code>Number</code>: 如果这里不设置，将使用 Eth 模块提供的默认值。 见 9.transactionPollingTimeout.</li><li><code>chain</code> - <code>Number</code>: 如果这里不设置，将使用 Eth 模块提供的默认值。 见 4.defaultChain.</li><li><code>hardfork</code> - <code>Number</code>: 如果这里不设置，将使用 Eth 模块提供的默认值。 见3. defaultHardfork.</li><li><code>common</code> - <code>Number</code>: 如果这里不设置，将使用 Eth 模块提供的默认值。 见 5.defaultCommon.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line">myContract.<span class="property">options</span>;</span><br><span class="line">&gt; &#123;</span><br><span class="line">    <span class="attr">address</span>: <span class="string">&#x27;0x1234567890123456789012345678901234567891&#x27;</span>,</span><br><span class="line">    <span class="attr">jsonInterface</span>: [...],</span><br><span class="line">    <span class="attr">from</span>: <span class="string">&#x27;0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe&#x27;</span>,</span><br><span class="line">    <span class="attr">gasPrice</span>: <span class="string">&#x27;10000000000000&#x27;</span>,</span><br><span class="line">    <span class="attr">gas</span>: <span class="number">1000000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myContract.<span class="property">options</span>.<span class="property">from</span> = <span class="string">&#x27;0x1234567890123456789012345678901234567891&#x27;</span>; <span class="comment">// 默认交易发送方地址</span></span><br><span class="line">myContract.<span class="property">options</span>.<span class="property">gasPrice</span> = <span class="string">&#x27;20000000000000&#x27;</span>; <span class="comment">// 默认 gas 价格，以 wei 为单位</span></span><br><span class="line">myContract.<span class="property">options</span>.<span class="property">gas</span> = <span class="number">5000000</span>; <span class="comment">// 5M gas 作为备用值</span></span><br></pre></td></tr></table></figure><h3 id="2-2-1-options-address"><a href="#2-2-1-options-address" class="headerlink" title="2.2.1 options.address"></a>2.2.1 options.address</h3><p>用于本合约实例的地址。 所有通过 web3.js 从这个合约生成的交易都将包含这个地址作为 “to” 地址（也就是交易接收方地址）</p><p><strong>属性：</strong><code>address</code> - <code>String|null</code>: 本合约的地址, 如果未设置其值为 <code>null</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子 </span></span><br><span class="line">myContract.<span class="property">options</span>.<span class="property">address</span>;</span><br><span class="line">&gt; <span class="string">&#x27;0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置新地址</span></span><br><span class="line">myContract.<span class="property">options</span>.<span class="property">address</span> = <span class="string">&#x27;0x1234FFDD...&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-options-jsonInterface"><a href="#2-2-2-options-jsonInterface" class="headerlink" title="2.2.2 options.jsonInterface"></a>2.2.2 options.jsonInterface</h3><p>从合约的 ABI 派生出来的 json 接口 对象。</p><p><strong>属性：</strong><code>jsonInterface</code> - <code>Array</code>: 当前合约的 json 接口 。重设该接口会导致合约实例方法和事件的重新生成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子 </span></span><br><span class="line">myContract.<span class="property">options</span>.<span class="property">jsonInterface</span>;</span><br><span class="line">&gt; [&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>:<span class="string">&quot;function&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;inputs&quot;</span>: [&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;a&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;uint256&quot;</span>&#125;],</span><br><span class="line">    <span class="string">&quot;outputs&quot;</span>: [&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;b&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;address&quot;</span>&#125;]</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>:<span class="string">&quot;event&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;Event&quot;</span>,</span><br><span class="line">    <span class="string">&quot;inputs&quot;</span>: [&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;a&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;uint256&quot;</span>,<span class="string">&quot;indexed&quot;</span>:<span class="literal">true</span>&#125;,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;b&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;bytes32&quot;</span>,<span class="string">&quot;indexed&quot;</span>:<span class="literal">false</span>&#125;],</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置新的接口</span></span><br><span class="line">myContract.<span class="property">options</span>.<span class="property">jsonInterface</span> = [...];</span><br></pre></td></tr></table></figure><h2 id="2-3-Methods-方法"><a href="#2-3-Methods-方法" class="headerlink" title="2.3 Methods(方法)"></a>2.3 Methods(方法)</h2><h3 id="2-3-1-clone"><a href="#2-3-1-clone" class="headerlink" title="2.3.1 clone"></a>2.3.1 clone</h3><p>克隆当前合约实例</p><p><strong>返回值(Object)：</strong>新合约实例</p><h3 id="2-3-2-deploy"><a href="#2-3-2-deploy" class="headerlink" title="2.3.2 deploy"></a>2.3.2 deploy</h3><p>调用此函数将合约部署到区块链上。 成功部署后 promise 对象会被解析为新的合约实例。</p><p><strong>参数：</strong><code>options</code> <strong>-</strong> <code>Object</code>: 用于合约部署的选项</p><ul><li><code>data</code> - <code>String</code>: 合约字节码</li><li><code>arguments</code> - <code>Array</code> （可选）: 在部署合约时传递给构造函数的参数。</li></ul><p><strong>返回值：</strong><code>Object</code>交易对象:</p><ul><li><code>Array</code> - 参数: 之前传递给方法的参数。它们是可以被改变的。</li><li><code>Function</code> - send: 用来部署合约。promise 会被解析为合约实例而不是交易收据。</li><li><code>Function</code> - estimateGas: 估算部署合约所需要的 gas 用量。</li><li><code>Function</code> - encodeABI: 编码由合约数据和构造函数参数构成的合约部署 ABI。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line">myContract.<span class="title function_">deploy</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="string">&#x27;0x12345...&#x27;</span>,</span><br><span class="line">    <span class="attr">arguments</span>: [<span class="number">123</span>, <span class="string">&#x27;My String&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">send</span>(&#123;</span><br><span class="line">    <span class="attr">from</span>: <span class="string">&#x27;0x1234567890123456789012345678901234567891&#x27;</span>,</span><br><span class="line">    <span class="attr">gas</span>: <span class="number">1500000</span>,</span><br><span class="line">    <span class="attr">gasPrice</span>: <span class="string">&#x27;30000000000000&#x27;</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error, transactionHash</span>)&#123; ... &#125;)</span><br><span class="line">.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">function</span>(<span class="params">error</span>)&#123; ... &#125;)</span><br><span class="line">.<span class="title function_">on</span>(<span class="string">&#x27;transactionHash&#x27;</span>, <span class="keyword">function</span>(<span class="params">transactionHash</span>)&#123; ... &#125;)</span><br><span class="line">.<span class="title function_">on</span>(<span class="string">&#x27;receipt&#x27;</span>, <span class="keyword">function</span>(<span class="params">receipt</span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(receipt.<span class="property">contractAddress</span>) <span class="comment">// 包含新合约地址</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">on</span>(<span class="string">&#x27;confirmation&#x27;</span>, <span class="keyword">function</span>(<span class="params">confirmationNumber, receipt</span>)&#123; ... &#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">newContractInstance</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newContractInstance.<span class="property">options</span>.<span class="property">address</span>) <span class="comment">// 带有新合约地址的合约实例</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据已经设置为合约本身的选项</span></span><br><span class="line">myContract.<span class="property">options</span>.<span class="property">data</span> = <span class="string">&#x27;0x12345...&#x27;</span>;</span><br><span class="line"></span><br><span class="line">myContract.<span class="title function_">deploy</span>(&#123;</span><br><span class="line">    <span class="attr">arguments</span>: [<span class="number">123</span>, <span class="string">&#x27;My String&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">send</span>(&#123;</span><br><span class="line">    <span class="attr">from</span>: <span class="string">&#x27;0x1234567890123456789012345678901234567891&#x27;</span>,</span><br><span class="line">    <span class="attr">gas</span>: <span class="number">1500000</span>,</span><br><span class="line">    <span class="attr">gasPrice</span>: <span class="string">&#x27;30000000000000&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">newContractInstance</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newContractInstance.<span class="property">options</span>.<span class="property">address</span>) <span class="comment">// 具有新合同地址的合约实例</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只是编码</span></span><br><span class="line">myContract.<span class="title function_">deploy</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="string">&#x27;0x12345...&#x27;</span>,</span><br><span class="line">    <span class="attr">arguments</span>: [<span class="number">123</span>, <span class="string">&#x27;My String&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">encodeABI</span>();</span><br><span class="line">&gt; <span class="string">&#x27;0x12345...0000012345678765432&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// gas 估算</span></span><br><span class="line">myContract.<span class="title function_">deploy</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="string">&#x27;0x12345...&#x27;</span>,</span><br><span class="line">    <span class="attr">arguments</span>: [<span class="number">123</span>, <span class="string">&#x27;My String&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">estimateGas</span>(<span class="keyword">function</span>(<span class="params">err, gas</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(gas);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-3-3-methods"><a href="#2-3-3-methods" class="headerlink" title="2.3.3 methods"></a>2.3.3 methods</h3><h4 id="2-3-3-1-methods-myMethod-call"><a href="#2-3-3-1-methods-myMethod-call" class="headerlink" title="2.3.3.1 methods.myMethod.call"></a>2.3.3.1 methods.myMethod.call</h4><p>将在不发送交易的情况下调用该“常量”方法并在 EVM 中执行其智能合约方法。注意此种调用方式无法改变智能合约状态。</p><p><strong>参数 ：</strong></p><ol><li><code>options</code> - <code>Object</code> （可选）: 用于发起调用的选项。<ul><li><code>from</code> - <code>String</code> （可选）: 调用“交易”的发起方地址。</li><li><code>gasPrice</code> - <code>String</code> （可选）: 用于该调用“交易”的 gas 价格。以 wei 为计量单位。</li><li><code>gas</code> - <code>Number</code> （可选）: 用于该调用“交易”的 gas 用量上限 (gas limit)。</li></ul></li><li><code>callback</code> - <code>Function</code> （可选）: 回调函数，回调时将以智能合约方法执行结果作为第二个参数，以错误对象作为第一个参数。</li></ol><p><strong>返回值(Promise)：</strong>Mixed,智能合约方法返回值。 如果只返回一个值，则按原样返回。如果有多个返回值，则作为一个带有属性和索引的对象返回。</p><h4 id="2-3-3-2-methods-myMethod-send"><a href="#2-3-3-2-methods-myMethod-send" class="headerlink" title="2.3.3.2  methods.myMethod.send"></a>2.3.3.2  methods.myMethod.send</h4><p>向合约发送交易来执行其方法。注意这会改变合约状态。</p><p><strong>参数 ：</strong></p><ol><li><code>options</code> - <code>Object</code> （可选）: 用于发起调用的选项。<ul><li><code>from</code> - <code>String</code> （可选）: 调用“交易”的发起方地址。</li><li><code>gasPrice</code> - <code>String</code> （可选）: 用于该调用“交易”的 gas 价格。以 wei 为计量单位。</li><li><code>gas</code> - <code>Number</code> （可选）: 用于该调用“交易”的 gas 用量上限 (gas limit)。</li><li><code>value</code> - <code>Number|String|BN|BigNumber</code>（可选）: 交易转账金额，以 wei 为单位。</li></ul></li><li><code>callback</code> - <code>Function</code> （可选）: 回调函数，回调时将以智能合约方法执行结果作为第二个参数，以错误对象作为第一个参数。</li></ol><p><strong>返回值(PromiEvent)：</strong>一个 整合了事件发生器 <promiEvent> promise. 当收到交易<em>收据</em>时会被解析, 当该<code>send()</code>调用是从<code>someContract.deploy()</code>发出时，promise 会解析为<em>新合约地址</em>。重设该接口会导致合约实例方法和事件的重新生成。 此外也存在下面这些事件:</p><ul><li><code>&quot;transactionHash&quot;</code> 返回 <code>String</code>: 发送交易且得到交易哈希值后立即触发。</li><li><code>&quot;receipt&quot;</code> 返回 <code>Object</code>: 当收到交易<em>收据</em>时触发。合约收据带有的不是<code>logs</code>，而是以事件名称为健，以事件本身为属性值的<code>events</code>。 关于返回事件对象的详情，参见 getPastEvents 返回值 。</li><li><code>&quot;confirmation&quot;</code> 返回 <code>Number</code>, <code>Object</code>: 从区块被挖到的第一个区块确认开始，每次确认都会触发，直到第 24 次确认。触发时第一个参数为收到的确认数，第二个参数为收到交易收据。</li><li><code>&quot;error&quot;</code> 返回 <code>Error</code> 和 <code>Object|undefined</code>: 交易发送过程中出错时触发。如果交易被网络拒绝且带有交易收据，第二个参数就是该交易收据。</li></ul><h4 id="2-3-3-3-methods-myMethod-estimateGas"><a href="#2-3-3-3-methods-myMethod-estimateGas" class="headerlink" title="2.3.3.3 methods.myMethod.estimateGas"></a>2.3.3.3 methods.myMethod.estimateGas</h4><p>通过在 EVM 中执行方法来估算链上执行是需要的 gas 用量。 由于彼时合约状态的不同，当前估算的 gas 用量和随后通过真实交易所得到的实际 gas 用量可能会有所出入。</p><p><strong>参数 ：</strong></p><ol><li><code>options</code> - <code>Object</code> （可选）: 用于发起调用的选项。<ul><li><code>from</code> - <code>String</code> （可选）: 调用“交易”的发起方地址。</li><li><code>gas</code> - <code>Number</code> （可选）: 用于该调用“交易”的 gas 用量上限 (gas limit)。</li><li><code>value</code> - <code>Number|String|BN|BigNumber</code> （可选）: 交易转账金额，以 wei 为单位。</li></ul></li><li><code>callback</code> - <code>Function</code> （可选）: 回调函数，回调时将以智能合约方法执行结果作为第二个参数，以错误对象作为第一个参数。</li></ol><p><strong>返回值(Promise)：</strong>Number,估算的 gas 用量</p><h4 id="2-3-3-4-methods-myMethod-encodeABI"><a href="#2-3-3-4-methods-myMethod-encodeABI" class="headerlink" title="2.3.3.4 methods.myMethod.encodeABI"></a>2.3.3.4 methods.myMethod.encodeABI</h4><p>为指定的合约方法进行 ABI 编码，可用于发送交易、调用方法或向另一个合约方法传递参数。</p><p><strong>返回值(String)：</strong>编码后的 ABI 字节码，可用于交易发送或方法调用</p><h4 id="2-3-3-5-methods-myMethod-createaccesslist"><a href="#2-3-3-5-methods-myMethod-createaccesslist" class="headerlink" title="2.3.3.5 methods.myMethod.createaccesslist"></a>2.3.3.5 methods.myMethod.createaccesslist</h4><p>创建访问列表并将用call调用，方法执行将在EVM中执行时访问该列表。注:目前eth_createAccessList好像只有Geth支持</p><p><strong>参数 ：</strong></p><ol><li><code>options</code> - <code>Object</code> （可选）: 用于发起调用的选项。<ul><li><code>from</code> - <code>String</code> （可选）: 调用“交易”的发起方地址。</li><li><code>gas</code> - <code>Number</code> （可选）: 用于该调用“交易”的 gas 用量上限 (gas limit)。</li></ul></li><li><code>block</code> - <code>String|Number|BN|BigNumber</code>(可选):块号或哈希。或者<code>&quot;earliest&quot;</code>, <code>&quot;latest&quot;</code> , <code>&quot;pending&quot;</code> , <code>&quot;safe&quot;</code>或者<code>&quot;finalized&quot;</code>作为 默认块参数.</li><li><code>callback</code> - <code>Function</code> （可选）: 回调函数，回调时将以智能合约方法执行结果作为第二个参数，以错误对象作为第一个参数。</li></ol><p><strong>返回值(Promise)：</strong>Object,为交易生成的访问列表。</p><h2 id="2-4-Events-事件"><a href="#2-4-Events-事件" class="headerlink" title="2.4 Events(事件)"></a>2.4 Events(事件)</h2><h3 id="2-4-1-once"><a href="#2-4-1-once" class="headerlink" title="2.4.1 once"></a>2.4.1 once</h3><p>订阅一个事件并在第一次事件触发或错误发生后立即取消订阅。一个事件仅触发一次。</p><p><strong>参数 ：</strong></p><ol><li><code>event</code> - <code>String</code>: 要订阅的合约事件名, 或者用 <code>&quot;allEvents&quot;</code> 来订阅所有事件。</li><li><code>options</code> - <code>Object</code> （可选）: 用于部署的选项。<ol><li><code>filter</code> - <code>Object</code> （可选）: 按索引参数过滤事件, 例如 <code>&#123;filter: &#123;myNumber: [12,13]&#125;&#125;</code> 表示 “myNumber” 为 12 或 13 的所有事件。</li><li><code>topics</code> - <code>Array</code> （可选）: 手动设置事件过滤器的主题。如果提供了过滤器属性和事件签名，则不会自动设置（topic [0]）</li></ol></li><li><code>callback</code> - <code>Function</code>: 回调函数，触发时把<em>事件</em>对象作为第二个参数，错误作为第一个参数。 关于详细事件结构，参见 getPastEvents 返回值</li></ol><h3 id="2-4-2-events"><a href="#2-4-2-events" class="headerlink" title="2.4.2 events"></a>2.4.2 events</h3><p>订阅指定的合约事件</p><p><strong>参数 ：</strong></p><ol><li><code>options</code> - <code>Object</code> （可选）: 用于部署的选项。<ul><li><code>filter</code> - <code>Object</code> （可选）: 按索引参数过滤事件, 例如 <code>&#123;filter: &#123;myNumber: [12,13]&#125;&#125;</code> 表示 “myNumber” 为 12 或 13 的所有事件。</li><li><code>fromBlock</code> - <code>Number|String|BN|BigNumber</code> （可选）: 读取从该编号开始的区块中的事件（大于或等于该区块号）。 也可以使用预先定义的区块号，比如 <code>&quot;latest&quot;</code>, <code>&quot;earliest&quot;</code>, <code>&quot;pending&quot;</code>, <code>&quot;genesis&quot;</code> 等。</li><li><code>topics</code> - <code>Array</code> （可选）: 手动设置事件过滤器的主题。如果提供了过滤器属性和事件签名，则不会自动设置（topic [0]）。</li></ul></li><li><code>callback</code> - <code>Function</code> （可选）: 回调函数，回调时将以智能合约方法执行结果作为第二个参数，以错误对象作为第一个参数。</li></ol><p><strong>返回值(EventEmitter)：</strong>该事件发生器有以下事件：</p><ul><li><code>&quot;data&quot;</code> 返回 <code>Object</code>: 接收到新传入的事件时触发，参数为事件对象。</li><li><code>&quot;changed&quot;</code> 返回 <code>Object</code>: 当事件从区块链上移除时触发。 该事件带有额外属性 <code>&quot;removed: true&quot;</code>。</li><li><code>&quot;error&quot;</code> 返回 <code>Object</code>: 当订阅中出现错误时触发。</li><li><code>&quot;connected&quot;</code> 返回 <code>String</code>: 当订阅成功连接时触发一次。返回订阅 id。</li></ul><p>返回的事件 “对象” 结构如下：</p><ul><li><code>event</code> - <code>String</code>: 事件名称。</li><li><code>signature</code> - <code>String|Null</code>: 事件签名，如果是匿名事件，其值为 <code>null</code>。</li><li><code>address</code> - <code>String</code>: 该事件的发源地地址。</li><li><code>returnValues</code> - <code>Object</code>: 事件返回值， 比如 <code>&#123;myVar: 1, myVar2: &#39;0x234...&#39;&#125;</code>.</li><li><code>logIndex</code> - <code>Number</code>: 事件在区块中的索引位置。</li><li><code>transactionIndex</code> - <code>Number</code>: 事件所在交易在区块中的索引位置。</li><li><code>transactionHash</code> 32 Bytes - <code>String</code>: 事件所在交易的哈希值。</li><li><code>blockHash</code> 32 Bytes - <code>String</code>: 事件所在区块链的哈希值。区块处于 pending 状态时其值为 <code>null</code> 。</li><li><code>blockNumber</code> - <code>Number</code>: 事件所在区块的区块号。 区块处于 pending 状态时其值为 <code>null</code> 。</li><li><code>raw.data</code> - <code>String</code>: 包含未索引的日志参数。</li><li><code>raw.topics</code> - <code>Array</code>: 最大可保存 4 个 32 字节长的主题数组，主题 1-3 包含事件的索引参数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子 </span></span><br><span class="line">myContract.<span class="property">events</span>.<span class="title class_">MyEvent</span>(&#123;</span><br><span class="line">    <span class="attr">filter</span>: &#123;<span class="attr">myIndexedParam</span>: [<span class="number">20</span>,<span class="number">23</span>], <span class="attr">myOtherIndexedParam</span>: <span class="string">&#x27;0x123456789...&#x27;</span>&#125;, <span class="comment">// 使用数组表示 或：如 20 或 23。</span></span><br><span class="line">    <span class="attr">fromBlock</span>: <span class="number">0</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error, event</span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(event); &#125;)</span><br><span class="line">.<span class="title function_">on</span>(<span class="string">&quot;connected&quot;</span>, <span class="keyword">function</span>(<span class="params">subscriptionId</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(subscriptionId);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event); <span class="comment">// 与上述可选的回调结果相同</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">on</span>(<span class="string">&#x27;changed&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    <span class="comment">// 从本地数据库中删除事件</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">function</span>(<span class="params">error, receipt</span>) &#123; <span class="comment">// 如果交易被网络拒绝并带有交易收据，第二个参数将是交易收据。</span></span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件输出例子</span></span><br><span class="line">&gt; &#123;</span><br><span class="line">    <span class="attr">returnValues</span>: &#123;</span><br><span class="line">        <span class="attr">myIndexedParam</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">myOtherIndexedParam</span>: <span class="string">&#x27;0x123456789...&#x27;</span>,</span><br><span class="line">        <span class="attr">myNonIndexParam</span>: <span class="string">&#x27;My String&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">raw</span>: &#123;</span><br><span class="line">        <span class="attr">data</span>: <span class="string">&#x27;0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385&#x27;</span>,</span><br><span class="line">        <span class="attr">topics</span>: [<span class="string">&#x27;0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7&#x27;</span>, <span class="string">&#x27;0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">event</span>: <span class="string">&#x27;MyEvent&#x27;</span>,</span><br><span class="line">    <span class="attr">signature</span>: <span class="string">&#x27;0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7&#x27;</span>,</span><br><span class="line">    <span class="attr">logIndex</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">transactionIndex</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">transactionHash</span>: <span class="string">&#x27;0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385&#x27;</span>,</span><br><span class="line">    <span class="attr">blockHash</span>: <span class="string">&#x27;0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7&#x27;</span>,</span><br><span class="line">    <span class="attr">blockNumber</span>: <span class="number">1234</span>,</span><br><span class="line">    <span class="attr">address</span>: <span class="string">&#x27;0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-getPastEvents"><a href="#2-5-getPastEvents" class="headerlink" title="2.5 getPastEvents"></a>2.5 getPastEvents</h2><p>读取合约历史事件。</p><p><strong>参数 ：</strong></p><ul><li><code>event</code> - <code>String</code>: 合约事件名，或者用 <code>&quot;allEvents&quot;</code> 读取所有事件。</li><li><code>options</code> - <code>Object</code> （可选）: 用于部署的选项。<ol><li><code>filter</code> - <code>Object</code> （可选）: 按索引参数过滤事件, 例如 <code>&#123;filter: &#123;myNumber: [12,13]&#125;&#125;</code> 表示 “myNumber” 为 12 或 13 的所有事件。</li><li><code>fromBlock</code> - <code>Number|String|BN|BigNumber</code> （可选）: 读取从该编号开始的区块中的历史事件（大于或等于该区块号）。 也可以使用预先定义的区块编号，比如 <code>&quot;latest&quot;</code>, <code>&quot;earliest&quot;</code>, <code>&quot;pending&quot;</code>, <code>&quot;genesis&quot;</code> 。</li><li><code>toBlock</code> - <code>Number|String|BN|BigNumber</code> （可选）: 读取截止到该编号的区块中的历史事件（小于或等于该区块号）（默认值为 “latest”）。 也可以使用预先定义的区块编号，比如 <code>&quot;latest&quot;</code>, <code>&quot;earliest&quot;</code>, <code>&quot;pending&quot;</code>, <code>&quot;genesis&quot;</code> 。</li><li><code>topics</code> - <code>Array</code> （可选）: 用来手动设置事件过滤器的主题。如果设置了 filter 属性和事件签名，则不会自动设置（topic [0]）。</li></ol></li><li><code>callback</code> - <code>Function</code> （可选）: 回调函数，回调时将以智能合约方法执行结果作为第二个参数，以错误对象作为第一个参数。</li></ul><p><strong>返回值(Promise)：</strong>Array，满足给定事件或过滤条件的历史事件对象数组</p><h1 id="accounts-生成账户和用来签名交易与数据的函数"><a href="#accounts-生成账户和用来签名交易与数据的函数" class="headerlink" title="accounts(生成账户和用来签名交易与数据的函数)"></a>accounts(生成账户和用来签名交易与数据的函数)</h1><blockquote><p>该程序包尚未经过安全评审，可能存在安全隐患。在用于生产环境之前，请采取必要的措施来合理的清理内存，安全的存储私钥并完整测试交易的接收和发送功能！</p></blockquote><h2 id="3-1-create"><a href="#3-1-create" class="headerlink" title="3.1 create"></a>3.1 create</h2><p>生成具有公私钥的账户对象</p><p><strong>参数 ：</strong><code>entropy</code> - <code>String</code> (可选): 增加混淆度的随机字符串，至少 32 字符长。如果未设定将使用 randomhex 生成一个随机字符串。</p><p><strong>返回值(Object)：</strong> 账户对象，具有如下结构：</p><ul><li><code>address</code> - <code>string</code>: 账户地址。</li><li><code>privateKey</code> - <code>string</code>: 帐户私钥。绝对不要将其共享或以未加密的形式存储在 localstorage 中，并确保使用后将内存清空 。</li><li><code>signTransaction(tx [, callback])</code> - <code>Function</code>: 签名交易的函数. 更多信息可参考 web3.eth.accounts.signTransaction() 。</li><li><code>sign(data)</code> - <code>Function</code>: 用来签名数据的函数. 更多信息可参考 web3.eth.accounts.sign() 。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">address</span>: <span class="string">&quot;0xF2CD2AA0c7926743B1D4310b2BC984a0a453c3d4&quot;</span>,</span><br><span class="line">    <span class="attr">privateKey</span>: <span class="string">&quot;0xd7325de5c2c1cf0009fac77d3d04a9c004b038883446b065871bc3e831dcd098&quot;</span>,</span><br><span class="line">    <span class="attr">signTransaction</span>: <span class="keyword">function</span>(<span class="params">tx</span>)&#123;...&#125;,</span><br><span class="line">    <span class="attr">sign</span>: <span class="keyword">function</span>(<span class="params">data</span>)&#123;...&#125;,</span><br><span class="line">    <span class="attr">encrypt</span>: <span class="keyword">function</span>(<span class="params">password</span>)&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-privateKeyToAccount"><a href="#3-2-privateKeyToAccount" class="headerlink" title="3.2 privateKeyToAccount"></a>3.2 privateKeyToAccount</h2><p>通过私钥来创建账户对象</p><p><strong>参数 ：</strong><code>privateKey</code> - <code>String</code>: 用来创建账户的私钥。</p><p><strong>返回值(Object)：</strong> 具体见web3.eth.accounts.create()</p><h2 id="3-3-signTransaction"><a href="#3-3-signTransaction" class="headerlink" title="3.3 signTransaction"></a>3.3 signTransaction</h2><p>使用给定的私钥签名以太坊交易</p><p><strong>参数 ：</strong></p><ul><li><code>tx</code> <strong>-</strong> <code>Object</code>:交易对象，具有如下结构：<ul><li><code>nonce</code> - <code>String</code>: (可选) 签名交易时所用的 nonce 值。默认使用33. web3.eth.getTransactionCount().</li><li><code>chainId</code> - <code>String</code>: (可选) 签名交易时所用的 chain id。 默认使用 web3.eth.net.getId().</li><li><code>to</code> - <code>String</code>: (可选) 交易接受者，部署合约时其值为空。</li><li><code>data</code> - <code>String</code>: (可选) 交易调用数据，对简单转账交易来说其值为空。</li><li><code>value</code> - <code>String</code>: (可选) 以 wei 为单位的以太币转账数量。</li><li><code>gasPrice</code> - <code>String</code>: (可选) 交易所用的燃料价格，如果传入为空值则会使用 web3.eth.gasPrice()</li><li><code>gas</code> - <code>String</code>: 交易可用的燃料上限。</li><li><code>chain</code> - <code>String</code>: (可选) 默认值为 <code>mainnet</code>.</li><li><code>hardfork</code> - <code>String</code>: (可选) 默认值为 <code>petersburg</code>.</li><li><code>common</code> - <code>Object</code>: (可选) common 对象：<ul><li><code>customChain</code> - <code>Object</code>: 自定义链属性<ul><li><code>name</code> - <code>string</code>: (可选) 链名称</li><li><code>networkId</code> - <code>number</code>: 自定义链的网络 id</li><li><code>chainId</code> - <code>number</code>: 自定义链的 chain id</li></ul></li><li><code>baseChain</code> - <code>string</code>: (可选) <code>mainnet</code>, <code>goerli</code>, <code>kovan</code>, <code>rinkeby</code>, 或 <code>ropsten</code></li><li><code>hardfork</code> - <code>string</code>: (可选) <code>chainstart</code>, <code>homestead</code>, <code>dao</code>, <code>tangerineWhistle</code>, <code>spuriousDragon</code>, <code>byzantium</code>, <code>constantinople</code>, <code>petersburg</code>, 或 <code>istanbul</code></li></ul></li></ul></li><li><code>privateKey</code> - <code>String</code>: 签名交易所用的私钥。</li><li><code>callback</code> - <code>Function</code>: (可选) 可选的回调函数, 其第一个返回值为错误对象，第二个返回值为调用结果。</li></ul><p><strong>返回值(Promise)：</strong> <strong>Object</strong>，<strong>RLP 编码的交易对象：</strong></p><ul><li><code>messageHash</code> - <code>String</code>: 给定消息的哈希值。</li><li><code>r</code> - <code>String</code>: 签名的头 32 个字节。</li><li><code>s</code> - <code>String</code>: 签名接下来的 32 个字节。</li><li><code>v</code> - <code>String</code>: 恢复值 + 27。</li><li><code>rawTransaction</code> - <code>String</code>: RLP 编码的交易, 可使用 35.web3.eth.sendSignedTransaction 直接发送。</li><li><code>transactionHash</code> - <code>String</code>: RLP 编码交易的交易哈希。</li></ul><h2 id="3-4-recoverTransaction"><a href="#3-4-recoverTransaction" class="headerlink" title="3.4 recoverTransaction"></a>3.4 recoverTransaction</h2><p>恢复用于签名给定 RLP 编码交易的以太坊地址。</p><p><strong>参数 ：</strong><code>signature</code> - <code>String</code>: RLP 编码的交易。</p><p><strong>返回值(String)：</strong> 用于签名该交易的以太坊地址。</p><h2 id="3-5-hashMessage"><a href="#3-5-hashMessage" class="headerlink" title="3.5 hashMessage"></a>3.5 hashMessage</h2><p>计算给定消息的哈希值，以便于用于 web3.eth.accounts.recover() 函数。 数据采用 UTF-8 十六进制解码封装: <code>&quot;\x19Ethereum Signed Message:\n&quot; + message.length + message</code>，并使用 keccak256 进行哈希运算。</p><p><strong>参数 ：</strong><code>message</code> - <code>String</code>: 要进行哈希运算的消息，如果是 16 进制字符串，首先对其进行 UTF-8 解码。</p><p><strong>返回值(String)：</strong> 哈希运算后的消息</p><h2 id="3-6-sign"><a href="#3-6-sign" class="headerlink" title="3.6 sign"></a>3.6 sign</h2><p>签名任意数据。</p><p><strong>参数 ：</strong></p><ol><li><code>data</code> - <code>String</code>: 要签名的数据。</li><li><code>privateKey</code> - <code>String</code>: 用以签名的私钥</li></ol><p><strong>返回值(<strong>Object</strong>)：</strong> 签名对象</p><ul><li><code>message</code> - <code>String</code>: 给定消息。</li><li><code>messageHash</code> - <code>String</code>: 给定消息的哈希值。</li><li><code>r</code> - <code>String</code>: 签名的头 32 个字节。</li><li><code>s</code> - <code>String</code>: 签名接下来的 32 个字节。</li><li><code>v</code> - <code>String</code>: 恢复值(Recovery) + 27。</li></ul><h2 id="3-7-recover"><a href="#3-7-recover" class="headerlink" title="3.7 recover"></a>3.7 recover</h2><p>恢复用于签名给定数据的以太坊地址。</p><p><strong>参数 ：</strong></p><ul><li><p><code>message|signatureObject</code> - <code>String|Object</code>: 要么是签名消息或哈希，要么是带有下面属性的签名对象：</p><ul><li><code>messageHash</code> - <code>String</code>: 给定消息的哈希值，该消息已加前缀 <code>&quot;\x19Ethereum Signed Message:\n&quot; + message.length + message</code>。</li></ul></li><li><p><code>r</code> - <code>String</code>: 签名的头 32 个字节</p><ul><li><code>s</code> - <code>String</code>: 签名接下来的 32 个字节。</li></ul></li><li><p><code>v</code> - <code>String</code>: 恢复值 + 27。</p></li><li><p><code>signature</code> - <code>String</code>: 原始 RLP 编码签名或者通过第 2-4 号参数指定 v，r，s 值。</p></li><li><p><code>preFixed</code> - <code>Boolean</code> (可选, 默认值: <code>false</code>): 如果其值为 <code>true</code>, 给定的消息不会自动添加前缀 <code>&quot;\x19Ethereum Signed Message:\n&quot; + message.length + message</code>, 假定给定消息已经带了该前缀。</p></li></ul><p><strong>返回值(String)：</strong> 哈希运算后的消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line">web3.<span class="property">eth</span>.<span class="property">accounts</span>.<span class="title function_">recover</span>(&#123;</span><br><span class="line">    <span class="attr">messageHash</span>: <span class="string">&#x27;0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655&#x27;</span>,</span><br><span class="line">    <span class="attr">v</span>: <span class="string">&#x27;0x1c&#x27;</span>,</span><br><span class="line">    <span class="attr">r</span>: <span class="string">&#x27;0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd&#x27;</span>,</span><br><span class="line">    <span class="attr">s</span>: <span class="string">&#x27;0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">&gt; <span class="string">&quot;0x2c7536E3605D9C16a7a3D7b1898e529396a65c23&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 签名消息, 签名</span></span><br><span class="line">web3.<span class="property">eth</span>.<span class="property">accounts</span>.<span class="title function_">recover</span>(<span class="string">&#x27;Some data&#x27;</span>, <span class="string">&#x27;0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c&#x27;</span>);</span><br><span class="line">&gt; <span class="string">&quot;0x2c7536E3605D9C16a7a3D7b1898e529396a65c23&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3-8-encrypt"><a href="#3-8-encrypt" class="headerlink" title="3.8 encrypt"></a>3.8 encrypt</h2><p>将私钥加密变换为 keystore v3 标准格式</p><p><strong>参数 ：</strong></p><ol><li><code>privateKey</code> - <code>String</code>: 要加密的私钥。</li><li><code>password</code> - <code>String</code>: 用于加密的密码。</li></ol><p><strong>返回值(<strong>Object</strong>)：</strong> 加密后的 keystore v3 JSON。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line">web3.<span class="property">eth</span>.<span class="property">accounts</span>.<span class="title function_">encrypt</span>(<span class="string">&#x27;0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318&#x27;</span>, <span class="string">&#x27;test!&#x27;</span>)</span><br><span class="line">&gt; &#123;</span><br><span class="line">    <span class="attr">version</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;04e9bcbb-96fa-497b-94d1-14df4cd20af6&#x27;</span>,</span><br><span class="line">    <span class="attr">address</span>: <span class="string">&#x27;2c7536e3605d9c16a7a3d7b1898e529396a65c23&#x27;</span>,</span><br><span class="line">    <span class="attr">crypto</span>: &#123;</span><br><span class="line">        <span class="attr">ciphertext</span>: <span class="string">&#x27;a1c25da3ecde4e6a24f3697251dd15d6208520efc84ad97397e906e6df24d251&#x27;</span>,</span><br><span class="line">        <span class="attr">cipherparams</span>: &#123; <span class="attr">iv</span>: <span class="string">&#x27;2885df2b63f7ef247d753c82fa20038a&#x27;</span> &#125;,</span><br><span class="line">        <span class="attr">cipher</span>: <span class="string">&#x27;aes-128-ctr&#x27;</span>,</span><br><span class="line">        <span class="attr">kdf</span>: <span class="string">&#x27;scrypt&#x27;</span>,</span><br><span class="line">        <span class="attr">kdfparams</span>: &#123;</span><br><span class="line">            <span class="attr">dklen</span>: <span class="number">32</span>,</span><br><span class="line">            <span class="attr">salt</span>: <span class="string">&#x27;4531b3c174cc3ff32a6a7a85d6761b410db674807b2d216d022318ceee50be10&#x27;</span>,</span><br><span class="line">            <span class="attr">n</span>: <span class="number">262144</span>,</span><br><span class="line">            <span class="attr">r</span>: <span class="number">8</span>,</span><br><span class="line">            <span class="attr">p</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">mac</span>: <span class="string">&#x27;b8b010fff37f9ae5559a352a185e86f9b9c1d7f7a9f1bd4e82a5dd35468fc7f6&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-9-decrypt"><a href="#3-9-decrypt" class="headerlink" title="3.9 decrypt"></a>3.9 decrypt</h2><p>解密 keystore v3 JSON，并创建账户</p><p><strong>参数 ：</strong></p><ol><li><code>encryptedPrivateKey</code> - <code>String</code>: 要进行解密的加密私钥。</li><li><code>password</code> - <code>String</code>: 用于加密的密码。</li></ol><p><strong>返回值(<strong>Object</strong>)：</strong> 解密的帐户对象。</p><h2 id="3-10-wallet"><a href="#3-10-wallet" class="headerlink" title="3.10 wallet"></a>3.10 wallet</h2><p>一个多账户内存钱包，这些账户可以用于 web3.eth.sendTransaction()。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line">web3.<span class="property">eth</span>.<span class="property">accounts</span>.<span class="property">wallet</span>;</span><br><span class="line">&gt; <span class="title class_">Wallet</span> &#123;</span><br><span class="line">    <span class="number">0</span>: &#123;...&#125;, <span class="comment">// 账户索引</span></span><br><span class="line">    <span class="string">&quot;0xF0109fC8DF283027b6285cc889F5aA624EaC1F55&quot;</span>: &#123;...&#125;,  <span class="comment">// 账户地址</span></span><br><span class="line">    <span class="string">&quot;0xf0109fc8df283027b6285cc889f5aa624eac1f55&quot;</span>: &#123;...&#125;,  <span class="comment">// 全小写账户地址</span></span><br><span class="line">    <span class="number">1</span>: &#123;...&#125;,</span><br><span class="line">    <span class="string">&quot;0xD0122fC8DF283027b6285cc889F5aA624EaC1d23&quot;</span>: &#123;...&#125;,</span><br><span class="line">    <span class="string">&quot;0xd0122fc8df283027b6285cc889f5aa624eac1d23&quot;</span>: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,</span><br><span class="line">    <span class="attr">remove</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,</span><br><span class="line">    <span class="attr">save</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,</span><br><span class="line">    <span class="attr">load</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,</span><br><span class="line">    <span class="attr">clear</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">length</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-10-1-wallet-create"><a href="#3-10-1-wallet-create" class="headerlink" title="3.10.1 wallet.create"></a>3.10.1 wallet.create</h3><p>在钱包中创建一个或多个账户。不会覆盖已经存在的钱包。</p><p><strong>参数：</strong></p><ol><li><code>numberOfAccounts</code> - <code>Number</code>: 要创建的账户数量。设为空值时创建空钱包。</li><li><code>entropy</code> - <code>String</code> (可选): 创建账户时为增加随机性而使用的随机字符串，至少 32 个字符长。</li></ol><p><strong>返回值(Object)：</strong>钱包对象</p><h3 id="3-10-2-wallet-add"><a href="#3-10-2-wallet-add" class="headerlink" title="3.10.2 wallet.add"></a>3.10.2 wallet.add</h3><p>使用私钥或账户对象向钱包中添加账户</p><p><strong>参数：</strong><code>account</code> - <code>String|Object</code>: 私钥或者通过 web3.eth.accounts.create() 创建的账户对象。</p><p><strong>返回值(Object)：</strong>所添加的账户</p><h3 id="3-10-3-wallet-remove"><a href="#3-10-3-wallet-remove" class="headerlink" title="3.10.3 wallet.remove"></a>3.10.3 wallet.remove</h3><p>从钱包中移除账户。</p><p><strong>参数：</strong><code>account</code> - <code>String|Number</code>: 账户地址，或者账户在钱包中的索引。</p><p><strong>返回值(Boolean)：</strong>移除成功则返回 <code>true</code> ，否则返回 <code>false</code> 。</p><h3 id="3-10-4-wallet-clear"><a href="#3-10-4-wallet-clear" class="headerlink" title="3.10.4 wallet.clear"></a>3.10.4 wallet.clear</h3><p>安全地清空钱包并移除全部账户。</p><p><strong>返回值(Object)：</strong>钱包对象。</p><h3 id="3-10-5-wallet-encrypt"><a href="#3-10-5-wallet-encrypt" class="headerlink" title="3.10.5 wallet.encrypt"></a>3.10.5 wallet.encrypt</h3><p>加密所有的钱包账户为 keystore v3 对象。</p><p><strong>参数：</strong><code>password</code> - <code>String</code>: 用于加密的密钥。</p><p><strong>返回值(Array)：</strong>已加密的 keystore v3 对象。</p><h3 id="3-10-6-wallet-decrypt"><a href="#3-10-6-wallet-decrypt" class="headerlink" title="3.10.6 wallet.decrypt"></a>3.10.6 wallet.decrypt</h3><p>解密 keystore v3 对象。</p><p><strong>参数：</strong></p><ol><li><code>keystoreArray</code> - <code>Array</code>: 要解密的加密 keystore v3 对象。</li><li><code>password</code> - <code>String</code>: 用来加密的密钥。</li></ol><p><strong>返回值(Object)：</strong>钱包对象</p><h3 id="3-10-7-wallet-save"><a href="#3-10-7-wallet-save" class="headerlink" title="3.10.7 wallet.save"></a>3.10.7 wallet.save</h3><p>将钱包加密并在 local storage 中保存为字符串。</p><p><strong>参数：</strong></p><ol><li><code>password</code> - <code>String</code>: 用来加密钱包的密钥。</li><li><code>keyName</code> - <code>String</code>: (可选) 用来在 local storage 中寻址的健值, 默认值为 <code>&quot;web3js_wallet&quot;</code>。</li></ol><p>**返回值(Boolean)**：是否成功</p><h3 id="3-10-8-wallet-load"><a href="#3-10-8-wallet-load" class="headerlink" title="3.10.8 wallet.load"></a>3.10.8 wallet.load</h3><p>从 local storage 中载入钱包并解密。</p><p><strong>参数：</strong></p><ol><li><code>password</code> - <code>String</code>: 用来加密钱包的密钥。</li><li><code>keyName</code> - <code>String</code>: (可选) 用来在 local storage 中寻址的健值, 默认值为 <code>&quot;web3js_wallet&quot;</code>。</li></ol><p>**返回值(Object)**：钱包对象</p>]]></content>
      
      
      <categories>
          
          <category> web3.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> web3.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-Web3.eth</title>
      <link href="/2022/08/31/%E5%8C%BA%E5%9D%97%E9%93%BE/web3/3-Web3.eth/"/>
      <url>/2022/08/31/%E5%8C%BA%E5%9D%97%E9%93%BE/web3/3-Web3.eth/</url>
      
        <content type="html"><![CDATA[<p><strong><code>web3-eth</code> 包用来与以太坊区块链和以太坊智能合约进行交互</strong></p><h2 id="1-defaultAccount"><a href="#1-defaultAccount" class="headerlink" title="1.defaultAccount"></a>1.defaultAccount</h2><p><strong>(默认地址)</strong></p><p>如果下面这些方法没有指定 <code>&quot;from&quot;</code> 属性，则使用该地址作为默认的 <code>&quot;from&quot;</code> 属性值。</p><ul><li>web3.eth.sendTransaction()</li><li>web3.eth.call()</li><li>new web3.eth.Contract() -&gt; myContract.methods.myMethod().call()</li><li>new web3.eth.Contract() -&gt; myContract.methods.myMethod().send()</li></ul><p><strong>属性</strong>：<code>String</code> - 20 字节: 任意以太坊地址。 该地址对应的私钥应该保存在你的以太坊节点或 keystore 文件中， 默认值为 <code>undefined</code></p><h2 id="2-defaultBlock"><a href="#2-defaultBlock" class="headerlink" title="2.defaultBlock"></a>2.defaultBlock</h2><p><strong>一些特定方法所使用的默认区块号( 默认值为 latest)</strong></p><ul><li>web3.eth.getBalance()</li><li>web3.eth.getCode()</li><li>web3.eth.getTransactionCount()</li></ul><p><strong>属性</strong>：<code>Number|BN|BigNumber</code>: 指定区块号、<code>&quot;latest&quot;</code> - <code>String</code>: 最新区块 (区块链的头号区块)、</p><p>​   <code>&quot;pending&quot;</code> - <code>String</code>: 正要挖到的区块 (包括待处理交易)、<code>&quot;earliest&quot;</code> - <code>String</code>: 创世区块</p><h2 id="3-defaultHardfork"><a href="#3-defaultHardfork" class="headerlink" title="3.defaultHardfork"></a>3.defaultHardfork</h2><p><strong>(使用的硬分叉属性)</strong></p><p><strong>属性(String)</strong>:”chainstart”、”homestead”、”dao”、”tangerineWhistle”、”spuriousDragon”、”byzantium”、”constantinople”、</p><p>​  “petersburg”、”istanbul”（默认值为 “petersburg”）</p><h2 id="4-defaultChain"><a href="#4-defaultChain" class="headerlink" title="4.defaultChain"></a>4.defaultChain</h2><p><strong>(签名交易时所用的默认链)</strong></p><p><strong>属性(String):</strong>“mainnet”、”goerli”、”kovan”、”rinkeby”、”ropsten”（默认值为 “mainnet”）</p><h2 id="5-defaultCommon"><a href="#5-defaultCommon" class="headerlink" title="5.defaultCommon"></a>5.defaultCommon</h2><p><strong>（签名交易时所使用的默认通用属性）</strong></p><p><strong>属性</strong>（默认值为 undefined）：</p><ul><li><p><code>customChain</code> - <code>Object</code>: 自定义链属性</p><ul><li><p><code>name</code> - <code>string</code>: (可选) 链名称</p></li><li><p><code>networkId</code> - <code>number</code>: 自定义链的网络 ID</p></li><li><p><code>chainId</code> - <code>number</code>: 自定义链的链 ID</p></li></ul></li><li><p><code>baseChain</code> - <code>string</code>: (可选) <code>mainnet</code>, <code>goerli</code>, <code>kovan</code>, <code>rinkeby</code>, or <code>ropsten</code></p></li><li><p><code>hardfork</code> - <code>string</code>: (可选) <code>chainstart</code>, <code>homestead</code>, <code>dao</code>, <code>tangerineWhistle</code>, <code>spuriousDragon</code>, <code>byzantium</code>, <code>constantinople</code>, <code>petersburg</code>, or <code>istanbul</code></p></li></ul><h2 id="6-transactionBlockTimeout"><a href="#6-transactionBlockTimeout" class="headerlink" title="6.transactionBlockTimeout"></a>6.transactionBlockTimeout</h2><p><strong>(直到第一次确认发生交易应该等待的区块数)</strong></p><p><strong>返回值</strong>(number)：transactionBlockTimeout 当前值 (默认值: 50)</p><blockquote><p>用在基于套接字的连接上</p></blockquote><h2 id="7-transactionConfirmationBlocks"><a href="#7-transactionConfirmationBlocks" class="headerlink" title="7.transactionConfirmationBlocks"></a>7.transactionConfirmationBlocks</h2><p><strong>(一笔交易被认为已确认所需要的区块数)</strong></p><p><strong>返回值</strong>(number):transactionConfirmationBlocks 当前值 (默认值: 24)</p><blockquote><p>用在基于套接字的连接上</p></blockquote><h2 id="8-blockHeaderTimeout"><a href="#8-blockHeaderTimeout" class="headerlink" title="8.blockHeaderTimeout"></a>8.blockHeaderTimeout</h2><p><strong>(返回轮询获取交易收据前等待“newBlockHeaders”事件的秒数)</strong></p><p><strong>返回值</strong>(number):blockHeaderTimeout的当前值(默认值:10秒)</p><h2 id="9-transactionPollingTimeout"><a href="#9-transactionPollingTimeout" class="headerlink" title="9.transactionPollingTimeout"></a>9.transactionPollingTimeout</h2><p><strong>(Web3 等待网络挖出交易的确认收据的秒数)</strong></p><p><strong>返回值</strong>(number):transactionPollingTimeout 当前值 (默认值: 750)</p><blockquote><p>用在基于 HTTP 的连接上使用，当超时发生时，交易可能仍未完成</p></blockquote><h2 id="10-transactionPollingInterval"><a href="#10-transactionPollingInterval" class="headerlink" title="10.transactionPollingInterval"></a>10.transactionPollingInterval</h2><p><strong>(Web3调用接收确认网络挖掘交易的间隔秒数)</strong></p><p><strong>返回值</strong>(number):transactionPollingInterval的当前值(默认值:1000毫秒)</p><blockquote><p>用在基于 HTTP 的连接上使用</p></blockquote><h2 id="11-handleRevert"><a href="#11-handleRevert" class="headerlink" title="11.handleRevert"></a>11.handleRevert</h2><p><strong>(在调用下面这些方法时启用，将返回回退原因字符串)</strong></p><ul><li>web3.eth.call()</li><li>web3.eth.sendTransaction()</li><li>contract.methods.myMethod(…).send(…)</li><li>contract.methods.myMethod(…).call(…)</li></ul><p><strong>返回值</strong>(boolean):handleRevert 当前值 (默认值: false)</p><blockquote><p>回退原因字符串和签名会作为返回错误的属性存在。</p></blockquote><h2 id="12-maxListenersWarningThreshold"><a href="#12-maxListenersWarningThreshold" class="headerlink" title="12.maxListenersWarningThreshold"></a>12.maxListenersWarningThreshold</h2><p><strong>(支持套接字订阅的提供程序的事件侦听器的数量)</strong></p><p><strong>返回值</strong>(number)：maxListenersWarningThreshold的当前值(默认值:100)</p><h2 id="13-getProtocolVersion"><a href="#13-getProtocolVersion" class="headerlink" title="13.getProtocolVersion"></a>13.getProtocolVersion</h2><p><strong>(返回节点的以太坊协议版本)</strong></p><p><strong>返回值(Promise)</strong>;返回协议版本</p><h2 id="14-isSyncing"><a href="#14-isSyncing" class="headerlink" title="14.isSyncing"></a>14.isSyncing</h2><p><strong>(检测当前节点是否正在进行数据同步)</strong></p><p><strong>返回值(Promise)&#x2F;“false”</strong>:</p><ul><li><code>startingBlock</code> - <code>Number</code>: 同步开启时的区块号。</li><li><code>currentBlock</code> - <code>Number</code>: 节点已经同步到的区块号。</li><li><code>highestBlock</code> - <code>Number</code>: 预计会同步到的区块号。</li><li><code>knownStates</code> - <code>Number</code>: 预计要下载的状态数据。</li><li><code>pulledStates</code> - <code>Number</code>: 已经下载的状态数据</li></ul><h2 id="15-getCoinbase"><a href="#15-getCoinbase" class="headerlink" title="15.getCoinbase"></a>15.getCoinbase</h2><p><strong>(返回用来收取挖矿奖励的 coinbase 地址)</strong></p><p>**返回值(Promise)**：String - 20 个字节，在节点中设置的用来挖矿的 coinbase 地址。</p><h2 id="16-isMining"><a href="#16-isMining" class="headerlink" title="16.isMining"></a>16.isMining</h2><p><strong>(检测节点是否正在挖矿)</strong></p><p>**返回值(Promise)**：Boolean,如果节点正在挖矿返回 true ，否则返回 false</p><h2 id="17-getHashrate"><a href="#17-getHashrate" class="headerlink" title="17.getHashrate"></a><strong>17.getHashrate</strong></h2><p>**返回值(Promise)**：Number,返回节点每秒所挖的哈希数。</p><h2 id="18-getGasPrice"><a href="#18-getGasPrice" class="headerlink" title="18.getGasPrice"></a>18.getGasPrice</h2><p>返回当前 gas 价格预言机， gas 价格由最后几个区块 gas 价格的中位数确定。</p><p>**返回值(Promise)**：String,当前以 wei 为单位的 gas 价格</p><h2 id="19-getFeeHistory"><a href="#19-getFeeHistory" class="headerlink" title="19.getFeeHistory"></a>19.getFeeHistory</h2><p>返回所请求区块范围的基本gas费用和每笔交易有效优先级费用(如果可用)，对于前EIP-1559区块，天然气价格作为奖励返回，零作为每种天然气的基本费用返回。</p><p><strong>参数：</strong></p><ul><li><code>String|Number|BN|BigNumber</code>-请求范围内的块数，在单个查询中可以请求1到1024个块。如果不是所有块都可用，则可能会返回少于请求的数量。</li><li><code>String|Number|BN|BigNumber</code>-所请求范围的最高数字块。</li><li><code>Array of numbers</code>-从每个区块每个gas的有效优先费用中取样的百分位值的单调递增列表，按使用的天然气进行加权。示例:[“0”, “25”, “50”, “75”, “100”]或者[“0”, “0.5”, “1”, “1.5”, “3”, “80”]</li></ul><p><strong>返回值(Promise)：</strong>Object,返回的区块范围的费用历史对象:</p><ul><li><code>Number</code>oldestBlock -返回范围中编号最小的块。</li><li><code>Array of strings</code>baseFeePerGas——每个区块gas的批量基本费用的数组。这包括返回范围中最新块之后的下一个块，因为该值可以从最新块中导出。对于EIP1559年以前的块，返回零。</li><li><code>Array of numbers</code>gasUsedRatio -区块gas使用比率的数组，这些被计算为gas使用和gas限制的比率。</li><li><code>Array of string arrays</code>奖励-来自单个区块的每个gas数据点的有效优先费用的阵列。如果块为空，则返回所有零。</li></ul><h2 id="20-getAccounts"><a href="#20-getAccounts" class="headerlink" title="20.getAccounts"></a>20.getAccounts</h2><p><strong>返回值(Promise)：</strong>Array,返回节点所控制的账户列表</p><h2 id="21-getBlockNumber"><a href="#21-getBlockNumber" class="headerlink" title="21.getBlockNumber"></a>21.getBlockNumber</h2><p><strong>返回值(Promise)：</strong>Number,返回当前区块号</p><h2 id="22-getBalance"><a href="#22-getBalance" class="headerlink" title="22.getBalance"></a>22.getBalance</h2><p><strong>参数：</strong></p><ol><li><code>String</code> - 要获取余额的地址。</li><li><code>Number|String|BN|BigNumber</code> - (可选) 如果传入该参数，则会覆盖通过 web3.eth.defaultBlock 设置的默认区块。 也可以使用像 <code>&quot;latest&quot;</code>, <code>&quot;earliest&quot;</code>, <code>&quot;pending&quot;</code>, and <code>&quot;genesis&quot;</code> 这种预先设置的区块号。</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</li></ol><p><strong>返回值(Promise)：</strong>string,返回给定地址的当前账户余额，以 wei 为单位</p><h2 id="23-getStorageAt"><a href="#23-getStorageAt" class="headerlink" title="23.getStorageAt"></a>23.getStorageAt</h2><p><strong>参数：</strong></p><ol><li><code>String</code> - 用来获取存储值的地址。</li><li><code>Number|String|BN|BigNumber</code> - 存储的索引位置。</li><li><code>Number|String|BN|BigNumber</code> - (可选) 如果传入值则会覆盖通过 web3.eth.defaultBlock 设置的默认区块号。预定义的区块号可以使用 <code>&quot;latest&quot;</code>, <code>&quot;earliest&quot;</code> <code>&quot;pending&quot;</code>, 和 <code>&quot;genesis&quot;</code> 等值。</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</li></ol><p><strong>返回值(Promise)：</strong>string,返回地址在某个特定位置的存储值</p><h2 id="24-getCode"><a href="#24-getCode" class="headerlink" title="24.getCode"></a>24.getCode</h2><p><strong>参数：</strong></p><ol><li><code>String</code> - 获取代码所需要的地址。</li><li><code>Number|String|BN|BigNumber</code> - (可选) 如果传入值则会覆盖通过 web3.eth.defaultBlock 设置的默认区块号。预定义的区块号 <code>&quot;latest&quot;</code>, <code>&quot;earliest&quot;</code> <code>&quot;pending&quot;</code>, 和 <code>&quot;genesis&quot;</code> 等也可以使用。</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</li></ol><p><strong>返回值(Promise)：</strong>string,返回给定地址的代码数据</p><h2 id="25-getBlock"><a href="#25-getBlock" class="headerlink" title="25.getBlock"></a>25.getBlock</h2><p><strong>参数：</strong></p><ol><li><code>String|Number|BN|BigNumber</code> - 区块号或区块哈希。 或者是 <code>&quot;genesis&quot;</code>、 <code>&quot;latest&quot;</code>、 <code>&quot;earliest&quot;</code> 、 <code>&quot;pending&quot;</code> 等在 默认区块参数 中定义的字符串。</li><li><code>Boolean</code> - (可选, 默认值 <code>false</code>) 如果设定为 <code>true</code>，返回的区块会包含完整的交易对象。 默认值为 <code>false</code> ，没必要特别设置为 false 了。 如果设置为 false，则返回的区块中仅包含交易哈希值。</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</li></ol><p><strong>返回值(Promise)：</strong>Object,区块对象:</p><ul><li><code>number</code> - <code>Number</code>: 区块号。 打包中的区块其值为 <code>null</code>。</li><li><code>hash</code> 32 字节 - <code>String</code>: Hash of the block. 打包中的区块其值为 <code>null</code>。</li><li><code>parentHash</code> 32 字节 - <code>String</code>: 父区块哈希值。</li><li><code>baseFeePerGas</code> - <code>Number</code>: 在网络上发送交易的最低收费.</li><li><code>nonce</code> 8 Bytes - <code>String</code>: 所生成的工作量证明哈希值。打包中的区块其值为 <code>null</code>。</li><li><code>sha3Uncles</code> 32 字节 - <code>String</code>: 区块中叔块数据的 SHA3 哈希值。</li><li><code>logsBloom</code> 256 Bytes - <code>String</code>: 区块日志的布隆过滤器。打包中的区块其值为 <code>null</code>。</li><li><code>transactionsRoot</code> 32 字节 - <code>String</code>: 区块中交易 trie 树的根哈希。</li><li><code>stateRoot</code> 32 字节 - <code>String</code>: 区块中状态 trie 树的根哈希。</li><li><code>miner</code> - <code>String</code>: 获得挖矿奖励的受益人地址。</li><li><code>difficulty</code> - <code>String</code>: 该区块难度值。</li><li><code>totalDifficulty</code> - <code>String</code>: 到此区块为止链的总难度值。</li><li><code>extraData</code> - <code>String</code>: 区块补充数据字段。</li><li><code>size</code> - <code>Number</code>: 该区块的字节数大小。</li><li><code>gasLimit</code> - <code>Number</code>: 该区块允许的最大 gas 消耗量。</li><li><code>gasUsed</code> - <code>Number</code>: 该区块所有交易所消耗的 gas 总量。</li><li><code>timestamp</code> - <code>Number</code>: 区块生成时的时间戳。</li><li><code>transactions</code> - <code>Array</code>: 交易对象数组, 或者基于 <code>returnTransactionObjects</code> 参数的 32 字节交易哈希。</li><li><code>uncles</code> - <code>Array</code>: 叔块哈希数组。</li></ul><h2 id="26-getBlockTransactionCount"><a href="#26-getBlockTransactionCount" class="headerlink" title="26.getBlockTransactionCount"></a>26.getBlockTransactionCount</h2><p><strong>参数：</strong></p><ul><li><p><code>String|Number|BN|BigNumber</code> - 区块号或区块哈希。 或者像 <code>&quot;genesis&quot;</code>, <code>&quot;latest&quot;</code>, <code>&quot;earliest&quot;</code>, or <code>&quot;pending&quot;</code> 这些在 默认区块参数中指定的字符串。</p></li><li><p><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</p></li></ul><p><strong>返回值(Promise)：</strong>Number, 返回区块中包含的交易数量。</p><h2 id="27-getBlockUncleCount"><a href="#27-getBlockUncleCount" class="headerlink" title="27.getBlockUncleCount"></a>27.getBlockUncleCount</h2><p><strong>参数：</strong></p><ul><li><code>String|Number|BN|BigNumber</code> - 区块号或区块哈希。 或者像 <code>&quot;genesis&quot;</code>, <code>&quot;latest&quot;</code>, <code>&quot;earliest&quot;</code>, or <code>&quot;pending&quot;</code> 这些在 默认区块参数中指定的字符串。</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</li></ul><p><strong>返回值(Promise)：</strong>Number, 返回区块中包含的叔块数量。</p><h2 id="28-getUncle"><a href="#28-getUncle" class="headerlink" title="28.getUncle"></a>28.getUncle</h2><p><strong>参数：</strong></p><ul><li><code>String|Number|BN|BigNumber</code> - 区块号或区块哈希。 或者像 <code>&quot;genesis&quot;</code>, <code>&quot;latest&quot;</code>, <code>&quot;earliest&quot;</code>, or <code>&quot;pending&quot;</code> 这些在 默认区块参数 中指定的字符串。</li><li><code>Number</code> - 叔块位置索引。</li><li><code>Boolean</code> - (可选, 默认值 <code>false</code>) 如果设定为 <code>true</code>，返回的区块会包含完整的交易对象。 默认值为 <code>false</code> ，没必要特别设置为 false 了。 如果设置为 false，则返回的区块中仅包含交易哈希值。</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</li></ul><p><strong>返回值(Promise)：</strong>Object, 返回的叔块对象。 具体返回值可查看 25.web3.eth.getBlock()。。</p><blockquote><p>叔块不包含任何交易。</p></blockquote><h2 id="29-getTransaction"><a href="#29-getTransaction" class="headerlink" title="29.getTransaction"></a>29.getTransaction</h2><p><strong>参数:</strong></p><ul><li><p><code>String</code> - 交易哈希。</p></li><li><p><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</p></li></ul><p><strong>返回值(Promise)：</strong>Object, 返回的交易对象：</p><ul><li><code>hash</code> 32 字节 - <code>String</code>: 交易哈希。</li><li><code>nonce</code> - <code>Number</code>: 发送人在此之前进行的交易次数。</li><li><code>blockHash</code> 32 字节 - <code>String</code>: 该交易所在区块的区块哈希。 打包中的区块其值为 <code>null</code>。</li><li><code>blockNumber</code> - <code>Number</code>: 该交易所在区块的区块号。 打包中的区块其值为 <code>null</code>。</li><li><code>transactionIndex</code> - <code>Number</code>: 该交易在区块中的位置索引。 打包中的区块其值为 <code>null</code>。</li><li><code>from</code> - <code>String</code>: 交易发送人地址。</li><li><code>to</code> - <code>String</code>: 交易接收人地址。 对于合约创建交易其值为<code>null</code></li><li><code>value</code> - <code>String</code>: 转账金额。以 wei 为单位。</li><li><code>gasPrice</code> - <code>String</code>: 由发送人指定的 gas 价格。以 wei 为单位。</li><li><code>gas</code> - <code>Number</code>: 由发送人指定的 gas 数量。</li><li><code>input</code> - <code>String</code>: 伴随交易发送的数据。</li></ul><h2 id="30-getPendingTransactions"><a href="#30-getPendingTransactions" class="headerlink" title="30.getPendingTransactions"></a>30.getPendingTransactions</h2><p><strong>参数：</strong><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</p><p><strong>返回值(Promise&lt;Object[]&gt;)：</strong> 等待打包的交易数组:</p><ul><li><code>hash</code> 32 字节 - <code>String</code>: 交易哈希。</li><li><code>nonce</code> - <code>Number</code>: 发送人在此之前进行的交易次数。</li><li><code>blockHash</code> 32 字节 - <code>String</code>: 该交易所在区块的区块哈希。 打包中的区块其值为 <code>null</code>。</li><li><code>blockNumber</code> - <code>Number</code>: 该交易所在区块的区块号。 打包中的区块其值为 <code>null</code>。</li><li><code>transactionIndex</code> - <code>Number</code>: 该交易在区块中的位置索引。 打包中的区块其值为 <code>null</code>。</li><li><code>from</code> - <code>String</code>: 交易发送人地址。</li><li><code>to</code> - <code>String</code>: 交易接收人地址。 对于合约创建交易其值为<code>null</code></li><li><code>value</code> - <code>String</code>: 转账金额。以 wei 为单位。</li><li><code>gasPrice</code> - <code>String</code>: 由发送人指定的 gas 价格。以 wei 为单位。</li><li><code>gas</code> - <code>Number</code>: 由发送人指定的 gas 数量。</li><li><code>input</code> - <code>String</code>: 伴随交易发送的数据。</li></ul><h2 id="31-getTransactionFromBlock"><a href="#31-getTransactionFromBlock" class="headerlink" title="31.getTransactionFromBlock"></a>31.getTransactionFromBlock</h2><p><strong>参数:</strong></p><ol><li><code>String|Number|BN|BigNumber</code> - 区块号或区块哈希。 或者像 <code>&quot;genesis&quot;</code>, <code>&quot;latest&quot;</code>, <code>&quot;earliest&quot;</code>, or <code>&quot;pending&quot;</code> 这些在 默认区块参数 中指定的字符串。</li><li><code>Number</code> - 交易位置索引。</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</li></ol><p>**返回值(Promise):**Object,交易对象, 详情请查看 29.web3.eth.getTransaction()</p><h2 id="32-getTransactionReceipt"><a href="#32-getTransactionReceipt" class="headerlink" title="32.getTransactionReceipt"></a>32.getTransactionReceipt</h2><p><strong>参数:</strong></p><ul><li><p><code>String</code> - 交易哈希</p></li><li><p><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</p></li></ul><p><strong>返回值(Promise)：</strong>Object, 返回的交易收据对象,未能找到交易收据时返回 <code>null</code> :</p><ul><li><p><code>status</code> - <code>Boolean</code>: 若交易成功其值为 <code>TRUE</code> ， 交易被 EVM 回退其值为 <code>FALSE</code>。</p></li><li><p><code>blockHash</code> 32 字节 - <code>String</code>: 该交易所在区块的区块哈希。</p></li><li><p><code>blockNumber</code> - <code>Number</code>: 该交易所在区块的区块号。</p></li><li><p><code>transactionHash</code> 32 字节 - <code>String</code>: 交易哈希。</p></li><li><p><code>transactionIndex</code>- <code>Number</code>: 该交易在区块中的位置索引。</p></li><li><p><code>from</code> - <code>String</code>: 交易发送人地址。</p></li><li><p><code>to</code> - <code>String</code>: 交易接收人地址。 对于合约创建交易其值为<code>null</code></p></li><li><p><code>contractAddress</code> - <code>String</code>: 若指定交易为合约创建交易，其值为新创合约地址，否则其值为 <code>null</code>。</p></li><li><p><code>cumulativeGasUsed</code> - <code>Number</code>: 该交易执行时其所在区块已经累计消耗的 gas 量。</p></li><li><p><code>gasUsed</code>- <code>Number</code>: 该交易本身所消耗的 gas 量。</p></li><li><p><code>logs</code> - <code>Array</code>: 该交易所生成的日志对象。</p></li><li><p><code>effectiveGasPrice</code> - <code>Number</code>(或者<code>hex String</code>):从发送人账户中扣除的gas的实际价值。</p></li></ul><h2 id="33-getTransactionCount"><a href="#33-getTransactionCount" class="headerlink" title="33.getTransactionCount"></a>33.getTransactionCount</h2><p><strong>参数：</strong></p><ul><li><code>String</code> - 要获取发送交易量的地址。</li><li><code>Number|String|BN|BigNumber</code> - (可选) 如果传入值则会覆盖通过 web3.eth.defaultBlock 设置的默认区块号。预定义的区块号 <code>&quot;latest&quot;</code>, <code>&quot;earliest&quot;</code> <code>&quot;pending&quot;</code>, 和 <code>&quot;genesis&quot;</code> 等也可以使用。</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</li></ul><p>**返回值(Promise):**Object,返回从给定地址发出的交易数量</p><h2 id="34-sendTransaction"><a href="#34-sendTransaction" class="headerlink" title="34.sendTransaction"></a>34.sendTransaction</h2><p><strong>参数：</strong>1.Object，要发送的交易对象：</p><ul><li><code>from</code> - <code>String|Number</code>: 发送账户地址。 如未指定，则使用 web3.eth.defaultAccount 属性值。 或者在 web3.eth.accounts.wallet 中的本地钱包地址。</li><li><code>to</code> - <code>String</code>: (可选) 交易消息的目标地址，对于合约创建交易来说其值为空。</li><li><code>value</code> - <code>Number|String|BN|BigNumber</code>: (可选) 交易转账金额，以 wei 为单位，也是合约创建交易的初始转账。</li><li><code>gas</code> - <code>Number</code>: (可选, 默认值: 待定) 交易可用的 gas 量 (未使用的 gas 会被退回)。</li><li><code>gasPrice</code> - <code>Number|String|BN|BigNumber</code>: (可选) 交易可用的 gas 价格，以 wei 为单位, 默认值通过 web3.eth.gasPrice 获得。</li><li><code>type</code> - <code>Number|String|BN|BigNumber</code>:(可选)介于0和0x7f之间的8位无符号正数，表示交易的类型。</li><li><code>maxFeePerGas</code> - <code>Number|String|BN</code>:(可选，默认为<code>(2 * block.baseFeePerGas) + maxPriorityFeePerGas</code>)交易愿意总共支付的gas的最大费用</li><li><code>data</code> - <code>String</code>: (可选) 包含合约函数调用数据的 ABI 字节字符串 ，对合约创建交易来说，其值为合约初始化代码。</li><li><code>accessList</code> - <code>List of hexstrings</code>(可选)交易计划访问的地址和存储键的列表</li><li><code>nonce</code> - <code>Number</code>: (可选) 使用同样的 nonce 值可以覆盖处理中的交易。</li><li><code>chain</code> - <code>String</code>: (可选) 默认值为 <code>mainnet</code>.</li><li><code>hardfork</code> - <code>String</code>: (可选) 默认值为 <code>london</code>.</li><li><code>common</code> - <code>Object</code>: (可选) 通用对象<ul><li><code>customChain</code> - <code>Object</code>: 自定义链属性<ul><li><code>name</code> - <code>string</code>:  (可选) 链名称。</li><li><code>networkId</code> - <code>number</code>: 自定义链的网络 ID。</li><li><code>chainId</code> - <code>number</code>: 自定义链的链 ID</li></ul></li><li><code>baseChain</code> - <code>string</code>: (可选) <code>mainnet</code>, <code>goerli</code>, <code>kovan</code>, <code>rinkeby</code>, 或 <code>ropsten</code></li><li><code>hardfork</code> - <code>string</code>: (可选) <code>chainstart</code>, <code>homestead</code>, <code>dao</code>, <code>tangerineWhistle</code>, <code>spuriousDragon</code>, <code>byzantium</code>, <code>constantinople</code>, <code>petersburg</code>, <code>istanbul</code>, <code>berlin</code>, 或 <code>london</code></li></ul></li></ul><p>2.<code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</p><p><strong>返回值(PromiEvent)：</strong> 一个 整合事件发生器的 promise 对象. 将在收到交易收据 receipt 后得到解析, 此外有以下事件可用：</p><ul><li><code>&quot;transactionHash&quot;</code> 返回 <code>String</code>: 在交易发出并得到有效的交易哈希后立刻触发。</li><li><code>&quot;receipt&quot;</code> 返回 <code>Object</code>: 当收到交易收据后立刻触发。</li><li><code>&quot;confirmation&quot;</code> 返回 <code>Number</code>, <code>Object</code>: 每次确认后立刻触发，最多 12 次确认。确认编号为第一个参数，收据 receipt 为第二个参数。从交易所在区块被挖到的 0 号确认开始触发。</li></ul><p><code>&quot;error&quot;</code> 返回 <code>Error</code> and <code>Object|undefined</code>: 在发送交易的过程中如果出现错误则立刻触发。如果交易被网络拒绝时附带有交易收据，则第二个参数为交易收据。</p><blockquote><p><code>from</code> 属性可以是个地址或者 web3.eth.accounts.wallet 的索引值。 随后可以在本地通过该账户对应的私钥签名并通过 web3.eth.sendSignedTransaction() 发送交易。 如果 <code>chain</code>、 <code>hardfork</code> 或 <code>common</code> 这些属性值都没有设置, Web3 会尝试通过网络查询相应的网络 ID 和链 ID 并设置它们。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="comment">// 使用回调</span></span><br><span class="line">web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;</span><br><span class="line">    <span class="attr">from</span>: <span class="string">&#x27;0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: code <span class="comment">// deploying a contracrt</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error, hash</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 promise</span></span><br><span class="line">web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;</span><br><span class="line">    <span class="attr">from</span>: <span class="string">&#x27;0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe&#x27;</span>,</span><br><span class="line">    <span class="attr">to</span>: <span class="string">&#x27;0x11f4d0A3c12e86B4b5F39B213F7E19D048276DAe&#x27;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;1000000000000000&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">receipt</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用事件发生器</span></span><br><span class="line">web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;</span><br><span class="line">    <span class="attr">from</span>: <span class="string">&#x27;0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe&#x27;</span>,</span><br><span class="line">    <span class="attr">to</span>: <span class="string">&#x27;0x11f4d0A3c12e86B4b5F39B213F7E19D048276DAe&#x27;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;1000000000000000&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">on</span>(<span class="string">&#x27;transactionHash&#x27;</span>, <span class="keyword">function</span>(<span class="params">hash</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">on</span>(<span class="string">&#x27;receipt&#x27;</span>, <span class="keyword">function</span>(<span class="params">receipt</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">on</span>(<span class="string">&#x27;confirmation&#x27;</span>, <span class="keyword">function</span>(<span class="params">confirmationNumber, receipt</span>)&#123; ... &#125;)</span><br><span class="line">.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="variable language_">console</span>.<span class="property">error</span>); <span class="comment">// 如果是 out of gas 错误, 第二个参数为交易收据</span></span><br></pre></td></tr></table></figure><h2 id="35-sendSignedTransaction"><a href="#35-sendSignedTransaction" class="headerlink" title="35.sendSignedTransaction"></a>35.sendSignedTransaction</h2><p>发送已签名的交易，交易签名可以通过 37.web3.eth(.accounts).signTransaction 生成。</p><p><strong>参数：</strong></p><ul><li><code>String</code> - 16 进制格式的签名交易数据。</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</li></ul><p><strong>返回值：</strong>34.web3.eth.sendTransaction()</p><h2 id="36-sign"><a href="#36-sign" class="headerlink" title="36.sign"></a>36.sign</h2><p>使用指定账户对数据进行签名，该账户必须先解锁。</p><p><strong>参数：</strong></p><ul><li><code>String</code> - 待签名的数据。 对于字符串要先用 web3.utils.utf8ToHex 将其转换为 16 进制数据。</li><li><code>String|Number</code> - 用来签名的账户地址。或者本地钱包 web3.eth.accounts.wallet 中的地址或其索引。</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</li></ul><p><strong>返回值(Promise)：</strong>string,返回签名</p><h2 id="37-signTransaction"><a href="#37-signTransaction" class="headerlink" title="37.signTransaction"></a>37.signTransaction</h2><p>签名交易，用来签名的账户需要首先解锁。</p><p><strong>参数：</strong></p><ul><li><code>Object</code> - 要签名的交易数据，更多信息请看 web3.eth.sendTransaction() 。</li><li><code>String</code> - 签名交易所用的账户地址。</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</li></ul><p><strong>返回值(Promise)：</strong>Object,RLP 编码的交易。<code>raw</code> 属性可以用来通过 web3.eth.sendSignedTransaction 来发送交易。</p><h2 id="38-call"><a href="#38-call" class="headerlink" title="38.call"></a>38.call</h2><p>执行一个消息调用交易，消息调用交易直接在节点旳 VM 中而不需要通过区块链挖矿来执行。</p><p><strong>参数：</strong></p><ul><li><code>Object</code> - 交易对象，相关信息可以查看 web3.eth.sendTransaction, 消息调用交易和一般交易的区别是 <code>from</code> 属性也是可选的。</li><li><code>Number|String|BN|BigNumber</code> - (可选) 如果传入值则会覆盖通过 web3.eth.defaultBlock 设置的默认区块号。预定义的区块号 <code>&quot;latest&quot;</code>, <code>&quot;earliest&quot;</code> <code>&quot;pending&quot;</code>, 和 <code>&quot;genesis&quot;</code> 等也可以使用。</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</li></ul><p><strong>返回值(Promise)：</strong>String,消息调用的返回数据, 比如合约函数的返回值。</p><h2 id="39-estimateGas"><a href="#39-estimateGas" class="headerlink" title="39.estimateGas"></a>39.estimateGas</h2><p>通过执行一个消息调用来得到交易的 gas 用量。</p><p><strong>参数：</strong></p><ul><li><code>Object</code> - 交易对象，相关信息可以查看 web3.eth.sendTransaction, 消息调用交易和一般交易的区别是 <code>from</code> 属性也是可选的。</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</li></ul><p><strong>返回值(Promise)：</strong>String,模拟消息或交易调用的 gas 用量</p><h2 id="40-getPastLogs"><a href="#40-getPastLogs" class="headerlink" title="40.getPastLogs"></a>40.getPastLogs</h2><p>获取匹配给定条件的历史日志。</p><p><strong>参数：</strong><code>Object</code> - 过滤器对象，包含如下字段</p><ul><li><code>fromBlock</code> - <code>Number|String</code>: 起始区块 (<code>&quot;latest&quot;</code> 是指最近已挖出区块， <code>&quot;pending&quot;</code> 指待挖出的区块). 默认为 <code>&quot;latest&quot;</code>。</li><li><code>toBlock</code> - <code>Number|String</code>: 终止区块 (<code>&quot;latest&quot;</code> 是指最近已挖出区块 and <code>&quot;pending&quot;</code> 指待挖出的区块). 默认为 <code>&quot;latest&quot;</code>。</li><li><code>address</code> - <code>String|Array</code>: 需要获取日志的一个或多个地址。</li><li><code>topics</code> - <code>Array</code>: 必须出现在日志项中的主题值数组。这里的顺序是很重要的， 你可以使用 <code>null</code> 值来忽略某个主题, e.g. <code>[null, &#39;0x12...&#39;]</code>. 你也可以通过一个数组来指定该主题关联的一系列属性 e.g. <code>[null, [&#39;option1&#39;, &#39;option2&#39;]]</code></li></ul><p><strong>返回值(Promise)：</strong>Array,日志对象数组，每个对象的属性:</p><ul><li><code>address</code> - <code>String</code>: 事件发生源地址。</li><li><code>data</code> - <code>String</code>: 包含未索引的日志参数。</li><li><code>topics</code> - <code>Array</code>: 包含最多 4 个 32 字节主题的数组，主题 1-3 包含日志的索引参数。</li><li><code>logIndex</code> - <code>Number</code>: 事件在块中的索引位置。</li><li><code>transactionIndex</code> - <code>Number</code>: 创建事件的交易的索引位置。</li><li><code>transactionHash</code> 32 字节 - <code>String</code>: 创建事件的交易的哈希值。</li><li><code>blockHash</code> 32 字节 - <code>String</code>: 创建事件的块的哈希值，若处于 pending 状态，其值为 <code>null</code>。</li><li><code>blockNumber</code> - <code>Number</code>: 创建事件的块编号，处于 pending 状态时其值为 <code>null</code>。</li></ul><h2 id="41-getWork"><a href="#41-getWork" class="headerlink" title="41.getWork"></a>41.getWork</h2><p>获取矿工要满足的挖矿条件。返回当前区块的哈希，种子哈希以及要满足的边界条件（”目标值”）。</p><p><strong>参数</strong>：<code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</p><p><strong>返回值(Promise)：</strong>Array，挖矿条件:</p><ul><li><code>String</code> 32 字节 - 于 <strong>索引位置 0</strong>: 当前区块头工作量证明哈希。</li><li><code>String</code> 32 字节 - 于 <strong>索引位置 1</strong>: 用于 DAG 的种子哈希。</li><li><code>String</code> 32 字节 - 于 <strong>索引位置 2</strong>: 边界条件 (“目标值”), 2^256 &#x2F; 难度.</li></ul><h2 id="42-submitWork"><a href="#42-submitWork" class="headerlink" title="42.submitWork"></a>42.submitWork</h2><p>用来提交一个工作量证明方案。</p><p><strong>参数：</strong></p><ul><li><code>String</code> 8 Bytes: 找到的 nonce 值 (64 位)</li><li><code>String</code> 32 字节: 区块头的工作量证明哈希 (256 位)</li><li><code>String</code> 32 字节: The mix digest (256 位)</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</li></ul><p><strong>返回值(Promise)：</strong>String,如果提交的方案有效返回 <code>TRUE</code>，否则返回 false</p><h2 id="43-requestAccounts"><a href="#43-requestAccounts" class="headerlink" title="43.requestAccounts"></a>43.requestAccounts</h2><p><strong>参数：</strong><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</p><p>该方法将从当前运行环境（Metamask，Status 或 Mist）中请求&#x2F;启用帐户，如果你使用默认的 Web3.js provider (WebsocketProvider, HttpProvidder and IpcProvider) 连接节点，则该方法不起作用。 该方法只在你使用像 Status, Mist or Metamask 这些应用的嵌入式 provider 时才有效。</p><p>**返回值(Promise)：Array,**返回所启用账户数组</p><h2 id="44-getChainId"><a href="#44-getChainId" class="headerlink" title="44.getChainId"></a>44.getChainId</h2><p><strong>返回值(Promise)：</strong>Number,如果提交的方案有效返回 <code>TRUE</code>，否则返回 false</p><h2 id="45-getNodeInfo"><a href="#45-getNodeInfo" class="headerlink" title="45.getNodeInfo"></a>45.getNodeInfo</h2><p><strong>返回值(Promise)：</strong>String,当前客户端版本</p><h2 id="46-getProof"><a href="#46-getProof" class="headerlink" title="46.getProof"></a>46.getProof</h2><p>返回账户及相关存储数据，包括 <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1186.md">EIP-1186</a> 所描述的默克尔证明</p><p><strong>参数：</strong></p><ul><li><code>String</code> 20 字节: 账户或合约地址。</li><li><code>Number[] | BigNumber[] | BN[] | String[]</code> 32 字节: 应该被证明和包含的存储键值数组， 更多信息请看 web3.eth.getStorageAt。</li><li><code>Number | String | BN | BigNumber</code>: 区块号。 也可以使用预定义区块号 <code>&quot;latest&quot;</code>, <code>&quot;earliest&quot;</code>, and <code>&quot;genesis&quot;</code> 。</li><li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</li></ul><p><strong>返回值(Promise)：</strong>Object,一个账户对象：</p><ul><li><code>address</code> - <code>String</code>: 账户地址。</li><li><code>balance</code> - <code>String</code>: 账户余额。 详情请查看 web3.eth.getBalance.</li><li><code>codeHash</code> - <code>String</code>: 账户关联代码哈希值。 对于没有代码的一般账户会返回 “0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470”</li><li><code>nonce</code> - <code>String</code>: 账户 nonce 值。</li><li><code>storageHash</code> - <code>String</code>: 存储树的根哈希. 所有存储将由此根哈希开始提供默克尔证明。</li><li><code>accountProof</code> - <code>String[]</code>: rlp 编码序列化的默克尔节点数组，从状态根节点开始，接着是以 SHA3 (地址) 为键值的路径。<ul><li><code>storageProof</code> - <code>Object[]</code> 请求的存储条目数组。</li><li><code>key</code> - <code>String</code> 请求的存储键值。<code>value</code> - <code>String</code> 存储数据。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> web3.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> web3.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-Web3</title>
      <link href="/2022/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/web3/2-Web3/"/>
      <url>/2022/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/web3/2-Web3/</url>
      
        <content type="html"><![CDATA[<h2 id="Web3"><a href="#Web3" class="headerlink" title="Web3"></a>Web3</h2><p>Web3是web.js的主类，可以通过<code>Web3.modules</code>返回所有子模块类的对象</p><p><strong>子模块列表</strong>：</p><ul><li>Eth：与以太坊网络交互的 Eth 模块</li><li>Net：与网络属性进行交互的 Net 模块</li><li>Personal：与以太坊账户交互的 Personal 模块</li><li>Shh：与whisper协议交互的 Shh 模块</li><li>Bzz：与swarm网络交互的 Bzz 模块</li><li>Utils：工具性函数</li></ul><h3 id="1-version"><a href="#1-version" class="headerlink" title="1.version"></a>1.<strong>version</strong></h3><p><strong>（ 返回当前 web3.js 库的软件包版本）</strong></p><p><strong>返回值</strong>(String)：当前版本</p><h3 id="2-setProvider"><a href="#2-setProvider" class="headerlink" title="2.setProvider"></a>2.<strong>setProvider</strong></h3><p><strong>（改变相应模块的 provider）</strong></p><p><strong>参数</strong>：Object(myProvider)：一个有效的provider</p><p>**返回值(String)**：Boolean</p><blockquote><p>通过web3调用它的时候，web3.eth、web3.net等子模块的provider也会被设置，除了web3.bzz，它总需要单独设置</p></blockquote><h3 id="3-providers"><a href="#3-providers" class="headerlink" title="3.providers"></a>3.providers</h3><p><strong>（包含当前可用的 providers）(子模块也有)</strong></p><p><strong>返回值(Object)：</strong></p><ul><li><code>HttpProvider</code>: 因为不能用于订阅，HTTP provider 已经<strong>不推荐使用</strong>。</li><li><code>WebsocketProvider</code>: Websocket provider 是用于传统的浏览器中的标准方法.</li><li><code>IpcProvider</code>: 当运行一个本地节点时，IPC provider 用于 node.js 下的DApp 环境，提供最为安全的连接。</li></ul><h3 id="4-giveProvider"><a href="#4-giveProvider" class="headerlink" title="4.giveProvider"></a>4.giveProvider</h3><p><strong>(返回浏览器设置的原生 provider ，否则返回 null)(子模块也有)</strong></p><p><strong>返回值：</strong>浏览器设置好的 provider 或者 <code>null</code></p><h3 id="5-currentProvider"><a href="#5-currentProvider" class="headerlink" title="5.currentProvider"></a>5.currentProvider</h3><p><strong>(当前在用的 provider)(子模块也有)</strong></p><p><strong>返回值</strong>：当前在用的 provider 或者 <code>null</code></p><h3 id="6-BatchRequest"><a href="#6-BatchRequest" class="headerlink" title="6.BatchRequest"></a>6.BatchRequest</h3><p><strong>（创建并执行批量请求的类）(子模块也有)</strong></p><p><strong>返回值(Object)：</strong>具有如下方法</p><ul><li><code>add(request)</code>: 添加请求对象到批量调用中。</li><li><code>execute()</code>: 执行批量请求。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">var</span> contract = <span class="keyword">new</span> web3.<span class="property">eth</span>.<span class="title class_">Contract</span>(abi, address);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> batch = <span class="keyword">new</span> web3.<span class="title class_">BatchRequest</span>();</span><br><span class="line">batch.<span class="title function_">add</span>(web3.<span class="property">eth</span>.<span class="property">getBalance</span>.<span class="title function_">request</span>(<span class="string">&#x27;0x0000000000000000000000000000000000000000&#x27;</span>, <span class="string">&#x27;latest&#x27;</span>, callback));</span><br><span class="line">batch.<span class="title function_">add</span>(contract.<span class="property">methods</span>.<span class="title function_">balance</span>(address).<span class="property">call</span>.<span class="title function_">request</span>(&#123;<span class="attr">from</span>: <span class="string">&#x27;0x0000000000000000000000000000000000000000&#x27;</span>&#125;, callback2));</span><br><span class="line">batch.<span class="title function_">execute</span>();</span><br></pre></td></tr></table></figure><h3 id="7-extend"><a href="#7-extend" class="headerlink" title="7.extend"></a>7.extend</h3><p><strong>（扩展 web3 模块）(子模块也有)</strong></p><p><strong>参数</strong>：</p><ul><li><code>methods</code> - <code>Object</code>: 扩展对象，带有一组如下所示的方法描述对象:<ul><li><code>property</code> - <code>String</code>: (可选) 要添加到模块上的属性名称。如果没有设置属性，则直接添加到模块上。</li><li><code>methods</code> - <code>Array</code>: 方法描述对象数组：<ul><li><code>name</code> - <code>String</code>: 要添加的方法名称。</li><li><code>call</code> - <code>String</code>: RPC 方法名称。</li><li><code>params</code> - <code>Number</code>: (可选) 方法的参数个数，默认值为 0。</li><li><code>inputFormatter</code> - <code>Array</code>: (可选) 输入格式化函数数组，每个成员对应一个函数参数，或者使用 null 来对应不需要进行格式化处理的参数。</li><li><code>outputFormatter - ``Function</code>: (可选) 用来格式化方法输出。</li></ul></li></ul></li></ul><p><strong>返回值(Object)</strong>: 扩展模块.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//l</span></span><br><span class="line">web3.<span class="title function_">extend</span>(&#123;</span><br><span class="line">    <span class="attr">property</span>: <span class="string">&#x27;myModule&#x27;</span>,</span><br><span class="line">    <span class="attr">methods</span>: [&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;getBalance&#x27;</span>,</span><br><span class="line">        <span class="attr">call</span>: <span class="string">&#x27;eth_getBalance&#x27;</span>,</span><br><span class="line">        <span class="attr">params</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">inputFormatter</span>: [web3.<span class="property">extend</span>.<span class="property">formatters</span>.<span class="property">inputAddressFormatter</span>, web3.<span class="property">extend</span>.<span class="property">formatters</span>.<span class="property">inputDefaultBlockNumberFormatter</span>],</span><br><span class="line">        <span class="attr">outputFormatter</span>: web3.<span class="property">utils</span>.<span class="property">hexToNumberString</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;getGasPriceSuperFunction&#x27;</span>,</span><br><span class="line">        <span class="attr">call</span>: <span class="string">&#x27;eth_gasPriceSuper&#x27;</span>,</span><br><span class="line">        <span class="attr">params</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">inputFormatter</span>: [<span class="literal">null</span>, web3.<span class="property">utils</span>.<span class="property">numberToHex</span>]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">web3.<span class="title function_">extend</span>(&#123;</span><br><span class="line">    <span class="attr">methods</span>: [&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;directCall&#x27;</span>,</span><br><span class="line">        <span class="attr">call</span>: <span class="string">&#x27;eth_callForFun&#x27;</span>,</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(web3);</span><br><span class="line">&gt; <span class="title class_">Web3</span> &#123;</span><br><span class="line">    <span class="attr">myModule</span>: &#123;</span><br><span class="line">        <span class="attr">getBalance</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,</span><br><span class="line">        <span class="attr">getGasPriceSuperFunction</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">directCall</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,</span><br><span class="line">    <span class="attr">eth</span>: <span class="title class_">Eth</span> &#123;...&#125;,</span><br><span class="line">    <span class="attr">bzz</span>: <span class="title class_">Bzz</span> &#123;...&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web3.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> web3.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-开始</title>
      <link href="/2022/08/26/%E5%8C%BA%E5%9D%97%E9%93%BE/web3/1-%E5%BC%80%E5%A7%8B/"/>
      <url>/2022/08/26/%E5%8C%BA%E5%9D%97%E9%93%BE/web3/1-%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li><h4 id="使用NPM-npm-install-web3"><a href="#使用NPM-npm-install-web3" class="headerlink" title="使用NPM:npm install web3"></a>使用NPM:npm install web3</h4></li><li><h4 id="Yarn-yarn-add-web3"><a href="#Yarn-yarn-add-web3" class="headerlink" title="Yarn:yarn add web3"></a>Yarn:yarn add web3</h4></li><li><h4 id="在浏览器中"><a href="#在浏览器中" class="headerlink" title="在浏览器中:"></a>在浏览器中:</h4></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In Node.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Web3</span> = <span class="built_in">require</span>(<span class="string">&#x27;web3&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> web3 = <span class="keyword">new</span> <span class="title class_">Web3</span>(<span class="string">&#x27;ws://localhost:8545&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In TypeScript</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Web3</span> <span class="keyword">from</span> <span class="string">&#x27;web3&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> web3 = <span class="keyword">new</span> <span class="title class_">Web3</span>(<span class="string">&#x27;ws://localhost:8545&#x27;</span>);</span><br></pre></td></tr></table></figure><h1 id="json接口"><a href="#json接口" class="headerlink" title="json接口"></a>json接口</h1><p>json接口是一个json对象，描述应用程序二进制接口(ABI)以太坊智能合约，使用这个json接口，web3.js能够创建表示智能契约的JavaScript对象及其使用web3.eth.Contract对象.</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能:"></a>功能:</h3><ul><li><code>type</code>: <code>&quot;function&quot;</code>, <code>&quot;constructor&quot;</code>(可以省略，默认为<code>&quot;function&quot;</code>; <code>&quot;fallback&quot;</code>也有可能，但与web3.js无关)；</li><li><code>name</code>:函数的名称(仅对函数类型存在)；</li><li><code>constant</code>: <code>true</code>如果函数被指定为不修改区块链状态；</li><li><code>payable</code>: <code>true</code>如果函数接受以太，则默认为<code>false</code>;</li><li><code>stateMutability</code>:具有下列值之一的字符串:<code>pure</code>(指定不读取区块链状态)，<code>view</code>(与相同<code>constant</code>以上)，<code>nonpayable</code>和<code>payable</code>(与相同<code>payable</code>以上)；</li><li><code>inputs</code>:对象的数组，每个对象包含:<ul><li><code>name</code>:参数的名称；</li><li><code>type</code>:参数的规范类型。</li></ul></li><li><code>outputs</code>:与相同的对象数组<code>inputs</code>如果没有输出，可以省略。</li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件:"></a>事件:</h3><ul><li><code>type</code>:始终<code>&quot;event&quot;</code></li><li><code>name</code>:事件的名称；</li><li><code>inputs</code>:对象的数组，每个对象包含:<ul><li><code>name</code>:参数的名称；</li><li><code>type</code>:参数的规范类型。</li><li><code>indexed</code>: <code>true</code>如果该字段是日志主题的一部分，<code>false</code>如果它是日志的数据段之一。</li></ul></li><li><code>anonymous</code>: <code>true</code>如果事件被声明为<code>anonymous</code>.</li></ul>]]></content>
      
      
      <categories>
          
          <category> web3.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> web3.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-实用工具Utils</title>
      <link href="/2022/08/24/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/7-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7Utils/"/>
      <url>/2022/08/24/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/7-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7Utils/</url>
      
        <content type="html"><![CDATA[<h1 id="应用程序二进制接口"><a href="#应用程序二进制接口" class="headerlink" title="应用程序二进制接口"></a>应用程序二进制接口</h1><h2 id="1-1-AbiCoder"><a href="#1-1-AbiCoder" class="headerlink" title="1.1 AbiCoder"></a>1.1 AbiCoder</h2><p><strong>AbiCoder</strong>是编码器的集合，可用于在EVM和更高级别库之间通过二进制数据格式进行编码和解码的操作。</p><p>大多数开发人员不需要直接使用这个类，因为Interface类极大地简化了这些操作。</p><h2 id="1-2-ABI格式"><a href="#1-2-ABI格式" class="headerlink" title="1.2 ABI格式"></a>1.2 ABI格式</h2><h3 id="1-2-1-HUman-REadable-ABI"><a href="#1-2-1-HUman-REadable-ABI" class="headerlink" title="1.2.1 HUman-REadable ABI"></a>1.2.1 HUman-REadable ABI</h3><p><strong>Human-Readable ABI</strong> 是早期被 ethers 所描述提出的， 它允许使用一个Solidity式签名(Solidity signature)来描述每个方法(method)、事件(event)和错误(error)。</p><h3 id="1-2-2-Solidity-JSON-ABI"><a href="#1-2-2-Solidity-JSON-ABI" class="headerlink" title="1.2.2 **Solidity JSON **ABI"></a>1.2.2 **Solidity JSON **ABI</h3><p><strong>Solidity JSON ABI</strong>是许多工具导出的标准格式，包括Solidity编译器.</p><h3 id="1-2-3-Solidity-Object-ABI"><a href="#1-2-3-Solidity-Object-ABI" class="headerlink" title="1.2.3 Solidity Object ABI"></a>1.2.3 <strong>Solidity Object</strong> ABI</h3><p>使用JSON.parse解析Solidity JSON ABI的结果完全与Interface类兼容， 且该对象的每个方法、事件和错误都与Fragment类兼容。</p><p>一些开发人员可能更喜欢这种方式，因为它允许将ABI属性作为普通的JavaScript对象访问，并且Solidity ABI与JSON ABI非常匹配。</p><h2 id="1-3-Fragments"><a href="#1-3-Fragments" class="headerlink" title="1.3 Fragments"></a>1.3 Fragments</h2><p>对一个ABI进行描述解释</p><h3 id="1-3-0-Formats"><a href="#1-3-0-Formats" class="headerlink" title="1.3.0 Formats"></a>1.3.0 Formats</h3><p>每个Fragment和ParamType可以使用其<code>format</code>方法输出。</p><p><strong><em>ethers</em>.<em>utils</em>.<em>FormatTypes</em>.full ⇒ <em>string</em>：</strong>这是一个完整的人类可读(human-readable)的字符串，包括所有的参数名，任何可选的修饰符(例如，<code>indexed</code>，<code>public</code>等)和空格，以提高代码可读性。</p><p><strong><em>ethers</em>.<em>utils</em>.<em>FormatTypes</em>.minimal ⇒ <em>string</em>：</strong>这类似于<code>full</code>，除了没有不必要的空白或参数名。这对于存储最小的字符串非常有用，该字符串仍然可以使用Fragment . from， 从完全重构原始的Fragment。</p><p><strong><em>ethers</em>.<em>utils</em>.<em>FormatTypes</em>.json ⇒ <em>string</em>：</strong>这将返回一个JavaScript对象，安全地调用<code>JSON.stringify</code>创建一个JSON字符串。</p><p><strong><em>ethers</em>.<em>utils</em>.<em>FormatTypes</em>.sighash ⇒ <em>string</em>：</strong>一个最小的输出格式，Solidity在计算签名哈希或事件主题topic的哈希时使用它。</p><h3 id="1-3-1-Fragment"><a href="#1-3-1-Fragment" class="headerlink" title="1.3.1 Fragment"></a>1.3.1 <strong>Fragment</strong></h3><p>一个ABI是<strong>Fragments</strong>的集合，每个fragment指定:一个错误、一个事件、一个函数、一个构造函数</p><p><strong>属性：</strong></p><p><strong><em>fragment</em>.name ⇒ <em>string</em>：</strong>事件或函数的name。如果是ConstructorFragment时为null。</p><p><em><strong>fragment*.type ⇒ *string：</strong></em>这是一个表示Fragment类型的字符串。如:<code>constructor</code>、<code>event</code>、<code>function</code></p><p>**<em>fragment</em>.inputs ⇒ *Array&lt; ParamType &gt;*：**构造函数、事件等输入参数的ParamType的数组。</p><p><strong>方法：</strong></p><p><strong><em>fragment</em>.format( [ <em>format</em> &#x3D; <em>sighash</em> ] ) ⇒ <em>string</em>：</strong>使用可用的输出格式创建Fragment的字符串描述。</p><p><strong><em>ethers</em>.<em>utils</em>.______Fragment.from( <em>objectOrString</em> ) ⇒ ____<em>Fragment</em>：</strong>从任何兼容的object或String创建一个新的**__Fragment**子类。</p><p><strong><em>ethers</em>.<em>utils</em>.<em>Fragment</em>.is__Fragment( <em>object</em> ) ⇒ <em>boolean</em>：</strong>如果<em>object</em> 是一个**__Fragment**返回true。</p><h3 id="1-3-2-ConstructorFragment"><a href="#1-3-2-ConstructorFragment" class="headerlink" title="1.3.2 ConstructorFragment"></a>1.3.2 ConstructorFragment</h3><p>**<em>fragment</em>.gas ⇒ *大数(BigNumber)*：**表示部署期间应该使用的gas limit，它可以是null。</p><p><strong><em>fragment</em>.payable ⇒ <em>boolean</em>：</strong>表示构造函数在部署期间是否可以接收ether(例如：msg.value !&#x3D; 0)。</p><p><strong><em>fragment</em>.stateMutability ⇒ <em>string</em>：</strong>构造函数的state mutability。它可以是:<code>nonpayable</code>、<code>payable</code></p><h3 id="1-3-3-ErrorFragment"><a href="#1-3-3-ErrorFragment" class="headerlink" title="1.3.3 ErrorFragment"></a>1.3.3 ErrorFragment</h3><h3 id="1-3-4-EventFragment"><a href="#1-3-4-EventFragment" class="headerlink" title="1.3.4 EventFragment"></a>1.3.4 EventFragment</h3><p><strong><em>fragment</em>.anonymous ⇒ <em>boolean</em>：</strong>表示事件(event)是否匿名。匿名事件在创建日志时不会将其topic哈希值注入到topic0中</p><h3 id="1-3-5-FunctionFragment"><a href="#1-3-5-FunctionFragment" class="headerlink" title="1.3.5 FunctionFragment"></a>1.3.5 FunctionFragment</h3><p><strong><em>fragment</em>.constant ⇒ <em>boolean</em>：</strong>表示函数是否为常量(即不改变状态)。如果设为true表示状态可变性是<code>pure</code> 或 <code>view</code>。</p><p><strong><em>fragment</em>.stateMutability ⇒ <em>string</em>：</strong>构造器的状态可变性。它可以是:<code>nonpayable</code>、<code>payable</code>、<code>pure</code>、<code>view</code></p><p>**<em>fragment</em>.outputs ⇒ *Array&lt; ParamType &gt;*：**函数输出参数的列表。</p><h3 id="1-3-6-ParamType"><a href="#1-3-6-ParamType" class="headerlink" title="1.3.6 ParamType"></a>1.3.6 ParamType</h3><p>表示Solidity中的参数:</p><p><strong>属性：</strong></p><p><strong><em>paramType</em>.name ⇒ <em>string</em>：</strong>本地参数名。对于未命名的参数，这个值为null。例如，参数字符串<code>string foobar</code>会输出<code>foobar</code>。</p><p><em><strong>paramType*.type ⇒ *string：</strong></em>参数的完整类型，包括元组和数组符号。对于未命名的参数，这个值可能为null。</p><p><em><strong>paramType*.baseType ⇒ *string：</strong></em>参数的基类型(base type)。对于原始类型(例如<code>address</code>, <code>uint256</code>等)，这等同于type。 对于数组，它将是string <code>array</code>，对于元组，它将是string <code>tuple</code>。</p><p><em><strong>paramType*.indexed ⇒ *boolean：</strong></em>参数是否被标记为索引。这只适用于参数是EventFragment的部分。</p><p><em><strong>paramType*.arrayChildren ⇒ *ParamType：</strong></em>数组的children类型。对于任何非数组的参数，这将是null。</p><p><em><strong>paramType*.arrayLength ⇒ *number：</strong></em>数组的长度，或动态数组的长度<code>-1</code>。对于不是数组的参数，这个值为null。</p><p>**<em>paramType</em>.components ⇒ *Array&lt; ParamType &gt;*：**元组的组成部分。这对于非元组参数是null。</p><p><strong>方法：</strong></p><p><strong><em>paramType</em>.format( [ <em>outputType</em> &#x3D; <em>sighash</em> ] )：</strong>使用可用的output formats创建Fragment的字符串描述。</p><p><strong><em>ethers</em>.<em>utils</em>.<em>ParamType</em>.from( <em>objectOrString</em> ) ⇒ <em>ParamType</em>：</strong>从任何兼容的<em>object或String</em>创建一个新的<strong>ParamType</strong>。</p><p><strong><em>ethers</em>.<em>utils</em>.<em>ParamType</em>.isParamType( <em>object</em> ) ⇒ <em>boolean</em>：</strong>如果<em>object</em> 是一个<strong>ParamType</strong>返回true。</p><h2 id="1-4-Interface"><a href="#1-4-Interface" class="headerlink" title="1.4 Interface"></a>1.4 Interface</h2><p>**接口(Interface)**类是以太坊网络上的与合约交互所需的编码和解码的一种抽象,EVM本身并不理解ABI是什么。</p><p>它只是一组商定的格式，用于编码合约所需的各种类型的数据，以便它们可以相互交互。</p><p><strong>（创建实例)new <em>ethers</em>.<em>utils</em>.Interface( <em>abi</em> ):<strong>从表示<em>abi</em>的JSON字符串或对象创建一个新的</strong>接口</strong>。</p><h3 id="1-4-1-属性"><a href="#1-4-1-属性" class="headerlink" title="1.4.1 属性"></a>1.4.1 属性</h3><p>**<em>interface</em>.fragments ⇒ *Array&lt; Fragment &gt;*：**接口中所有的Fragments。</p><p><em><strong>interface*.errors ⇒ *Array&lt; ErrorFragment &gt;：</strong></em>接口中所有的Error Fragments。</p><p><em><strong>interface*.events ⇒ *Array&lt; EventFragment &gt;：</strong></em>接口中所有的Event Fragments。</p><p><em><strong>interface*.functions ⇒ *Array&lt; FunctionFragment &gt;：</strong></em>接口中所有的Function Fragments。</p><p><em><strong>interface*.deploy ⇒ *ConstructorFragment“：</strong></em>接口中所有的Constructor Fragments。</p><h3 id="1-4-2-格式化"><a href="#1-4-2-格式化" class="headerlink" title="1.4.2 格式化"></a>1.4.2 格式化</h3><p>**<em>interface</em>.format( [ <em>format</em> ] ) ⇒ *string | Array&lt; string &gt;*：**返回格式化的接口。如果格式类型是<code>json</code>，则返回一个字符串，否则返回一个由human-readable（人类可读）字符串组成的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">FormatTypes</span> = ethers.<span class="property">utils</span>.<span class="property">FormatTypes</span>;</span><br><span class="line"></span><br><span class="line">iface.<span class="title function_">format</span>(<span class="title class_">FormatTypes</span>.<span class="property">json</span>)</span><br><span class="line"><span class="comment">// &#x27;[&#123;&quot;type&quot;:&quot;constructor&quot;,&quot;payable&quot;:false,&quot;inputs&quot;:[&#123;&quot;type&quot;:&quot;string&quot;,&quot;name&quot;:&quot;symbol&quot;&#125;,&#123;&quot;type&quot;:&quot;string&quot;,&quot;name&quot;:&quot;name&quot;&#125;]&#125;,&#123;&quot;type&quot;:&quot;function&quot;,&quot;name&quot;:&quot;transferFrom&quot;,&quot;constant&quot;:false,&quot;payable&quot;:false,&quot;inputs&quot;:[&#123;&quot;type&quot;:&quot;address&quot;,&quot;name&quot;:&quot;from&quot;&#125;,&#123;&quot;type&quot;:&quot;address&quot;,&quot;name&quot;:&quot;to&quot;&#125;,&#123;&quot;type&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;amount&quot;&#125;],&quot;outputs&quot;:[]&#125;,&#123;&quot;type&quot;:&quot;function&quot;,&quot;name&quot;:&quot;mint&quot;,&quot;constant&quot;:false,&quot;stateMutability&quot;:&quot;payable&quot;,&quot;payable&quot;:true,&quot;inputs&quot;:[&#123;&quot;type&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;amount&quot;&#125;],&quot;outputs&quot;:[]&#125;,&#123;&quot;type&quot;:&quot;function&quot;,&quot;name&quot;:&quot;balanceOf&quot;,&quot;constant&quot;:true,&quot;stateMutability&quot;:&quot;view&quot;,&quot;payable&quot;:false,&quot;inputs&quot;:[&#123;&quot;type&quot;:&quot;address&quot;,&quot;name&quot;:&quot;owner&quot;&#125;],&quot;outputs&quot;:[&#123;&quot;type&quot;:&quot;uint256&quot;&#125;]&#125;,&#123;&quot;type&quot;:&quot;event&quot;,&quot;anonymous&quot;:false,&quot;name&quot;:&quot;Transfer&quot;,&quot;inputs&quot;:[&#123;&quot;type&quot;:&quot;address&quot;,&quot;name&quot;:&quot;from&quot;,&quot;indexed&quot;:true&#125;,&#123;&quot;type&quot;:&quot;address&quot;,&quot;name&quot;:&quot;to&quot;,&quot;indexed&quot;:true&#125;,&#123;&quot;type&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;amount&quot;&#125;]&#125;,&#123;&quot;type&quot;:&quot;error&quot;,&quot;name&quot;:&quot;AccountLocked&quot;,&quot;inputs&quot;:[&#123;&quot;type&quot;:&quot;address&quot;,&quot;name&quot;:&quot;owner&quot;&#125;,&#123;&quot;type&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;balance&quot;&#125;]&#125;,&#123;&quot;type&quot;:&quot;function&quot;,&quot;name&quot;:&quot;addUser&quot;,&quot;constant&quot;:false,&quot;payable&quot;:false,&quot;inputs&quot;:[&#123;&quot;type&quot;:&quot;tuple&quot;,&quot;name&quot;:&quot;user&quot;,&quot;components&quot;:[&#123;&quot;type&quot;:&quot;string&quot;,&quot;name&quot;:&quot;name&quot;&#125;,&#123;&quot;type&quot;:&quot;address&quot;,&quot;name&quot;:&quot;addr&quot;&#125;]&#125;],&quot;outputs&quot;:[&#123;&quot;type&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;id&quot;&#125;]&#125;,&#123;&quot;type&quot;:&quot;function&quot;,&quot;name&quot;:&quot;addUsers&quot;,&quot;constant&quot;:false,&quot;payable&quot;:false,&quot;inputs&quot;:[&#123;&quot;type&quot;:&quot;tuple[]&quot;,&quot;name&quot;:&quot;user&quot;,&quot;components&quot;:[&#123;&quot;type&quot;:&quot;string&quot;,&quot;name&quot;:&quot;name&quot;&#125;,&#123;&quot;type&quot;:&quot;address&quot;,&quot;name&quot;:&quot;addr&quot;&#125;]&#125;],&quot;outputs&quot;:[&#123;&quot;type&quot;:&quot;uint256[]&quot;,&quot;name&quot;:&quot;id&quot;&#125;]&#125;,&#123;&quot;type&quot;:&quot;function&quot;,&quot;name&quot;:&quot;getUser&quot;,&quot;constant&quot;:true,&quot;stateMutability&quot;:&quot;view&quot;,&quot;payable&quot;:false,&quot;inputs&quot;:[&#123;&quot;type&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;id&quot;&#125;],&quot;outputs&quot;:[&#123;&quot;type&quot;:&quot;tuple&quot;,&quot;name&quot;:&quot;user&quot;,&quot;components&quot;:[&#123;&quot;type&quot;:&quot;string&quot;,&quot;name&quot;:&quot;name&quot;&#125;,&#123;&quot;type&quot;:&quot;address&quot;,&quot;name&quot;:&quot;addr&quot;&#125;]&#125;]&#125;]&#x27;</span></span><br><span class="line"></span><br><span class="line">iface.<span class="title function_">format</span>(<span class="title class_">FormatTypes</span>.<span class="property">full</span>)</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   &#x27;constructor(string symbol, string name)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function transferFrom(address from, address to, uint256 amount)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function mint(uint256 amount) payable&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function balanceOf(address owner) view returns (uint256)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;event Transfer(address indexed from, address indexed to, uint256 amount)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;error AccountLocked(address owner, uint256 balance)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function addUser(tuple(string name, address addr) user) returns (uint256 id)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function addUsers(tuple(string name, address addr)[] user) returns (uint256[] id)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function getUser(uint256 id) view returns (tuple(string name, address addr) user)&#x27;</span></span><br><span class="line"><span class="comment">// ]</span></span><br><span class="line"></span><br><span class="line">iface.<span class="title function_">format</span>(<span class="title class_">FormatTypes</span>.<span class="property">minimal</span>)</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   &#x27;constructor(string,string)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function transferFrom(address,address,uint256)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function mint(uint256) payable&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function balanceOf(address) view returns (uint256)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;event Transfer(address indexed,address indexed,uint256)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;error AccountLocked(address,uint256)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function addUser(tuple(string,address)) returns (uint256)&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function addUsers(tuple(string,address)[]) returns (uint256[])&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;function getUser(uint256) view returns (tuple(string,address))&#x27;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><h3 id="1-4-3-Fragment-Access"><a href="#1-4-3-Fragment-Access" class="headerlink" title="1.4.3 Fragment Access"></a>1.4.3 <strong>Fragment Access</strong></h3><p><strong><em>interface</em>.getFunction( <em>fragment</em> ) ⇒ FunctionFragment：</strong>返回<em>fragment</em>的FunctionFragment</p><p><strong><em>interface</em>.getError( <em>fragment</em> ) ⇒ ErrorFragment：</strong>返回<em>fragment</em>的ErrorFragment</p><p><strong><em>interface</em>.getEvent( <em>fragment</em> ) ⇒ EventFragment：</strong>返回<em>fragment</em>的EventFragment</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过方法(method)的签名，这是经过标准化后的，因此空格和多余的属性会被舍去</span></span><br><span class="line"></span><br><span class="line">iface.<span class="title function_">getFunction</span>(<span class="string">&quot;transferFrom(address, address, uint256)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过name的方式;这只在方法名称是唯一确定的情况下才有效</span></span><br><span class="line">iface.<span class="title function_">getFunction</span>(<span class="string">&quot;transferFrom&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过函数选择器</span></span><br><span class="line">iface.<span class="title function_">getFunction</span>(<span class="string">&quot;0x23b872dd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果方法不存在将抛出异常</span></span><br><span class="line">iface.<span class="title function_">getFunction</span>(<span class="string">&quot;doesNotExist()&quot;</span>);</span><br><span class="line"><span class="comment">// [Error: no matching function] &#123;</span></span><br><span class="line"><span class="comment">//   argument: &#x27;signature&#x27;,</span></span><br><span class="line"><span class="comment">//   code: &#x27;INVALID_ARGUMENT&#x27;,</span></span><br><span class="line"><span class="comment">//   reason: &#x27;no matching function&#x27;,</span></span><br><span class="line"><span class="comment">//   value: &#x27;doesNotExist()&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-4-签名和主题的哈希"><a href="#1-4-4-签名和主题的哈希" class="headerlink" title="1.4.4 签名和主题的哈希"></a>1.4.4 签名和主题的哈希</h3><p><em>*<em>interface</em>.getSighash( <em>fragment</em> ) ⇒ *string&lt; DataHexString&lt; 4 &gt; &gt;<em>：**返回</em>fragment</em>的签名哈希(sighash)或函数选择器(Function Selector)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iface.<span class="title function_">getSighash</span>(<span class="string">&quot;balanceOf&quot;</span>);</span><br><span class="line">iface.<span class="title function_">getSighash</span>(<span class="string">&quot;balanceOf(address)&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fragment = iface.<span class="title function_">getFunction</span>(<span class="string">&quot;balanceOf&quot;</span>)</span><br><span class="line">iface.<span class="title function_">getSighash</span>(fragment);</span><br><span class="line"><span class="comment">// &#x27;0x70a08231&#x27;</span></span><br></pre></td></tr></table></figure><p><strong><em>interface</em>.getEventTopic( <em>fragment</em> ) ⇒ string&lt; DataHexString&lt; 32 &gt; &gt;：</strong>返回<em>fragment</em>的主题哈希(topic hash)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iface.<span class="title function_">getEventTopic</span>(<span class="string">&quot;Transfer&quot;</span>);</span><br><span class="line">iface.<span class="title function_">getEventTopic</span>(<span class="string">&quot;Transfer(address, address, uint)&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fragment = iface.<span class="title function_">getEvent</span>(<span class="string">&quot;Transfer&quot;</span>)</span><br><span class="line">iface.<span class="title function_">getEventTopic</span>(fragment);</span><br><span class="line"><span class="comment">// &#x27;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-5-编码数据"><a href="#1-4-5-编码数据" class="headerlink" title="1.4.5 编码数据"></a>1.4.5 编码数据</h3><h3 id="1-4-6-解码数据"><a href="#1-4-6-解码数据" class="headerlink" title="1.4.6 解码数据"></a>1.4.6 解码数据</h3><h3 id="1-4-7-解析"><a href="#1-4-7-解析" class="headerlink" title="1.4.7 解析"></a>1.4.7 解析</h3><h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h1><p><em>*<em>ethers</em>.<em>utils</em>.getAddress( <em>address</em> ) ⇒ *string&lt; 地址(Address) &gt;<em>：**返回一个校验和</em>地址</em>。</p><p>**<em>ethers</em>.<em>utils</em>.getIcapAddress( <em>address</em> ) ⇒ *string&lt; IcapAddress &gt;*：**返回一个ICAP address地址，与getAddress具有相同的限制条件。</p><p><strong><em>ethers</em>.<em>utils</em>.isAddress( <em>address</em> ) ⇒ boolean：</strong>如果地址有效(任何支持的格式)则返回true。</p><p><em>*<em>ethers</em>.<em>utils</em>.computeAddress( <em>publicOrPrivateKey</em> ) ⇒ *string&lt; 地址(Address) &gt;<em>：**返回</em>publicOrPrivateKey</em>的地址。公钥可以压缩或不压缩，私钥将自动转换为派生的公钥。</p><p>**<em>ethers</em>.<em>utils</em>.recoverAddress( <em>digest</em> , <em>signature</em> ) ⇒ *string&lt; 地址(Address) &gt;*：**使用ECDSA Public Key Recovery来确定摘要(digest)生成签名的公钥地址，</p><p>**<em>ethers</em>.<em>utils</em>.getContractAddress( <em>transaction</em> ) ⇒ *string&lt; 地址(Address) &gt;*：**一个交易用于部署合约则返回部署合约后的合约地址。</p><p>**<em>ethers</em>.<em>utils</em>.getCreate2Address( <em>from</em> , <em>salt</em> , <em>initCodeHash</em> ) ⇒ *string&lt; 地址(Address) &gt;*：**返回给定CREATE2调用后的合约地址。</p><h1 id="大数-BigNumber"><a href="#大数-BigNumber" class="headerlink" title="大数(BigNumber)"></a>大数(BigNumber)</h1><p><strong>BigNumber</strong>是一个可以安全地对任意大小的数字进行数学运算的对象。</p><p>大多数需要返回值的操作将返回一个<strong>BigNumber</strong>，接受值的参数通常会接收它们。</p><h2 id="3-1-创建实例"><a href="#3-1-创建实例" class="headerlink" title="3.1 创建实例"></a>3.1 创建实例</h2><p>BigNumber的构造函数不能被直接调用。相反，使用静态<code>BigNumber.from</code>。</p><p><em>*<em>ethers</em>.<em>BigNumber</em>.from( <em>aBigNumberish</em> ) ⇒ *大数(BigNumber)<em>：**为</em>aBigNumberish</em>返回一个<strong>BigNumber</strong>的实例</p><h2 id="3-2-方法"><a href="#3-2-方法" class="headerlink" title="3.2 方法"></a>3.2 方法</h2><h3 id="3-2-1-数学运算"><a href="#3-2-1-数学运算" class="headerlink" title="3.2.1 数学运算"></a>3.2.1 数学运算</h3><p><em>*<em>BigNumber</em>.add( <em>otherValue</em> ) ⇒ *大数(BigNumber)<em>：**返回值为</em>BigNumber</em> <strong>+</strong> <em>otherValue</em>的BigNumber。</p><p>**<em>BigNumber</em>.sub( <em>otherValue</em> ) ⇒ *大数(BigNumber)*：**返回值为 <em>BigNumber</em> <strong>-</strong> <em>otherValue</em>的BigNumber。</p><p>**<em>BigNumber</em>.mul( <em>otherValue</em> ) ⇒ *大数(BigNumber)*：**返回值为 <em>BigNumber</em> <strong>×</strong> <em>otherValue</em>的BigNumber。</p><p><em><strong>BigNumber*.div( <em>divisor</em> ) ⇒ *大数(BigNumber)：</strong></em>返回值为 <em>BigNumber</em> <strong>÷</strong> <em>divisor</em>的BigNumber。</p><p><em><strong>BigNumber*.mod( <em>divisor</em> ) ⇒ *大数(BigNumber)：</strong></em>返回值为 <em>BigNumber</em> ÷ <em>divisor</em>余数的BigNumber。</p><p><em><strong>BigNumber*.pow( <em>exponent</em> ) ⇒ *大数(BigNumber)：</strong></em>返回值为 <em>BigNumber</em> 指数的幂为<em>exponent</em>的BigNumber。</p><p>**<em>BigNumber</em>.abs( ) ⇒ *大数(BigNumber):***返回值为绝对值的BigNumber。</p><p>**<em>BigNumber</em>.mask( <em>bitcount</em> ) ⇒ *大数(BigNumber):**<em>返回一个BigNumber，其BigNumber的值超出</em>bitcount*最低有效位的位则设为0。</p><h4 id="Two’s-Complement"><a href="#Two’s-Complement" class="headerlink" title="Two’s Complement"></a>Two’s Complement</h4><p>Two’s Complement是用于编码和解码固定宽度的有符号值，同时有效地保留数学运算。大多数用户不需要与它们交互。</p><p>**<em>BigNumber</em>.fromTwos( <em>bitwidth</em> ) ⇒ <em>大数(BigNumber)</em>:**返回一个BigNumber, 值由带位宽（bitwidth）的二进制补码转换而来。</p><p>**<em>BigNumber</em>.toTwos( <em>bitwidth</em> ) ⇒ *大数(BigNumber)*：**返回一个BigNumber, BigNumber的值转换为带位宽的二进制补码。</p><h3 id="3-2-2-比较和相等"><a href="#3-2-2-比较和相等" class="headerlink" title="3.2.2 比较和相等"></a>3.2.2 比较和相等</h3><p><strong><em>BigNumber</em>.eq( <em>otherValue</em> ) ⇒ <em>boolean</em>：</strong>当且仅当<em>BigNumber</em>的值等于<em>otherValue</em>时返回true。</p><p><em><strong>BigNumber*.lt( <em>otherValue</em> ) ⇒ *boolean：</strong></em>当且仅当<em>BigNumber</em>的值**&lt;**otherValue时返回true。</p><p><em><strong>BigNumber*.lte( <em>otherValue</em> ) ⇒ *boolean：</strong></em>当且仅当<em>BigNumber</em>的值<strong>≤</strong>otherValue时返回true。</p><p><strong><em>BigNumber</em>.gt( <em>otherValue</em> ) ⇒ <em>boolean</em>：</strong>当且仅当<em>BigNumber</em>的值**&gt;**<em>otherValue</em>时返回true。</p><p><em><strong>BigNumber*.gte( <em>otherValue</em> ) ⇒ *boolean：</strong></em>当且仅当<em>BigNumber</em>的值<strong>≥</strong><em>otherValue</em>时返回true。</p><p><em><strong>BigNumber*.isZero( ) ⇒ *boolean：</strong></em>当且仅当<em>BigNumber</em>的值为0时返回true。</p><h3 id="3-2-3-转换"><a href="#3-2-3-转换" class="headerlink" title="3.2.3 转换"></a>3.2.3 转换</h3><p><strong><em>BigNumber</em>.toBigInt( ) ⇒ <em>bigint</em>：</strong>在支持BigInt的平台上以JavScript BigInt值返回BigNumber的值。</p><p><strong><em>BigNumber</em>.toNumber( ) ⇒ <em>number</em>：</strong>将BigNumber的值转换JavaScript值。</p><blockquote><p>如果该值大于<em>Number.MAX_SAFE_INTEGER</em>或小于等于<em>Number.MIN_SAFE_INTEGER</em>， 则会<strong>抛出一个错误</strong>。</p></blockquote><p><strong><em>BigNumber</em>.toString( ) ⇒ <em>string</em>：</strong>以十进制字符串的形式返回BigNumber的值。</p><p>**<em>BigNumber</em>.toHexString( ) ⇒ *string&lt; DataHexString &gt;*：**返回BigNumber的值为十六进制的值，<code>0x</code>是前缀DataHexString.。</p><h3 id="3-2-4-检查"><a href="#3-2-4-检查" class="headerlink" title="3.2.4 检查"></a>3.2.4 检查</h3><p><strong><em>ethers</em>.<em>BigNumber</em>.isBigNumber( <em>object</em> ) ⇒ <em>boolean</em>：</strong>当且仅当对象是BigNumber是<em>对象</em>时返回true。</p><h1 id="字节处理"><a href="#字节处理" class="headerlink" title="字节处理"></a>字节处理</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p><strong>Bytes：Bytes</strong>是一个Array或TypedArray对象， 每个值都在有效字节范围内(例如0到255之间)，或者是一个具有<code>length</code>属性的对象，每个索引的属性都在有效字节范围内。</p><p><strong>BytesLike：BytesLike</strong>可以是Bytes或DataHexString。</p><p><strong>DataHexString：DataHexstring</strong>与HexString是相同的，除了它有偶数个nibbles，因此二进制数据作为字符串是有效的。</p><p><strong>HexString：Hexstring</strong>是一个字符串，有一个0x前缀，后面跟着nibbles number类型(例如，不区分大小写的十六进制字符<code>0-9</code>和<code>a-f</code>)</p><p><strong>Signature：</strong></p><ul><li><strong>r</strong> and <strong>s</strong> — The x co-ordinate of <strong>r</strong> and the <strong>s</strong> value of the signature</li><li><strong>v</strong> — The parity of the y co-ordinate of <strong>r</strong></li><li><strong>_vs</strong> — The compact representation of the <strong>s</strong> and <strong>v</strong></li><li><strong>recoveryParam</strong> — The normalized (i.e. 0 or 1) value of <strong>v</strong></li></ul><p>**Raw Signature：原始签名(Raw Signature)**是一种常见的签名格式，r, s和v被连接成一个65字节(130 nibble)的DataHexString。</p><p><strong>SignatureLike：SignatureLike</strong>类似于一个Signature，除了多余的属性可以被省略或者它也可以是一个 Raw Signature。</p><p>​例如，如果指定了**_vs<strong>，则</strong>s<strong>和</strong>v<strong>可以省略。同样，如果提供了</strong>recoveryParam<strong>， 则可以省略</strong>v**(在这种情况下，可以计算出缺失的值)。</p><h2 id="4-1-检查"><a href="#4-1-检查" class="headerlink" title="4.1 检查"></a>4.1 检查</h2><p><strong><em>ethers</em>.<em>utils</em>.isBytes( <em>object</em> ) ⇒ <em>boolean</em>：</strong>当且仅当<em>object</em>为有效Bytes时返回true。</p><p><strong><em>ethers</em>.<em>utils</em>.isBytesLike( <em>object</em> ) ⇒ <em>boolean</em>：</strong>当且仅当<em>object</em>是Bytes或DataHexString时返回true。</p><p><strong><em>ethers</em>.<em>utils</em>.isHexString( <em>object</em> , [ <em>length</em> ] ) ⇒ <em>boolean</em>：</strong>当且仅当<em>object</em>是一个有效的十六进制字符串时返回true。 如果指定了<em>length</em>并且<em>object</em> 不是一个有效的长度字节的DataHexString，则抛出一个InvalidArgument错误。</p><h2 id="4-2-数组和十六进制字符串之间的转换"><a href="#4-2-数组和十六进制字符串之间的转换" class="headerlink" title="4.2 数组和十六进制字符串之间的转换"></a>4.2 数组和十六进制字符串之间的转换</h2><p><strong><em>ethers</em>.<em>utils</em>.arrayify( <em>DataHexStringOrArrayish</em> [ , <em>options</em> ] ) ⇒ <em>Uint8Array</em>：</strong>将<em>DataHexStringOrArrayish</em>转换为Uint8Array。</p><p><em>*<em>ethers</em>.<em>utils</em>.hexlify( <em>hexstringOrArrayish</em> ) ⇒ *string&lt; DataHexString &gt;<em>：**将</em>hexstringOrArrayish</em>转换为DataHexString。</p><p><em>*<em>ethers</em>.<em>utils</em>.hexValue( <em>aBigNumberish</em> ) ⇒ *string&lt; HexString &gt;<em>：**将</em>aBigNumberish</em>转换为HexString，没有前导零。</p><h2 id="4-3-数组处理"><a href="#4-3-数组处理" class="headerlink" title="4.3 数组处理"></a>4.3 数组处理</h2><p><strong><em>ethers</em>.<em>utils</em>.concat( <em>arrayOfBytesLike</em> ) ⇒ <em>Uint8Array</em>：</strong>将<em>arrayOfBytesLike</em>中的所有<a href="https://learnblockchain.cn/ethers_v5/api/utils/bytes/#BytesLike">BytesLike</a>连接到一个单独的Uint8Array中。</p><p><strong><em>ethers</em>.<em>utils</em>.stripZeros( <em>aBytesLike</em> ) ⇒ <em>Uint8Array</em>：</strong>返回一个无前导零<em>aBtyesLike</em>字节的Uint8Array</p><p><strong><em>ethers</em>.<em>utils</em>.zeroPad( <em>aBytesLike</em> , <em>length</em> ) ⇒ <em>Uint8Array</em>：</strong></p><p>返回一个以aBytesLike为单位的Uint8Array，前面有0字节的length bytes long。</p><p>如果<em>aBytesLike</em>的长度已经超过长度字节，则会抛出InvalidArgument错误。</p><h2 id="4-4-十六进制字符串处理"><a href="#4-4-十六进制字符串处理" class="headerlink" title="4.4 十六进制字符串处理"></a>4.4 十六进制字符串处理</h2><p><em>*<em>ethers</em>.<em>utils</em>.hexConcat( <em>arrayOfBytesLike</em> ) ⇒ *string&lt; DataHexString &gt;<em>：**将</em>arrayOfBytesLike</em>中的所有BytesLike连接成一个单一的DataHexString。</p><p><em>*<em>ethers</em>.<em>utils</em>.hexDataLength( <em>aBytesLike</em> ) ⇒ *string&lt; DataHexString &gt;<em>：**返回</em>aBytesLike</em>的长度(以字节为单位)。</p><p><em>*<em>ethers</em>.<em>utils</em>.hexDataSlice( <em>aBytesLike</em> , <em>offset</em> [ , <em>endOffset</em> ] ) ⇒ <em>string&lt; DataHexString &gt;<em>*<em>：返回一个</em>aBytesLike*切片的DataHexString表示，从</em>offset</em>(以字节为单位)到*endOffset</em>(以字节为单位)。 如果省略了<em>endOffset</em>，则使用<em>aBytesLike</em>的长度。</p><p><em>*<em>ethers</em>.<em>utils</em>.hexStripZeros( <em>aBytesLike</em> ) ⇒ *string&lt; HexString &gt;<em>：**返回</em>aBytesLike</em>的HexString表示形式，去掉所有前导零。</p><p><em>*<em>ethers</em>.<em>utils</em>.hexZeroPad( <em>aBytesLike</em> , <em>length</em> ) ⇒ *string&lt; DataHexString &gt;<em>：**返回被填充到</em>length</em>字节的<em>aBytesLike</em>的DataHexString表示。如果<em>aBytesLike</em>的长度已经超过<em>length</em>字节，则会抛出InvalidArgument错误。</p><h2 id="4-5-签名转换"><a href="#4-5-签名转换" class="headerlink" title="4.5 签名转换"></a>4.5 签名转换</h2><p><em>*<em>ethers</em>.<em>utils</em>.joinSignature( <em>aSignatureLike</em> ) ⇒ *string&lt; RawSignature &gt;<em>：**返回</em>aSignaturelike</em>的原始格式，它是65字节(130个nibbles)长，连接签名的<strong>r</strong>, <strong>s</strong>和(标准化后))<strong>v</strong>。</p><p><strong><em>ethers</em>.<em>utils</em>.splitSignature( <em>aSignatureLikeOrBytesLike</em> ) ⇒ <em>Signature</em>：</strong>返回<em>aSignaturelike</em>的完整扩展格式或原始格式DataHexString，将自动计算所有缺失的属性。</p><h2 id="4-6-随机字节"><a href="#4-6-随机字节" class="headerlink" title="4.6 随机字节"></a>4.6 随机字节</h2><p><strong><em>ethers</em>.<em>utils</em>.randomBytes( <em>length</em> ) ⇒ <em>Uint8Array</em>：</strong>返回一个新的Uint8Array 长度为<em>length</em>的随机字节。</p><p>**<em>ethers</em>.<em>utils</em>.shuffled( <em>array</em> ) ⇒ *Array&lt; any &gt;*：**返回一个使用Fisher-Yates Shuffle打乱后的数组副本。</p><h1 id="以太币格式化与转换"><a href="#以太币格式化与转换" class="headerlink" title="以太币格式化与转换"></a>以太币格式化与转换</h1><p><strong>utils  . etherSymbol</strong> </p><p>以太坊符号(希腊字母  <em>Xi</em>  ) </p><p><strong>utils  . parseEther ( etherString )   &#x3D;&gt;   BigNumber</strong> </p><p>将代表 ether 单位数的  <em>etherString</em>  解析为 wei 单位数的 BitNumber 实例。 （译者注：ether、gwei、wei 等是以太坊的货币单位名称，下同。） </p><p><strong>utils  . formatEther ( wei )   &#x3D;&gt;   string</strong> </p><p>将代表 wei 单位数的  <em>wei</em>  格式化为代表 ether 单位数的十进制字符串。 输出值总是包含至少一个整数和一个小数位，否则将剪除前导和尾随的 0。 </p><p><strong>utils  . parseUnits ( valueString , decimalsOrUnitName )   &#x3D;&gt;   BigNumber</strong> </p><p>将代表某单位数的  <em>valueString</em>  解析为一个代表 wei 单位数的 BigNumber 实例。 参数  <em>decimalsOrUnitsName</em>  可以是 3 到 18 之间（3 的倍数）的小数位数， 或者是以太币单位名称，如： gwei 。 </p><p><strong>utils  . formatUnits ( wei , decimalsOrUnitName )   &#x3D;&gt;   string</strong> </p><p>将  <em>wei</em>  单位数格式化为一个代表某单位数的十进制字符串。 输出值总是包含至少一个整数和一个小数位，否则将修剪前导和尾随的 0。 参数  <em>decimalsOrUnitsName</em>  可以是 3 到 18 之间（3 的倍数）的小数位数， 或者是单位名称，如： gwei 。 </p><p><strong>utils  . commify ( numberOrString )   &#x3D;&gt;   string</strong> </p><p>返回含有千分符的<em>numberOrString</em>。如果  <em>numberOrString</em>  包含小数点， 则输出值将至少具有一位整数和小数。如果不包含小数点，则输出值不会包含小数。 </p>]]></content>
      
      
      <categories>
          
          <category> ether@5.4.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> ether@5.4.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-合约(contract)</title>
      <link href="/2022/08/20/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/6-%E5%90%88%E7%BA%A6(contract)/"/>
      <url>/2022/08/20/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/6-%E5%90%88%E7%BA%A6(contract)/</url>
      
        <content type="html"><![CDATA[<h1 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h1><p><strong>new <em>ethers</em>.Contract( <em>address</em> , <em>abi</em> , <em>signerOrProvider</em> )：</strong>如果给定了Provider，那么合约只有<strong>只读</strong>访问权限，而Signer则提供了<strong>对状态操作方法</strong>的访问权限。</p><h2 id="1-1-attach"><a href="#1-1-attach" class="headerlink" title="1.1 attach"></a>1.1 attach</h2><p><em>contract</em>.<strong>attach</strong>( <em>addressOrName</em> ) ⇒ <em>合约（<strong>Contract</strong>）</em></p><p>返回一个新地址的<strong>Contract</strong>新实例,如果网络上有多个类似的合约副本,并且您希望与它们中的每一个进行交互，那么这是非常有用的。</p><h2 id="1-2-connect"><a href="#1-2-connect" class="headerlink" title="1.2 connect"></a>1.2 connect</h2><p><em>contract</em>.<strong>connect</strong>( <em>providerOrSigner</em> ) ⇒ <em>合约（<strong>Contract</strong>）</em></p><p>返回合约的一个新实例，但需要连接到<em>providerOrSigner</em>。</p><p>通过传入一个Provider，这将返回一个低级的合约实例，它只有只读访问的权限(即常量调用)。</p><p>通过传入一个Signer，这将返回一个代表该签名人（signer）的合约实例。</p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>**<em>contract</em>.address ⇒ *string&lt; 地址(Address) &gt;*：**这是构建合约时使用的地址(或ENS名称)。</p><p>**<em>contract</em>.resolvedAddress ⇒ *string&lt; 地址(Address) &gt;*：**这是一个合约对象将解析合约地址的promise。 如果一个地址(Address)被提供给构造函数，它将解析成这个地址; 如果提供的是ENS名称，这将解析成对应的地址。</p><p><strong><em>contract</em>.deployTransaction ⇒ <em>TransactionResponse</em>：</strong>如果<strong>Contract</strong>是ContractFactory部署后返回的对象， deployTransaction返回的数据就是部署这个合约的交易信息（transaction）。</p><p><strong><em>contract</em>.interface ⇒ <em>Interface</em>：</strong>这是作为Interface接口的ABI。</p><p><strong><em>contract</em>.provider ⇒ <em>Provider</em>：</strong>如果构造函数使用的是provider生成的contract合约对象，那么这个结果就是这个provider，如果使用的是具有Provider的signer，那么这个结果就是provider。</p><p><strong><em>contract</em>.signer ⇒ <em>Signer</em>：</strong>如果构造函数使用的是signer生成的contract合约对象，那么这个结果就是这个signer。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p><em>contract</em>.<strong>deployed</strong>( ) ⇒ <em>Promise&lt; 合约（Contract） &gt;</em></p><p><em>Contract</em>.<strong>isIndexed</strong>( <em>value</em> ) ⇒ <em>boolean</em></p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p><em>*<em>contract</em>.queryFilter( <em>event</em> [ , <em>fromBlockOrBlockHash</em> [ , <em>toBlock</em> ] ) ⇒ *Promise&lt; Array&lt; Event &gt; &gt;<em>：**返回与</em>event</em>匹配的事件</p><p><strong><em>contract</em>.listenerCount( [ <em>event</em> ] ) ⇒ <em>number</em>：</strong>返回订阅该<em>event</em>的监听器数量。如果没有提供<em>event</em>，则返回所有事件的总数。</p><p><em>*<em>contract</em>.listeners( <em>event</em> ) ⇒ *Array&lt; Listener &gt;<em>：**返回订阅该</em>event</em>的监听器列表。</p><p><strong><em>contract</em>.off( <em>event</em> , <em>listener</em> ) ⇒ <em>this</em>：</strong>监听器取消订阅<em>event</em>事件。</p><p><strong><em>contract</em>.on( <em>event</em> , <em>listener</em> ) ⇒ <em>this</em>：</strong>监听<em>event</em>事件，当事件发生时，会调用<em>listener</em>函数。</p><p><em><strong>contract*.once( <em>event</em> , <em>listener</em> ) ⇒ *this：</strong></em>监听<em>event</em>事件，当事件发生时，仅调用一次<em>listener</em>函数。</p><p><em><strong>contract*.removeAllListeners( [ <em>event</em> ] ) ⇒ *this：</strong></em>取消所有订阅<em>event</em>事件监听器，如果未提供<em>event</em>事件，则取消订阅所有事件的监听</p><h1 id="元类-Meta-Class"><a href="#元类-Meta-Class" class="headerlink" title="元类(Meta-Class)"></a>元类(Meta-Class)</h1><p>元类是在运行时确定其所有属性的类。<strong>Contract</strong>对象使用合约的ABI来确定可使用方法（methods）， 因此下面的部分将描述用一些属性，来与在合约构造函数期间交互的通用方法。</p><p>只读的方法 (常量; 如 view 或 pure)</p><p>常量方法是只读的，针对当前区块链状态计算少量EVM代码，并可以通过请求单个节点来计算，该节点会返回一个结果。 因此，它是免费的，不需要任何以太币，但不能更改区块链状态。</p><h2 id="5-1-METHOD-NAME"><a href="#5-1-METHOD-NAME" class="headerlink" title="5.1 METHOD_NAME"></a>5.1 METHOD_NAME</h2><p><em>contract</em>.<strong>METHOD_NAME</strong>( …<em>args</em> [ , <em>overrides</em> ] ) ⇒ <em>Promise&lt; any &gt;</em></p><p>结果的类型取决于ABI。如果方法返回单个值，则将直接返回该值，否则将返回一个Result对象，其中包含每个位置可用的参数， 如果参数被命名，那么就按照命名后的值去执行。</p><p>如果返回的值匹配JavaScript中的类型值，如strings字符串类型 和 booleans布尔类型，那么返回的值类型就直接是JavaScript中的类型值。</p><p>但对于numbers类型，如果类型在JavaScript的安全范围内(即小于53位，如<code>int24</code>或<code>uint48</code>)，则使用标准的JavaScript number类型。 否则返回大数(BigNumber)类型。</p><p>对于字节bytes类型(包括固定长度和动态)，将返回一个DataHexString。</p><p>如果call reverts(或runs out of gas)，将抛出一个CALL_EXCEPTION，其中包括:</p><ul><li><code>error.address</code> - 合约地址</li><li><code>error.args</code> - 合约方法中传入的参数</li><li><code>error.transaction</code> - 交易</li></ul><p>只读方法的<em>overrides</em>对象可以包括以下任何一个:</p><ul><li><p><code>overrides.from</code> - 代码执行期间使用的<code>msg.sender</code> (或 <code>CALLER</code>)</p></li><li><p><code>overrides.value</code> - 代码执行期间使用的<code>msg.value</code> (或 <code>CALLVALUE</code>)</p></li><li><p><code>overrides.gasPrice</code> - 每个gas的价格(理论上);因为没有交易，所以不会收取任何费用，但EVM仍然需要向<code>tx.gasprice</code>(或<code>GASPRICE</code>)传递value值; <em>大多数开发人员不需要这样做</em></p></li><li><p><code>overrides.gasLimit</code> - 在执行代码期间允许节点使用的gas数量(理论上);因为没有交易，所以不会有任何费用，但EVM仍然估计gas总数量，因此会向<code>gasleft</code> (或 <code>GAS</code>) 传递这些值。</p></li><li><p><code>overrides.blockTag</code> - 一个用来模拟在哪里执行的块标签，可以用于假设性历史分析;注意，许多后端不支持这一点，或者可能需要付费访问，因为节点数据库存储和处理需求费用要高得多</p></li></ul><h2 id="5-2-functions-METHOD-NAME"><a href="#5-2-functions-METHOD-NAME" class="headerlink" title="5.2 functions.METHOD_NAME"></a>5.2 <em>functions</em>.METHOD_NAME</h2><p><em>contract</em>.<em>functions</em>.<strong>METHOD_NAME</strong>( …<em>args</em> [ , <em>overrides</em> ] ) ⇒ <em>Promise&lt; Result &gt;</em></p><p>结果将始终是Result，即使只有一个返回值类型。</p><p>这简化了期望使用合约（Contract）对象的框架，因为它们不需要检查返回类型来展开简化函数。</p><p>此方法的另一个用途是用于错误恢复。例如，如果一个函数的结果是一个无效的UTF-8字符串，使用上述元类函数的普通调用将抛出一个异常。 这允许使用Result access error来访问低级字节以及错误的原因，从而允许使用另一种UTF-8错误策略。</p><p>大多数开发人员不需要这样做。</p><p><em>overrides</em>与上面的只读操作相同。</p><h3 id="Write-Methods-non-constant"><a href="#Write-Methods-non-constant" class="headerlink" title="Write Methods (non-constant)"></a>Write Methods (non-constant)</h3><p>非常量方法要求签名一笔交易，并需要向矿工支付费用。这个交易将由整个网络上的所有节点以及矿工进行验证， 矿工会根据当前状态执行，接着在区块链计算新状态。</p><p>它不能返回结果。如果需要一个结果，那么应该使用Solidity事件(或EVM日志)对其进行记录，然后可以从交易收据中查询该事件。</p><h2 id="5-3-METHOD-NAME"><a href="#5-3-METHOD-NAME" class="headerlink" title="5.3 METHOD_NAME"></a>5.3 METHOD_NAME</h2><p><em>contract</em>.<strong>METHOD_NAME</strong>( …<em>args</em> [ , <em>overrides</em> ] ) ⇒ <em>Promise&lt; TransactionResponse &gt;</em></p><p>交易被发送到网络后，返回交易的TransactionResponse。 <strong>Contract</strong>合约对象需要signer。</p><p>重写方法的<em>overrides</em>对象可以是以下任何一个:</p><ul><li><code>overrides.gasPrice</code> - 每个gas的价格</li><li><code>overrides.gasLimit</code> - 该笔交易允许使用的gas的最大数量，未被使用的gas按照gasPrice退还</li><li><code>overrides.value</code> - 调用中转账的ether (wei格式)数量</li><li><code>overrides.nonce</code> - Signer使用的nonce值</li></ul><p>如果返回的TransactionResponse使用了<code>wait()</code>方法，那么在收据上将会有额外的属性:</p><ul><li><code>receipt.events</code> - 带有附加属性的日志数组(如果ABI包含事件的描述)</li><li><code>receipt.events[n].args</code> - 解析后的参数</li><li><code>receipt.events[n].decode</code> - 可以用来解析日志主题（topics）和数据的方法(用于计算<code>args</code>)</li><li><code>receipt.events[n].event</code> - 事件的名称</li><li><code>receipt.events[n].eventSignature</code> - 这个事件完整的签名</li><li><code>receipt.removeListener()</code> - 用于移除触发此事件的监听器的方法</li><li><code>receipt.getBlock()</code> - 返回发生触发此事件的Block</li><li><code>receipt.getTransaction()</code> - 返回发生触发此事件的Transaction</li><li><code>receipt.getTransactionReceipt()</code> - 返回发生触发此事件的Transaction Receipt</li></ul><h2 id="Write-Methods-Analysis"><a href="#Write-Methods-Analysis" class="headerlink" title="Write Methods Analysis"></a>Write Methods Analysis</h2><p>在不实际执行的情况下，有几个选项可以分析write method的属性和结果。</p><h2 id="5-4-estimateGas-METHOD-NAME"><a href="#5-4-estimateGas-METHOD-NAME" class="headerlink" title="5.4 estimateGas.METHOD_NAME"></a>5.4 estimateGas.METHOD_NAME</h2><p><em>contract</em>.<em>estimateGas</em>.<strong>METHOD_NAME</strong>( …<em>args</em> [ , <em>overrides</em> ] ) ⇒ <em>Promise&lt; 大数(BigNumber) &gt;</em></p><p>返回使用 <em>args</em>和<em>overrides</em>执行<em>METHOD_NAME</em>所需的gas的估计单位。</p><p><em>overrides</em>与上面针对只读或写方法的overrides相同，具体取决于 <em>METHOD_NAME</em>调用的类型。</p><h2 id="5-5-populateTransaction-METHOD-NAME"><a href="#5-5-populateTransaction-METHOD-NAME" class="headerlink" title="5.5 populateTransaction.METHOD_NAME"></a>5.5 populateTransaction.METHOD_NAME</h2><p><em>contract</em>.<em>populateTransaction</em>.<strong>METHOD_NAME</strong>( …<em>args</em> [ , <em>overrides</em> ] ) ⇒ <em>Promise&lt; UnsignedTx &gt;</em></p><p>返回一个未签名交易(UnsignedTransaction)，它表示需要签名并提交给网络的交易，以执行带有<em>args</em>和<em>overrides</em>的<em>METHOD_NAME</em>。</p><p><em>overrides</em>与上面针对只读或写方法的overrides相同，具体取决于 <em>METHOD_NAME</em>调用的类型。</p><h2 id="5-6-callStatic-METHOD-NAME"><a href="#5-6-callStatic-METHOD-NAME" class="headerlink" title="5.6 callStatic.METHOD_NAME"></a>5.6 callStatic.METHOD_NAME</h2><p><em>contract</em>.<em>callStatic</em>.<strong>METHOD_NAME</strong>( …<em>args</em> [ , <em>overrides</em> ] ) ⇒ <em>Promise&lt; any &gt;</em></p><p>比起执行交易状态更改，更可能是会要求节点<em>尝试</em>调用不进行状态的更改并返回结果。</p><p>这实际上并不改变任何状态，而是免费的。在某些情况下，这可用于确定交易是失败还是成功。</p><p>otherwise函数与Read-Only Method相同。</p><p><em>overrides</em>与上面的只读操作相同。</p><h2 id="Event-Filters"><a href="#Event-Filters" class="headerlink" title="Event Filters"></a>Event Filters</h2><p>事件过滤器由主题（topics）组成，这些主题是Bloom Filter中记录的值，允许对匹配过滤器的条目进行有效搜索。</p><h2 id="5-7-filters-EVENT-NAME"><a href="#5-7-filters-EVENT-NAME" class="headerlink" title="5.7 filters.EVENT_NAME"></a>5.7 filters.EVENT_NAME</h2><p><em>contract</em>.<em>filters</em>.<strong>EVENT_NAME</strong>( …<em>args</em> ) ⇒ <em>Filter</em></p><p>返回<em>EVENT_NAME</em>的过滤器，可以通过增加其他约束进行过滤。</p><p>只有<code>indexed</code>索引的事件参数可以被过滤。如果参数为空(或未提供)，则该字段中的任何值都匹配。</p><h1 id="Example-ERC-20-Contract"><a href="#Example-ERC-20-Contract" class="headerlink" title="Example:ERC-20 Contract"></a>Example:ERC-20 Contract</h1><h2 id="6-1-部署合约"><a href="#6-1-部署合约" class="headerlink" title="6.1 部署合约"></a>6.1 部署合约</h2><p>**new <em>ethers</em>.ContractFactory( <em>abi</em> , <em>bytecode</em> , <em>signer</em> )**：创建一个新的ContractFactory，它可以将合约部署到区块链。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bytecode = <span class="string">&quot;0x60806040523480156100105760008......&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个人类可读（Human-Readable）的ABI;我们只需要指定相关的部分内容，在这里我们用到了构造函数</span></span><br><span class="line"><span class="keyword">const</span> abi = [</span><br><span class="line">    <span class="string">&quot;constructor(uint totalSupply)&quot;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factory = <span class="keyword">new</span> ethers.<span class="title class_">ContractFactory</span>(abi, bytecode, signer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部署，设置token的total supply为100，分配给部署人（deployer）</span></span><br><span class="line"><span class="keyword">const</span> contract = <span class="keyword">await</span> factory.<span class="title function_">deploy</span>(<span class="title function_">parseUnits</span>(<span class="string">&quot;100&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//链上现在虽然我们还没有这个合约，但是这个合约地址我们是预先经过计算后得到的</span></span><br><span class="line">contract.<span class="property">address</span></span><br><span class="line"><span class="comment">// &#x27;0xa22aB6748282B3125dC26dAFb79e38B7eb24EAcC&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在交易被挖出来之前(即合约被部署)等待（Wait）</span></span><br><span class="line"><span class="comment">//  - 部署后，交易会返回receipt</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="property">deployTransaction</span>.<span class="title function_">wait</span>();</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   blockHash: &#x27;0xe9b244958d066490c46a826a9733c1a43210316777185353b3ecbc2ec362ea87&#x27;,</span></span><br><span class="line"><span class="comment">//   blockNumber: 22,</span></span><br><span class="line"><span class="comment">//   byzantium: true,</span></span><br><span class="line"><span class="comment">//   confirmations: 1,</span></span><br><span class="line"><span class="comment">//   contractAddress: &#x27;0xa22aB6748282B3125dC26dAFb79e38B7eb24EAcC&#x27;,</span></span><br><span class="line"> ......</span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h2 id="6-2-Meta-Class-Methods"><a href="#6-2-Meta-Class-Methods" class="headerlink" title="6.2 Meta-Class Methods"></a>6.2 <strong>Meta-Class Methods</strong></h2><blockquote><p>因为合约是元类，这里面可用的方法取决于传入<strong>合约</strong>的ABI</p></blockquote><p>**<em>erc20</em>.decimals( [ <em>overrides</em> ] ) ⇒ *Promise&lt; number &gt;*：**返回此ERC-20 token所使用的小数位数。在前端界面，当从用户获取输入时，可以使用parseUnits转化后传入合约； 从合约获得token后可以通过[formatUnits](utils-formatunits]转化后再显示给用户。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> erc20.<span class="title function_">decimals</span>(); </span><br><span class="line"><span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>**<em>erc20</em>.balanceOf( <em>owner</em> [ , <em>overrides</em> ] ) ⇒ *Promise&lt; 大数(BigNumber) &gt;<em>：**返回持有这个ERC-20 token的</em>持有者(owner)*的余额。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> erc20.<span class="title function_">balanceOf</span>(signer.<span class="title function_">getAddress</span>()) </span><br><span class="line"><span class="comment">// &#123; BigNumber: &quot;100000000000000000000&quot; &#125;</span></span><br></pre></td></tr></table></figure><p>**<em>erc20</em>.symbol( [ <em>overrides</em> ] ) ⇒ *Promise&lt; string &gt;*：**返回token的symbol。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> erc20.<span class="title function_">symbol</span>(); </span><br><span class="line"><span class="comment">// &#x27;MyToken&#x27;</span></span><br></pre></td></tr></table></figure><p><em>*<em>erc20_rw</em>.transfer( <em>target</em> , <em>amount</em> [ , <em>overrides</em> ] ) ⇒ *Promise&lt; TransactionResponse &gt;<em>：**从当前的signer将数量为</em>amount</em>的tokens转给接收者<em>target</em>。 在交易处于写入操作时，返回值(布尔类型)是得不到的。 如果需要这个值，则需要其他方法(如事件)。链上合约调用<code>transfer</code>函数可以得到这个结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这之前先转化格式</span></span><br><span class="line"><span class="title function_">formatUnits</span>(<span class="keyword">await</span> erc20_rw.<span class="title function_">balanceOf</span>(signer.<span class="title function_">getAddress</span>()));</span><br><span class="line"><span class="comment">// &#x27;100.0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转 1.23 tokens 到 ENS name 为 &quot;ricmoo.eth&quot; 的地址</span></span><br><span class="line">tx = <span class="keyword">await</span> erc20_rw.<span class="title function_">transfer</span>(<span class="string">&quot;ricmoo.eth&quot;</span>, <span class="title function_">parseUnits</span>(<span class="string">&quot;1.23&quot;</span>));</span><br><span class="line"><span class="comment">//TransactionRequest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待交易所在的区块被挖出打包</span></span><br><span class="line"><span class="keyword">await</span> tx.<span class="title function_">wait</span>();</span><br><span class="line"><span class="comment">//TransactionResponse </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功后转化格式</span></span><br><span class="line"><span class="title function_">formatUnits</span>(<span class="keyword">await</span> erc20_rw.<span class="title function_">balanceOf</span>(signer.<span class="title function_">getAddress</span>()));</span><br><span class="line"><span class="comment">// &#x27;98.77&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">formatUnits</span>(<span class="keyword">await</span> erc20_rw.<span class="title function_">balanceOf</span>(<span class="string">&quot;ricmoo.eth&quot;</span>));</span><br><span class="line"><span class="comment">// &#x27;1.23</span></span><br></pre></td></tr></table></figure><p><em>*<em>erc20</em>.<em>callStatic</em>.transfer( <em>target</em> , <em>amount</em> [ , <em>overrides</em> ] ) ⇒ <em>Promise&lt; boolean &gt;</em>:*<em>执行一次从当前signer向</em>target<em>地址转移</em>amount</em>数量的token的演练，而不实际签名或发送交易,这可以用于检查真实的转账前，交易是否能成功。</p><p><em>*<em>erc20</em>.<em>estimateGas</em>.transfer( <em>target</em> , <em>amount</em> [ , <em>overrides</em> ] ) ⇒ <em>Promise&lt; 大数(BigNumber) &gt;</em>:*<em>返回估计的“将</em>amount<em>数量的tokens发送</em>target</em>地址”所需的多少gas值。</p><p><em>*<em>erc20</em>.<em>populateTransaction</em>.transfer( <em>target</em> , <em>amount</em> [ , <em>overrides</em> ] ) ⇒ <em>Promise&lt; UnsignedTx &gt;</em>:*<em>返回一个未签名交易，它可以被签名并提交给网络，达成“将</em>amount<em>数量的tokens发送</em>target</em>地址”的目的。</p><h2 id="6-3-Meta-Class-Fileters"><a href="#6-3-Meta-Class-Fileters" class="headerlink" title="6.3 Meta-Class Fileters"></a>6.3 Meta-Class Fileters</h2><p><strong><em>erc20</em>.<em>filters</em>.Transfer( [ <em>fromAddress</em> [ , <em>toAddress</em> ] ] ) ⇒ <em>Filter</em>：</strong>返回一个新的Filter用于查询或者去subscribe&#x2F;unsubscribe to events，如果<em>fromAddress</em> 是空的或者没有填写，将匹配任何发送人的地址。 如果 <em>toAddress</em>是空的或者没有填写，将匹配任何接受人的地址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">filterFrom = erc20.<span class="property">filters</span>.<span class="title class_">Transfer</span>(signer.<span class="property">address</span>);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   address: &#x27;0xa22aB6748282B3125dC26dAFb79e38B7eb24EAcC&#x27;,</span></span><br><span class="line"><span class="comment">//   topics: [</span></span><br><span class="line"><span class="comment">//     &#x27;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&#x27;,</span></span><br><span class="line"><span class="comment">//     &#x27;0x000000000000000000000000894ed91b666facce5a4d2ff8261924b4754a5759&#x27;</span></span><br><span class="line"><span class="comment">//   ]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在最新的10个区块内查询我发送的交易</span></span><br><span class="line">logsFrom = <span class="keyword">await</span> erc20.<span class="title function_">queryFilter</span>(filterFrom, -<span class="number">10</span>, <span class="string">&quot;latest&quot;</span>);</span><br><span class="line"><span class="comment">//Array&lt;TransactionResponse&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听signer的发送的event事件:</span></span><br><span class="line">erc20.<span class="title function_">on</span>(filterFrom, <span class="function">(<span class="params"><span class="keyword">from</span>, to, amount, event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// The `from` will always be the signer address</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听signer的接受转账的event事件:</span></span><br><span class="line">erc20.<span class="title function_">on</span>(filterTo, <span class="function">(<span class="params"><span class="keyword">from</span>, to, amount, event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// The `to` will always be the signer address</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听所有的转账交易event事件:</span></span><br><span class="line">erc20.<span class="title function_">on</span>(<span class="string">&quot;Transfer&quot;</span>, <span class="function">(<span class="params"><span class="keyword">from</span>, to, amount, event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ether@5.4.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> ether@5.4.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-Singers</title>
      <link href="/2022/08/14/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/5-Singers/"/>
      <url>/2022/08/14/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/5-Singers/</url>
      
        <content type="html"><![CDATA[<h1 id="Singer"><a href="#Singer" class="headerlink" title="Singer"></a>Singer</h1><p><strong>Signer</strong>类是抽象的，<strong>不能直接实例化，而是应该使用一个具体的子类</strong>，如 Wallet, VoidSigner 或 JsonRpcSigner。</p><h2 id="1-1-属性"><a href="#1-1-属性" class="headerlink" title="1.1 属性"></a>1.1 属性</h2><p><em><strong>signer*.connect( <em>provider</em> ) ⇒ *Signer</strong></em>:子类<strong>必须</strong>实现这个，如果更改后的providers是不被支持的话，它们可能仅仅只抛出一个错误。</p><p><em><strong>signer*.getAddress( ) ⇒ *Promise&lt; string&lt; 地址(Address) &gt; &gt;</strong></em>:返回一个解析为帐户地址的Promise。</p><p>​子类<strong>必须</strong>实现这个,这是一个Promise，因此一个<strong>Signer</strong>可以围绕一个异步源进行设计，如硬钱包。</p><p><em><strong>Signer*.isSigner( <em>object</em> ) ⇒ *boolean</strong></em>:当且仅当 <em>object</em> 是一个<strong>Signer</strong>时返回true。</p><h2 id="1-2-Blockchain-方法"><a href="#1-2-Blockchain-方法" class="headerlink" title="1.2 Blockchain 方法"></a>1.2 <strong>Blockchain</strong> 方法</h2><h3 id="1-2-1-getBalance"><a href="#1-2-1-getBalance" class="headerlink" title="1.2.1 getBalance"></a>1.2.1 getBalance</h3><p><em>signer</em>.<strong>getBalance</strong>( [ <em>blockTag</em> &#x3D; “<em>latest</em>“ ] ) ⇒ <em>Promise&lt; 大数(**BigNumber**) &gt;</em></p><p>在指定的<em>blockTag</em>下返回这个钱包的余额。</p><h3 id="1-2-2-getChainId"><a href="#1-2-2-getChainId" class="headerlink" title="1.2.2  getChainId"></a>1.2.2  getChainId</h3><p><em>signer</em>.<strong>getChainId</strong>( ) ⇒ <em>Promise&lt; **number** &gt;</em></p><p>返回这个钱包连接的链 ID。</p><h3 id="1-2-3-getGasPrice"><a href="#1-2-3-getGasPrice" class="headerlink" title="1.2.3 getGasPrice"></a>1.2.3 getGasPrice</h3><p><em>signer</em>.<strong>getGasPrice</strong>( ) ⇒ <em>Promise&lt; 大数(**BigNumber**) &gt;</em></p><p>返回当前的gas price。</p><h3 id="1-2-4-getTransactionCount"><a href="#1-2-4-getTransactionCount" class="headerlink" title="1.2.4 getTransactionCount"></a>1.2.4 getTransactionCount</h3><p><em>signer</em>.<strong>getTransactionCount</strong>( [ <em>blockTag</em> &#x3D; “<em>latest</em>“ ] ) ⇒ <em>Promise&lt; **number** &gt;</em></p><p>返回此帐户曾经发送的交易数量，交易中的中nonce依赖这个值。</p><h3 id="1-2-5-call"><a href="#1-2-5-call" class="headerlink" title="1.2.5 call"></a>1.2.5 call</h3><p><em>signer</em>.<strong>call</strong>( <em>transactionRequest</em> ) ⇒ <em>Promise&lt; string&lt; **DataHexString** &gt; &gt;</em></p><p>返回<em>transactionRequest</em>调用的结果，此帐户地址用作<code>from</code> 字段。</p><h3 id="1-2-6-estimateGas"><a href="#1-2-6-estimateGas" class="headerlink" title="1.2.6 estimateGas"></a>1.2.6 estimateGas</h3><p><em>signer</em>.<strong>estimateGas</strong>( <em>transactionRequest</em> ) ⇒ <em>Promise&lt; 大数(**BigNumber**) &gt;</em></p><p>返回发送<em>transactionRequest</em>的估算费用，在使用这个方法之前先用账户地址填充<code>from</code>字段。</p><h3 id="1-2-7-resolveName"><a href="#1-2-7-resolveName" class="headerlink" title="1.2.7 resolveName"></a>1.2.7 resolveName</h3><p><em>signer</em>.<strong>resolveName</strong>( <em>ensName</em> ) ⇒ <em>Promise&lt; string&lt; 地址(**Address**) &gt; &gt;</em></p><p>返回与<em>ensName</em>关联的地址。</p><h2 id="1-3-Signing方法"><a href="#1-3-Signing方法" class="headerlink" title="1.3 Signing方法"></a>1.3 <strong>Signing</strong>方法</h2><h3 id="1-3-1-signMessage"><a href="#1-3-1-signMessage" class="headerlink" title="1.3.1 signMessage"></a>1.3.1 signMessage</h3><p><em>signer</em>.<strong>signMessage</strong>( <em>message</em> ) ⇒ <em>Promise&lt; string&lt; **RawSignature** &gt; &gt;</em></p><p>这将返回一个解析为消息的Raw Signature Promise。</p><p>由于使用的是hashMessage方法，因此它是EIP-191兼容的。 如果在Solidity中恢复地址，则需要这个前缀来创建一个匹配的哈希。</p><p>子类<strong>必须</strong>实现这个方法。 如果不支持签名消息可能会抛出错误，比如在基于合约的钱包或基于元交易的钱包中使用时。</p><h3 id="1-3-2-signTransaction"><a href="#1-3-2-signTransaction" class="headerlink" title="1.3.2 signTransaction"></a>1.3.2 signTransaction</h3><p><em>signer</em>.<strong>signTransaction</strong>( <em>transactionRequest</em> ) ⇒ <em>Promise&lt; string&lt; **DataHexString** &gt; &gt;</em></p><p>返回一个解析为<em>transactionRequest</em>中<strong>已签名的交易</strong>的Promise。 此方法不填充任何缺少的字段。</p><p>子类<strong>必须</strong>实现这个，如果不支持签名消息可能会抛出错误，出于安全这在许多客户端中是常见的。</p><h3 id="1-3-3-sendTransaction"><a href="#1-3-3-sendTransaction" class="headerlink" title="1.3.3 sendTransaction"></a>1.3.3 sendTransaction</h3><p><em>signer</em>.<strong>sendTransaction</strong>( <em>transactionRequest</em> ) ⇒ <em>Promise&lt; **TransactionResponse** &gt;</em></p><p>该方法使用populate Transaction填充缺少字段的transactionRequest，并返回一个解析成交易的Promise。</p><h3 id="1-3-4-signTypedData"><a href="#1-3-4-signTypedData" class="headerlink" title="1.3.4 _signTypedData"></a>1.3.4 _signTypedData</h3><p><em>signer</em>.<strong>_signTypedData</strong>( <em>domain</em> , <em>types</em> , <em>value</em> ) ⇒ <em>Promise&lt; string&lt; **RawSignature** &gt; &gt;</em></p><blockquote><p>实验中的功能。如果使用它，请<strong>指定</strong>您正在使用的ethers的确切版本(例如指定<code>&quot;5.0.18&quot;</code>，而不是<code>&quot;^5.0.18&quot;</code>)， 因为方法名将从<code>_signTypedData</code>重命名为<code>signTypedData</code>。</p></blockquote><h2 id="1-4-Sub-Classes"><a href="#1-4-Sub-Classes" class="headerlink" title="1.4 Sub-Classes"></a>1.4 <strong>Sub-Classes</strong></h2><p><strong>Signer</strong>的所有重要属性都是不可变的，这一点非常重要。由于以太坊是异步的，并处理关键数据(如ether和其他潜在有价值的加密资产)， 整个Signer的生命周期中保持<em>provider</em>和 <em>address</em>等属性是静态的有助于防止严重的问题的出现， 而且许多其他类和库也是认定<em>provider</em>和 <em>address</em>等属性是静态的。</p><p>子类<strong>必须</strong>扩展Signer，并且<strong>必须</strong>调用<code>super()</code>。</p><h3 id="1-4-1-checkTransaction"><a href="#1-4-1-checkTransaction" class="headerlink" title="1.4.1 checkTransaction"></a>1.4.1 <strong>checkTransaction</strong></h3><p><em>signer</em>.<strong>checkTransaction</strong>( <em>transactionRequest</em> ) ⇒ <em><strong>TransactionRequest</strong></em></p><p>这应该返回一个<em>transactionRequest</em>的副本，包含<code>call</code>、<code>estimateGas</code>和<code>populateTransaction</code> (sendTransaction使用的)所需的任何属性。 如果指定了任何未知的key，它会抛出一个错误。</p><p>默认的实现只<strong>验证有效的TransactionRequest属性是否存在</strong>，如果不存在，则将<code>from</code>添加到交易中。</p><p>如果存在<code>from</code>字段，则<strong>必须</strong>验证它与 Signer的地址是否相等。</p><h3 id="1-4-2-populateTransaction"><a href="#1-4-2-populateTransaction" class="headerlink" title="1.4.2 populateTransaction"></a>1.4.2 <strong>populateTransaction</strong></h3><p><em>signer</em>.<strong>populateTransaction</strong>( <em>transactionRequest</em> ) ⇒ <em>Promise&lt; **TransactionRequest** &gt;</em></p><p>这应该返回一个<em>transactionRequest</em>的副本，遵循与<code>checkTransaction</code>相同的过程， 并填写发送交易所需的任何属性。</p><p>返回的结果都是promises，可以使用<strong>resolvePropertiesutility</strong>函数来解析。</p><p>默认实现调用<code>checkTransaction</code>，如果它是一个ENS name就会解析它，并根据Signer上的相关操作添加<code>gasPrice</code>, <code>nonce</code>, <code>gasLimit</code>和<code>chainId</code></p><h1 id="Wallet"><a href="#Wallet" class="headerlink" title="Wallet"></a>Wallet</h1><p>Wallet类继承了Signer，可以使用私钥作为外部拥有帐户(EOA)的标准对交易和消息进行签名</p><p><strong>new <em>ethers</em>.Wallet( <em>privateKey</em> [ , <em>provider</em> ] )</strong></p><p>为<em>privateKey</em>创建一个新的钱包实例，并可选地连接到<em>provider</em>。</p><h2 id="2-1-方法"><a href="#2-1-方法" class="headerlink" title="2.1 方法"></a>2.1 方法</h2><h3 id="2-1-1-createRandom"><a href="#2-1-1-createRandom" class="headerlink" title="2.1.1 createRandom"></a>2.1.1 createRandom</h3><p><em>ethers</em>.<em>Wallet</em>.<strong>createRandom</strong>( [ <em>options</em> &#x3D; {} ] ) ⇒ <em><strong>Wallet</strong></em></p><p>返回一个带有随机私钥的新钱包，由加密安全的熵源生成。如果当前环境没有安全的熵源，则会抛出错误。</p><p>使用此方法创建的钱包将具有助记词。</p><h3 id="2-1-2-fromEncryptedJson"><a href="#2-1-2-fromEncryptedJson" class="headerlink" title="2.1.2 fromEncryptedJson"></a>2.1.2 fromEncryptedJson</h3><p><em>ethers</em>.<em>Wallet</em>.<strong>fromEncryptedJson</strong>( <em>json</em> , <em>password</em> [ , <em>progress</em> ] ) ⇒ <em>Promise&lt; **Wallet** &gt;</em></p><p>从加密的JSON钱包创建一个实例。</p><p>如果提供了<em>进度</em>，它将在解密期间被调用，其值介于0到1之间，表示一个完成进度。</p><h3 id="2-1-3-fromEncryptedJsonSync"><a href="#2-1-3-fromEncryptedJsonSync" class="headerlink" title="2.1.3 fromEncryptedJsonSync"></a>2.1.3 fromEncryptedJsonSync</h3><p><em>ethers</em>.<em>Wallet</em>.<strong>fromEncryptedJsonSync</strong>( <em>json</em> , <em>password</em> ) ⇒ <em><strong>Wallet</strong></em></p><p>从加密的JSON钱包创建一个实例。</p><p>此操作将同步操作，从而锁定用户界面一段时间。 大多数应用程序应该使用异步的<code>fromEncryptedJson</code>。</p><h3 id="2-1-4-fromMnemonic"><a href="#2-1-4-fromMnemonic" class="headerlink" title="2.1.4 fromMnemonic"></a>2.1.4 fromMnemonic</h3><p><em>ethers</em>.<em>Wallet</em>.<strong>fromMnemonic</strong>( <em>mnemonic</em> [ , <em>path</em> , [ <em>wordlist</em> ] ] ) ⇒ <em><strong>Wallet</strong></em></p><p>从助记短语中创建实例如果没有指定path，则使用的默认path路径(<code>m/44&#39;/60&#39;/0&#39;/0/0</code>),如果不指定wordlist，则使用English Wordlist</p><h3 id="2-1-5-encrypt"><a href="#2-1-5-encrypt" class="headerlink" title="2.1.5 encrypt"></a>2.1.5 encrypt</h3><p><em>wallet</em>.<strong>encrypt</strong>( <em>password</em> , [ <em>options</em> &#x3D; {} , [ <em>progress</em> ] ] ) ⇒ <em>Promise&lt; **string** &gt;</em></p><p>加密钱包，使用<em>password</em>返回一个解析为JSON钱包的Promise。</p><p>如果提供了<em>进度</em>，它将在解密期间被调用，其值介于0到1之间，表示一个完成进度。</p><h2 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="2.2 属性"></a>2.2 属性</h2><p>**<em>wallet</em>.address ⇒ *string&lt; 地址(Address) &gt;*：**此钱包表示的帐户的地址。</p><p><strong><em>wallet</em>.provider ⇒ <em>Provider</em>：</strong>这个钱包所连接的provider，它将用于任何Blockchain Methods的方法，它也可以是null。</p><blockquote><p>一个<strong>钱包</strong>实例是不可变的，因此如果您希望更改Provider，您可以使用connect方法创建一个连接到所需的provider的新实例。</p></blockquote><p>**<em>wallet</em>.publicKey ⇒ *string&lt; DataHexString&lt; 65 &gt; &gt;***：此钱包的未压缩的公钥</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过助记词创建一个钱包实例</span></span><br><span class="line">mnemonic = <span class="string">&quot;announce room limb pattern dry unit scale effort smooth jazz weasel alcohol&quot;</span></span><br><span class="line">walletMnemonic = <span class="title class_">Wallet</span>.<span class="title function_">fromMnemonic</span>(mnemonic)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者通过私钥创建一个钱包实例</span></span><br><span class="line">walletPrivateKey = <span class="keyword">new</span> <span class="title class_">Wallet</span>(walletMnemonic.<span class="property">privateKey</span>)</span><br><span class="line"></span><br><span class="line">walletMnemonic.<span class="property">address</span> === walletPrivateKey.<span class="property">address</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有着每个Signer API的地址，是一个Promise对象</span></span><br><span class="line"><span class="keyword">await</span> walletMnemonic.<span class="title function_">getAddress</span>()</span><br><span class="line"><span class="comment">// &#x27;0x71CB05EE1b1F506fF321Da3dac38f25c0c9ce6E1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个钱包地址，也可用同步的方式获得</span></span><br><span class="line">walletMnemonic.<span class="property">address</span></span><br><span class="line"><span class="comment">// &#x27;0x71CB05EE1b1F506fF321Da3dac38f25c0c9ce6E1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部加密组件</span></span><br><span class="line">walletMnemonic.<span class="property">privateKey</span></span><br><span class="line"><span class="comment">// &#x27;0x1da6847600b0ee25e9ad9a52abbd786dd2502fa4005dd5af9310b7cc7a3b25db&#x27;</span></span><br><span class="line">walletMnemonic.<span class="property">publicKey</span></span><br><span class="line"><span class="comment">// &#x27;0x04b9e72dfd423bcf95b3801ac93f4392be5ff22143f9980eb78b3a860c4843bfd04829ae61cdba4b3b1978ac5fc64f5cc2f4350e35a108a9c9a92a81200a60cd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 钱包助记词</span></span><br><span class="line">walletMnemonic.<span class="property">mnemonic</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   locale: &#x27;en&#x27;,</span></span><br><span class="line"><span class="comment">//   path: &quot;m/44&#x27;/60&#x27;/0&#x27;/0/0&quot;,</span></span><br><span class="line"><span class="comment">//   phrase: &#x27;announce room limb pattern dry unit scale effort smooth jazz weasel alcohol&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: 通过私钥创建的钱包实例没有助记词，因为从数学上无法推导</span></span><br><span class="line">walletPrivateKey.<span class="property">mnemonic</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 签名消息</span></span><br><span class="line"><span class="keyword">await</span> walletMnemonic.<span class="title function_">signMessage</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"><span class="comment">// &#x27;0x14280e5885a19f60e536de50097e96e3738c7acae4e9e62d67272d794b8127d31c03d9cd59781d4ee31fb4e1b893bd9b020ec67dfa65cfb51e2bdadbb1de26d91c&#x27;</span></span><br><span class="line"></span><br><span class="line">tx = &#123;</span><br><span class="line">  <span class="attr">to</span>: <span class="string">&quot;0x8ba1f109551bD432803012645Ac136ddd64DBA72&quot;</span>,</span><br><span class="line">  <span class="attr">value</span>: utils.<span class="title function_">parseEther</span>(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 签名交易</span></span><br><span class="line"><span class="keyword">await</span> walletMnemonic.<span class="title function_">signTransaction</span>(tx)</span><br><span class="line"><span class="comment">// &#x27;0xf865808080948ba1f109551bd432803012645ac136ddd64dba72880de0b6b3a7640000801ca0918e294306d177ab7bd664f5e141436563854ebe0a3e523b9690b4922bbb52b8a01181612cec9c431c4257a79b8c9f0c980a2c49bb5a0e6ac52949163eeb565dfc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// connect方法返回一个连接到provider的新钱包实例</span></span><br><span class="line">wallet = walletMnemonic.<span class="title function_">connect</span>(provider)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从网络中查询</span></span><br><span class="line"><span class="keyword">await</span> wallet.<span class="title function_">getBalance</span>();</span><br><span class="line"><span class="comment">// &#123; BigNumber: &quot;6846&quot; &#125;</span></span><br><span class="line"><span class="keyword">await</span> wallet.<span class="title function_">getTransactionCount</span>();</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 ether</span></span><br><span class="line"><span class="keyword">await</span> wallet.<span class="title function_">sendTransaction</span>(tx)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   accessList: [],</span></span><br><span class="line"><span class="comment">//   chainId: 31337,</span></span><br><span class="line"><span class="comment">//   confirmations: 0,</span></span><br><span class="line"><span class="comment">//   data: &#x27;0x&#x27;,</span></span><br><span class="line"><span class="comment">//   from: &#x27;0x894ed91B666FacCe5a4D2FF8261924b4754A5759&#x27;,</span></span><br><span class="line"><span class="comment">//   gasLimit: &#123; BigNumber: &quot;21001&quot; &#125;,</span></span><br><span class="line"><span class="comment">//   gasPrice: null,</span></span><br><span class="line"><span class="comment">//   hash: &#x27;0x1b4a95e9d23bd96d5429c535148eb3eaed326d89118b118e44cc05c26703224e&#x27;,</span></span><br><span class="line"><span class="comment">//   maxFeePerGas: &#123; BigNumber: &quot;1572346688&quot; &#125;,</span></span><br><span class="line"><span class="comment">//   maxPriorityFeePerGas: &#123; BigNumber: &quot;1500000000&quot; &#125;,</span></span><br><span class="line"><span class="comment">//   nonce: 5,</span></span><br><span class="line"><span class="comment">//   r: &#x27;0x5e32c2741700a9120cfa186bc74e88b3d9488393be796a5124fddf08ffdbfdc6&#x27;,</span></span><br><span class="line"><span class="comment">//   s: &#x27;0x2431f3e3274cd22d6de63ed6e23a5c6839c1fabeb97b6683fb15584b9bf1f29d&#x27;,</span></span><br><span class="line"><span class="comment">//   to: &#x27;0x8ba1f109551bD432803012645Ac136ddd64DBA72&#x27;,</span></span><br><span class="line"><span class="comment">//   type: 2,</span></span><br><span class="line"><span class="comment">//   v: 0,</span></span><br><span class="line"><span class="comment">//   value: &#123; BigNumber: &quot;1000000000000000000&quot; &#125;,</span></span><br><span class="line"><span class="comment">//   wait: [Function]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h1 id="VoidSinger"><a href="#VoidSinger" class="headerlink" title="VoidSinger"></a>VoidSinger</h1><p>一个<strong>VoidSigner</strong>是一个简单的Signer，它不能签名。</p><p>当API需要signer作为参数时，它作为只读的signer是有用的，但它只能携带只读的操作。</p><p>比如，在<code>call</code>函数调用期间会自动传递所提供的地址。</p><p><strong>new <em>ethers</em>.VoidSigner( <em>address</em> [ , <em>provider</em> ] ) ⇒ <em>VoidSigner</em>：**为一个地址创建</strong>VoidSigner**实例。</p><p>**<em>voidSigner</em>.address ⇒ *string&lt; 地址(Address) &gt;<em><strong>：</strong>VoidSigner</em>*的地址。</p><h1 id="ExternallyOwnedAccount"><a href="#ExternallyOwnedAccount" class="headerlink" title="ExternallyOwnedAccount"></a><strong>ExternallyOwnedAccount</strong></h1><p>这个接口包含外部拥有帐户（EOA）所需的最小属性集，可以执行某些操作，比如将其编码为JSON钱包。</p><p><em><strong>eoa*.address ⇒ *string&lt; 地址(Address) &gt;：</strong></em>地址(Address)EOA的地址</p><p><em><strong>eoa*.privateKey ⇒ *string&lt; DataHexString&lt; 32 &gt; &gt;：</strong></em>EOA的私钥</p><p><strong><em>eoa</em>.mnemonic ⇒ <em>助记词</em>：</strong>帐户HD的助记词，如果有的话可以打印出来。EOA账户源不编码助记符，如HD extended keys。</p>]]></content>
      
      
      <categories>
          
          <category> ether@5.4.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> ether@5.4.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-Types</title>
      <link href="/2022/08/09/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/4-Types/"/>
      <url>/2022/08/09/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/4-Types/</url>
      
        <content type="html"><![CDATA[<h1 id="BlockTag"><a href="#BlockTag" class="headerlink" title="BlockTag"></a>BlockTag</h1><p><strong>BlockTag</strong> 在区块链中指定了一个特定的区块位置</p><ul><li><strong><code>&quot;latest&quot;</code></strong> - 最新挖出的区块</li><li><strong><code>&quot;earliest&quot;</code></strong> - 创世区块</li><li><strong><code>&quot;pending&quot;</code></strong> - 目前正在挖的区块;不是所有的操作和后端都支持这个BlockTag属性</li><li><strong><code>&quot;number&quot;</code></strong>- 区块高度</li><li><strong><code>&quot;a negative number&quot;</code></strong> - 几个区块前的区块</li><li><strong><code>&quot;hex string&quot;</code></strong> - 区块高度(十六进制表示)</li></ul><h1 id="Networkish"><a href="#Networkish" class="headerlink" title="Networkish"></a>Networkish</h1><p><strong>Networkish</strong>可以是以下任意一种:</p><ul><li><p>一个Network 对象</p><p><em>network</em>.<strong>name</strong> ⇒ <em>string</em>，可读的网络名称，如<code>homestead</code>。如果网络的name未指定，将会是<code>&quot;unknown&quot;</code>。</p><p><em>network</em>.<strong>chainId</strong> ⇒ <em>number</em>，网络的Chain ID。</p><p><em>network</em>.<strong>ensAddress</strong> ⇒ *string&lt; 地址(Address) &gt;*，部署在这个网络上的ENS注册表的地址。</p></li><li><p>字符串形式的常见网络 (如<code>&quot;homestead&quot;</code>)</p></li><li><p>number类型的网络chain ID， 如果chain ID 是常见网络的一种,<code>name</code> 和 <code>ensAddress</code> 会自动填充, 否则 name 会是<code>&quot;unknown&quot;</code> 且不使用任何的 <code>ensAddress</code>。</p></li></ul><h1 id="FeeData"><a href="#FeeData" class="headerlink" title="FeeData"></a>FeeData</h1><p><strong>FeeData</strong>对象根据最好且可用建议，去封装发送交易所需的费用数据。</p><p>**<em>feeData</em>.gasPrice ⇒ *大数(BigNumber):***gasPrice用于那些不支持EIP-1559的遗留交易或网络。</p><p><strong><em>feeData</em>.maxFeePerGas ⇒ <em>大数(BigNumber)</em>:</strong><code>maxFeePerGas</code>用于交易。这基于最近产出区块的<code>baseFee</code>。</p><p>**<em>feeData</em>.maxPriorityFeePerGas ⇒ <em>大数(BigNumber)</em>:**用于交易的“最大优先的Gas”</p><h1 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h1><p>**<em>block</em>.hash ⇒ <em>string&lt; DataHexString&lt; 32 &gt; &gt;</em>:**这个区块的哈希。</p><p>**<em>block</em>.parentHash ⇒ <em>string&lt; DataHexString&lt; 32 &gt; &gt;</em>:**上个区块的哈希。</p><p>**<em>block</em>.number ⇒ <em>number</em>:**当前区块的高度（数量）。</p><p>**<em>block</em>.timestamp ⇒ numbe:**r当前区块的时间戳。</p><p>**<em>block</em>.nonce ⇒ <em>string&lt; DataHexString &gt;<em>nonce:</em></em> 用在基于工作量证明（PoW）机制挖取区块</p><p>**<em>block</em>.difficulty ⇒ *number:***该区块的矿工需要达到的难度指标。 开发人员通常对这个属性不感兴趣。</p><p>**<em>block</em>.gasLimit ⇒ *大数(BigNumber):***这个区块允许使用的最大gas数量,该值可以由矿工投票决定要变大还是变小</p><p>**<em>block</em>.gasUsed ⇒ *大数(BigNumber):***当前区块所有的交易已使用的gas总数量。</p><p>**<em>block</em>.miner ⇒ *string:***当前区块的coinbase 地址，这个地址表示挖出这个区块的矿工想要接受这笔开采奖励的地址。</p><p>**<em>block</em>.extraData ⇒ *string:***该数据表示的是当挖出一个区块时，这个矿工可以选择包含的额外数据。 </p><p>**<em>block</em>.transactions ⇒ <em>Array&lt; string&lt; DataHexString&lt; 32 &gt; &gt; &gt;</em>:**一个当前区块包含的每一条交易哈希的列表。</p><p>**<em>block</em>.transactions ⇒ *Array&lt; TransactionResponse &gt;:***当前区块包含的交易列表。</p><h1 id="Events-and-Logs"><a href="#Events-and-Logs" class="headerlink" title="Events and Logs"></a>Events and Logs</h1><h2 id="5-1-EventFilter"><a href="#5-1-EventFilter" class="headerlink" title="5.1 EventFilter"></a><strong>5.1 EventFilter</strong></h2><p>**<em>filter</em>.address ⇒ <em>string&lt; 地址(Address) &gt;</em>:**想要筛选的地址， <code>null</code> 表示匹配任何用户的地址。</p><p>**<em>filter</em>.topics ⇒ <em>Array&lt; string&lt; Data&lt; 32 &gt; &gt; | Array&lt; string&lt; Data&lt; 32 &gt; &gt; &gt; &gt;</em>:**要筛选的主题，<code>null</code>示匹配任何用户的主题。</p><p>每一个 entry 表示一个<strong>AND</strong>匹配条件，entry 也可以是<code>null</code>来匹配所有的内容。 如果给定的 entry 是一个数组，那么这个 entry 是被视为 <strong>OR</strong>匹配条件来匹配entry里面的内容。 有关指定复杂过滤器的详细信息和示例，请参阅Filters。</p><h2 id="5-2-Filter"><a href="#5-2-Filter" class="headerlink" title="5.2 Filter"></a>5.2 Filter</h2><p>**<em>filter</em>.fromBlock ⇒ <em>BlockTag</em>:**用于搜索匹配过滤条件的日志的起始区块(包含在内)。</p><p>**<em>filter</em>.toBlock ⇒ <em>BlockTag</em>:**用于搜索匹配过滤条件的日志的结束区块(包含在内)。</p><h2 id="5-3-FilterByBlockHash"><a href="#5-3-FilterByBlockHash" class="headerlink" title="5.3 FilterByBlockHash"></a>5.3 FilterByBlockHash</h2><p>**<em>filter</em>.blockHash ⇒ *string&lt; DataHexString&lt; 32 &gt; &gt;:***指定区块(按这个区块哈希值)搜索符合过滤条件的日志。</p><h2 id="5-4-Log"><a href="#5-4-Log" class="headerlink" title="5.4 Log"></a>5.4 Log</h2><p>**<em>log</em>.blockNumber ⇒ *number:***包含该日志的交易的区块高度(区块数)。</p><p>**<em>log</em>.blockHash ⇒ <em>string&lt; DataHexString&lt; 32 &gt; &gt;</em>:**包含该日志的交易的区块的哈希值。</p><p>**<em>log</em>.removed ⇒ <em>boolean</em>:**在区块重组期间，如果一个交易是孤立的，它将被设置为true，表示Log entry已被删除; 在不久的将来，当使用包含该日志的交易被另一个区块挖出时，可能会再次触发此日志，但请记住，值可能会更改。</p><p>**<em>log</em>.transactionLogIndex ⇒ <em>number</em>:**该日志在交易中的索引。</p><p>**<em>log</em>.address ⇒ <em>string&lt; 地址(Address) &gt;</em>:**生成这条日志的合约地址。</p><p>**<em>log</em>.data ⇒ <em>string&lt; DataHexString &gt;</em>:**日志的数据。</p><p>**<em>log</em>.topics ⇒ <em>Array&lt; string&lt; DataHexString&lt; 32 &gt; &gt; &gt;</em>:**日志的主题(索引属性)列表。</p><p>**<em>log</em>.transactionHash ⇒ <em>string&lt; DataHexString&lt; 32 &gt; &gt;</em>:**包含这条日志的交易的哈希值。</p><p>**<em>log</em>.transactionIndex ⇒ <em>number</em>:**区块中包含这条日志的交易的索引。</p><p><strong><em>log</em>.logIndex ⇒ <em>number</em>:<strong>在整个</strong>区块中</strong>所有的日志集合里，该条日志的索引。</p><h1 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h1><h2 id="6-1-TransactionRequest"><a href="#6-1-TransactionRequest" class="headerlink" title="6.1 TransactionRequest"></a>6.1 TransactionRequest</h2><p>描述了一笔将要被发送到网络或以其他方式处理的交易，所有字段都是可选的，并且可以是一个能被解析为所需类型的promise。</p><p>**<em>transactionRequest</em>.to ⇒ <em>string | Promise&lt; string &gt;</em>:**接受这笔交易的地址(or ENS name)。</p><p>**<em>transactionRequest</em>.from ⇒ <em>string&lt; 地址(Address) &gt; | Promise&lt; string&lt; 地址(Address) &gt; &gt;</em>:**发送这笔交易的地址。</p><p>**<em>transactionRequest</em>.nonce ⇒ *number | Promise&lt; number &gt;:***交易的 nonce 值。 <strong>发送</strong>这笔交易要设置这个值，是number类型的。</p><p>**<em>transactionRequest</em>.data ⇒ <em>DataHexString | Promise&lt; DataHexString &gt;</em>:**交易的数据。</p><p>**<em>transactionRequest</em>.value ⇒ <em>大数(BigNumber) | Promise&lt; 大数(BigNumber) &gt;</em>:**这笔交易要发送的数量(以wei为单位)。</p><p>**<em>transactionRequest</em>.gasLimit ⇒ <em>大数(BigNumber) | Promise&lt; 大数(BigNumber) &gt;</em>:**这笔交易允许使用的最大gas值。</p><p>如果未指定，ethers将使用<code>estimateGas</code>来确定要使用的gas值。对于无法预测的gas的交易，可能需要这样做显式地指定。</p><p>**<em>transactionRequest</em>.gasPrice ⇒ <em>大数(BigNumber) | Promise&lt; 大数(BigNumber) &gt;</em>:**这笔交易将支付的每个gas的价格(以wei为单位)。</p><p>这个属性不适用于这笔交易的<code>type</code>设置为<code>1</code> 或者 <code>2</code>的情形，也不适用于交易已指定了<code>maxFeePerGas</code> 或者 <code>maxPriorityFeePerGas</code>的情形。</p><p>**<em>transactionRequest</em>.maxFeePerGas ⇒ *大数(BigNumber) | Promise&lt; 大数(BigNumber) &gt;:***这笔交易将支付EIP-1559基础费用的每个gas的价格的最高价格(以wei为单位)。</p><p>大多数开发人员不应该指定该参数，而应该使用网络决定的默认值。 这个属性不适用于这笔交易的<code>type</code>设置为<code>0</code>的情形，也不适用于交易已指定了<code>gasPrice</code>的情形。</p><p><strong><em>transactionRequest</em>.maxPriorityFeePerGas ⇒ <em>大数(BigNumber) | Promise&lt; 大数(BigNumber) &gt;</em>:<strong>这笔交易将支付EIP-1559优先费用的每个gas的价格的价格(以wei为单位)。 这包含在<code>maxFeePerGass</code>中，所以这</strong>不会影响</strong><code>maxFeePerGas</code>设置的总最大价格。</p><p>大多数开发人员应该不指定该参数，而应该使用网络决定的默认值。 这个属性不适用于这笔交易的<code>type</code>设置为<code>0</code>的情形，也不适用于交易已指定了<code>gasPrice</code>的情形。</p><p><strong><em>transactionRequest</em>.chainId ⇒ <em>number | Promise&lt; number &gt;</em>:<strong>已被授权交易的chain ID，由EIP-155指定。 如果chain ID为0将禁用EIP-155，交易将在任何网络上有效。这可能</strong>很危险</strong>，应该小心，因为它允许交易在可能不是你想指定的网络上复现。 在最新版本的Geth中，有意重现的交易在默认情况下是禁用的，需要配置才能启用。</p><p><strong><em>transactionRequest</em>.type ⇒ <em>null | number</em>:</strong> 这笔交易envelope的EIP-2718类型，在网络上这个默认值是<code>null</code>。要强制使用没有envelope的lagacy交易，请使用type <code>0</code>。</p><p>**<em>transactionRequest</em>.accessList ⇒ <em>AccessListish</em>:**要包含的AccessList;仅适用于EIP-2930和EIP-1559的交易。</p><h2 id="6-2-TransactionResponse"><a href="#6-2-TransactionResponse" class="headerlink" title="6.2 TransactionResponse"></a>6.2 TransactionResponse</h2><p><strong>TransactionResponse</strong>包括交易的所有属性，以及等区块被挖出来后就很有用的几个属性。</p><p>**<em>transaction</em>.blockNumber ⇒ <em>number</em>:**这笔交易所在区块被挖出来时的高度(区块数量)如果区块还没有被挖出，这个值为<code>null</code>。</p><p>**<em>transaction</em>.blockHash ⇒ *string&lt; DataHexString&lt; 32 &gt; &gt;:***交易所在区块挖出来时的哈希值,如果区块还没有被挖出，这个值为<code>null</code>。</p><p>**<em>transaction</em>.timestamp ⇒ <em>number</em>:**这笔交易所在区块被挖出来时的时间戳。如果区块还没有被挖出，这个值为<code>null</code>。</p><p>**<em>transaction</em>.confirmations ⇒ *number:***当这笔交易所在的区块被挖出来时，所有已挖出的区块数量(包括初始块)。</p><p>**<em>transaction</em>.raw ⇒ *string&lt; DataHexString &gt;:<em><strong>序列化交易。如果一些后端不重新填充它时可能是null。 如果你需要这个属性，可以使用this cookbook recipe从</strong>TransactionResponse</em>*对象中计算。</p><p>**<em>transaction</em>.wait( [ <em>confirms</em> &#x3D; <em>1</em> ] ) ⇒ <em>Promise&lt; TransactionReceipt &gt;</em>:*<em>confirms</em>属性表示你愿意等待的挖出区块数量，一旦满足这个值将返回一个待解析的TransactionReceipt。 如果*confirms为0，并且交易还没有被挖出，则返回<code>null</code>。</p><p>如果交易执行失败(即接收状态为<code>0</code>)，将会生成一个<strong>CALL_EXCEPTION</strong>，其属性如下:</p><ul><li><code>error.transaction</code> - 这笔交易</li><li><code>error.transactionHash</code> - 这笔交易的哈希值<ul><li><code>error.receipt</code> - the actual receipt, 状态是 <code>0</code></li></ul></li></ul><p>如果这笔交易被另一个交易替换，将会生成一个<strong>TRANSACTION_REPLACED</strong>，其属性如下:</p><ul><li><code>error.hash</code> - 被替换的交易的哈希值</li><li><code>error.reason</code> - string类型的错误原因; 是 <code>&quot;repriced&quot;</code>或 <code>&quot;cancelled&quot;</code>或 <code>&quot;replaced&quot;</code>其中一个</li><li><code>error.cancelled</code> - boolean类型; <code>&quot;repriced&quot;</code>表示不视为cancelled, 但<code>&quot;cancelled&quot;</code> 和<code>&quot;replaced&quot;</code>视为cancelled。</li><li><code>error.replacement</code> - the replacement transaction (a <strong>TransactionResponse</strong>)</li><li><code>error.receipt</code> - replacement transaction的收据 (a <strong>TransactionReceipt</strong>)</li></ul><p>当用户在客户端相同的帐户中发送一笔新的交易，这笔交易与之前一笔交易的<code>nonce</code>相同时，之前的那笔交易将被替换。 这通常是为了加快交易或取消交易，新交易可以给矿工更多的费用，让他们更喜欢新交易，而不是原来的交易。</p><p>**<em>transactionRequest</em>.type ⇒ <em>number</em>:**这笔交易的EIP-2718类型。如果事务是没有envelope的legacy交易，则其类型为<code>0</code>。</p><p><strong><em>transactionRequest</em>.accessList ⇒ <em>AccessList</em>:<strong>包含的</strong>AccessList</strong>，对于不支持访问列表的交易类型时该值为空。</p><h2 id="6-3-TransactionReceipt"><a href="#6-3-TransactionReceipt" class="headerlink" title="6.3 TransactionReceipt"></a>6.3 TransactionReceipt</h2><p>**<em>receipt</em>.to ⇒ <em>string&lt; 地址(Address) &gt;</em>:**接受这笔交易的地址。如果交易是用于部署合约，则为<code>null</code>。</p><p>**<em>receipt</em>.from ⇒ <em>string&lt; 地址(Address) &gt;</em>:**发起这笔交易的地址。</p><p>**<em>receipt</em>.contractAddress ⇒ *string&lt; 地址(Address) &gt;:<em><strong>如果这笔交易是转去一个<code>null</code>的地址，它是表示一个</strong>init transaction</em>*用于部署合约。在这种情况下，这个属性就代表所创建的合约的地址。 要计算合约地址，getContractAddress的utility function还可以与TransactionResponse对象一起使用，该对象需要交易的nonce值和发送人的地址。</p><p>**<em>receipt</em>.transactionIndex ⇒ <em>number</em>:**当前区块包含所有交易列表中，此交易的索引。</p><p>**<em>receipt</em>.type ⇒ *number:***此交易的EIP-2718类型。如果事务是没有envelope的legacy事务，则其type 为<code>0</code>。</p><p>**<em>receipt</em>.root ⇒ <em>string</em>:**收据的中间状态根</p><p>只有在Byzantium Hard Fork之前包含在区块中的交易才有这个属性，因为它被<code>status</code>属性取代了。</p><p>这些属性通常对开发者没什么用处。仅考虑单笔交易的防伪性的时候可以用于验证状态转换;如果没有它，则必须考虑整个区块。</p><p>**<em>receipt</em>.gasUsed ⇒ <em>大数(BigNumber)</em>:**该交易实际使用的gas值。</p><p>**<em>receipt</em>.logsBloom ⇒ *string&lt; DataHexString &gt;:***一个bloom-filter，包含此交易中所有日志中包含的全部地址和主题。</p><p>**<em>receipt</em>.blockHash ⇒ *string&lt; DataHexString&lt; 32 &gt; &gt;:***包含该交易的区块的区块哈希值。</p><p>**<em>receipt</em>.transactionHash ⇒ *string&lt; DataHexString&lt; 32 &gt; &gt;:***这笔交易的哈希值。</p><p>**<em>receipt</em>.logs ⇒ *Array&lt; Log &gt;:***这笔交易触发的所有日志。</p><p>**<em>receipt</em>.blockNumber ⇒ *number:***包含这笔交易的区块的高度（区块数量）。</p><p>**<em>receipt</em>.confirmations ⇒ *number:***当这笔交易所在的区块被挖出来时，所有已挖出的区块数量(包括这笔刚挖出的区块)。</p><p>**<em>receipt</em>.cumulativeGasUsed ⇒ 大数(BigNumber):**对包含该交易的块，这是截至(该交易的有序交易列表中每个交易使用的gas的总和</p><p>**<em>receipt</em>.byzantium ⇒ <em>boolean</em>:**如果区块是在post-Byzantium Hard Fork区块，这个值是true。</p><p>**<em>receipt</em>.status ⇒ *boolean:***如果交易成功，这个值为1；如果交易被reverted，这个值为为0。 只有post-Byzantium Hard Fork中包含的交易才有这个属性。</p><h1 id="Access-Lists"><a href="#Access-Lists" class="headerlink" title="Access Lists"></a>Access Lists</h1><p>Access List是可选的，它包含一个地址列表和地址的存储槽，这些地址应该是<em>warmed</em>或pre-fetched的，以便在这个交易的执行中使用。 一个<em>warmed</em>值有一个额外的预先支付访问的成本，但在整个读取和写入代码的执行过程中会被降低。</p><h2 id="7-1-AccessListish"><a href="#7-1-AccessListish" class="headerlink" title="7.1 AccessListish"></a>7.1 AccessListish</h2><p>AccessList的一个更宽松的描述，它将在内部使用accessListify进行转换。</p><p>他可以是以下的任意一种:</p><ul><li>任意的AccessList</li><li>一个包含两个元素的数组，第一个元素是地址，第二个是数组在storage中的key</li><li>一个对象, 所以的key表示地址，相应的value表示数组在storage中的key</li></ul><p>当使用对象形式(上述最后一个选项)时，地址和存储槽将被排序。 如果需要access list的显式顺序，则必须使用方式。 大多数开发人员不需要明确的顺序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Option 1:</span></span><br><span class="line"><span class="comment">// AccessList</span></span><br><span class="line"><span class="comment">// see below</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 2:</span></span><br><span class="line"><span class="comment">// Array&lt; [ Address, Array&lt;Bytes32&gt; ] &gt;</span></span><br><span class="line">accessList = [</span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;0x0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e&quot;</span>,</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000004&quot;</span>,</span><br><span class="line">      <span class="string">&quot;0x0bcad17ecf260d6506c6b97768bdc2acfb6694445d27ffd3f9c1cfbee4a9bd6d&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;0x5FfC014343cd971B7eb70732021E26C35B744cc4&quot;</span>,</span><br><span class="line">    [</span><br><span class="line">        <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 3:</span></span><br><span class="line"><span class="comment">// Record&lt;Address, Array&lt;Bytes32&gt;&gt;</span></span><br><span class="line">accessList = &#123;</span><br><span class="line">  <span class="string">&quot;0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000004&quot;</span>,</span><br><span class="line">    <span class="string">&quot;0x0bcad17ecf260d6506c6b97768bdc2acfb6694445d27ffd3f9c1cfbee4a9bd6d&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;0x5FfC014343cd971B7eb70732021E26C35B744cc4&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;equivalent to the <span class="title class_">AccessList</span> example below</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 1:</span></span><br><span class="line"><span class="comment">// AccessList</span></span><br><span class="line"><span class="comment">// see below</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 2:</span></span><br><span class="line"><span class="comment">// Array&lt; [ Address, Array&lt;Bytes32&gt; ] &gt;</span></span><br><span class="line">accessList = [</span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;0x0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e&quot;</span>,</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000004&quot;</span>,</span><br><span class="line">      <span class="string">&quot;0x0bcad17ecf260d6506c6b97768bdc2acfb6694445d27ffd3f9c1cfbee4a9bd6d&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;0x5FfC014343cd971B7eb70732021E26C35B744cc4&quot;</span>,</span><br><span class="line">    [</span><br><span class="line">        <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 3:</span></span><br><span class="line"><span class="comment">// Record&lt;Address, Array&lt;Bytes32&gt;&gt;</span></span><br><span class="line">accessList = &#123;</span><br><span class="line">  <span class="string">&quot;0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000004&quot;</span>,</span><br><span class="line">    <span class="string">&quot;0x0bcad17ecf260d6506c6b97768bdc2acfb6694445d27ffd3f9c1cfbee4a9bd6d&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;0x5FfC014343cd971B7eb70732021E26C35B744cc4&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-2-AccessList"><a href="#7-2-AccessList" class="headerlink" title="7.2 AccessList"></a>7.2 AccessList</h2><p>一个EIP-2930交易允许一个可选的<strong>AccessList</strong>，它会导致交易<em>warm</em>（预缓存）另一个地址状态和指定的storage key。</p><p>这会使得交易的内在成本变大，但在整个事务执行过程中给存储和状态访问带来了好处。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array of objects with the form:</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   address: Address,</span></span><br><span class="line"><span class="comment">//   storageKey: Array&lt; DataHexString&lt; 32 &gt; &gt;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">accessList = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">address</span>: <span class="string">&quot;0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e&quot;</span>,</span><br><span class="line">    <span class="attr">storageKeys</span>: [</span><br><span class="line">        <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000004&quot;</span>,</span><br><span class="line">        <span class="string">&quot;0x0bcad17ecf260d6506c6b97768bdc2acfb6694445d27ffd3f9c1cfbee4a9bd6d&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">address</span>: <span class="string">&quot;0x5FfC014343cd971B7eb70732021E26C35B744cc4&quot;</span>,</span><br><span class="line">    <span class="attr">storageKeys</span>: [</span><br><span class="line">        <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ether@5.4.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> ether@5.4.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-Providers</title>
      <link href="/2022/08/08/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/3-Providers/"/>
      <url>/2022/08/08/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/3-Providers/</url>
      
        <content type="html"><![CDATA[<h1 id="JsonRpcProvider"><a href="#JsonRpcProvider" class="headerlink" title="JsonRpcProvider"></a>JsonRpcProvider</h1><p>JSON-RPC API是与以太坊交互比较流行的方法，在主要的以太坊节点实现(如Geth 和 Parity)以及许多第三方web服务中都可以用。</p><p><strong>new <em>ethers</em>.<em>providers</em>.JsonRpcProvider( [ <em>urlOrConnectionInfo</em> [ ，<em>networkish</em> ] ] )</strong></p><p>使用 URL 或者 urlOrConnectionInfo 作为一个一个 JSON-RPC HTTP API 连接到 <em>networkish</em> 网络。</p><p>如果 <em>urlOrConnectionInfo</em> 没有被指定， 默认值是<code>http://localhost:8545</code>。 如果网络没有被指定， 它将会自动使用 <code>eth_chaindId</code>查询网络节点并返回 <code>eth_networkId</code>从而确定网络。</p><h2 id="1-1-getSigner"><a href="#1-1-getSigner" class="headerlink" title="1.1 getSigner"></a>1.1 getSigner</h2><p><em>jsonRpcProvider</em>.<strong>getSigner</strong>( [ <em>addressOrIndex</em> ] ) ⇒ <em><strong>JsonRpcSigner</strong></em></p><p>返回由该以太坊节点管理的JsonRpcSigner，地址为<em>addressOrIndex</em>。如果没有提供<em>addressOrIndex</em>，则使用第一个帐户(account #0)。</p><h2 id="1-2-listAccounts"><a href="#1-2-listAccounts" class="headerlink" title="1.2 listAccounts"></a>1.2 listAccounts</h2><p><em>jsonRpcProvider</em>.<strong>listAccounts</strong>( ) ⇒ <em>Promise&lt; Array&lt; **string** &gt; &gt;</em></p><p>返回此provider管理的所有帐户地址的列表。</p><h2 id="1-3-send"><a href="#1-3-send" class="headerlink" title="1.3 send"></a>1.3 send</h2><p><em>jsonRpcProvider</em>.<strong>send</strong>( <em>method</em>，<em>params</em> ) ⇒ <em>Promise&lt; **any** &gt;</em></p><p>允许向provider发送原始消息,这可以用于后端特定的调用，比如调试或特定的帐户管理。</p><p>获取不常见的或特定于某些以太坊节点(例如Parity 与 Geth)才有的</p><h2 id="1-4-getUncheckedSigner"><a href="#1-4-getUncheckedSigner" class="headerlink" title="1.4 getUncheckedSigner"></a>1.4 <strong>getUncheckedSigner</strong></h2><p><em>jsonRpcProvider</em>.<strong>getUncheckedSigner</strong>( [ <em>addressOrIndex</em> ] ) ⇒ <em><strong>JsonRpcUncheckedSigner</strong></em></p><p><strong>JsonRpcUncheckedSigner</strong>:JSON-RPC API仅在发送交易时提供交易哈希作为响应，但ether Provider要求在返回交易之前填充交易的所有细节。 例如，燃料价格（gas price）和燃料限制（gas limit）可能由节点或自动包含在内的nonce调整。</p><p>为了解决这个问题，<strong>JsonRpcSigner</strong>立即查询provider的详细信息，用返回的交易哈希来填充<strong>TransactionResponse</strong>对象。</p><p><strong>UncheckedSigner</strong>不填充任何附加信息，并将一个模拟的类似<strong>TransactionResponse</strong>的对象作为立即返回的结果， 其中大部分属性设置为null，但如果只需要这些，则可以快速获得交易哈希。</p><h2 id="1-5-StaticJsonRpcProvider"><a href="#1-5-StaticJsonRpcProvider" class="headerlink" title="1.5 StaticJsonRpcProvider"></a>1.5 StaticJsonRpcProvider</h2><p>ethers Provider将频繁执行<code>getNetwork</code>调用，以确保网络调用和网络通信是一致的(<strong>MetaMask</strong>)</p><p>在某些情况下网络不能改变，如当连接到一个INFURA端点，在这种情况下，可以使用<strong>StaticJsonRpcProvider</strong>来将一直缓存链ID，可以减少网络流量和往返查询chain ID的次数。</p><h1 id="JsonRpcSinger"><a href="#JsonRpcSinger" class="headerlink" title="JsonRpcSinger"></a>JsonRpcSinger</h1><p><strong>JsonRpcSigner</strong>是一个简单的Signer，它由一个连接的JsonRpcProvider支持。</p><h2 id="2-1-provider"><a href="#2-1-provider" class="headerlink" title="2.1 provider"></a>2.1 provider</h2><p><em>signer</em>.<strong>provider</strong> ⇒ <em><strong>JsonRpcProvider</strong></em></p><p>创建这个signer的provider</p><h2 id="2-2-connectUnchecked"><a href="#2-2-connectUnchecked" class="headerlink" title="2.2 connectUnchecked"></a>2.2 connectUnchecked</h2><p><em>signer</em>.<strong>connectUnchecked</strong>( ) ⇒ <em><strong>JsonRpcUncheckedSigner</strong></em></p><p>返回一个新的Signer对象，该对象在发送交易时不执行额外的检查。详情请参阅getUncheckedSigner。</p><h2 id="2-3-sendUncheckedTransaction"><a href="#2-3-sendUncheckedTransaction" class="headerlink" title="2.3 sendUncheckedTransaction"></a>2.3 sendUncheckedTransaction</h2><p><em>signer</em>.<strong>sendUncheckedTransaction</strong>( <em>transaction</em> ) ⇒ <em>Promise&lt; string&lt; **DataHexString**&lt; 32 &gt; &gt; &gt;</em></p><p>发送<em>交易</em>并返回一个解析为不透明交易哈希的Promise。</p><h2 id="2-4-unlock"><a href="#2-4-unlock" class="headerlink" title="2.4 unlock"></a>2.4 unlock</h2><p><em>signer</em>.<strong>unlock</strong>( <em>password</em> ) ⇒ <em>Promise&lt; **boolean** &gt;</em></p><p>使用<em>密码</em>请求节点解除锁定（如果被锁了）。</p><h1 id="API-Proviers"><a href="#API-Proviers" class="headerlink" title="API Proviers"></a>API Proviers</h1><p>很多服务提供了访问以太坊区块链的web API,这些提供商允许连接到它们，因为你不需要运行你自己的实例或以太坊节点集群，这就简化了开发。这种对第三方服务的依赖会降低弹性和安全性，并增加所需的信任度。为了缓解这些问题，建议您使用 <strong>Default</strong> <strong>Provider</strong>。</p><h2 id="3-1-EtherscanProvider"><a href="#3-1-EtherscanProvider" class="headerlink" title="3.1 EtherscanProvider"></a>3.1 EtherscanProvider</h2><p><strong>new</strong> <em>ethers</em>.<em>providers</em>.<strong>EtherscanProvider</strong>( [ <em>network</em> &#x3D; “<em>homestead</em>“ , [ <em>apiKey</em> ] ] )</p><p>使用可选的<em>apiKey</em>创建一个新的<strong>EtherscanProvider</strong>连接到<em>网络</em>。</p><p>这个<em>网络</em>可以被指定为一个<strong>字符串</strong>类型的网络名称、或<strong>number</strong>类型的链ID，或[网络对象]provider-(network)。</p><p>如果没有提供<em>apiKey</em>,将使用一个共享的API key,可能导致性能降低和请求受限,推荐在生产环境中使用您在Etherscan上注册的API密钥。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接主网 (homestead)</span></span><br><span class="line">provider = <span class="keyword">new</span> <span class="title class_">EtherscanProvider</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接 rinkeby 测试网(以下这两种方式是等价的)</span></span><br><span class="line">provider = <span class="keyword">new</span> <span class="title class_">EtherscanProvider</span>(<span class="string">&quot;goerli&quot;</span>);</span><br><span class="line">provider = <span class="keyword">new</span> <span class="title class_">EtherscanProvider</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">provider = <span class="keyword">new</span> <span class="title class_">EtherscanProvider</span>(network);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过API key 连接主网(homestead)</span></span><br><span class="line">provider = <span class="keyword">new</span> <span class="title class_">EtherscanProvider</span>(<span class="literal">null</span>, apiKey);</span><br><span class="line">provider = <span class="keyword">new</span> <span class="title class_">EtherscanProvider</span>(<span class="string">&quot;homestead&quot;</span>, apiKey);</span><br></pre></td></tr></table></figure><h2 id="3-2-InfuraProvider"><a href="#3-2-InfuraProvider" class="headerlink" title="3.2 InfuraProvider"></a>3.2 InfuraProvider</h2><p><strong>new <em>ethers</em>.<em>providers</em>.InfuraProvider( [ <em>network</em> &#x3D; “<em>homestead</em>“ , [ <em>apiKey</em> ] ] )</strong></p><p><em>apiKey</em>可以是一个<strong>string</strong>类型的Project ID，也可以是一个带有<code>projectId</code>和<code>projectSecret</code>属性<strong>对象</strong>， 用于指定一个可以在非公共源(如服务器)上使用的Project Secret， 以进一步保护你的API access 和 quotas。</p><p><em><strong>InfuraProvider*.getWebSocketProvider( [ <em>network</em> [ , <em>apiKey</em> ] ] ) ⇒ *WebSocketProvider</strong></em></p><p>Create a new WebSocketProvider 使用 INFURA web-socket 端点创建一个新的WebSocketProvider，并使用可选的<em>apiKey</em>连接到网络。 网络和apiKey的设定与构造函数相同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一个Project ID连接到主网(以下这两种方式是等价的)</span></span><br><span class="line">provider = <span class="keyword">new</span> <span class="title class_">InfuraProvider</span>(<span class="literal">null</span>, projectId);</span><br><span class="line">provider = <span class="keyword">new</span> <span class="title class_">InfuraProvider</span>(<span class="string">&quot;homestead&quot;</span>, projectId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Project ID 和 Project Secret 连接到主网</span></span><br><span class="line">provider = <span class="keyword">new</span> <span class="title class_">InfuraProvider</span>(<span class="string">&quot;homestead&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">projectId</span>: projectId,</span><br><span class="line">    <span class="attr">projectSecret</span>: projectSecret</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个 WebSocketProvider 连接到 INFURA WebSocket 端点</span></span><br><span class="line">provider = <span class="title class_">InfuraProvider</span>.<span class="title function_">getWebSocketProvider</span>()</span><br></pre></td></tr></table></figure><h2 id="3-3-AlchemyProvider"><a href="#3-3-AlchemyProvider" class="headerlink" title="3.3 AlchemyProvider"></a>3.3 AlchemyProvider</h2><h2 id="3-4-CloundfalreProvier"><a href="#3-4-CloundfalreProvier" class="headerlink" title="3.4 CloundfalreProvier"></a>3.4 CloundfalreProvier</h2><h1 id="其他的Providers"><a href="#其他的Providers" class="headerlink" title="其他的Providers"></a>其他的Providers</h1><h2 id="4-1-FallbackProvider"><a href="#4-1-FallbackProvider" class="headerlink" title="4.1 FallbackProvider"></a>4.1 <strong>FallbackProvider</strong></h2><p><strong>FallbackProvider</strong> 是ethers中可用的且最高级的Provider。</p><p>它使用一个quorum并连接到多个Providers作为后端，每个Providers都配置了一个<em>优先级</em>和<em>权重</em>。</p><p>当发出一个请求时，请求被分配给多个随机选择的后端(优先级较低的后端总是被先选中)， 并将每个请求的结果与其他请求进行比较。只有达到quorum规定的数量后，该结果才会被接受并返回给调用方。</p><p><strong>new</strong> <em>ethers</em>.<em>providers</em>.<strong>FallbackProvider</strong>( <em>providers</em> [ , <em>quorum</em> ] )</p><p>创建一个连接到<em>providers</em>的FallbackProvider的新实例。 如果quorum未指定，则默认为provider权重总和的一半。</p><p><em>providers</em>可以是<strong>Provider</strong> 或 <strong>FallbackProviderConfig</strong>的数组。 如果提供了Provider，默认的优先级为1，权重为1。</p><p>描述后端的Provider配置列表:<strong>providerConfigs ⇒ <em>Array&lt; FallbackProviderConfig &gt;</em></strong></p><p>在得到结果之前，后端响应的quorum必须达成一致:<em><strong>provider*.quorum ⇒ *number</strong></em></p><h3 id="FallbackProviderConfig"><a href="#FallbackProviderConfig" class="headerlink" title="FallbackProviderConfig"></a>FallbackProviderConfig</h3><p>该配置的provider:<em><strong>fallbackProviderConfig*.provider ⇒ *Provider</strong></em></p><p>表示provider使用的优先级:<em><strong>fallbackProviderConfig*.priority ⇒ *number</strong></em></p><p>超时后(以ms为单位)将会尝试其他的Provider:<em><strong>fallbackProviderConfig*.stallTimeout ⇒ *number</strong></em></p><p>表示这个provider响应的权重:<strong>fallbackProviderConfig.weight ⇒ <em>number</em></strong></p><h2 id="4-2-IpcProvider"><a href="#4-2-IpcProvider" class="headerlink" title="4.2 IpcProvider"></a>4.2 IpcProvider</h2><p><strong>IpcProvider</strong> 允许JSON-RPC API在文件系统的本地文件名上使用。 Geth, Parity和其他节点都会开放了这个功能。</p><p>这只能在<em>node.js</em>中使用，因为它需要访问文件系统，并且由于文件权限可能有增加额外的复杂性。(请参阅相关节点实现的文档)</p><p>这个Provider要连接的路径:<strong>ipcProvider.path ⇒ <em>string</em></strong></p><h2 id="4-3-UrlJsonRpcProvider"><a href="#4-3-UrlJsonRpcProvider" class="headerlink" title="4.3 UrlJsonRpcProvider"></a>4.3 <strong>UrlJsonRpcProvider</strong></h2><p>这个类打算作为子类而不是直接使用。只需要额外生成一个JSON-RPC URL后，就能通过JsonRpcProvider创建一个Provider。</p><p><strong>new</strong> <em>ethers</em>.<em>providers</em>.<strong>UrlJsonRpcProvider</strong>( [ <em>network</em> [ , <em>apiKey</em> ] ] )</p><p>子类通常不需要重写这一部分。相反应该重写静态的方法 <code>getUrl</code> 和可选的<code>getApiKey</code>。</p><p><em><strong>urlJsonRpcProvider*.apiKey ⇒ *any</strong></em></p><p>从<code>InheritedClass.getApiKey</code>返回的apiKey的值。</p><p><em><strong>InheritingClass*.getApiKey( <em>apiKey</em> ) ⇒ *any</strong></em></p><p>这个函数应该检查<em>apiKey</em>以确保它是有效的，并返回一个(可能修改过的)值在<code>getUrl</code>函数中使用。</p><p><em><strong>InheritingClass*.getUrl( <em>network</em> , <em>apiKey</em> ) ⇒ *string</strong></em></p><p>这个URL在JsonRpcProvider 实例中使用。</p><h2 id="4-4-Web3Provider"><a href="#4-4-Web3Provider" class="headerlink" title="4.4 Web3Provider"></a>4.4 <strong>Web3Provider</strong></h2><h2 id="4-5-ExternalProvider"><a href="#4-5-ExternalProvider" class="headerlink" title="4.5 ExternalProvider"></a>4.5 <strong>ExternalProvider</strong></h2><h2 id="4-6-WebSocketProvider"><a href="#4-6-WebSocketProvider" class="headerlink" title="4.6 WebSocketProvider"></a>4.6 WebSocketProvider</h2><p><strong>WebSocketProvider</strong> 连接到一个JSON-RPC websocket兼容的后端，它允许持久连接、多路复用请求和发布-子事件，以实现更即时的事件调度。WebSocket API是较新的，如果运行自己的基础设施，请注意WebSockets对服务器资源的占用会很大， 因为它们必须管理和维护每个客户端的状态。由于这个原因，许多服务也可能会为使用他们的WebSocket端点而收取额外的费用。</p><p><strong>new <em>ethers</em>.<em>providers</em>.WebSocketProvider( [ <em>url</em> [ , <em>network</em> ] ] )</strong></p><p>通过一个<em>url</em>连接到<em>网络</em>，返回一个新的WebSocketProvider。</p><p>如果<em>url</em>未指定，默认值是<code>&quot;ws://localhost:8546&quot;</code>。 如果<em>network</em>未被指定，它将会从网络中查询。</p>]]></content>
      
      
      <categories>
          
          <category> ether@5.4.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> ether@5.4.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-Provider方法</title>
      <link href="/2022/08/07/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/2-Provider%E6%96%B9%E6%B3%95/"/>
      <url>/2022/08/07/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/2-Provider%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Providers"><a href="#Providers" class="headerlink" title="Providers"></a>Providers</h1><p><strong>提供者</strong>(<strong>Provider</strong>)是以太坊网络连接的抽象,为标准以太坊节点功能提供简洁、一致的接口.</p><p>ethers.js 库 提供了几种选项应该涵盖了绝大多数用例,但如果需要个性化配置,也包括了子类化所需的函数和类.</p><p>大多数用户应该使用默认的Provider.</p><h2 id="1-1-默认的Provider"><a href="#1-1-默认的Provider" class="headerlink" title="1.1 默认的Provider"></a>1.1 默认的Provider</h2><p>默认的 provider 是在<em>Ethereum</em>上最简单、最安全的方法方式,而且它也具备足够强的鲁棒性,可以在生产环境中使用.</p><p>它创建一个连接到尽可能多的后端服务的FallbackProvider.当发出一个请求时,它会同时发送到多个后端.当从每个后端返回响应时,会检查它们是否同意. 一旦达到规定数量(即足够多的后端同意),你的应用程序就会得到相应.它确保后端不同步或者被破坏,那么会放弃这个响应,选择接受而支持大多数认同的响应.</p><p><em><strong>ethers*.getDefaultProvider( [ <em>network</em> , [ <em>options</em> ] ] ) ⇒ *Provider</strong></em></p><p>返回一个新的Provider,由多个服务支持连接到 <em>网络</em>.如果没有提供<em>网络</em>,那么将会使用 <strong>homestead</strong> (例如mainnet) .</p><p><em>网络</em> 也可以作为 URL 来连接,比如 <code>http://localhost:8545</code> 或 <code>wss://example.com</code>.</p><p><em><strong>options</strong></em> 参数是一个对象,有以下几个属性:</p><table><thead><tr><th><strong>Property</strong></th><th><strong>Description</strong></th><th></th></tr></thead><tbody><tr><td><em>alchemy</em></td><td>Alchemy API Token</td><td></td></tr><tr><td><em>etherscan</em></td><td>Etherscan API Token</td><td></td></tr><tr><td><em>infura</em></td><td>INFURA Project ID 或 <code>&#123; projectId, projectSecret &#125;</code></td><td></td></tr><tr><td><em>pocket</em></td><td>Pocket Network Application ID 或 <code>&#123; applicationId, applicationSecretKey &#125;</code></td><td></td></tr><tr><td><em>quorum</em></td><td>必须满足规定的后端同意数量 <em>(默认: 2 for mainnet, 1 for testnets)</em></td><td></td></tr></tbody></table><h2 id="1-2-网络"><a href="#1-2-网络" class="headerlink" title="1.2 网络"></a>1.2 网络</h2><p>任何接收Networkish 的API都可以传递一个通用名称(如 <code>&quot;mainnet&quot;</code> or <code>&quot;ropsten&quot;</code>) 或者 chain ID、自定义的参数来定义网络.</p><p><em>ethers</em>.<em>providers</em>.<strong>getNetwork</strong>( <em>Networkish</em> ) ⇒ <em>Network.</em></p><p>通过给定标准规范的Networkish,返回完整的 Network .</p><p>这对于希望接受Networkish作为输入参数的函数和类非常有用.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过链名</span></span><br><span class="line"><span class="title function_">getNetwork</span>(<span class="string">&quot;homestead&quot;</span>);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   chainId: 1,</span></span><br><span class="line"><span class="comment">//   ensAddress: &#x27;0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e&#x27;,</span></span><br><span class="line"><span class="comment">//   name: &#x27;homestead&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过链ID</span></span><br><span class="line"><span class="title function_">getNetwork</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   chainId: 1,</span></span><br><span class="line"><span class="comment">//   ensAddress: &#x27;0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e&#x27;,</span></span><br><span class="line"><span class="comment">//   name: &#x27;homestead&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h2 id="1-3-自定义的-ENS-合约"><a href="#1-3-自定义的-ENS-合约" class="headerlink" title="1.3 自定义的 ENS 合约"></a>1.3 <strong>自定义的 ENS 合约</strong></h2><p>这是因为通常需要在为Network 指定自定义属性来覆盖root ENS registry,或者是在一个通用的网络中拦截ENS 方法,又或者是在一个开发环境的网络中（绝大多数开发环境中的网络中的ENS合约需要你手动部署)指定ENS registry.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> network = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;dev&quot;</span>,</span><br><span class="line">    <span class="attr">chainId</span>: <span class="number">1337</span>,</span><br><span class="line">    <span class="attr">ensAddress</span>: customEnsAddress</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-4-Provider"><a href="#1-4-Provider" class="headerlink" title="1.4 Provider"></a>1.4 <strong>Provider</strong></h2><p>在ethers里面,<strong>Provider</strong> 是访问区块链数据的只读抽象.</p><blockquote><p>如果你用过Web3.js,以下是与ethers.js最大不同点:ethers library 在 <strong>Provider</strong>和<strong>Signer</strong>可执行的操作之间创建了一个强大的划分,而Web3.js将二者结合在一起.这种划分的关注点在于Provider严格的操作子集允许更多的后端、更一致的API,并确保其他库可以在不依赖任何潜在假设的情况下运行.</p></blockquote><h1 id="账户的方法"><a href="#账户的方法" class="headerlink" title="账户的方法"></a>账户的方法</h1><h2 id="2-1-getBalance"><a href="#2-1-getBalance" class="headerlink" title="2.1 getBalance"></a>2.1 <strong>getBalance</strong></h2><p><em>provider</em>.<strong>getBalance</strong>( <em>address</em> [ , <em>blockTag</em> &#x3D; <em>latest</em> ] ) ⇒ <em>Promise&lt; 大数(**BigNumber**) &gt;</em></p><p>返回给定的<em>blockTag</em> 区块高度下<strong>地址的余额</strong></p><h2 id="2-2-getCode"><a href="#2-2-getCode" class="headerlink" title="2.2 getCode"></a>2.2 <strong>getCode</strong></h2><p><em>provider</em>.<strong>getCode</strong>( <em>address</em> [ , <em>blockTag</em> &#x3D; <em>latest</em> ] ) ⇒ <em>Promise&lt; string&lt; **DataHexString** &gt; &gt;</em></p><p>返回给定的<em>blockTag</em> 区块高度下的<strong>合约源代码</strong>,如果当前没有合约被部署, 将返回 <code>0x</code>.</p><h2 id="2-3-getStorageAt"><a href="#2-3-getStorageAt" class="headerlink" title="2.3 getStorageAt"></a>2.3 <strong>getStorageAt</strong></h2><p><em>provider</em>.<strong>getStorageAt</strong>( <em>addr</em> , <em>pos</em> [ , <em>blockTag</em> &#x3D; <em>latest</em> ] ) ⇒ <em>Promise&lt; string&lt; **DataHexString** &gt; &gt;</em></p><p>在当前的<em>blockTag</em>下,输入address参数addr和position(位置)参数pos,返回类型为<code>Bytes32</code>的值.</p><h2 id="2-4-getTransactionCount"><a href="#2-4-getTransactionCount" class="headerlink" title="2.4 getTransactionCount"></a>2.4 <strong>getTransactionCount</strong></h2><p><em>provider</em>.<strong>getTransactionCount</strong>( <em>address</em> [ , <em>blockTag</em> &#x3D; <em>latest</em> ] ) ⇒ <em>Promise&lt; **number** &gt;</em></p><p>在当前的<em>blockTag</em>下,返回已经发送的交易的数量,这个值是用来提供给<strong>发送</strong>到网络的下一个交易的<strong>nonce值</strong>.</p><h1 id="区块的方法"><a href="#区块的方法" class="headerlink" title="区块的方法"></a>区块的方法</h1><h2 id="3-1-getBlock"><a href="#3-1-getBlock" class="headerlink" title="3.1 getBlock"></a>3.1 <strong>getBlock</strong></h2><p><em>provider</em>.<strong>getBlock</strong>( <em>block</em> ) ⇒ <em>Promise&lt; **Block** &gt;</em></p><p>从网络中得到某个<strong>区块信息</strong>, <code>result.transactions</code> 是一串交易集合的哈希值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> provider.<span class="title function_">getBlock</span>(<span class="params"><span class="number">99</span></span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">_difficulty</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;3849295379889&quot;</span> &#125;,</span><br><span class="line">  <span class="attr">difficulty</span>: <span class="number">3849295379889</span>,</span><br><span class="line">  <span class="attr">extraData</span>: <span class="string">&#x27;0x476574682f76312e302e312d39383130306634372f6c696e75782f676f312e34&#x27;</span>,</span><br><span class="line">  <span class="attr">gasLimit</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;3141592&quot;</span> &#125;,</span><br><span class="line">  <span class="attr">gasUsed</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;21000&quot;</span> &#125;,</span><br><span class="line">  <span class="attr">hash</span>: <span class="string">&#x27;0xf93283571ae16dcecbe1816adc126954a739350cd1523a1559eabeae155fbb63&#x27;</span>,</span><br><span class="line">  <span class="attr">miner</span>: <span class="string">&#x27;0x909755D480A27911cB7EeeB5edB918fae50883c0&#x27;</span>,</span><br><span class="line">  <span class="attr">nonce</span>: <span class="string">&#x27;0x1a455280001cc3f8&#x27;</span>,</span><br><span class="line">  <span class="attr">number</span>: <span class="number">100004</span>,</span><br><span class="line">  <span class="attr">parentHash</span>: <span class="string">&#x27;0x73d88d376f6b4d232d70dc950d9515fad3b5aa241937e362fdbfd74d1c901781&#x27;</span>,</span><br><span class="line">  <span class="attr">timestamp</span>: <span class="number">1439799168</span>,</span><br><span class="line">  <span class="attr">transactions</span>: [</span><br><span class="line">    <span class="string">&#x27;0x6f12399cc2cb42bed5b267899b08a847552e8c42a64f5eb128c1bcbd1974fb0c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0x7f12399cc2cb42bed5b267899b08a847552e8c42a64f5eb128c1bcbd1974fb0c&#x27;</span>,</span><br><span class="line">    ....</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-getBlockWithTransactions"><a href="#3-2-getBlockWithTransactions" class="headerlink" title="3.2 getBlockWithTransactions"></a>3.2 <strong>getBlockWithTransactions</strong></h2><p><em>provider</em>.<strong>getBlockWithTransactions</strong>( <em>block</em> ) ⇒ <em>Promise&lt; **BlockWithTransactions** &gt;</em></p><p>从网络中得到某个<strong>区块信息</strong>, <code>result.transactions</code> 是 一个<strong>TransactionResponse</strong> 对象的数组集合.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> provider.<span class="title function_">getBlock</span>(<span class="params"><span class="number">99</span></span>)</span><br><span class="line">&#123;</span><br><span class="line">  ...(参考上面)</span><br><span class="line">  <span class="attr">transactions</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">accessList</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">blockHash</span>: <span class="string">&#x27;0xf93283571ae16dcecbe1816adc126954a739350cd1523a1559eabeae155fbb63&#x27;</span>,</span><br><span class="line">        <span class="attr">blockNumber</span>: <span class="number">100004</span>,</span><br><span class="line">        <span class="attr">chainId</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">confirmations</span>: <span class="number">16283837</span>,</span><br><span class="line">        <span class="attr">creates</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">data</span>: <span class="string">&#x27;0x&#x27;</span>,</span><br><span class="line">        <span class="attr">from</span>: <span class="string">&#x27;0xcf00A85f3826941e7A25BFcF9Aac575d40410852&#x27;</span>,</span><br><span class="line">        <span class="attr">gasLimit</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;90000&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">gasPrice</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;54588778004&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">hash</span>: <span class="string">&#x27;0x6f12399cc2cb42bed5b267899b08a847552e8c42a64f5eb128c1bcbd1974fb0c&#x27;</span>,</span><br><span class="line">        <span class="attr">nonce</span>: <span class="number">25</span>,</span><br><span class="line">        <span class="attr">r</span>: <span class="string">&#x27;0xb23adc880d3735e4389698dddc953fb02f1fa9b57e84d3510a2a4b3597ac2486&#x27;</span>,</span><br><span class="line">        <span class="attr">s</span>: <span class="string">&#x27;0x4e856f95c4e2828933246fb4765a5bfd2ca5959840643bef0e80b4e3a243d064&#x27;</span>,</span><br><span class="line">        <span class="attr">to</span>: <span class="string">&#x27;0xD9666150A9dA92d9108198a4072970805a8B3428&#x27;</span>,</span><br><span class="line">        <span class="attr">transactionIndex</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">v</span>: <span class="number">27</span>,</span><br><span class="line">        <span class="attr">value</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;5000000000000000000&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">wait</span>: [<span class="title class_">Function</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    ....</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="以太坊域名服务-ENS-方法"><a href="#以太坊域名服务-ENS-方法" class="headerlink" title="以太坊域名服务 (ENS) 方法"></a><strong>以太坊域名服务 (ENS) 方法</strong></h1><p><strong>以太坊域名服务 (ENS)</strong> 允许一个简短且易于记忆的ENS名称附加到任何一组键和值.</p><p>最常见的用法之一是使用一个简单的命名来<strong>引用以太坊地址</strong>.</p><h2 id="4-1-lookupAddress"><a href="#4-1-lookupAddress" class="headerlink" title="4.1 lookupAddress"></a>4.1 <strong>lookupAddress</strong></h2><p><em>provider</em>.<strong>lookupAddress</strong>( <em>address</em> ) ⇒ <em>Promise&lt; **string** &gt;</em></p><p>使用<em>反向注册器</em>对<strong>ENS中的地址进行反向查找</strong>.如果名称不存在,或者正向查找不匹配,则返回<code>null</code>.</p><p>ENS名称需要额外的配置来设置反向记录,它们不会自动设置.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">await</span> provider.<span class="title function_">lookupAddress</span>(<span class="string">&quot;0x5555763613a12D8F3e73be831DFf8598089d3dCa&quot;</span>);</span><br><span class="line">&gt; <span class="string">&#x27;ricmoo.eth&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="4-2-resolveName"><a href="#4-2-resolveName" class="headerlink" title="4.2 resolveName"></a>4.2 <strong>resolveName</strong></h2><p><em>provider</em>.<strong>resolveName</strong>( <em>name</em> ) ⇒ <em>Promise&lt; string&lt; **Address** &gt; &gt;</em></p><p><strong>查找一个名称的地址</strong>,如果这个<em>名称</em>没有被拥有,或者没有配置一个解析器,或者解析器没有配置一个地址,则返回<code>null</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">await</span> provider.<span class="title function_">resolveName</span>(<span class="string">&quot;ricmoo.eth&quot;</span>);</span><br><span class="line">&gt; <span class="string">&#x27;0x5555763613a12D8F3e73be831DFf8598089d3dCa&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="4-3-getResolver"><a href="#4-3-getResolver" class="headerlink" title="4.3 getResolver"></a>4.3 <strong>getResolver</strong></h2><p><em>provider</em>.<strong>getResolver</strong>( <em>name</em> ) ⇒ <em>Promise&lt; **EnsResolver** &gt;</em></p><p><strong>返回一个EnsResolver实例,该实例可用于进一步查询ENS命名的特定实体.</strong></p><h2 id="4-4-EnsResolver"><a href="#4-4-EnsResolver" class="headerlink" title="4.4 EnsResolver"></a>4.4 EnsResolver</h2><p><strong>Resolver 的名称</strong>:<em>resolver</em>.<strong>name</strong> ⇒ <em>string</em></p><p><strong>Resolver 的地址</strong>:<em>resolver</em>.<strong>address</strong> ⇒ <em>string&lt; 地址(**Address**) &gt;</em></p><h3 id="4-4-1-getAddress"><a href="#4-4-1-getAddress" class="headerlink" title="4.4.1 getAddress"></a>4.4.1 <strong>getAddress</strong></h3><p><em>resolver</em>.<strong>getAddress</strong>( [ <em>cointType</em> &#x3D; <em>60</em> ] ) ⇒ <em>Promise&lt; **string** &gt;</em></p><p>返回一个解析的类型为EIP-2304 <em>多币地址</em>的 Promise,默认情况下,<strong>返回一个以太坊的地址(Address)</strong>(<code>coinType = 60</code>).</p><h3 id="4-4-2-getContentHash"><a href="#4-4-2-getContentHash" class="headerlink" title="4.4.2 getContentHash"></a>4.4.2 <strong>getContentHash</strong></h3><p><em>resolver</em>.<strong>getContentHash</strong>( ) ⇒ <em>Promise&lt; **string** &gt;</em></p><p>返回一个Promise,解析为任何<strong>存储的EIP-1577内容哈希</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">await</span> resolver.<span class="title function_">getContentHash</span>();</span><br><span class="line">&gt; <span class="string">&#x27;ipfs://QmdTPkMMBWQvL8t7yXogo7jq5pAcWg8J7RkLrDsWZHT82y&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-4-3-getText"><a href="#4-4-3-getText" class="headerlink" title="4.4.3 getText"></a>4.4.3 <strong>getText</strong></h3><p><em>resolver</em>.<strong>getText</strong>( <em>key</em> ) ⇒ <em>Promise&lt; **string** &gt;</em></p><p>返回一个Promise,解析为任何<strong>存储的EIP-634作为key的文本实体</strong>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">await</span> resolver.<span class="title function_">getText</span>(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">&gt; <span class="string">&#x27;me@ricmoo.com&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">await</span> resolver.<span class="title function_">getText</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">&gt; <span class="string">&#x27;https://www.ricmoo.com/&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">await</span> resolver.<span class="title function_">getText</span>(<span class="string">&quot;com.twitter&quot;</span>);</span><br><span class="line">&gt; <span class="string">&#x27;@ricmoo&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="Logs方法"><a href="#Logs方法" class="headerlink" title="Logs方法"></a>Logs方法</h1><p><em>provider</em>.<strong>getLogs</strong>( <em>filter</em> ) ⇒ <em>Promise</em><em>&lt; Array&lt; Log &gt;</em>* &gt;*</p><p>返回<strong>匹配筛选器的 Log数组</strong>.</p><blockquote><p>许多后端会丢弃旧的事件,并且请求范围太广可能也会被丢弃,因为它们需要太多的资源来执行查询.</p></blockquote><h1 id="网络状态方法"><a href="#网络状态方法" class="headerlink" title="网络状态方法"></a><strong>网络状态方法</strong></h1><h2 id="6-1-getNetwork"><a href="#6-1-getNetwork" class="headerlink" title="6.1 getNetwork"></a>6.1 getNetwork</h2><p><em>provider</em>.<strong>getNetwork</strong>( ) ⇒ <em>Promise&lt; **Network** &gt;</em></p><p>返回这个 Provider 所<strong>连接的 Network</strong>.</p><h2 id="6-2-getBlockNumber"><a href="#6-2-getBlockNumber" class="headerlink" title="6.2 getBlockNumber"></a>6.2 getBlockNumber</h2><p><em>provider</em>.<strong>getBlockNumber</strong>( ) ⇒ <em>Promise&lt; **number** &gt;</em></p><p>返回<strong>最近挖出的区块的序号(或高度</strong>).</p><h2 id="6-3-getGasPrice"><a href="#6-3-getGasPrice" class="headerlink" title="6.3 getGasPrice"></a>6.3 getGasPrice</h2><p><em>provider</em>.<strong>getGasPrice</strong>( ) ⇒ <em>Promise&lt; 大数(**BigNumber**) &gt;</em></p><p>返回一个 关于这个交易中的 <strong>gas price的<em>最准预测</em></strong>.</p><h2 id="6-4-getFeeData"><a href="#6-4-getFeeData" class="headerlink" title="6.4 getFeeData"></a>6.4 getFeeData</h2><p><em>provider</em>.<strong>getFeeData</strong>( ) ⇒ <em>Promise&lt; **FeeDatba** &gt;</em></p><p>返回在一笔交易中当前的<strong>建议 FeeData</strong>.</p><p>对于 EIP-1559 的交易, 应该使用 <code>maxFeePerGas</code> 和 <code>maxPriorityFeePerGas</code>.</p><p>对于不支持 EIP-1559 中被遗留的交易和网络,应该使用 <code>gasPrice</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 燃料价格 (单位: wei)...</span></span><br><span class="line">feeData = <span class="keyword">await</span> provider.<span class="title function_">getFeeData</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">gasPrice</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;16674318809&quot;</span> &#125;,</span><br><span class="line">   <span class="attr">lastBaseFeePerGas</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;16492712329&quot;</span> &#125;,</span><br><span class="line">   <span class="attr">maxFeePerGas</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;34485424658&quot;</span> &#125;,</span><br><span class="line">   <span class="attr">maxPriorityFeePerGas</span>: &#123; <span class="title class_">BigNumber</span>: <span class="string">&quot;1500000000&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通常来说燃料的价格用 gwei 会更好理解</span></span><br><span class="line">utils.<span class="title function_">formatUnits</span>(feeData.<span class="property">maxFeePerGas</span>, <span class="string">&quot;gwei&quot;</span>)</span><br><span class="line"><span class="string">&#x27;34.485424658&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="6-5-ready"><a href="#6-5-ready" class="headerlink" title="6.5 ready"></a>6.5 ready</h2><p><em>provider</em>.<strong>ready</strong> ⇒ <em>Promise&lt; **Network** &gt;</em></p><p>返回一个 Promise ,直到网络建立就失效,忽略由于目标节点还未激活而出现的错误. </p><p>这可以用于测试或附上脚本,以等待节点启动并顺利运行.</p><h1 id="交易方法"><a href="#交易方法" class="headerlink" title="交易方法"></a>交易方法</h1><h2 id="7-1-call"><a href="#7-1-call" class="headerlink" title="7.1 call"></a>7.1 call</h2><p><em>provider</em>.<strong>call</strong>( <em>transaction</em> [ , <em>blockTag</em> &#x3D; <em>latest</em> ] ) ⇒ <em>Promise&lt; string&lt; **DataHexString** &gt; &gt;</em></p><p>使用<em>call</em>返回<strong>执行交易的结果</strong>,调用不需要任何的以太,但不能改变任何状态.这在合约上调用getter方法是非常有用的.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">await</span> provider.<span class="title function_">call</span>(&#123;</span><br><span class="line">  <span class="comment">// ENS public resovler address</span></span><br><span class="line">  <span class="attr">to</span>: <span class="string">&quot;0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `function addr(namehash(&quot;ricmoo.eth&quot;)) view returns (address)`</span></span><br><span class="line">  <span class="attr">data</span>: <span class="string">&quot;0x3b3b57debf074faa138b72c65adbdcfb329847e4f2c04bde7f7dd7fcad5a52d2f395a558&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line">&gt; <span class="string">&#x27;0x0000000000000000000000005555763613a12d8f3e73be831dff8598089d3dca&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="7-2-estimateGas"><a href="#7-2-estimateGas" class="headerlink" title="7.2 estimateGas"></a>7.2 estimateGas</h2><p><em>provider</em>.<strong>estimateGas</strong>( <em>transaction</em> ) ⇒ <em>Promise&lt; 大数(**BigNumber**) &gt;</em></p><p>返回向网络提交<strong>交易所需的预估gas值</strong>.</p><blockquote><p>估计的gas值可能不准确,因为网络上可能有另一个交易没有被计算在内,但在被挖出来之后就会影响相关状态.</p></blockquote><h2 id="7-3-getTransaction"><a href="#7-3-getTransaction" class="headerlink" title="7.3 getTransaction"></a>7.3 getTransaction</h2><p><em>provider</em>.<strong>getTransaction</strong>( <em>hash</em> ) ⇒ <em>Promise&lt; **TransactionResponse** &gt;</em></p><p>返回<strong>带有哈希值的交易</strong>,如果交易未知,则返回null.</p><p>如果一个交易还没有被挖出,这个方法将搜索交易池.各种后端可能有更多的限制交易池访问(例如,燃料价格太低或交易最近才发送,还没有索引),在这种情况下,这个方法也可能返回null.</p><h2 id="7-4-getTransactionReceipt"><a href="#7-4-getTransactionReceipt" class="headerlink" title="7.4 getTransactionReceipt"></a>7.4 getTransactionReceipt</h2><p><em>provider</em>.<strong>getTransactionReceipt</strong>( <em>hash</em> ) ⇒ <em>Promise&lt; **TransactionReceipt** &gt;</em></p><p>返回<strong>交易收据的哈希值</strong>,如果交易还没有被挖出则返回null.</p><p>如果需要等待交易被挖出,请考虑下面的<code>waitForTransaction</code>方法.</p><h2 id="7-5-sendTransaction"><a href="#7-5-sendTransaction" class="headerlink" title="7.5 sendTransaction"></a>7.5 sendTransaction</h2><p><em>provider</em>.<strong>sendTransaction</strong>( <em>transaction</em> ) ⇒ <em>Promise&lt; **TransactionResponse** &gt;</em></p><p>向在挖区块的网络提交交易,<strong>交易必须经过签名</strong>,并且需要合法(例如:nonce值需要正确并且账户要有足够的余额来进行该笔交易的支付）</p><h2 id="7-6-waitForTransaction"><a href="#7-6-waitForTransaction" class="headerlink" title="7.6 waitForTransaction"></a>7.6 waitForTransaction</h2><p><em>provider</em>.<strong>waitForTransaction</strong>( <em>hash</em> [ , <em>confirms</em> &#x3D; <em>1</em> [ , <em>timeout</em> ] ] ) ⇒ <em>Promise&lt; **TxReceipt** &gt;</em></p><p>返回一个Promise,直到transactionHash被挖出来,才能够被解析.</p><p>如果<em>confirms</em>参数为0,这个方法是非阻塞的,如果交易还没有被挖出,则返回null. </p><p>否则,该方法是阻塞的,直到这个包含该交易的、被<em>confirms</em>标识的区块被挖出.</p><h1 id="事件方法"><a href="#事件方法" class="headerlink" title="事件方法"></a>事件方法</h1><h2 id="eventName参数"><a href="#eventName参数" class="headerlink" title="eventName参数"></a>eventName参数</h2><p><strong>Log Filter</strong>:一个过滤器是一个对象.表示合约log Filter它具有可选的<code>address</code> (合约地址) 和 <code>topics</code> (一个要匹配的主题集).</p><p>如果参数<code>address</code>未被指定.则过滤器匹配任何合约地址.</p><p><strong>Topic-Set Filter</strong>:<strong>主题集过滤器</strong>的值是一个主题集数组.</p><p>此事件与日志过滤器相同.但参数<code>address</code>可以不用填(匹配任何合约).</p><p><strong>Transaction Filter</strong>:<strong>交易过滤器</strong>的值是交易的哈希值.</p><p>这个事件会在任何给定的交易挖出的链上区块中触发. 使用once方法比使用on方法要普遍地多.</p><p><strong>除了交易和过滤事件外.还有几个命名事件:</strong></p><table><thead><tr><th><strong>EventName</strong></th><th><strong>Arguments</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>&quot;block&quot;</code></td><td><em>blockNumber</em></td><td>当一个区块被挖出时触发</td></tr><tr><td><code>&quot;error&quot;</code></td><td><em>error</em></td><td>只要有错误就触发</td></tr><tr><td><code>&quot;pending&quot;</code></td><td><em>pendingTransaction</em></td><td>当一个新交易进入内存池时触发;只有特定的providers提供此事件.从而在运行在自己的节点上获得可靠的数据</td></tr><tr><td><code>&quot;willPoll&quot;</code></td><td><em>pollId</em></td><td>在一个polling loop开始之前触发;<em>(大多数开发者很少使用)</em></td></tr><tr><td><code>&quot;poll&quot;</code></td><td><em>pollId</em>, <em>blockNumber</em></td><td>在每个poll cycle中.<code>blockNumber</code>更新之后(如果改变了).以及与在poll loop中任何其他的事件(如果有)之前触发; <em>(大多数开发者很少使用)</em></td></tr><tr><td><code>&quot;didPoll&quot;</code></td><td><em>pollId</em></td><td>在polling loop中的所有事件被触发后触发;(<em>大多数开发者很少使用</em>)</td></tr><tr><td><code>&quot;debug&quot;</code></td><td>provider dependent</td><td>每个Provider可以使用它来发出有用的调试信息.格式由开发者决定;<em>(大多数开发者很少使用)</em> <em>(very rarely used by most developers)</em></td></tr></tbody></table><h2 id="8-1-on"><a href="#8-1-on" class="headerlink" title="8.1 on"></a>8.1 on</h2><p><em>provider</em>.<strong>on</strong>( <em>eventName</em> , <em>listener</em> ) ⇒ <em><strong>this</strong></em></p><p>为<strong>每一个参数为<em>eventName</em>的 事件添加<em>监听器</em></strong>.</p><h2 id="8-2-once"><a href="#8-2-once" class="headerlink" title="8.2 once"></a>8.2 once</h2><p><em>provider</em>.<strong>once</strong>( <em>eventName</em> , <em>listener</em> ) ⇒ <em><strong>this</strong></em></p><p>为参数<strong>为<em>eventName</em>的 事件添加<em>监听器</em>,监听使用过后将会被移除</strong>.</p><h2 id="8-3-emit"><a href="#8-3-emit" class="headerlink" title="8.3 emit"></a>8.3 emit</h2><p><em>provider</em>.<strong>emit</strong>( <em>eventName</em> , …<em>args</em> ) ⇒ <em><strong>boolean</strong></em></p><p><strong>通知所有的<em>eventName</em> event监听器,并把参数传递给它们,这通常只在内部使用.</strong></p><h2 id="8-4-off"><a href="#8-4-off" class="headerlink" title="8.4 off"></a>8.4 off</h2><p><em>provider</em>.<strong>off</strong>( <em>eventName</em> [ , <em>listener</em> ] ) ⇒ <em><strong>this</strong></em></p><p><strong>移除一个参数为<em>eventName</em>的事件<em>监听器</em></strong>,如果没有提供<em>listener</em>参数,则移除所有关于<em>eventName</em>的监听器.</p><h2 id="8-5-removeAllListeners"><a href="#8-5-removeAllListeners" class="headerlink" title="8.5 removeAllListeners"></a><strong>8.5</strong> removeAllListeners</h2><p><em>provider</em>.<strong>removeAllListeners</strong>( [ <em>eventName</em> ] ) ⇒ <em><strong>this</strong></em></p><p><strong>移除所有参数为<em>eventName</em>的事件监听器</strong>,如果没有提供<em>eventName</em>参数,则移除<strong>所有</strong>事件.</p><h2 id="8-6-listenerCount"><a href="#8-6-listenerCount" class="headerlink" title="8.6 listenerCount"></a>8.6 listenerCount</h2><p><em>provider</em>.<strong>listenerCount</strong>( [ <em>eventName</em> ] ) ⇒ <em><strong>number</strong></em></p><p><strong>返回所有参数为<em>eventName</em>事件的监听器数量</strong>,如果没有提供<em>eventName</em>参数,返回所有监听器的数量.</p><h2 id="8-7-listeners"><a href="#8-7-listeners" class="headerlink" title="8.7 listeners"></a>8.7 listeners</h2><p><em>provider</em>.<strong>listeners</strong>( <em>eventName</em> ) ⇒ <em>Array&lt; **Listener** &gt;</em></p><p><strong>返回参数为<em>eventName</em>事件监听器的list集合.</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">provider.<span class="title function_">on</span>(<span class="string">&quot;block&quot;</span>, <span class="function">(<span class="params">blockNumber</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有有一个区块改变就会触发</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">provider.<span class="title function_">once</span>(txHash, <span class="function">(<span class="params">transaction</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当含有交易的区块被挖出就会触发</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个过滤器也可以通过Contract或接口API生成。</span></span><br><span class="line"><span class="comment">// 如果不指定address，则默认匹配任何地址，</span></span><br><span class="line"><span class="comment">// 如果不指定topics，则默认匹配任何日志。</span></span><br><span class="line">filter = &#123;</span><br><span class="line">    <span class="attr">address</span>: <span class="string">&quot;dai.tokens.ethers.eth&quot;</span>,</span><br><span class="line">    <span class="attr">topics</span>: [</span><br><span class="line">        utils.<span class="title function_">id</span>(<span class="string">&quot;Transfer(address,address,uint256)&quot;</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">provider.<span class="title function_">on</span>(filter, <span class="function">(<span class="params">log, event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当 DAI token 发生转账时触发</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，这是一个主题集数组，与使用没有address参数的过滤器相同(即匹配任何地址)</span></span><br><span class="line">topicSets = [</span><br><span class="line">    utils.<span class="title function_">id</span>(<span class="string">&quot;Transfer(address,address,uint256)&quot;</span>),</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    [</span><br><span class="line">        <span class="title function_">hexZeroPad</span>(myAddress, <span class="number">32</span>),</span><br><span class="line">        <span class="title function_">hexZeroPad</span>(myOtherAddress, <span class="number">32</span>)</span><br><span class="line">    ]</span><br><span class="line">]</span><br><span class="line">provider.<span class="title function_">on</span>(topicSets, <span class="function">(<span class="params">log, event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当任何一个token 发送到我的或者我的其他的地址时触发</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">provider.<span class="title function_">on</span>(<span class="string">&quot;pending&quot;</span>, <span class="function">(<span class="params">tx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当有一笔pending交易被捕获时触发</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">provider.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="function">(<span class="params">tx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只要有错误就会触发</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="校验方法"><a href="#校验方法" class="headerlink" title="校验方法"></a>校验方法</h1><p><em>Provider</em>.<strong>isProvider</strong>( <em>object</em> ) ⇒ <em><strong>boolean</strong></em></p><p>当且仅<strong>当参数<em>object</em>是Provider返回 true .</strong></p>]]></content>
      
      
      <categories>
          
          <category> ether@5.4.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> ether@5.4.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-开始</title>
      <link href="/2022/08/02/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/1-%E5%BC%80%E5%A7%8B/"/>
      <url>/2022/08/02/%E5%8C%BA%E5%9D%97%E9%93%BE/ether@5.4/1-%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save ethers</span><br></pre></td></tr></table></figure><h1 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node.js </span></span><br><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">&quot;ethers&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6 或 TypeScript</span></span><br><span class="line"><span class="keyword">import</span> &#123; ethers &#125; <span class="keyword">from</span> <span class="string">&quot;ethers&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="Web-浏览器"><a href="#Web-浏览器" class="headerlink" title="Web 浏览器"></a>Web 浏览器</h3><p>出于安全，通常较好的方式是将这个库复制到你的web服务器中来进行各种操作。</p><p>但若想快速构建实例展示，可以将我们的CDN加载到你的web应用程序中。</p><p>在浏览器中通过ES6的方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在浏览器中通过ES6的方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; ethers &#125; <span class="keyword">from</span> <span class="string">&quot;https://cdn.ethers.io/lib/ethers-5.2.esm.min.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// Your code here...</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在浏览器中通过ES3 (UMD)的方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.ethers.io/lib/ethers-5.2.umd.min.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接 MetaMask</span></span><br><span class="line"><span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.<span class="property">providers</span>.<span class="title class_">Web3Provider</span>(<span class="variable language_">window</span>.<span class="property">ethereum</span>)</span><br><span class="line"><span class="keyword">const</span> singer = provider.<span class="title function_">getSigner</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接一个 RPC 客户端</span></span><br><span class="line"><span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.<span class="property">providers</span>.<span class="title class_">JsonRpcProvider</span>();</span><br><span class="line"><span class="keyword">const</span> singer = provider.<span class="title function_">getSigner</span>()</span><br></pre></td></tr></table></figure><h1 id="Provider-API-Keys"><a href="#Provider-API-Keys" class="headerlink" title="Provider API Keys"></a>Provider API Keys</h1><p><strong>获得自己的API密钥，以提高您的应用程序性能</strong>：</p><p>当使用由API服务商(例如Alchemy,Etherscan 或 INFURA)支持的<strong>Provider</strong>时, 他们都需要一个API密钥，从而能够跟踪每个项目及其使用和权限。</p><p>ethers.js 库 为上述的API服务商提供了默认的API密钥，因此每个<strong>Provider</strong>都可以轻松地连接-开箱即用。</p><p>这些API密钥是由后端服务作为社区资源提供的，用于低流量项目和早期原型开发。因为这些API键是由所有用户共享的(没有获得自己的API密钥)，所以它们被经常被使用，这意味着重新请求发生得更频繁，响应也更慢。</p><p><strong>强烈建议</strong>你从下列的API服务商注册一个免费的API密钥，这有很多好处（可能有些差别，这取决于具体的API服务商）:</p><ul><li>更<strong>高</strong>的请求速率和并发请求限制</li><li>更<strong>快</strong>的响应，更少的重连和超时</li><li>在用于性能调优和分析客户行为具有更<strong>优秀</strong>的指标追踪</li><li>更<strong>高级</strong>的api，例如归档数据或高级日志查询</li></ul><blockquote><p>ethers提供的默认的API Keys是所有用户之间共享的，在大量服务加载的时候可能默认的API key服务会有所被限制，需要提前意识到这一点。</p><p>许多服务还具有监视和使用指标，这些指标只有在指定了API Key时才可用。这允许跟踪有多少请求正在被发送，以及哪些方法被使用得最多。</p><p>有些服务还提供额外的付费功能，这些功能只有在指定API Key时才可用。</p></blockquote><h2 id="Etherscan-以太坊区块浏览器-免费注册一个-API-key"><a href="#Etherscan-以太坊区块浏览器-免费注册一个-API-key" class="headerlink" title="Etherscan(以太坊区块浏览器)免费注册一个 API key"></a>Etherscan(以太坊区块浏览器)<a href="https://etherscan.io/apis">免费注册一个 API key</a></h2><p>Etherscan 是以太坊区块资源管理器，它可能是最有用的构建和调试以太坊应用程序的开发工具。</p><p>Etherscan提供了大量的 API endpoints 集合， 包含了所有能够用来与以太坊区块链交互的操作。</p><p>**优点:**更高的速率限制 (因为没有共享速率限制)、客户使用指标</p><h2 id="INFURA在-INFURA-免费注册一个-Project-ID"><a href="#INFURA在-INFURA-免费注册一个-Project-ID" class="headerlink" title="INFURA在 INFURA 免费注册一个 Project ID"></a>INFURA<a href="https://infura.io/register">在 INFURA 免费注册一个 Project ID</a></h2><p>INFURA服务已经存在相当一段时间了，鲁棒性强、可靠性高，强烈推荐。</p><p>它们提供了一个标准的JSON-RPC接口和一个WebSocket接口，这使得与标准工具的交互更加通用、简单和直接。</p><p>**优点:**更高的速率限制、客户使用指标、访问归档数据 (需要付费升级)</p><h2 id="Alchemy在-Alchemy-免费注册一个-API-key"><a href="#Alchemy在-Alchemy-免费注册一个-API-key" class="headerlink" title="Alchemy在 Alchemy 免费注册一个 API key"></a>Alchemy<a href="https://dashboard.alchemyapi.io/signup?referral=55a35117-028e-4b7c-9e47-e275ad0acc6d">在 Alchemy 免费注册一个 API key</a></h2><p>Alchemy服务已经有几年的历史了，它也具备强鲁棒性和高可靠性。</p><p>它们提供了一个标准的JSON-RPC接口和一个WebSocket接口，以及一组用于与通证（tokens）交互和帮助调试的高级API。</p><p>**优点:**更高的速率限制、客户使用指标、能够访问高级通证余额和元数据API、能够进行高级调试跟踪和恢复reason APIs</p><h2 id="Pocket-Gateway在-Pocket-免费注册一个-API-key"><a href="#Pocket-Gateway在-Pocket-免费注册一个-API-key" class="headerlink" title="Pocket Gateway在 Pocket 免费注册一个 API key"></a>Pocket Gateway<a href="https://pokt.network/pocket-gateway-ethereum-mainnet/">在 Pocket 免费注册一个 API key</a></h2><p>**优点:**客户使用指标、使用去中心化区块链基础设施、入股而不是按月付费、受加密经济激励的高度冗余的全局节点集合</p><h2 id="创建默认的-Provider"><a href="#创建默认的-Provider" class="headerlink" title="创建默认的 Provider"></a><strong>创建默认的 Provider</strong></h2><p>默认的提供者连接到多个后端，并在内部验证它们的结果，这使得对第三方服务的高度信任变得很简单。</p><p>第二个可选参数允许为每个内部创建的Provider指定API keys，任何被遗漏的API keys将返回使用该服务的默认API keys。</p><p><strong>极度推荐</strong> 您为每个服务提供一个API，让您的应用程序性能实现最大化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用主网</span></span><br><span class="line"><span class="keyword">const</span> network = <span class="string">&quot;homestead&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定你的API keys</span></span><br><span class="line"><span class="comment">// 每个都是可选的，如果省略它，则为默认值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> provider = ethers.<span class="title function_">getDefaultProvider</span>(network, &#123;</span><br><span class="line">    <span class="attr">etherscan</span>: <span class="variable constant_">YOUR_ETHERSCAN_API_KEY</span>,</span><br><span class="line">    <span class="attr">infura</span>: <span class="variable constant_">YOUR_INFURA_PROJECT_ID</span>,</span><br><span class="line">    <span class="comment">// 或者使用项目私钥:</span></span><br><span class="line">    <span class="comment">// infura: &#123;</span></span><br><span class="line">    <span class="comment">//   projectId: YOUR_INFURA_PROJECT_ID,</span></span><br><span class="line">    <span class="comment">//   projectSecret: YOUR_INFURA_PROJECT_SECRET,</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="attr">alchemy</span>: <span class="variable constant_">YOUR_ALCHEMY_API_KEY</span>,</span><br><span class="line">    <span class="attr">pocket</span>: <span class="variable constant_">YOUR_POCKET_APPLICATION_KEY</span></span><br><span class="line">    <span class="comment">// 或者使用应用私钥:</span></span><br><span class="line">    <span class="comment">// pocket: &#123;</span></span><br><span class="line">    <span class="comment">//   applicationId: ,</span></span><br><span class="line">    <span class="comment">//   applicationSecretKey:</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ether@5.4.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> ether@5.4.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity总结</title>
      <link href="/2022/07/28/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/solidity%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/28/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/solidity%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><h3 id="1-receive-和-fallback-共存的调用"><a href="#1-receive-和-fallback-共存的调用" class="headerlink" title="1.receive 和 fallback 共存的调用"></a>1.receive 和 fallback 共存的调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    调用时发送了ETH</span><br><span class="line">            |</span><br><span class="line">判断 msg.data 是否为空</span><br><span class="line">          /     \</span><br><span class="line">        是       否</span><br><span class="line">是否存在 receive   fallbak()</span><br><span class="line">      /   \</span><br><span class="line">    存在   不存在</span><br><span class="line">    /        \</span><br><span class="line">receive()   fallbak()</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><hr><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h3 id="2-即便一个合约的代码中没有显式地调用-selfdestruct，它仍然有可能通过-delegatecall-或-callcode-执行自毁操作。"><a href="#2-即便一个合约的代码中没有显式地调用-selfdestruct，它仍然有可能通过-delegatecall-或-callcode-执行自毁操作。" class="headerlink" title="2.即便一个合约的代码中没有显式地调用 selfdestruct，它仍然有可能通过 delegatecall 或 callcode 执行自毁操作。"></a>2.即便一个合约的代码中没有显式地调用 <code>selfdestruct</code>，它仍然有可能通过 <code>delegatecall</code> 或 <code>callcode</code> 执行自毁操作。</h3><hr><h3 id="3-合约进行selfdestruct后，还可以调用状态变量和函数么？"><a href="#3-合约进行selfdestruct后，还可以调用状态变量和函数么？" class="headerlink" title="3.合约进行selfdestruct后，还可以调用状态变量和函数么？"></a>3.合约进行<code>selfdestruct</code>后，还可以调用状态变量和函数么？</h3><blockquote><p>可以调用，但是返回默认值。如果想调用，也可以在存档节点里指定未删除的高度进行调用。</p></blockquote><hr><h3 id="4-三种-call-的总结-call-delegatecall-staticcall"><a href="#4-三种-call-的总结-call-delegatecall-staticcall" class="headerlink" title="4.三种 call 的总结(call&#x2F;delegatecall&#x2F;staticcall)"></a>4.三种 call 的总结(call&#x2F;delegatecall&#x2F;staticcall)</h3><p>为了与不知道 ABI 的合约进行交互，Solidity 提供了函数 <code>call</code>&#x2F;<code>delegatecall</code>&#x2F;<code>staticcall</code> 直接控制编码。它们都带有一个 <code>bytes memory</code> 参数和返回执行<strong>成功状态</strong>（bool）和<strong>数据</strong>（bytes memory）。</p><p>函数 <code>abi.encode</code>，<code>abi.encodePacked</code>，<code>abi.encodeWithSelector</code> 和 <code>abi.encodeWithSignature</code> 可用于编码结构化数据。</p><p><strong>它们可以接受任意类型，任意数量的参数</strong>。这些参数会被打包到以 32 字节为单位的连续区域中存放。其中一个<strong>例外是当第一个参数被编码成正好 4 个字节的情况</strong>。 在这种情况下，这个参数后边不会填充后续参数编码，以允许使用函数签名。</p><p>下面具体的介绍三种 call。</p><h4 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h4><p>用给定的有效载荷（payload）发出低级 <code>CALL</code> 调用，并<strong>返回交易成功状态和返回数据</strong>（调用合约的方法并转账）, 格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.call(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure><ol><li><p>低级CALL调用：不需要 payable address, 普通地址即可</p><ol><li>注意: 调用 <code>call</code> 的时候，地址可以不具备 payable 属性</li></ol></li><li><p>返回两个参数，一个 <code>bool</code> 值代表成功或者失败，另外一个是可能存在的 <code>data</code></p></li><li><p>发送所有可用 gas，也可以自己调节 gas。</p><ol><li>如果 <code>fallback</code> 和 <code>receive</code> 内的代码相对复杂也可以，但是如果是恶意代码，需要考虑消耗的 gas 是否值得执行。</li><li><code>_ads.call&#123;value: msg.value,gas:2300&#125;(data)</code></li></ol></li><li><p>当合约调用合约时，不知道对方源码和 ABI 时候，可以使用 call 调用对方合约</p></li><li><p>推荐使用 call 转账 ETH，但是不推荐使用 call 来调用其他合约。</p><ol><li>原因是: call 调用的时候，将合约控制权交给对方，如果碰到恶意代码，或者不安全的代码就很容易凉凉。</li></ol></li><li><p>当调用不存在的合约方法时候，会触发对方合约内的fallback或receive</p><ol><li>我们的合约也可以在 <code>fallback</code> &#x2F; <code>receive</code> 这两个方法内抛出事件，查看是否有人对其做了什么操作。</li></ol></li><li><p>三种方法都提供 <code>gas</code> 选项，而 <code>value</code> 选项仅 <code>call</code> 支持 。三种 call 里只有 <code>call</code> 可以进行 ETH 转账，其他两种不可以进行转账。</p></li></ol><p><strong>例子 （重要）：调用其他合约方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test1 &#123;</span><br><span class="line">    string public name;</span><br><span class="line">    uint256 public age;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function setNameAndAge(string memory name_, uint256 age_)</span><br><span class="line">        external</span><br><span class="line">        payable</span><br><span class="line">        returns (string memory __name, uint256 __age)</span><br><span class="line">    &#123;</span><br><span class="line">        name = name_;</span><br><span class="line">        age = age_;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        return (name_, age_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CallTest &#123;</span><br><span class="line">    // 需要一个网页，动态的解析 _bys</span><br><span class="line">    bytes public bys;</span><br><span class="line"></span><br><span class="line">    function call_Test1_setNameAndAge(</span><br><span class="line">        address ads_,</span><br><span class="line">        string memory name_,</span><br><span class="line">        uint256 age_</span><br><span class="line">    ) external payable &#123;</span><br><span class="line">        bytes memory data = abi.encodeWithSignature(</span><br><span class="line">            &quot;setNameAndAge(string,uint256)&quot;,</span><br><span class="line">            name_,</span><br><span class="line">            age_</span><br><span class="line">        );</span><br><span class="line">        (bool success, bytes memory _bys) = ads_.call&#123;value: msg.value&#125;(data);</span><br><span class="line">        require(success, &quot;Call Failed&quot;);</span><br><span class="line">        bys = _bys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说下这个例子的原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    普通调用:用户A 调用 callB 合约, 发送 100 wei ; </span><br><span class="line">    callB 调用 Test1, 发送 50 wei此时在 Test1 合约内部</span><br><span class="line">        msg.sender = B</span><br><span class="line">        msg.value = 50</span><br><span class="line">        Test1 内部如果有状态变量修改，则会被修改</span><br><span class="line">        发送到 Test1 内的ETH主币也会被留在Test1内</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h4 id="delegatecall-委托调用"><a href="#delegatecall-委托调用" class="headerlink" title="delegatecall() 委托调用"></a>delegatecall() 委托调用</h4><p>发出低级函数 <code>DELEGATECALL</code>，失败时返回 false，发送所有可用 gas，也可以自己调节 gas。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.delegatecall(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure><p><code>delegatecall</code> 使用方法和 <code>call</code> 完全一样。区别在于，<code>delegatecall</code> 只调用给定地址的代码（函数），其他状态属性如（存储，余额 …）都来自当前合约。<code>delegatecall</code> 的目的是使用另一个合约中的库代码。</p><p>委托调用是：<strong>委托对方调用自己数据的</strong>。类似授权转账，比如我部署一个 Bank 合约， 授权 ContractA 使用 Bank 地址内的资金，ContractA 只拥有控制权，但是没有拥有权。</p><ul><li>委托调用后，所有变量修改都是发生在委托合约内部，并不会保存在被委托合约中。<ul><li>利用这个特性，可以通过更换被委托合约，来升级委托合约。</li></ul></li><li>委托调用合约内部，需要和被委托合约的内部参数完全一样，否则容易导致数据混乱<ul><li>可以通过顺序来避免这个问题，但是推荐完全一样</li></ul></li></ul><p><strong>例子 1（重要）</strong></p><p>代码如下:</p><ul><li><code>DelegateCall</code> 是委托合约</li><li><code>TestVersion1</code> 是第 1 次被委托合约</li><li><code>TestVersion2</code> 是第 2 次被委托合约</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 合约版本 V.1</span><br><span class="line">contract TestVersion1 &#123;</span><br><span class="line">    address public sender;</span><br><span class="line">    uint256 public value;</span><br><span class="line">    uint256 public num;</span><br><span class="line"></span><br><span class="line">    function set(uint256 num_) external payable &#123;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">        value = msg.value;</span><br><span class="line">        num = num_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 合约版本 V.2</span><br><span class="line">contract TestVersion2 &#123;</span><br><span class="line">    address public sender;</span><br><span class="line">    uint256 public value;</span><br><span class="line">    uint256 public num;</span><br><span class="line"></span><br><span class="line">    function set(uint256 num_) external payable &#123;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">        value = msg.value;</span><br><span class="line">        num = num_ * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 委托调用测试</span><br><span class="line">contract DelegateCall &#123;</span><br><span class="line">    address public sender;</span><br><span class="line">    uint256 public value;</span><br><span class="line">    uint256 public num;</span><br><span class="line"></span><br><span class="line">    function set(address _ads, uint256 num_) external payable &#123;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">        value = msg.value;</span><br><span class="line">        num = num_;</span><br><span class="line">        // 第1种 encode</span><br><span class="line">        // 不需知道合约名字，函数完全自定义</span><br><span class="line">        bytes memory data1 = abi.encodeWithSignature(&quot;set(uint256)&quot;, num_);</span><br><span class="line">        // 第2种 encode</span><br><span class="line">        // 需要合约名字，可以避免函数和参数写错</span><br><span class="line">        bytes memory data2 = abi.encodeWithSelector(TestVersion1.set.selector, num_);</span><br><span class="line"></span><br><span class="line">        (bool success, bytes memory _data) = _ads.delegatecall(data2);</span><br><span class="line"></span><br><span class="line">        require(success, &quot;DelegateCall set failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说下这个例子的原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    委托调用</span><br><span class="line">    用户A 调用 DelegateCall 合约, 发送 100 wei ; DelegateCall 委托调用 Test1</span><br><span class="line">    此时在 Test1 合约内部</span><br><span class="line">        msg.sender = A</span><br><span class="line">        msg.value = 100</span><br><span class="line">        Test1 内部如果有状态变量修改，也不会被修改，会在DelegateCallB 内改变</span><br><span class="line">        发送到 Test1 内的ETH主币，会被留在 DelegateCallB 内，不会在Test1 内</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h4 id="staticcall-静态调用"><a href="#staticcall-静态调用" class="headerlink" title="staticcall() 静态调用"></a>staticcall() 静态调用</h4><p>用给定的有效载荷（payload）发出低级 <code>STATICCALL</code> 调用，并<strong>返回交易成功状态和返回数据</strong>（调用合约的方法并转账）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.staticcall(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure><p>它与 call 基本相同，发送所有可用 gas，也可以自己调节 gas，<strong>但如果被调用的函数以任何方式修改状态变量，都将回退</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 被调用的合约</span><br><span class="line">contract Hello1 &#123;</span><br><span class="line">    function echo() external pure returns (string memory) &#123;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hello2 &#123;</span><br><span class="line">    uint8 public a;</span><br><span class="line">    function echo() external returns (string memory) &#123;</span><br><span class="line">        a = 1;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用者合约</span><br><span class="line">contract SoldityTest &#123;</span><br><span class="line">    function callHello(address ads_) external view returns (string memory) &#123;</span><br><span class="line">        // 编码被调用者的方法签名</span><br><span class="line">        bytes4 methodId = bytes4(keccak256(&quot;echo()&quot;));</span><br><span class="line"></span><br><span class="line">        // 调用合约</span><br><span class="line">        (bool success, bytes memory data) = ads_.staticcall(</span><br><span class="line">            abi.encodeWithSelector(methodId)</span><br><span class="line">        );</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            return abi.decode(data, (string));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;error&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>call</code> ， <code>delegatecall</code> 和 <code>staticcall</code> 是非常低级的函数，应该把它们当作最后一招来使用，破坏了 Solidity 的类型安全性。</li><li>三种方法都提供 <code>gas</code> 选项，而 <code>value</code> 选项仅 <code>call</code> 支持 。三种 call 里只有 <code>call</code> 可以进行 ETH 转账，其他两种不可以进行转账</li><li>如果在通过低级函数 <code>delegatecall</code> 发起调用时需要访问存储中的变量，那么这两个合约的存储布局需要一致，以便被调用的合约代码可以正确地通过变量名访问合约的存储变量。 这不是指在库函数调用（高级的调用方式）时所传递的存储变量指针需要满足那样情况。</li></ol><hr><h3 id="5-调用合约时，不知道对方源码和-ABI-时候，可以使用-call-调用对方合约"><a href="#5-调用合约时，不知道对方源码和-ABI-时候，可以使用-call-调用对方合约" class="headerlink" title="5.调用合约时，不知道对方源码和 ABI 时候，可以使用 call 调用对方合约"></a>5.调用合约时，不知道对方源码和 ABI 时候，可以使用 call 调用对方合约</h3><hr><h3 id="6-transfer-send-call-三种转账的总结"><a href="#6-transfer-send-call-三种转账的总结" class="headerlink" title="6.transfer &#x2F; send &#x2F; call 三种转账的总结"></a>6.transfer &#x2F; send &#x2F; call 三种转账的总结</h3><p>低级CALL调用<strong>不需要<code>payable address</code></strong>,ransfer 和 send <strong>只能是 <code>payable address</code></strong></p><p>transfer()失败时抛出异常,send()失败时仅会返回false,不会终止执行（合约地址转账）</p><p>call的 gas 可以动态调整,transfer 和 send 只能是固定制 <code>2300</code></p><p>call除了可以转账外，可以还可以调用不知道 ABI 的方法，还可以调用的时候转账</p><ul><li>当调用不存在的合约方法时候，会触发对方合约内的 <code>fallback</code> 或者 <code>receive</code>。</li><li>如果使用 <code>_to.call&#123;value: 100&#125;(data)</code>，那么<code>data</code>中被调用的方法必须添加 <code>payable</code> 修饰符，否则转账失败！</li><li>因为可以调用方法，所以 call 有两个参数，除了一个 <code>bool</code> 值代表成功或者失败，另外一个是可能存在的 <code>data</code>，比如创建合约时候得到部署的地址，调用函数时候得到的函数放回值</li></ul><hr><h3 id="7-所有的引用类型，都有数据位置这个额外的注解来指定存储在哪里，所以一定要掌握好"><a href="#7-所有的引用类型，都有数据位置这个额外的注解来指定存储在哪里，所以一定要掌握好" class="headerlink" title="7.所有的引用类型，都有数据位置这个额外的注解来指定存储在哪里，所以一定要掌握好"></a>7.所有的引用类型，都有数据位置这个额外的注解来指定存储在哪里，所以一定要掌握好</h3><h3 id="7-比较字符串和字节"><a href="#7-比较字符串和字节" class="headerlink" title="7.比较字符串和字节"></a><strong>7.比较字符串和字节</strong></h3><ul><li><code>keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))</code></li><li><code>keccak256(bytes(s1)) == keccak256(bytes(s2))</code>:更省 gas</li></ul><hr><h3 id="8-堆栈是由-EVM-Ethereum-虚拟机-维护的非持久性数据。EVM-使用堆栈数据位置在执行期间加载变量。堆栈位置最多有-1024-个级别的限制。"><a href="#8-堆栈是由-EVM-Ethereum-虚拟机-维护的非持久性数据。EVM-使用堆栈数据位置在执行期间加载变量。堆栈位置最多有-1024-个级别的限制。" class="headerlink" title="8.堆栈是由 EVM (Ethereum 虚拟机)维护的非持久性数据。EVM 使用堆栈数据位置在执行期间加载变量。堆栈位置最多有 1024 个级别的限制。"></a>8.堆栈是由 EVM (Ethereum 虚拟机)维护的非持久性数据。EVM 使用堆栈数据位置在执行期间加载变量。堆栈位置最多有 1024 个级别的限制。</h3><hr><h3 id="9-数据位置总结"><a href="#9-数据位置总结" class="headerlink" title="9.数据位置总结"></a>9.数据位置总结</h3><ul><li>storage: 存储区: 状态变量总是储存在<strong>存储区</strong>上</li><li>memory: 内存区: 局部变量使用，只在内存中生效。<ul><li>值类型的局部变量，存储在<strong>内存</strong>中。</li><li><strong>引用类型局部变量，需要显式地指定数据位置</strong>。</li><li>函数的输入参数如果是数组或者 string，必须是 <code>memory</code> 或 <code>calldata</code></li><li>内存中的数组必须是定长数组（不能使用 push 赋值），动态数组只能储存在状态变量中。</li></ul></li><li>calldata<ul><li>和 memory 类似，但是 calldata 只能用在函数的输入参数中。</li><li>相比使用 memory ,合约输入参数如果使用 calldata, 可以节约 gas</li></ul></li></ul><p>按照函数参数:</p><ul><li>内部函数参数: (包括返回参数)都存储在<strong>memory（内存）</strong>中。</li><li>外部函数参数: (不包括返回参数)存储在 <code>calldata</code> 中</li></ul><hr><h3 id="10-为什么映射不能像哈希表一样遍历？"><a href="#10-为什么映射不能像哈希表一样遍历？" class="headerlink" title="10.为什么映射不能像哈希表一样遍历？"></a>10.为什么映射不能像哈希表一样遍历？</h3><p>映射与哈希表不同的地方：<strong>在映射中,并不存储 key，而是存储它的 <code>keccak256</code> 哈希值，从而便于查询实际的值</strong>。正因为如此，映射是没有长度的，也没有 <code>key 的集合</code>或 <code>value 的集合</code>的概念。映射只能是存储的数据位置，因此只允许作为状态变量或作为函数内的存储引用 或 作为库函数的参数。</p><hr><h3 id="11-遍历所有-Mapping-内的数据，（Mapping-配合-array-）"><a href="#11-遍历所有-Mapping-内的数据，（Mapping-配合-array-）" class="headerlink" title="11.遍历所有 Mapping 内的数据，（Mapping 配合 array ）"></a>11.遍历所有 Mapping 内的数据，（Mapping 配合 array ）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line">    // 用于检查:地址是否已经存在于 balancesKey</span><br><span class="line">    mapping(address =&gt; bool) public balancesInserted;</span><br><span class="line">    address[] public balancesKey; // 所有地址</span><br><span class="line"></span><br><span class="line">    // 设置</span><br><span class="line">    function set(address ads_,uint256 amount_) external&#123;</span><br><span class="line">        balances[ads_] = amount_;</span><br><span class="line">        // 1.检查</span><br><span class="line">        if(!balancesInserted[ads_])&#123;</span><br><span class="line">            // 2.修改检查条件</span><br><span class="line">            balancesInserted[ads_] = true;</span><br><span class="line">            // 3.正在的操作</span><br><span class="line">            balancesKey.push(ads_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取</span><br><span class="line">    function get(uint256 index_) external view returns(uint256)&#123;</span><br><span class="line">        require(index_&lt;balancesKey.length,&quot;index_ error&quot;);</span><br><span class="line">        return balances[balancesKey[index_]];</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取所有</span><br><span class="line">    function totalAddress() external view returns(uint256)&#123;</span><br><span class="line">        return balancesKey.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取第一个值</span><br><span class="line">    function first() external view returns(uint256)&#123;</span><br><span class="line">        return balances[balancesKey[0]];</span><br><span class="line">    &#125;</span><br><span class="line">    // 最后一个值</span><br><span class="line">    function latest() external view returns(uint256)&#123;</span><br><span class="line">        return balances[balancesKey[balancesKey.length-1]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>更完善的实现: <a href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol">https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol</a></li><li>更新的实现: <a href="https://learnblockchain.cn/docs/solidity/types.html#iterable-mappings">https://learnblockchain.cn/docs/solidity/types.html#iterable-mappings</a></li></ul><hr><h3 id="12-聊一聊-checked-和-unchecked"><a href="#12-聊一聊-checked-和-unchecked" class="headerlink" title="12.聊一聊 checked 和 unchecked"></a>12.聊一聊 <code>checked</code> 和 <code>unchecked</code></h3><p>0.8.0 开始，算术运算有两种计算模式：一种是<code>checked</code>（检查）模式，另一种是 <code>unchecked</code>（不检查）模式。 默认情况下，算术运算在 <code>checked</code> 模式下，即都会进行溢出检查，如果结果落在取值范围之外，调用会通过 失败异常 回退。 你也可以通过 <code>unchecked&#123; ... &#125;</code> 切换到 “unchecked”模式，更多可参考 <code>unchecked</code> .</p><hr><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h3 id="13-constant常量-和-immutable-不可变量总结"><a href="#13-constant常量-和-immutable-不可变量总结" class="headerlink" title="13.constant常量 和 immutable 不可变量总结"></a>13.constant常量 和 immutable 不可变量总结</h3><h4 id="值的确定时机不同"><a href="#值的确定时机不同" class="headerlink" title="值的确定时机不同"></a>值的确定时机不同</h4><p>状态变量声明为 constant (常量)或者 immutable （不可变量），在这两种情况下，合约一旦部署之后，变量将不在修改。</p><ul><li>对于 constant 常量, 他的值在编译器确定.</li><li>对于 immutable, 它的值在部署时确定。</li></ul><h4 id="gas-不同"><a href="#gas-不同" class="headerlink" title="gas 不同"></a>gas 不同</h4><p>与常规状态变量相比，常量和不可变量的 gas 成本要低得多。</p><ul><li>对于常量，赋值给它的表达式将复制到所有访问该常量的位置，并且每次都会对其进行重新求值。这样可以进行本地优化。</li><li>不可变变量在构造时进行一次求值，并将其值复制到代码中访问它们的所有位置。 对于这些值，将保留 32 个字节，即使它们适合较少的字节也是如此。很多时候常量的 gas 更低。</li></ul><p>如果可以使用常量的时候，推荐使用常量。</p><h4 id="支持的数据不同"><a href="#支持的数据不同" class="headerlink" title="支持的数据不同"></a>支持的数据不同</h4><p>不是所有类型的状态变量都支持用 <code>constant</code> 或 <code>immutable</code> 来修饰</p><ul><li>当前<code>constant</code>仅支持值类型和引用类型中的 string 和 bytes</li><li><code>immutable</code>仅支持值类型</li></ul><hr><h3 id="14-private-external-internal-public"><a href="#14-private-external-internal-public" class="headerlink" title="14.private &#x2F; external &#x2F; internal &#x2F; public"></a>14.<code>private</code> &#x2F; <code>external</code> &#x2F; <code>internal</code> &#x2F; <code>public</code></h3><ul><li>函数有四可见型，分别是 <code>private</code> &#x2F; <code>external</code> &#x2F; <code>internal</code> &#x2F; <code>public</code></li><li>状态变量可以有三种可见型，分别是 <code>private</code> &#x2F; <code>internal</code> &#x2F; <code>public</code></li></ul><ol><li><strong>private</strong>: 私有，仅在当前合约中可以访问，在继承的合约内不可访问</li><li><strong>internal(默认)</strong>: 能在它们所定义的合约和派生合同中访问,它们不能被外部访问,需要注意的是不能加前缀 this，前缀 this 是表示通过外部方式访问</li><li><strong>external:</strong> 不能声明在状态变量上，只能标识在函数上,只能从智能合约外部调用。 如果要从智能合约中调用它，则必须使用this</li><li><strong>public</strong>: 公开可视(合约内部，被继承的，外部都可以调用)</li></ol><hr><h3 id="15-变量作用域的规则"><a href="#15-变量作用域的规则" class="headerlink" title="15.变量作用域的规则"></a>15.变量作用域的规则</h3><ul><li>变量将会从它们被声明之后可见，直到一对 <code>&#123;&#125;</code> 块的结束。</li><li>对于参数形式的变量（例如：函数参数、修饰器参数、catch 参数等等）在其后接着的代码块内有效。<ul><li>这些代码块是函数的实现，catch 语句块等。</li><li>有一个例外，在 for 循环语句中初始化的变量，其可见性仅维持到 <code>for</code> 循环的结束。</li></ul></li></ul><hr><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="16-extcodesize-操作码来检查要调用的合约是否确实存在"><a href="#16-extcodesize-操作码来检查要调用的合约是否确实存在" class="headerlink" title="16.extcodesize 操作码来检查要调用的合约是否确实存在?"></a>16.extcodesize 操作码来检查要调用的合约是否确实存在?</h3><p>由于 EVM 认为可以调用不存在的合约的调用，因此在 Solidity 语言层面里会使用 extcodesize 操作码来检查要调用的合约是否确实存在（包含代码），如果不存在该合约，则抛出异常。如果返回数据在调用后被解码，则跳过这个检查，因此 ABI 解码器将捕捉到不存在的合约的情况。请注意，这个检查在 <strong>低级 call</strong> 时不被执行，这些调用是对地址而不是合约实例进行操作。</p><hr><h3 id="17-mutability状态可变性-Pure、view、payable"><a href="#17-mutability状态可变性-Pure、view、payable" class="headerlink" title="17.mutability状态可变性(Pure、view、payable)"></a>17.mutability状态可变性(Pure、view、payable)</h3><ol><li><p><strong>pure: 既不读取也不修改状态变量,这种函数被称为纯函数</strong></p><ul><li>读取状态变量。<ul><li>这也意味着读取 <code>immutable</code> 变量也不是一个 <code>pure</code> 操作。</li></ul></li><li>访问 <code>address(this).balance</code> 或 <code>&lt;address&gt;.balance</code></li><li>访问 <code>block</code>，<code>tx</code>， <code>msg</code> 中任意成员 （除 <code>msg.sig</code> 和 <code>msg.data</code> 之外）。</li><li>调用任何未标记为 <code>pure</code> 的函数。</li><li>使用包含特定操作码的内联汇编。<ul><li><code>TODO:</code> 这个不了解，需要用例子加深印象。</li></ul></li><li>使用操作码 <code>STATICCALL</code> , 这并不保证状态未被读取, 但至少不被修改。</li></ul></li><li><p><strong>view: 读取状态变量，但是不修改状态变量,这种函数被称为视图函数</strong></p><ul><li><p>修改状态变量。</p></li><li><p>触发事件。</p></li><li><p>创建其它合约。</p></li><li><p>使用 <code>selfdestruct</code>。</p></li><li><p>通过调用发送以太币。</p></li><li><p>调用任何没有标记为 view 或者 pure 的函数。</p></li><li><p>使用底层调用</p><ul><li>(TODO:这里是 call 操作么？)</li></ul></li><li><p>使用包含某些操作码的内联程序集。</p></li><li><p>状态变量的 Getter 方法默认是 view 函数。</p></li></ul></li><li><p><strong>payable：用 payable 声明的函数可以接受发送给合约的以太币.</strong></p><ul><li>如果未指定，该函数将自动拒绝所有发送给它的以太币</li></ul></li></ol><hr><h3 id="18-函数的构造函数有什么特点？"><a href="#18-函数的构造函数有什么特点？" class="headerlink" title="18.函数的构造函数有什么特点？"></a>18.函数的构造函数有什么特点？</h3><p>它仅能在智能合约部署的时候调用一次，创建之后就不能再次被调用。</p><p>构造函数是可选的，只允许有一个构造函数，这意味着不支持重载。（普通函数支持重载）</p><p>在合约创建的过程中，它的代码还是空的，所以直到构造函数执行结束，我们都不应该在其中调用合约自己的函数。(可以直接写函数名调用，但是不推荐调用，不可以通过 this 来调用函数，因为此时真实的合约实例还没有被创建。)</p><hr><h1 id="运算操作符"><a href="#运算操作符" class="headerlink" title="运算操作符"></a>运算操作符</h1><h3 id="19-A-B-如果-A-为-false，B-就不执行了-A-B-如果-A-为-true，B-就不执行了合理的使用短路操作，可以省一些-gas-费。"><a href="#19-A-B-如果-A-为-false，B-就不执行了-A-B-如果-A-为-true，B-就不执行了合理的使用短路操作，可以省一些-gas-费。" class="headerlink" title="19. A &amp;&amp; B,如果 A 为 false，B 就不执行了,A || B,如果 A 为 true，B 就不执行了合理的使用短路操作，可以省一些 gas 费。"></a>19. <code>A &amp;&amp; B</code>,如果 A 为 false，B 就不执行了,<code>A || B</code>,如果 A 为 true，B 就不执行了合理的使用短路操作，可以省一些 gas 费。</h3><hr><h3 id="20-三元运算符"><a href="#20-三元运算符" class="headerlink" title="20.三元运算符"></a>20.三元运算符</h3><p>三元运算符的结果类型是由两个操作数的类型决定的，方法与上面一样，如果需要的话，首先转换为它们的最小可容纳类型。</p><p>因此， <code>255 + (true ? 1 : 0)</code> 将由于算术溢出而被回退。 原因是 <code>(true ? 1 : 0)</code> 是 uint8 类型，这迫使加法也要在 <code>uint8</code> 中执行。 而 <code>256</code> 超出了这个类型所允许的范围。</p><p>另一个结果是，像 <code>1.5 + 1.5</code> 这样的表达式是有效的，但 <code>1.5 + (true ? 1.5 : 2.5)</code> 则无效。 这是因为前者是以无限精度来进行有理表达式运算，只有它的最终结果值才是重要的。 后者涉及到将小数有理数转换为整数，这在目前是不允许的。</p><hr><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h3 id="21-require、assert、revert对比"><a href="#21-require、assert、revert对比" class="headerlink" title="21.require、assert、revert对比"></a>21.require、assert、revert对比</h3><p><code>require(false)</code> 会退还所有剩余的 gas，同时可以返回一个自定义的报错信息。</p><p><code>assert(false)</code> 会消耗掉所有剩余的 gas，并恢复所有的操作。</p><p> <code>revert()</code> 会触发一个没有任何错误数据的回退</p><p>以下三个语句的功能完全相同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// revert</span><br><span class="line">if(msg.sender != owner) &#123;</span><br><span class="line">   revert error();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">// require</span><br><span class="line">require(msg.sender == owner,&quot;error&quot;);</span><br><span class="line"></span><br><span class="line">// assert</span><br><span class="line">assert(msg.sender == owner);</span><br></pre></td></tr></table></figure><hr><h3 id="22-自定义error"><a href="#22-自定义error" class="headerlink" title="22.自定义error"></a>22.自定义error</h3><p><strong><code>error</code> 只能通过 <code>revert</code> 触发</strong></p><p>错误产生的数据，会通过 revert 操作传递给调用者，可以交由链外组件处理或在 try&#x2F;catch 语句 中捕获它。</p><p>注意，只有外部调用的错误才能被捕获。发生在内部调用或同一函数内的 revert 不能被捕获。</p><hr><h3 id="23-try-catch"><a href="#23-try-catch" class="headerlink" title="23.try catch"></a>23.try catch</h3><p>Solidity 如果遇到异常错误，是通过回退状态的方式来进行处理。发生异常时，会撤消当前调用和所有子调用改变的状态变量，同时给调用者返回一个错误标识。</p><p>调用者调用某个函数方法，要么成功修改了所有状态变量，要么遇到异常不修改任何状态变量，不存在成功修改部分变量的情况，</p><p>Solidity 提供了 <strong>require</strong> 、<strong>assert</strong> 和 <strong>revert</strong> 来处理异常。同时可以使用 <code>error</code> 关键字来实现错误。</p><p>跟用错误字符串相比， error 更便宜并且允许你编码额外的数据，还可以用 <code>NatSpec</code> 为用户去描述错误。</p><p>Solidity 使用状态恢复异常来处理错误。这种异常将撤消对当前调用（及其所有子调用）中的状态所做的所有更改，并且还向调用者标记错误。</p><p>如果异常在子调用发生，那么异常会自动冒泡到顶层（例如：异常会重新抛出），除非他们在 <code>try/catch</code> 语句中捕获了错误。 但是如果是在 <code>send</code> 和 低级 <code>call</code>, <code>delegatecall</code> 和 <code>staticcall</code> 的调用里发生异常时， 他们会返回 <code>false</code> （第一个返回值） 而不是冒泡异常。</p><p>警告注意：根据 EVM 的设计，如果被调用的地址不存在，低级别函数 <code>call</code>, <code>delegatecall</code> 和 <code>staticcall</code> 第一个返回值同样是 <code>true</code>。 如果需要，请在调用之前检查账号的存在性。</p><p>异常可以包含错误数据，以 error 示例 的形式传回给调用者。 内置的错误 <code>Error(string)</code> 和 <code>Panic(uint256)</code> 被作为特殊函数使用，下面将解释。 <code>Error</code> 用于 “常规” 错误条件，而 <code>Panic</code> 用于在（无 bug）代码中不应该出现的错误。</p><p>函数 assert 和 require 可用于检查条件并在条件不满足时抛出异常。</p><hr><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h3 id="24-带-indexed-参数名的-event"><a href="#24-带-indexed-参数名的-event" class="headerlink" title="24. 带 indexed 参数名的 event"></a>24. 带 indexed 参数名的 event</h3><p>这种事件也被称为<strong>索引事件</strong></p><p>语法:<code>event EventName(TypeName indexed varibleName....);</code></p><p>事件中 indexed 标记过的参数，可以在链外进行搜索查询:</p><p>主要用在链下服务，可以通过 RPC 获取，比如 web3 的以下方法:</p><ul><li><pre><code class="js">myContract.once //订阅一个事件并在第一次事件触发或错误发生后立即取消订阅<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```solidity</span><br><span class="line">  myContract.events.MyEvent //订阅指定的合约事件</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="solidity">myContract.getPastEvents //读取合约历史事件</code></pre></li></ul><p>一个事件中 indexed 标记过的参数最多有 3 个。</p><hr><h1 id="合约继承"><a href="#合约继承" class="headerlink" title="合约继承"></a>合约继承</h1><h3 id="25-注意："><a href="#25-注意：" class="headerlink" title="25.注意："></a>25.注意：</h3><ul><li>父合约必须写在子合约的前面，否则会报错</li><li>子类可以访问父类的权限修饰符只有：<code>public/internal</code>，不能是 <code>external/private</code></li><li>多重继承中不允许出现相同的<strong>函数名</strong>、<strong>事件名</strong>、<strong>修改器名</strong>以及<strong>状态变量名</strong>等</li></ul><h3 id="26-virtual-override-abstract"><a href="#26-virtual-override-abstract" class="headerlink" title="26.virtual, override , abstract"></a>26.<code>virtual</code>, <code>override</code> , <code>abstract</code></h3><p>父合约标记为 <code>virtual</code>函数可以在继承合约里重写(overridden)以更改他们的行为。重写的函数需要使用关键字 <code>override</code> 修饰。</p><p>基础合约中可以包含没有实现代码的函数，也就是纯虚函数，那么基础合约必须声明为 <code>abstract</code>。</p><h1 id="接口Interface"><a href="#接口Interface" class="headerlink" title="接口Interface"></a>接口Interface</h1><h3 id="27-限制"><a href="#27-限制" class="headerlink" title="27.限制"></a>27.限制</h3><ul><li><p>无法实现任何功能，没有函数体。</p></li><li><p>无法定义构造函数。</p></li><li><p>无法定义状态变量。</p></li><li><p>无法定义结构（<code>struct</code>）（<code>0.5.0</code> 版本开始接口里可以支持声明 <code>enum</code> 类型）。</p></li><li><p>不可以声明修改器。</p></li><li><p>所有声明的函数必须是external的，尽管在合约里可以是 public</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20-合约编码规范</title>
      <link href="/2022/07/27/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/20-%E5%90%88%E7%BA%A6%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2022/07/27/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/20-%E5%90%88%E7%BA%A6%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>良好统一的编程风格，有助于提高代码的可读性和可维护性。根据风格整理成规范，可以让团队之间更好的配合。</p><p>下面是我结合网络上别人分享的内容，以及参考 Vscode 代码格式化整理优化出的；抛砖引玉，仅供参考。</p><ul><li>如果合约对状态变量进行了修改，需要抛出事件。</li><li>构造函数的参数必须是<code>storage</code>或<code>memory</code>，不能使用<code>calldata</code>;</li><li>版权注释在文件的任何位置都可以被编译器识别，但建议把它放在文件的顶部第一行。</li></ul><h2 id="代码布局"><a href="#代码布局" class="headerlink" title="代码布局"></a>代码布局</h2><ul><li><p>源码编码</p><ul><li>UTF-8</li></ul></li><li><p>缩进</p><ul><li>使用 4 个空格代替制表符作为缩进，避免空格与制表符混用。</li></ul></li><li><p>2 个合约定义之间空 2 行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract LedgerBalance &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Updater &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2 个函数之间空 1 行,在只有声明的情况下，不需要空行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function balance() public pure;</span><br><span class="line">    function account() public pure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract B is A &#123;</span><br><span class="line">    function balance() public pure &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function account() public pure &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单行不要太长，VScode 一行默认不超过 80 个字符。</p></li><li><p>函数声明如果太长，左括号不换行，每个参数一行并缩进，右括号换行，并对齐左括号所在行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function_with_a_long_name(</span><br><span class="line">    longArgument1,</span><br><span class="line">    longArgument2,</span><br><span class="line">    longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">variable = function_with_a_long_name(</span><br><span class="line">    longArgument1,</span><br><span class="line">    longArgument2,</span><br><span class="line">    longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">event multipleArguments(</span><br><span class="line">    address sender,</span><br><span class="line">    address recipient,</span><br><span class="line">    uint256 publicKey,</span><br><span class="line">    uint256 amount,</span><br><span class="line">    bytes32[] options</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">MultipleArguments(</span><br><span class="line">    sender,</span><br><span class="line">    recipient,</span><br><span class="line">    publicKey,</span><br><span class="line">    amount,</span><br><span class="line">    options</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>避免在圆括号、方括号或大括号后有空格。</p></li><li><p>控制结构的大括号左括号不换行，右括号换行，与左括号所在行对齐。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Coin &#123;</span><br><span class="line">    struct Bank &#123;</span><br><span class="line">        address owner;</span><br><span class="line">        uint balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (x &lt; 3) &#123;</span><br><span class="line">    x += 1;</span><br><span class="line">&#125; else if (x &gt; 7) &#123;</span><br><span class="line">    x -= 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    x = 5;</span><br><span class="line">&#125;</span><br><span class="line">if (x &lt; 3)</span><br><span class="line">    x += 1;</span><br><span class="line">else</span><br><span class="line">    x -= 1;</span><br></pre></td></tr></table></figure></li><li><p>函数声明，添加可见性标签。可见性标签应该放在自定义修饰符之前。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function kill() public onlyowner &#123;</span><br><span class="line">    selfdestruct(owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明映射变量时避免多余空格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mapping(uint =&gt; uint) map; // 不是 mapping (uint =&gt; uint) map;</span><br><span class="line">mapping(address =&gt; bool) registeredAddresses;</span><br><span class="line">mapping(uint =&gt; mapping(bool =&gt; Data[])) public data;</span><br><span class="line">mapping(uint =&gt; mapping(uint =&gt; s)) data;</span><br></pre></td></tr></table></figure></li><li><p>声明数组变量时避免多余空格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint[] x;  // 不是 unit [] x;</span><br></pre></td></tr></table></figure></li><li><p>字符串声明,使用双引号声明字符串，而不是单引号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;foo&quot;;</span><br><span class="line">str = &quot;Hamlet says, &#x27;To be or not to be...&#x27;&quot;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="代码中各部分的顺序"><a href="#代码中各部分的顺序" class="headerlink" title="代码中各部分的顺序"></a>代码中各部分的顺序</h2><p>代码中各部分顺序如下：</p><ol><li>License</li><li>Pragma</li><li>import</li><li>interface</li><li>library</li><li>contract</li></ol><p>在 Interface、库或 Contract 中，各部分顺序应为：</p><ol><li><p>Type declaration : 类型声明</p></li><li><p>State variable : 状态变量</p></li><li><p>Event : 事件</p></li><li><p>Modifier : 函数修改器</p></li><li><p>Errors : 自定义错误</p></li><li><p>Constructor : 构造函数</p></li><li><p>Function : 函数</p><ol><li>函数按<strong>visibility:可见性</strong>进行排序: <code>External - Public - Internal - Private</code></li><li>同一可见性，按照 <strong>mutability:状态可变性</strong> 排序: <code>payable - 无 - view - pure</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// External functions</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// External view functions</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// External pure functions</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// Public functions</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// Internal functions</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// Private functions</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure></li><li><p>Helper : 辅助函数</p></li></ol><h2 id="文件结构分享"><a href="#文件结构分享" class="headerlink" title="文件结构分享"></a>文件结构分享</h2><p>我的文件结构，分享给大家，仅供参考，抛砖引玉。代码块分割主要是让合约的逻辑更清晰，团队合作写代码的时候，都能按照统一的约定来进行编码。</p><p>不同功能的代码块使用下面任意一种做明显标记。</p><p>第一种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  * ========================================</span><br><span class="line">  * State Variables</span><br><span class="line">  * ========================================</span><br><span class="line">  */</span><br></pre></td></tr></table></figure><p>第二种：(两边各 12 个 <code>=</code>)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* ============ State Variables ============ */</span><br></pre></td></tr></table></figure><p>如果需要写详细的 NetSpec 注释，我比较喜欢使用第一种。如果是不需要这样做，比较喜欢第二种。第一种写法，在第一章<a href="https://www.axihe.com/source/01.hello.html#id40">同志们好</a> 那里已经演示过了，这里演示第二种写法。如下是写法的演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// import</span><br><span class="line"></span><br><span class="line">// interface</span><br><span class="line"></span><br><span class="line">// library</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    /* ============ Type Declaration ============ */</span><br><span class="line">    struct Book &#123;</span><br><span class="line">        string title;</span><br><span class="line">        string author;</span><br><span class="line">        uint256 book_id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* ============ State Variables ============ */</span><br><span class="line">    address public immutable owner;</span><br><span class="line">    Book[] public bookcase;</span><br><span class="line"></span><br><span class="line">    /* ============ Events ============ */</span><br><span class="line">    event Hello(string);</span><br><span class="line"></span><br><span class="line">    /* ============ Modifier ============ */</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Only owner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* ============ Errors ============ */</span><br><span class="line">    error MyError(string);</span><br><span class="line"></span><br><span class="line">    /* ============ Constructor ============ */</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* ============ Functions ============ */</span><br><span class="line"></span><br><span class="line">    /* ============ External Functions ============ */</span><br><span class="line">    function hello() external onlyOwner &#123;</span><br><span class="line">        emit Hello(&quot;Hello Comrades&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* ============ Helper ============ */</span><br><span class="line">    function getBalance() external view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><ul><li><p>合约和库名: 大驼峰式命名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Owned &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>合约和库名: 匹配它们的文件名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 文件名:Owned.sol</span><br><span class="line">contract Owned &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果文件中有多个合约&#x2F;库，使用核心合约&#x2F;库的名称。🤔️</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 文件名:Owned.sol</span><br><span class="line">contract Owned &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        //....</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferOwnership(address newOwner) public onlyOwner returns(true)&#123;</span><br><span class="line">        //...</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">import &quot;./Owned.sol&quot;;</span><br><span class="line"></span><br><span class="line">// Congress.sol</span><br><span class="line">contract Congress is Owned &#123;</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结构体名称: 大驼峰式命名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct BookInfo &#123;</span><br><span class="line">    string title;</span><br><span class="line">    string author;</span><br><span class="line">    uint256 book_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>事件名称: 大驼峰式命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event AfterTransfer(address ads);</span><br></pre></td></tr></table></figure></li><li><p>函数名: 小驼峰命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function balanceOf(address account) external view returns (uint256)&#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>internal</code>函数名:<code>_</code>+小驼峰命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function _grantRole(address _ads, bytes32 _role) internal &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>internal</code>变量:<code>_</code>+小驼峰</p></li><li><p>函数参数:小驼峰+<code>_</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor(string memory name_, string memory symbol_) &#123;</span><br><span class="line">    _name = name_;</span><br><span class="line">    _symbol = symbol_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>局部变量和状态变量:小驼峰命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping(address =&gt; uint256) public balanceOf;</span><br></pre></td></tr></table></figure></li><li><p>常量:大写字母单词用下划线分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address public constant MIN_BLOCKS;</span><br></pre></td></tr></table></figure></li><li><p>函数修改器: 小驼峰命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modifier onlyOwner()&#123;</span><br><span class="line">    require(msg.sender==owner,&quot;must owner address&quot;);</span><br><span class="line">    _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举的名字:大驼峰式命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Status &#123;</span><br><span class="line">    None,</span><br><span class="line">    Pending,</span><br><span class="line">    Shiped,</span><br><span class="line">    Completed,</span><br><span class="line">    Rejected,</span><br><span class="line">    Canceled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mapping可迭代映射</title>
      <link href="/2022/07/27/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/mapping%E5%8F%AF%E8%BF%AD%E4%BB%A3%E6%98%A0%E5%B0%84/"/>
      <url>/2022/07/27/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/mapping%E5%8F%AF%E8%BF%AD%E4%BB%A3%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="学校和学生"><a href="#学校和学生" class="headerlink" title="学校和学生"></a>学校和学生</h1><p>我们想创建一个“学校”智能合约来收集学生地址。合约必须具有 3 个主要功能：</p><ol><li>从合同中添加或删除学生。</li><li>询问给定的学生地址是否属于学校。</li><li>获取所有学生的列表。</li></ol><p>我们的<code>School</code>智能合约将如下所示：</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/1lY-XnsfdjPztGwztIEBIvQ.png" alt="img"> </p><h2 id="简单解决方案-1：使用mapping-address-bool"><a href="#简单解决方案-1：使用mapping-address-bool" class="headerlink" title="简单解决方案 1：使用mapping (address =&gt; bool)"></a>简单解决方案 1：使用<code>mapping (address =&gt; bool)</code></h2><p>我们使用映射来存储每个学生的存在。如果映射到给定地址的值为<code>true</code>，则表示该地址是我们的学生之一。虽然解决方案很简单，但它的局限性在于它不能支持获取所有学生。与大多数其他语言不同，在 Solidity 中，不支持映射迭代。</p><h2 id="简单解决方案-2：使用address-students"><a href="#简单解决方案-2：使用address-students" class="headerlink" title="简单解决方案 2：使用address[] students"></a>简单解决方案 2：使用<code>address[] students</code></h2><p>我们使用地址数组而不是映射。现在很明显，我们解决了第三个需求（能够返回所有学生的列表）。但是，查找和删除现有学生变得更加困难。我们必须循环遍历数组中的每个元素以查找地址、检查地址是否存在或删除学生。</p><h2 id="更好的解决方案：使用mapping-address-⇒-address"><a href="#更好的解决方案：使用mapping-address-⇒-address" class="headerlink" title="更好的解决方案：使用mapping(address ⇒ address)"></a>更好的解决方案：使用<code>mapping(address ⇒ address)</code></h2><p>激动人心的部分来了！这种数据结构的基础是<a href="https://en.wikipedia.org/wiki/Linked_list">链表</a>。我们将下一个学生的地址（即指向下一个学生的指针）存储为映射值而不是普通布尔值。听起来很困惑吧？这张图会帮助你理解。</p><img src="/noteimg/区块链/Solidity0.8/img/1ybjLvYv-CdGfOinFvFq4vA.png" alt="img" style="zoom:80%;" /> <p>顶部：链表数据结构。每个节点指向它的下一个节点，最后一个节点指向 GUARD。底部：使用键值映射的顶部图像的具体表示。</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/1eXK0rf5Ec4VQ8a_eSyHtnA.png" alt="img"> </p><p>数据结构的初始化是通过将 GUARD 设置为指向 GUARD 来完成的，这意味着列表为空</p><p>现在让我们来看看每个功能的实现。</p><h3 id="检查学生是否在学校：isStudent"><a href="#检查学生是否在学校：isStudent" class="headerlink" title="检查学生是否在学校：isStudent"></a>检查学生是否在学校：<code>isStudent</code></h3><p><code>mapping</code>我们使用这样一个事实，即学校中特定学生的结构中的值始终指向下一个学生的地址。因此，我们可以通过检查给定地址映射到的值来轻松验证给定地址是否在学校内。如果它指向某个非零地址，则表示该学生地址在学校。</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/1Leo2GwdsqhJBpnLxowweWw.png" alt="img"> </p><h3 id="向学校添加新学生：addStudent"><a href="#向学校添加新学生：addStudent" class="headerlink" title="向学校添加新学生：addStudent"></a>向学校添加新学生：<code>addStudent</code></h3><p>我们可以在（表示列表的 HEAD 指针）之后添加一个新地址，<code>GUARD</code>方法是将守卫的指针更改为这个新地址，并将这个新地址（New Student）的指针设置为先前的前面地址（Front Student）。</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/1h3xft5gEAseZGZEFdkbDHA.png" alt="img"> </p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/1gd__pHCftvpWsmPbVCQ3Nw.png" alt="img"> </p><h3 id="从学校删除学生：removeStudent"><a href="#从学校删除学生：removeStudent" class="headerlink" title="从学校删除学生：removeStudent"></a>从学校删除学生：<code>removeStudent</code></h3><p>这个函数比上面的两个函数更棘手。我们知道地址是否在列表中，但我们无法轻易推导出任何给定学生的先前地址（除非我们使用<a href="https://en.wikipedia.org/wiki/Doubly_linked_list">双重链接列表</a>，但就存储成本而言，这要昂贵得多）。要删除一个地址，我们需要让它的前一个学生指向删除地址的下一个地址，并将删除地址的指针设置为零。</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/1CAAcxCXqJ3zXdNfol-bBCg.png" alt="img"> </p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/15ziw2ePv1CTuqyp164ZYAQ.png" alt="img"> </p><p>请注意，要实现<code>removeStudent</code>，我们还必须引入<code>getPrevStudent</code>有助于在任何给定学生之前找到以前学生地址的功能。</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/12oIfywFrb5VoQW1x2UD07w.png" alt="img"> </p><h3 id="获取所有学生的列表：getStudents"><a href="#获取所有学生的列表：getStudents" class="headerlink" title="获取所有学生的列表：getStudents"></a>获取所有学生的列表：<code>getStudents</code></h3><p>这很简单。我们从 GUARD 地址开始循环遍历映射，并将当前指针设置为下一个指针，直到它再次指向 GUARD，即迭代完成。</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/1Z5KdTBzFq4NFwcq3cRs-Hg.png" alt="img"> </p><h3 id="removeStudent进一步优化"><a href="#removeStudent进一步优化" class="headerlink" title="removeStudent进一步优化"></a><code>removeStudent</code>进一步优化</h3><p>请注意，<code>removeStudent</code>我们实现的函数消耗的 gas 与学校的学生人数成正比，因为我们需要遍历整个列表一次才能找到要删除的地址的前一个地址。我们可以通过使用链下计算将先前的地址发送给函数来优化此函数。因此，智能合约只需要验证之前的地址确实指向我们要删除的地址。</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/img/1hFzsKxzbmwYiDWqM7USzNA.png" alt="img"> </p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在本文中，我们探索了<em>Iterable Maps</em>的一种实现，这是一种数据结构，它不仅支持<strong>O(1) 的</strong>添加、删除和查找，类似于传统的<code>mapping</code>，而且还支持集合迭代。</p>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19-变量的布局</title>
      <link href="/2022/07/27/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/19-%E5%8F%98%E9%87%8F%E7%9A%84%E5%B8%83%E5%B1%80/"/>
      <url>/2022/07/27/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/19-%E5%8F%98%E9%87%8F%E7%9A%84%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="状态变量在-storge-中的布局"><a href="#状态变量在-storge-中的布局" class="headerlink" title="状态变量在 storge 中的布局"></a>状态变量在 storge 中的布局</h1><p>合约的状态变量以一种紧凑的方式存储在区块链存储中，以这样的方式，<strong>有时多个值会使用同一个存储槽</strong>。</p><p>除了动态大小的数组和 mapping，数据的存储方式是从位置 <code>0</code> 开始连续放置在 storage 中。对于每个变量，根据其类型确定字节大小。</p><p>存储大小少于 32 字节的多个变量会被打包到一个存储插槽(storage slot)中，规则如下：</p><ul><li>存储插槽的第一项会以低位对齐的方式储存。</li><li>值类型仅使用存储它们所需的字节。</li><li>如果存储插槽中的剩余空间不足以储存一个值类型，那么它会被存入下一个存储插槽。</li><li>结构体（struct）和数组数据总是会开启一个新插槽（但结构体或数组中的各元素，则按规则紧密打包）。</li><li>结构体和数组之后的数据也或开启一个新插槽。</li></ul><p>对于使用继承的合约，状态变量的排序由 C3 线性化合约顺序（顺序从最基类合约开始）确定。如果上述规则成立，那么来自不同的合约的状态变量会共享一个存储插槽。</p><p>结构体和数组中的成员变量会存储在一起，就像它们单独声明时一样。</p><h2 id="1-1-使用时候的注意"><a href="#1-1-使用时候的注意" class="headerlink" title="1.1 使用时候的注意"></a>1.1 使用时候的注意</h2><p>⚠️ 注意: 在使用小于 32 字节的变量时，合约的 gas 使用量可能会高于使用 32 字节的元素。这是因为 EVM 每次操作 32 个字节，所以如果元素比 32 字节小，EVM 必须执行额外的操作以便将其大小缩减到到所需的大小。</p><p>当我们在处理状态变量时，利用编译器会将多个元素（变量）缩减的存储大小打包到一个 存储插槽中，也许是有益，因为可以合并多次读写为单个操作。如果你不是在同一时间读或写一个槽中的所有值，这可能会适得其反。当一个值被写入一个多值存储槽时，必须先读取该存储槽，然后将其与新值合并，避免破坏同一槽中的其他数据，再写入。</p><p>当处理函数参数或 memory(内存)中的值时，因为编译器不会打包这些值，所以没有什么额外的益处。</p><h2 id="1-2-书写时的注意"><a href="#1-2-书写时的注意" class="headerlink" title="1.2 书写时的注意"></a>1.2 书写时的注意</h2><p>最后，为了允许 evm 对此进行优化，请确保 storage 中的变量和 <code>struct</code> 成员的书写顺序允许它们被紧密地打包。例如，应该按照 <code>uint128，uint128，uint256</code> 的顺序来声明状态变量，而不是使用 <code>uint128，uint256，uint128</code>，因为前者只占用两个存储插槽，而后者将占用三个。</p><p>⚠️ 注意: storage 中状态变量的布局被认为是 solidity 外部接口的一部分， 因此 storage 变量指针可以传递给库（library）函数。这意味着，本节所述规则的任何变更均被视为语言破坏性变更，并且由于其关键性质，在执行之前应该非常仔细地考虑，在发生这种破坏性变化的情况下，我们希望发布一种兼容模式，在这种模式下，编译器将生成支持旧布局的字节码。</p><h2 id="1-3-mapping-和动态数组"><a href="#1-3-mapping-和动态数组" class="headerlink" title="1.3 mapping 和动态数组"></a>1.3 mapping 和动态数组</h2><p>由于 mapping 和动态数组不可预知大小，不能在状态变量之间存储他们。相反，他们自身根据以上规则仅占用 32 个字节，然后他们包含的元素的存储的起始位置，则是通过 Keccak-256 哈希计算来确定。</p><h2 id="1-4-起始位置"><a href="#1-4-起始位置" class="headerlink" title="1.4 起始位置"></a>1.4 起始位置</h2><p>假设 mapping 或动态数组根据上述存储规则最终可确定某个位置 <code>p</code> 。</p><ul><li>对于动态数组，此插槽中会存储数组中元素的数量（字节数组和字符串除外，见下文）。</li><li>对于 mapping，该插槽未被使用（为空），但它仍是需要的，以确保两个彼此挨着 mapping，他们的内容在不同的位置上。</li></ul><p>数组的元素会从 <code>keccak256(p)</code> 开始；它的布局方式与静态大小的数组相同。一个元素接着一个元素，如果元素的长度不超过 16 字节，就有可能共享存储槽。</p><p>动态数组的数组会递归地应用这一规则，例如，如何确定 <code>x[i][j]</code>元素的位置，其中 <code>x</code> 的类型是 <code>uint24[][]</code>，计算方法如下（假设<code>x</code>本身存储在槽 <code>p</code>）: 槽位于 <code>keccak256(keccak256(p) + i) + floor(j / floor(256 / 24))</code>，且可以从槽数据 <code>v</code>得到元素内容，使用 <code>(v &gt;&gt; ((j % floor(256 / 24)) * 24)) &amp; type(uint24).max</code>.</p><p>mapping 中的键 <code>k</code> 所对应的槽会位于 <code>keccak256(h(k) . p)</code> ，其中 <code>.</code>是连接符， <code>h</code> 是一个函数，根据键的类型：</p><ul><li>值类型， <code>h</code> 与在内存中存储值的方式相同的方式将值填充为 32 字节。</li><li>对于字符串和字节数组， <code>h(k)</code> 只是未填充的数据。</li></ul><p>如果映射值是一个非值类型，计算槽位置标志着数据的开始位置。例如，如果值是结构类型，你必须添加一个与结构成员相对应的偏移量才能到达该成员。</p><h4 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    struct S &#123;</span><br><span class="line">        uint16 a;</span><br><span class="line">        uint16 b;</span><br><span class="line">        uint256 c;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 x;</span><br><span class="line">    mapping(uint256 =&gt; mapping(uint256 =&gt; S)) data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们计算一下 <code>data[4][9].c</code> 的存储位置。映射本身的位置是 <code>1</code>（前面有 32 字节变量 <code>x</code> ）。 因此 <code>data[4]</code> 存储在<code>keccak256(uint256(4) . uint256(1))</code>。 <code>data[4]</code> 的类型又是一个映射，<code>data[4][9]</code> 的数据开始于槽位<code>keccak256(uint256(9). keccak256(uint256(4). uint256(1))</code>。</p><p>在结构 <code>S</code> 的成员 <code>c</code> 中的槽位偏移是 <code>1</code>，因为 <code>a</code> 和<code>b</code>被装在一个槽位中。 最后 <code>data[4][9].c</code> 的插槽位置是<code>keccak256(uint256(9) . keccak256(uint256(4) . uint256(1)) + 1</code>.该值的类型是 <code>uint256</code>，所以它使用一个槽。</p><h2 id="1-5-bytes-和-string"><a href="#1-5-bytes-和-string" class="headerlink" title="1.5 bytes 和 string"></a>1.5 <code>bytes</code> 和 <code>string</code></h2><p><code>bytes</code> 和 <code>string</code> 编码是一样的。</p><p>一般来说，编码与 <code>bytes1[]</code>类似，即有一个槽用于存放数组本身同时还有一个数据区，数据区位置使用槽的<br><code>keccak256</code> hash 计算。然而，对于短字节数组（短于 32 字节），数组元素与长度一起存储在同一个槽中。</p><p>具体地说：如果数据长度小于等于 <code>31</code>字节，则元素存储在高位字节（左对齐），最低位字节存储值 <code>length * 2</code>。如果数据长度大于等于 32 字节，则在主插槽 <code>p</code> 存储 <code>length * 2 + 1</code>，数据照常存储在 <code>keccak256(p)</code> 中。因此，可以通过检查是否设置了最低位：短（未设置最低位）和长（设置最低位）来区分短数组和长数组。</p><p>⚠️ 注意: 目前不支持处理无效编码的插槽，但可能在将来添加。如果你通过 IR 编译，读取一个无效的编码槽会导致 <code>Panic(0x22)</code> 错误。</p><h2 id="1-6-JSON-输出"><a href="#1-6-JSON-输出" class="headerlink" title="1.6 JSON 输出"></a>1.6 JSON 输出</h2><p>合约的存储布局可以通过 standard JSON interface 获取到。 输出 JSON 对象包含 2 个字段 <code>storage</code> 和 <code>types</code> 。<code>storage</code> 对象是一个数组。</p><p>文件： <code>fileA</code> 合约： <code>contract A &#123; uint x; &#125;</code>存储布局，它的每个元素有如下的形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;astId&quot;: 2,</span><br><span class="line">    &quot;contract&quot;: &quot;fileA:A&quot;,</span><br><span class="line">    &quot;label&quot;: &quot;x&quot;,</span><br><span class="line">    &quot;offset&quot;: 0,</span><br><span class="line">    &quot;slot&quot;: &quot;0&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;t_uint256&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个字段说明如下：</p><ul><li><code>astId</code> 是状态变量声明的 AST 节点的 id。</li><li><code>contract</code> 是合约的名称，包括其路径作为前缀。</li><li><code>label</code> 是状态变量的名称。</li><li><code>offset</code> 是根据编码在存储槽内以字节为单位的偏移量。</li><li><code>slot</code> 是状态变量所在或开始的存储槽。这个数字可能非常大，因此它的 JSON 值被表示为一个字符串。</li><li><code>type</code> 是一个标识符，作为变量类型信息的关键(如下所述)。</li></ul><p>给定的 <code>type</code>，在本例中 <code>t_uint256</code> 代表 <code>types</code>中的一个元素，其形式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;encoding&quot;: &quot;inplace&quot;,</span><br><span class="line">    &quot;label&quot;: &quot;uint256&quot;,</span><br><span class="line">    &quot;numberOfBytes&quot;: &quot;32&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而</p><ul><li><pre><code>encoding<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  数据在存储中如何编码，可能的数值是：</span><br><span class="line"></span><br><span class="line">  - `inplace`: 数据在存储中连续排列 (见 前面状态变量储存结构`).</span><br><span class="line">  - `mapping`: Keccak-256 基于哈希的方法 (见 前面前面映射和动态数组`).</span><br><span class="line">  - `dynamic_array`: Keccak-256 基于哈希的方法 (见 前面映射和动态数组`).</span><br><span class="line">  - `bytes`: 单槽或基于 Keccak-256 哈希的方法，取决于数据大小 (见 前面 bytes).</span><br><span class="line"></span><br><span class="line">- `label` 是规范的类型名称 。</span><br><span class="line"></span><br><span class="line">- `numberOfBytes` 是使用的字节数(十进制字符串) 注意，如果`numberOfBytes&gt;32` 意味着使用了一个以上的槽。</span><br><span class="line"></span><br><span class="line">除了上述四个外，有些类型还有额外的信息。映射包含其 `key` 和 `value`类型(再次引用该类型映射中元素类型)，数组有其 `base` 类型，结构以与顶层`storage` 相同的格式列出其 `members` (见:ref:`前面JSON 输出`).</span><br><span class="line"></span><br><span class="line">⚠️ 注意: 合约的存储布局的 JSON 输出格式仍被认为是实验性的，即使在 Solidity 的非突破性版本更新中也可能会发生变化。</span><br><span class="line"></span><br><span class="line">#### 例子</span><br><span class="line"></span><br><span class="line">下面的例子显示了一个合约和它的存储布局，包含值类型和引用类型、被编码打包的类型和嵌套类型。</span><br><span class="line"></span><br><span class="line">```solidity</span><br><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.4.0 &lt;0.9.0;</span><br><span class="line">contract A &#123;</span><br><span class="line">    struct S &#123;</span><br><span class="line">        uint128 a;</span><br><span class="line">        uint128 b;</span><br><span class="line">        uint[2] staticArray;</span><br><span class="line">        uint[] dynArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint x;</span><br><span class="line">    uint y;</span><br><span class="line">    S s;</span><br><span class="line">    address addr;</span><br><span class="line">    mapping (uint =&gt; mapping (address =&gt; bool)) map;</span><br><span class="line">    uint[] array;</span><br><span class="line">    string s1;</span><br><span class="line">    bytes b1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;storage&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">15</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;x&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_uint256&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">17</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;y&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_uint256&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_struct(S)13_storage&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">22</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;addr&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_address&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">28</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;map&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_mapping(t_uint256,t_mapping(t_address,t_bool))&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">31</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;array&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_array(t_uint256)dyn_storage&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">33</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;9&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_string_storage&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">35</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_bytes_storage&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;t_address&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inplace&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;address&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;t_array(t_uint256)2_storage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;base&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_uint256&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inplace&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256[2]&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;64&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;t_array(t_uint256)dyn_storage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;base&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_uint256&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dynamic_array&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256[]&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;32&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;t_bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inplace&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bool&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;t_bytes_storage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bytes&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bytes&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;32&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;t_mapping(t_address,t_bool)&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mapping&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_address&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mapping(address =&gt; bool)&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;32&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_bool&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;t_mapping(t_uint256,t_mapping(t_address,t_bool))&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mapping&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_uint256&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mapping(uint256 =&gt; mapping(address =&gt; bool))&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;32&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_mapping(t_address,t_bool)&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;t_string_storage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bytes&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;32&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;t_struct(S)13_storage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inplace&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;struct A.S&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;members&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_uint128&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_uint128&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;staticArray&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_array(t_uint256)2_storage&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fileA:A&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dynArray&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_array(t_uint256)dyn_storage&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;128&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;t_uint128&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inplace&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint128&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;16&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;t_uint256&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inplace&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;32&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="变量在-memory-布局"><a href="#变量在-memory-布局" class="headerlink" title="变量在 memory 布局"></a>变量在 memory 布局</h1><p>Solidity 保留了四个 32 字节的插槽，字节范围(包括端点)特定用途如下：</p><ul><li><code>0x00</code> - <code>0x3f</code> (64 字节): 用于哈希方法的<strong>暂存空间</strong>（临时空间）</li><li><code>0x40</code> - <code>0x5f</code> (32 字节): 当前分配的内存大小(也作为<strong>空闲内存指针</strong>)</li><li><code>0x60</code> - <code>0x7f</code> (32 字节): <strong>零位插槽</strong></li></ul><p><strong>暂存空间</strong>可以在语句之间使用 (例如在内联汇编中)。<strong>零位插槽</strong>用作动态内存数组的初始值，并且永远不应写入（空闲内存指针最初指向<code>0x80</code>）.Solidity 总是将新对象放在<strong>空闲内存指针</strong>上，并且内存永远不会被释放(将来可能会改变)。</p><p>Solidity 中的内存数组中的元素始终占据 32 字节的倍数（对于 <code>bytes1[]</code>总是这样，但不适用与 <code>bytes</code> 和 <code>string</code> ）。</p><p>多维内存数组是指向内存数组的指针，动态数组的长度存储在数组的第一个插槽中，然后是数组元素。</p><p>⚠️ 警告: Solidity 中有一些需要临时存储区的操作需要大于 64 个字节，因此无法放入暂存空间。它们将被放置在空闲内存指向的位置，但是由于使用寿命短，指针不会更新。内存可以归零，也可以不归零。因此，不应指望空闲内存指针指向归零内存区域。</p><p>尽管使用 <code>msize</code>到达绝对归零的内存区域似乎是一个好主意，但使用此类非临时指针而不更新空闲内存指针可能会产生意外结果。</p><h3 id="与存储中布局的不同"><a href="#与存储中布局的不同" class="headerlink" title="与存储中布局的不同"></a>与存储中布局的不同</h3><p>如上所述，在内存中的布局与在 <strong>存储中</strong> 有一些不同。下面是一些例子：</p><h4 id="数组的不同"><a href="#数组的不同" class="headerlink" title="数组的不同"></a>数组的不同</h4><p>下面的数组在存储中占用 32 字节（1 个槽），但在内存中占用 128 字节（4 个元素，每个 32 字节）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint8[4] a;</span><br></pre></td></tr></table></figure><h4 id="结构体的不同"><a href="#结构体的不同" class="headerlink" title="结构体的不同"></a>结构体的不同</h4><p>下面的结构体在存储中占用 96 (1 个槽，每个 32 字节) ，但在内存中占用 128<br>个字节（4 个元素每个 32 字节）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct S &#123;</span><br><span class="line">    uint a;</span><br><span class="line">    uint b;</span><br><span class="line">    uint8 c;</span><br><span class="line">    uint8 d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Call-Data-布局"><a href="#Call-Data-布局" class="headerlink" title="Call Data 布局"></a>Call Data 布局</h1><p>假定：函数调用的输入数据采用 ABI 规范。</p><p>其中，ABI 规范要求将参数填充为 32 的倍数 个字节。内部函数调用使用不同的约定。</p><p>合约构造函数的参数直接附加在合约代码的末尾，也采用 ABI 编码。构造函数将通过硬编码偏移量，而不是通过使用 <code>codesize</code> 操作码来访问它们，因为在将数据追加到代码时，它就会会改变。</p><h1 id="清理变量"><a href="#清理变量" class="headerlink" title="清理变量"></a>清理变量</h1><p>当一个值短于 256 位时，在某些情况下，剩余位必须被清理。编译器在设计时，会在操作数据之前清理这些剩余位，以避免剩余位中潜在垃圾数据在操作产生任何不利影响。</p><ul><li>在将一个值写入存储器之前，需要清除剩余的位，因为存储器的内容可以用于计算哈希值或作为消息调用的数据发送。</li><li>同样，在将一个值存储到存储器中之前，也需要清除剩余的位，因为否则可以观察到垃圾数据。</li><li>如果紧接着的操作不受影响，就不会清理位。例如，由于任何非零值都会被 <code>JUMPI</code> 指令认为是 <code>true</code>，所以在布尔值被用作条件判断之前，不需要清理它们。 <code>JUMPI</code>。</li><li>编译器会在将输入数据（input data）加载到堆栈时，会对其进行清理。</li></ul><p>⚠️ 注意：通过内联汇编的访问数据没有此操作。如果使用内联汇编来访问短于 256 位的 Solidity 变量，编译器不保证该值被正确清理。</p><p>不同的类型有不同的清理无效值的规则：</p><table><thead><tr><th>Type</th><th>Valid Values</th><th>Invalid Values Mean</th></tr></thead><tbody><tr><td>enum of nmembers</td><td>0 until n - 1</td><td>exception</td></tr><tr><td>bool</td><td>0 or 1</td><td>1</td></tr><tr><td>signed integers</td><td>sign-extended word</td><td>currently silently wraps; in the future exceptions will be thrown</td></tr><tr><td>unsigned integers</td><td>higher bits zeroed</td><td>currently silently wraps; in the future exceptions will be thrown</td></tr></tbody></table><h1 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h1><ul><li>存储大小少于 32 字节的多个变量会被打包到一个存储插槽(storage slot)中，规则是什么？<ul><li>存储插槽的第一项会以低位对齐的方式储存。</li><li>值类型仅使用存储它们所需的字节。</li><li>如果存储插槽中的剩余空间不足以储存一个值类型，那么它会被存入下一个存储插槽。</li><li>结构体（struct）和数组数据总是会开启一个新插槽（但结构体或数组中的各元素，则按规则紧密打包）。</li><li>结构体和数组之后的数据也或开启一个新插槽。</li></ul></li><li>在使用小于 32 字节的变量时，合约的 gas 使用量可能会高于使用 32 字节的元素。为什么？<ul><li>这是因为 EVM 每次操作 32 个字节，所以如果元素比 32 字节小，EVM 必须执行额外的操作以便将其大小缩减到到所需的大小。</li></ul></li><li>Solidity 保留了四个 32 字节的插槽，分别是什么，用来做什么？<ul><li><code>0x00</code> - <code>0x3f</code> (64 字节): 用于哈希方法的<strong>暂存空间</strong>（临时空间）</li><li><code>0x40</code> - <code>0x5f</code> (32 字节): 当前分配的内存大小(也作为<strong>空闲内存指针</strong>)</li><li><code>0x60</code> - <code>0x7f</code> (32 字节): <strong>零位插槽</strong></li><li><strong>暂存空间</strong>可以在语句之间使用 (例如在内联汇编中)。<strong>零位插槽</strong>用作动态内存数组的初始值，并且永远不应写入（空闲内存指针最初指向<code>0x80</code>）.Solidity 总是将新对象放在<strong>空闲内存指针</strong>上，并且内存永远不会被释放(将来可能会改变)。</li></ul></li><li>memory 与 storge 之间不同之处有哪些？<ul><li>数组的不同</li><li>结构体的不同</li><li>原因都是因为内存中每条数据都单独占 32 字节，而在 storge 里，可以储存在一个存储插槽中。</li></ul></li><li>calldata 布局<ul><li>函数调用的输入数据采用 ABI 规范。</li><li>ABI 规范要求将参数填充为 32 的倍数 个字节。</li><li>合约构造函数的参数直接附加在合约代码的末尾，也采用 ABI 编码。构造函数将通过硬编码偏移量，而不是通过使用 <code>codesize</code> 操作码来访问它们，因为在将数据追加到代码时，它就会会改变。</li></ul></li><li>聊一聊清理变量<ul><li>当一个值短于 256 位时，在某些情况下，剩余位必须被清理。编译器在设计时，会在操作数据之前清理这些剩余位，以避免剩余位中潜在垃圾数据在操作产生任何不利影响。</li><li>在将一个值写入存储器之前，需要清除剩余的位，因为存储器的内容可以用于计算哈希值或作为消息调用的数据发送。</li><li>同样，在将一个值存储到存储器中之前，也需要清除剩余的位，因为否则可以观察到垃圾数据。</li><li>如果紧接着的操作不受影响，就不会清理位。例如，由于任何非零值都会被 <code>JUMPI</code> 指令认为是 <code>true</code>，所以在布尔值被用作条件判断之前，不需要清理它们。 <code>JUMPI</code>。</li><li>编译器会在将输入数据（input data）加载到堆栈时，会对其进行清理。</li><li>⚠️ 注意：通过内联汇编的访问数据没有此操作。如果使用内联汇编来访问短于 256 位的 Solidity 变量，编译器不保证该值被正确清理。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-ABI编码</title>
      <link href="/2022/07/26/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/18-ABI%E7%BC%96%E7%A0%81/"/>
      <url>/2022/07/26/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/18-ABI%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>ABI 是应用二进制接口，ABI 是从区块链外部与合约进行交互以及合约与合约间进行交互的一种标准方式。数据会根据其类型进行编码。需要一种特定的概要（schema）来进行解码。</p><p>对于一些没有开源的代码，我们可以通过区块链上传入的参数，来反推数据结构，根据方法的结果，来反推内部实现逻辑。经常听到一些没有开源的合约被盗，基本就是被别人通过 ABI 编码反推来寻找漏洞的。</p><h1 id="ABI-类型编码"><a href="#ABI-类型编码" class="headerlink" title="ABI 类型编码"></a>ABI 类型编码</h1><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><ul><li><code>uint&lt;M&gt;</code>： <code>M</code> 位的无符号整数， <code>0 &lt; M &lt;= 256</code>、<code>M % 8 == 0</code>。例如： <code>uint32</code>， <code>uint8</code>， <code>uint256</code>。</li><li><code>int&lt;M&gt;</code>：以 2 的补码作为符号的 <code>M</code> 位整数， <code>0 &lt; M &lt;= 256</code>、<code>M % 8 == 0</code>。</li><li><code>address</code>：除了字面上的意思和语言类型的区别以外，等价于<code>uint160</code>。在计算和 函数选择器(function selector) 中，通常使用 <code>address</code>。</li><li><code>uint</code>、 <code>int</code>： <code>uint256</code>、 <code>int256</code> 各自的同义词。在计算和函数选择器(function selector) 中，通常使用 <code>uint256</code> 和 <code>int256</code>。</li><li><code>bool</code>：等价于 <code>uint8</code>，取值限定为 0 或 1 。在计算和函数选择器(function selector) 中，通常使用 <code>bool</code>。</li><li><code>fixed&lt;M&gt;x&lt;N&gt;</code>： <code>M</code> 位的有符号的固定小数位的十进制数字<code>8 &lt;= M &lt;= 256</code>、 <code>M % 8 == 0</code>、且 <code>0 &lt; N &lt;= 80</code>。其值 <code>v</code> 即是<code>v / (10 ** N)</code>。</li><li><code>ufixed&lt;M&gt;x&lt;N&gt;</code>：无符号的 <code>fixed&lt;M&gt;x&lt;N&gt;</code>。</li><li><code>fixed</code>、 <code>ufixed</code>： <code>fixed128x18</code>、 <code>ufixed128x18</code>各自的同义词。在计算和 函数选择器(function selector) 中，通常使用<code>fixed128x18</code> 和 <code>ufixed128x18</code>。</li><li><code>bytes&lt;M&gt;</code>： <code>M</code> 字节的二进制类型， <code>0 &lt; M &lt;= 32</code>。</li><li><code>function</code>：一个地址（20 字节）之后紧跟一个 函数选择器(function selector)（4 字节）。编码之后等价于 <code>bytes24</code>。</li></ul><h3 id="定长数组类型"><a href="#定长数组类型" class="headerlink" title="定长数组类型"></a>定长数组类型</h3><ul><li><type>[M]：有M个元素的定长数组，M &gt;&#x3D; 0，数组元素为给定类型。<ul><li>⚠️：尽管此 ABI 规范可以表示零个元素的定长数组，但编译器不支持它们。</li></ul></li></ul><h3 id="非定长类型："><a href="#非定长类型：" class="headerlink" title="非定长类型："></a>非定长类型：</h3><ul><li><p><code>bytes</code>：动态大小的字节序列。</p></li><li><p><code>string</code>：动态大小的 unicode 字符串，通常呈现为 UTF-8 编码。</p></li><li><p><type>[]：元素为给定类型的变长数组。</p><ul><li>可以将若干类型放到一对括号中，用逗号分隔开，以此来构成一个 元组(tuple)：</li></ul></li><li><p><code>(T1,T2,...,Tn)</code>：由 <code>T1</code>，…， <code>Tn</code>， <code>n &gt;= 0</code> 构成的 元组(tuple)。</p></li></ul><p>用 元组(tuple) 构成 元组(tuple)、用 元组(tuple)构成数组等等也是可能的。另外也可以构成”零元组（zero-tuples）”，就是<br><code>n = 0</code> 的情况。</p><h3 id="不支持-ABI-的-Solidity-类型"><a href="#不支持-ABI-的-Solidity-类型" class="headerlink" title="不支持 ABI 的 Solidity 类型"></a>不支持 ABI 的 Solidity 类型</h3><p>Solidity 支持上面介绍的所有同名称的类型，除元组外。 另一方面，一些 Solidity 类型不被 ABI 支持。下表在左栏显示了不支持 ABI 的 Solidity 类型，以及在右栏显示可以代表它们的 ABI 类型。</p><table><thead><tr><th>Solidity</th><th>ABI</th></tr></thead><tbody><tr><td>address payable</td><td><code>address</code></td></tr><tr><td>contract</td><td><code>address</code></td></tr><tr><td>enum</td><td><code>uint8</code></td></tr><tr><td>user defined value types</td><td>its underlying value type</td></tr><tr><td>struct</td><td><code>tuple</code></td></tr></tbody></table><p>⚠️: 在 <code>0.8.0</code> 版本之前，枚举（enums） 可以多余 256 个成员并且可以使用最小可保存的整型来保存他们。</p><h1 id="ABI编码的设计准则"><a href="#ABI编码的设计准则" class="headerlink" title="ABI编码的设计准则"></a>ABI编码的设计准则</h1><p>我们现在来正式讲述编码，它具有如下属性，如果参数是嵌套的数组，这些属性非常有用：</p><ol><li>读取的次数取决于参数数组结构中的最大深度；也就是说，要取得<code>a_i[k][l][r]</code> 需要读取 4 次。</li><li>变量或数组元素的数据不与其他数据交错，并且它是可以再定位的。它们只会使用相对的”地址”。</li></ol><h1 id="编码的形式化说明"><a href="#编码的形式化说明" class="headerlink" title="编码的形式化说明"></a>编码的形式化说明</h1><p>我们需要区分静态和动态类型。静态类型会被直接编码，动态类型则会在当前数据块之后单独分配的位置被编码。</p><p><strong>定义：</strong> 以下类型被称为”动态”：</p><ul><li><code>bytes</code></li><li><code>string</code></li><li>任意类型 <code>T</code> 的变长数组 <code>T[]</code></li><li>任意动态类型 <code>T</code> 的定长数组 <code>T[k]</code> （ <code>k &gt;= 0</code>）</li><li>由动态的 <code>Ti</code> （ <code>1 &lt;= i &lt;= k</code>）构成的 元组(tuple) <code>(T1,...,Tk)</code></li></ul><p>所有其他类型都被称为”静态”。</p><p><strong>定义：</strong> <code>len(a)</code> 是一个二进制字符串 <code>a</code> 的字节长度。 <code>len(a)</code>的类型被呈现为 <code>uint256</code>。</p><p>我们把实际的编码 <code>enc</code>定义为一个由 ABI 类型到二进制字符串的值的映射；因而，当且仅当 <code>X</code>的类型是动态的， <code>len(enc(X))</code> （即 <code>X</code>经编码后的实际长度，译者注）才会依赖于 <code>X</code> 的值。</p><p><strong>定义：</strong> 对任意 ABI 值 <code>X</code>，我们根据 <code>X</code> 的实际类型递归地定义 <code>enc(X)</code>。</p><ul><li><p><code>(T1,...,Tk)</code> 对于 <code>k &gt;= 0</code> 且任意类型 <code>T1</code> ,…, <code>Tk</code></p><p><code>enc(X) = head(X(1)) ... head(X(k)) tail(X(1)) ... tail(X(k))</code></p><p>这里， <code>X = (X(1), ..., X(k))</code>，并且 当 <code>Ti</code> 为静态类型时， <code>head</code>和 <code>tail</code> 被定义为<code>head(X(i)) = enc(X(i))</code> and <code>tail(X(i)) = &quot;&quot;</code> （空字符串）否则，比如 <code>Ti</code> 是动态类型时，它们被定义为</p></li></ul><p><code>head(X(i)) = enc(len(head(X(1)) ... head(X(k-1)) tail(X(1)) ... tail(X(i-1))))</code><br>  <code>tail(X(i)) = enc(X(i))</code></p><p>  注意，在动态类型的情况下，由于 head部分的长度仅取决于类型而非值，所以 <code>head(X(i))</code>是定义明确的。它的值是从 <code>enc(X)</code> 的开头算起的，<code>tail(X(i))</code>的起始位在 <code>enc(X)</code> 中的偏移量。</p><ul><li><p><code>T[k]</code> 对于任意 <code>T</code> 和 <code>k</code>：<code>enc(X) = enc((X[0], ..., X[k-1]))</code>即是说，它就像是个由相同类型的 <code>k</code> 个元素组成的 元组(tuple)那样被编码的。</p></li><li><p><code>T[]</code> 当 <code>X</code> 有 <code>k</code> 个元素（ <code>k</code> 被呈现为类型 <code>uint256</code>）：<code>enc(X) = enc(k) enc([X[1], ..., X[k]])</code>即是说，它就像是个由静态大小 <code>k</code>的数组那样被编码的，且由元素的个数作为前缀。</p></li><li><p>具有 <code>k</code> （呈现为类型 <code>uint256</code>）长度的 <code>bytes</code>：<code>enc(X) = enc(k) pad_right(X)</code>，即是说，字节数被编码为<code>uint256</code>，紧跟着实际的 <code>X</code> 的字节码序列，再在高位（左侧）补上可以使<code>len(enc(X))</code> 成为 32 的倍数的最少数量的 0 值字节数据。</p></li><li><p><code>string</code>：<code>enc(X) = enc(enc_utf8(X))</code>，即是说， <code>X</code> 被 UFT-8<br>编码，且在后续编码中将这个值解释为 <code>bytes</code>类型。注意，在随后的编码中使用的长度是其 UFT-8编码的字符串的字节数，而不是其字符数。</p></li><li><p><code>uint&lt;M&gt;</code>： <code>enc(X)</code> 是在 <code>X</code> 的大端序编码的高位（左侧）补充若干 0值字节以使其长度成为 32 字节。</p></li><li><p><code>address</code>：与 <code>uint160</code> 的情况相同。</p></li><li><p><code>int&lt;M&gt;</code>： <code>enc(X)</code> 是在 <code>X</code> 的大端序的 2的补码编码的高位（左侧）添加若干字节数据以使其长度成为 32字节；对于负数，添加值为 <code>0xff</code> （即 8 位全为1，译者注）的字节数据，对于非负数，添加 0 值（即 8 位全为0，译者注）字节数据。</p></li><li><p><code>bool</code>：与 <code>uint8</code> 的情况相同， <code>1</code> 用来表示 <code>true</code>， <code>0</code> 表示<code>false</code>。</p></li><li><p><code>fixed&lt;M&gt;x&lt;N&gt;</code>： <code>enc(X)</code> 就是 <code>enc(X * 10**N)</code>，其中 <code>X * 10**N</code>可以理解为 <code>int256</code>。</p></li><li><p><code>fixed</code>：与 <code>fixed128x18</code> 的情况相同。</p></li><li><p><code>ufixed&lt;M&gt;x&lt;N&gt;</code>： <code>enc(X)</code> 就是 <code>enc(X * 10**N)</code>，其中 <code>X * 10**N</code>可以理解为 <code>uint256</code>。</p></li><li><p><code>ufixed</code>：与 <code>ufixed128x18</code> 的情况相同。</p></li><li><p><code>bytes&lt;M&gt;</code>： <code>enc(X)</code> 就是 <code>X</code> 的字节序列加上为使长度成为 32字节而添加的若干 0 值字节。</p></li></ul><p>注意，对于任意的 <code>X</code>， <code>len(enc(X))</code> 都是 32 的倍数。</p><h1 id="函数选择器和参数编码"><a href="#函数选择器和参数编码" class="headerlink" title="函数选择器和参数编码"></a>函数选择器和参数编码</h1><p>函数选择器(function selector)：以 <code>a_1, ..., a_n</code> 为参数的对 <code>f</code> 函数的调用，会被编码为<code>function_selector(f) enc((a_1, ..., a_n))</code>，<code>f</code> 的返回值 <code>v_1, ..., v_k</code> 会被编码为 <code>enc((v_1, ..., v_k))</code>，也就是说，返回值会被组合为一个 元组(tuple) 进行编码。</p><h3 id="函数选择器-function-selector"><a href="#函数选择器-function-selector" class="headerlink" title="函数选择器 function selector"></a>函数选择器 function selector</h3><p>这个在 <a href="https://www.axihe.com/source/04.function.html#id19">函数的签名</a> 那里已经详细介绍过，之类做一个小总结。</p><p>一个函数调用数据的前 4 字节，指定了要调用的函数。这就是某个函数签名的 Keccak 哈希的前 4 字节（bytes32 类型是从左取值）。</p><p>函数签名被定义为基础原型的规范表达，而基础原型是<strong>函数名称加上由括号括起来的参数类型列表，参数类型间由一个逗号分隔开，且没有空格。</strong>.</p><p>⚠️ 注意: 函数的返回类型并不是函数签名的一部分。在 <a href="https://www.axihe.com/source/04.function.html#id21">Solidity 的函数重载</a> 中，返回值并没有被考虑。这是为了使对函数调用的解析保持上下文无关。 然而 metadata 的描述中即包含了输入也包含了输出。（参考 <a href="https://www.axihe.com/source/17.metadata.html">JSON ABI</a>）。</p><h3 id="参数编码"><a href="#参数编码" class="headerlink" title="参数编码"></a>参数编码</h3><p>从第 5 字节开始是被编码的参数。这种编码方式也被用在其他地方，比如，返回值和事件的参数也会被用同样的方式进行编码，而用来指定函数的 4 个字节则不需要再进行编码。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>给定一个合约：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.4.16 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">  function bar(bytes3[2]) public pure &#123;&#125;</span><br><span class="line">  function baz(uint32 x, bool y) public pure returns (bool r) &#123; r = x &gt; 32 || y; &#125;</span><br><span class="line">  function sam(bytes, bool, uint[]) public pure &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用-baz"><a href="#调用-baz" class="headerlink" title="调用 baz"></a>调用 baz</h3><p>这样，对于我们的例子 <code>Foo</code>，如果我们想用 <code>69</code> 和 <code>true</code> 做参数调用 <code>baz</code>，我们总共需要传送 68 字节，可以分解为：</p><ul><li><code>0xcdcd77c0</code>：方法 ID。这源自 ASCII 格式的 <code>baz(uint32,bool)</code> 签名的<br>Keccak 哈希的前 4 字节。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000045</code>：第一个参数，一个被用<br>0 值字节补充到 32 字节的 uint32 值 <code>69</code>。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：第二个参数，一个被用<br>0 值字节补充到 32 字节的 boolean 值 <code>true</code>。</li></ul><p>合起来就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xcdcd77c0</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000045</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000001</span><br></pre></td></tr></table></figure><p>它返回一个 <code>bool</code>。比如它返回 <code>false</code>，那么它的输出将是一个字节数组<br><code>0x0000000000000000000000000000000000000000000000000000000000000000</code>，一个 bool 值。</p><h3 id="调用-bar"><a href="#调用-bar" class="headerlink" title="调用 bar"></a>调用 bar</h3><p>如果我们想用 <code>[&quot;abc&quot;, &quot;def&quot;]</code> 做参数调用<code>bar</code>，我们总共需要传送 68 字节，可以分解为：</p><ul><li><code>0xfce353f6</code>：方法 ID。源自 <code>bar(bytes3[2])</code> 的签名。</li><li><code>0x6162630000000000000000000000000000000000000000000000000000000000</code>：第一个参数的第一部分，一个<code>bytes3</code> 值 <code>&quot;abc&quot;</code> （左对齐）。</li><li><code>0x6465660000000000000000000000000000000000000000000000000000000000</code>：第一个参数的第二部分，一个 <code>bytes3</code> 值 <code>&quot;def&quot;</code> （左对齐）。</li></ul><p>合起来就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xfce353f6</span><br><span class="line">6162630000000000000000000000000000000000000000000000000000000000</span><br><span class="line">6465660000000000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><h3 id="调用-sam"><a href="#调用-sam" class="headerlink" title="调用 sam"></a>调用 sam</h3><p>如果我们想用 <code>&quot;dave&quot;</code>、 <code>true</code> 和 <code>[1,2,3]</code> 作为参数调用<code>sam</code>，我们总共需要传送 292 字节，可以分解为：</p><ul><li><code>0xa5643bf2</code>：方法 ID。源自 <code>sam(bytes,bool,uint256[])</code>的签名。注意， <code>uint</code> 被替换为了它的权威代表 <code>uint256</code>。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000060</code>：第一个参数（动态类型）的数据部分的位置，即从参数编码块开始位置算起的字节数。在这里，是 <code>0x60</code> 。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：第二个参数：boolean 的 true。</li><li><code>0x00000000000000000000000000000000000000000000000000000000000000a0</code>：第三个参数（动态类型）的数据部分的位置，由字节数计量。在这里，是<code>0xa0</code>。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000004</code>：第一个参数的数据部分，以字节数组的元素个数作为开始，在这里，是 4。</li><li><code>0x6461766500000000000000000000000000000000000000000000000000000000</code>：第一个参数的内容 <code>&quot;dave&quot;</code> 的 UTF-8 编码（在这里等同于 ASCII 编码），并在右侧（低位）用 0 值字节补充到 32 字节。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000003</code>：第三个参数的数据部分，以数组的元素个数作为开始，在这里，是 3。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：第三个参数的第一个数组元素。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000002</code>：第三个参数的第二个数组元素。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000003</code>：第三个参数的第三个数组元素。</li></ul><p>合起来就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0xa5643bf2</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000060</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000001</span><br><span class="line">00000000000000000000000000000000000000000000000000000000000000a0</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000004</span><br><span class="line">6461766500000000000000000000000000000000000000000000000000000000</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000003</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000001</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000003</span><br></pre></td></tr></table></figure><h1 id="动态类型的使用"><a href="#动态类型的使用" class="headerlink" title="动态类型的使用"></a>动态类型的使用</h1><h3 id="例子-1-静态和动态混合"><a href="#例子-1-静态和动态混合" class="headerlink" title="例子 1:静态和动态混合"></a>例子 1:静态和动态混合</h3><p>用参数 <code>(0x123, [0x456, 0x789], &quot;1234567890&quot;, &quot;Hello, world!&quot;)</code> 进行对函数 <code>f(uint,uint32[],bytes10,bytes)</code> 的调用会通过以下方式进行编码：</p><p>取得 <code>sha3(&quot;f(uint256,uint32[],bytes10,bytes)&quot;)</code> 的前 4 字节，也就是 <code>0x8be65246</code>。 然后我们对所有 4 个参数的头部进行编码。对静态类型 <code>uint256</code> 和 <code>bytes10</code> 是可以直接传过去的值；对于动态类型 <code>uint32[]</code> 和 <code>bytes</code>，<strong>我们使用的字节数偏移量是它们的数据区域的起始位置，由需编码的值的开始位置算起</strong>（也就是说，不计算包含了函数签名的前 4 字节），这就是：</p><p><strong>基础部分</strong>：</p><ul><li><code>0x8be65246</code></li><li><code>0x0000000000000000000000000000000000000000000000000000000000000123</code> <code>0x123</code> 补充到 32 字节）</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000080</code>（第二个参数的数据部分起始位置的偏移量，<code>4*32</code> 字节，正好是头部的大小）</li><li><code>0x3132333435363738393000000000000000000000000000000000000000000000</code>（<code>&quot;1234567890&quot;</code> 从右边补充到 32 字节）</li><li><code>0x00000000000000000000000000000000000000000000000000000000000000e0</code>（第四个参数的数据部分起始位置的偏移量 &#x3D;<br>第一个动态参数的数据部分起始位置的偏移量 + 第一个动态参数的数据部分的长度 &#x3D; <code>4*32 + 3*32</code>，参考后文）</li></ul><p><strong>动态部分</strong>：</p><p>在此之后，跟着<strong>第一个动态参数</strong>的数据部分 <code>[0x456, 0x789]</code>：</p><ul><li><code>0x0000000000000000000000000000000000000000000000000000000000000002</code>（数组元素个数，2）</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000456</code>（第一个数组元素）</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000789</code>（第二个数组元素）</li></ul><p>最后，我们将<strong>第二个动态参数</strong>的数据部分 <code>&quot;Hello, world!&quot;</code> 进行编码：</p><ul><li><code>0x000000000000000000000000000000000000000000000000000000000000000d</code>（元素个数，在这里是字节数：13）</li><li><code>0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000</code>（ <code>&quot;Hello, world!&quot;</code> 从右边补充到 32 字节）</li></ul><p>最后，合并到一起的编码就是（为了清晰，在 函数选择器(function selector) 和每 32 字节之后加了换行）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x8be65246</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000123</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000080</span><br><span class="line">3132333435363738393000000000000000000000000000000000000000000000</span><br><span class="line">00000000000000000000000000000000000000000000000000000000000000e0</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000456</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000789</span><br><span class="line">000000000000000000000000000000000000000000000000000000000000000d</span><br><span class="line">48656c6c6f2c20776f726c642100000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><hr><h3 id="例子-2-纯动态参数"><a href="#例子-2-纯动态参数" class="headerlink" title="例子 2: 纯动态参数"></a>例子 2: 纯动态参数</h3><p>让我们使用相同的原理来对一个签名为 <code>g(uint[][],string[])</code>，参数值为<code>([[1, 2], [3]], [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])</code>的函数来进行编码；但从最原子的部分开始：</p><p>首先我们将第一个根数组 <code>[[1, 2], [3]]</code> 的第一个嵌入的动态数组 <code>[1, 2]</code>的长度和数据进行编码：</p><ul><li><code>0x0000000000000000000000000000000000000000000000000000000000000002</code>(第一个数组中的元素数量 2；元素本身是 <code>1</code> 和 <code>2</code>)</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>(第一个元素)</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000002</code>(第二个元素)</li></ul><p>然后我们将第一个根数组 <code>[[1, 2], [3]]</code> 的第二个潜入的动态数组 <code>[3]</code>的长度和数据进行编码：</p><ul><li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>(第二个数组中的元素数量 1；元素数据是 <code>3</code>)</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000003</code>(第一个元素)</li></ul><p>然后我们需要找到动态数组 <code>[1, 2]</code> 和 <code>[3]</code>的偏移量。要计算这个偏移量，我们可以来看一下第一个根数组 <code>[[1, 2], [3]]</code>编码后的具体数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 - a                                                                - [1, 2] 的偏移量</span><br><span class="line">1 - b                                                                - [3] 的偏移量</span><br><span class="line">2 - 0000000000000000000000000000000000000000000000000000000000000002 - [1, 2] 的计数</span><br><span class="line">3 - 0000000000000000000000000000000000000000000000000000000000000001 - 1 的编码</span><br><span class="line">4 - 0000000000000000000000000000000000000000000000000000000000000002 - 2 的编码</span><br><span class="line">5 - 0000000000000000000000000000000000000000000000000000000000000001 - [3] 的计数</span><br><span class="line">6 - 0000000000000000000000000000000000000000000000000000000000000003 - 3 的编码</span><br></pre></td></tr></table></figure><p>偏移量 <code>a</code> 指向数组 <code>[1, 2]</code> 内容的开始位置，即第 2 行的开始（64 字节）；所以 <code>a = 0x0000000000000000000000000000000000000000000000000000000000000040</code>。</p><p>偏移量 <code>b</code> 指向数组 <code>[3]</code> 内容的开始位置，即第 5 行的开始（160 字节）；所以 <code>b = 0x00000000000000000000000000000000000000000000000000000000000000a0</code>。</p><p>然后我们对第二个根数组的嵌入字符串进行编码：</p><ul><li><code>0x0000000000000000000000000000000000000000000000000000000000000003</code>(单词 <code>&quot;one&quot;</code> 中的字符个数)</li><li><code>0x6f6e650000000000000000000000000000000000000000000000000000000000</code>(单词 <code>&quot;one&quot;</code> 的 utf8 编码)</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000003</code>(单词 <code>&quot;two&quot;</code> 中的字符个数)</li><li><code>0x74776f0000000000000000000000000000000000000000000000000000000000</code>(单词 <code>&quot;two&quot;</code> 的 utf8 编码)</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000005</code>(单词 <code>&quot;three&quot;</code> 中的字符个数)</li><li><code>0x7468726565000000000000000000000000000000000000000000000000000000</code>(单词 <code>&quot;three&quot;</code> 的 utf8 编码)</li></ul><p>作为与第一个根数组的并列，因为字符串也属于动态元素，我们也需要找到它们的偏移量 <code>c</code>, <code>d</code> 和 <code>e</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 - c                                                                - &quot;one&quot; 的偏移量</span><br><span class="line">1 - d                                                                - &quot;two&quot; 的偏移量</span><br><span class="line">2 - e                                                                - &quot;three&quot; 的偏移量</span><br><span class="line">3 - 0000000000000000000000000000000000000000000000000000000000000003 - &quot;one&quot; 的字符计数</span><br><span class="line">4 - 6f6e650000000000000000000000000000000000000000000000000000000000 - &quot;one&quot; 的编码</span><br><span class="line">5 - 0000000000000000000000000000000000000000000000000000000000000003 - &quot;two&quot; 的字符计数</span><br><span class="line">6 - 74776f0000000000000000000000000000000000000000000000000000000000 - &quot;two&quot; 的编码</span><br><span class="line">7 - 0000000000000000000000000000000000000000000000000000000000000005 - &quot;three&quot; 的字符计数</span><br><span class="line">8 - 7468726565000000000000000000000000000000000000000000000000000000 - &quot;three&quot; 的编码</span><br></pre></td></tr></table></figure><p>偏移量 <code>c</code> 指向字符串 <code>&quot;one&quot;</code> 内容的开始位置，即第 3 行的开始（96 字节）；所以<code>c = 0x0000000000000000000000000000000000000000000000000000000000000060</code>。</p><p>偏移量 <code>d</code> 指向字符串 <code>&quot;two&quot;</code> 内容的开始位置，即第 5 行的开始（160 字节）；所以<code>d = 0x00000000000000000000000000000000000000000000000000000000000000a0</code>。</p><p>偏移量 <code>e</code> 指向字符串 <code>&quot;three&quot;</code> 内容的开始位置，即第 7 行的开始（224 字节）；所以<code>e = 0x00000000000000000000000000000000000000000000000000000000000000e0</code>。</p><p>注意，根数组的嵌入元素的编码并不互相依赖，且具有对于函数签名<code>g(string[],uint[][])</code> 所相同的编码。</p><p>然后我们对第一个根数组的长度进行编码：</p><ul><li><code>0x0000000000000000000000000000000000000000000000000000000000000002</code>(第一个根数组的元素数量 2；这些元素本身是 <code>[1, 2]</code> 和 <code>[3]</code>)</li></ul><p>而后我们对第二个根数组的长度进行编码：</p><ul><li><code>0x0000000000000000000000000000000000000000000000000000000000000003</code>(第二个根数组的元素数量 3；这些字符串本身是 <code>&quot;one&quot;</code>、<code>&quot;two&quot;</code> 和<code>&quot;three&quot;</code>)</li></ul><p>最后，我们找到根动态数组元素 <code>[[1, 2], [3]]</code> 和<code>[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</code> 的偏移量 <code>f</code> 和 <code>g</code>。汇编数据的正确顺序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0x2289b18c                                                            - 函数签名</span><br><span class="line"> 0 - f                                                                - [[1, 2], [3]] 的偏移量</span><br><span class="line"> 1 - g                                                                - 第二个参数的偏移量</span><br><span class="line"> 2 - 0000000000000000000000000000000000000000000000000000000000000002 - [[1, 2], [3]] 元素计数</span><br><span class="line"> 3 - 0000000000000000000000000000000000000000000000000000000000000040 - [1, 2] 的偏移量</span><br><span class="line"> 4 - 00000000000000000000000000000000000000000000000000000000000000a0 - [3] 的偏移量</span><br><span class="line"> 5 - 0000000000000000000000000000000000000000000000000000000000000002 - [1, 2] 的元素计数</span><br><span class="line"> 6 - 0000000000000000000000000000000000000000000000000000000000000001 - 1 的编码</span><br><span class="line"> 7 - 0000000000000000000000000000000000000000000000000000000000000002 - 2 的编码</span><br><span class="line"> 8 - 0000000000000000000000000000000000000000000000000000000000000001 - [3] 的元素计数</span><br><span class="line"> 9 - 0000000000000000000000000000000000000000000000000000000000000003 - 3 的编码</span><br><span class="line">10 - 0000000000000000000000000000000000000000000000000000000000000003 - 第二个参数元素计数</span><br><span class="line">11 - 0000000000000000000000000000000000000000000000000000000000000060 - &quot;one&quot; 的偏移量</span><br><span class="line">12 - 00000000000000000000000000000000000000000000000000000000000000a0 - &quot;two&quot; 的偏移量</span><br><span class="line">13 - 00000000000000000000000000000000000000000000000000000000000000e0 - &quot;three&quot; 的偏移量</span><br><span class="line">14 - 0000000000000000000000000000000000000000000000000000000000000003 - &quot;one&quot; 的字符计数</span><br><span class="line">15 - 6f6e650000000000000000000000000000000000000000000000000000000000 - &quot;one&quot; 的编码</span><br><span class="line">16 - 0000000000000000000000000000000000000000000000000000000000000003 - &quot;two&quot; 的字符计数</span><br><span class="line">17 - 74776f0000000000000000000000000000000000000000000000000000000000 - &quot;two&quot; 的编码</span><br><span class="line">18 - 0000000000000000000000000000000000000000000000000000000000000005 - &quot;three&quot; 的字符计数</span><br><span class="line">19 - 7468726565000000000000000000000000000000000000000000000000000000 - &quot;three&quot; 的编码</span><br></pre></td></tr></table></figure><p>偏移量 <code>f</code> 指向数组 <code>[[1, 2], [3]]</code> 内容的开始位置，即第 2 行的开始（64 字节）；所以<code>f = 0x0000000000000000000000000000000000000000000000000000000000000040</code>。</p><p>偏移量 <code>g</code> 指向数组 <code>[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</code> 内容的开始位置，即第 10 行的开始（320 字节）；所以 <code>g = 0x0000000000000000000000000000000000000000000000000000000000000140</code>。</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>事件是以太坊的日志，事件是监视协议的一个抽象。日志项提供了合约的地址、一系列的<code>indexed</code>（最多 4 项）和一些任意长度的二进制数据。为了使用合适的类型数据结构来演绎这些功能，事件沿用了既存的 ABI 函数。</p><p>给定了事件名称和事件参数之后，我们将其分解为两个子集：已索引的和未索引的。已索引的部分，最多有 3 个（对于非匿名事件）或 4 个（对于匿名事件），被用来与事件签名的 Keccak 哈希一起组成日志项的主题。未索引的部分就组成了事件的字节数组。</p><p>这样，一个使用 ABI 的日志项就可以描述为：</p><ul><li><p><code>address</code>：合约地址（由 以太坊 真正提供）；</p></li><li><p>topics[0]：keccak(EVENT_NAME+”(“+EVENT_ARGS.map(canonical_type_of).join(“,”)+”)”)</p><ul><li>（ <code>canonical_type_of</code> 是一个可以返回给定参数的权威类型的函数，例如，对 <code>uint indexed foo</code> 它会返回 <code>uint256</code>）。</li><li>如果事件被声明为 <code>anonymous</code>，那么 <code>topics[0]</code> 不会被生成；</li></ul></li><li><p>topics[n]：</p><ul><li>如果不是匿名事件，为 <code>abi_encode(EVENT_INDEXED_ARGS[n - 1])</code></li><li>否则则为 <code>abi_encode(EVENT_INDEXED_ARGS[n])</code>（ <code>EVENT_INDEXED_ARGS</code> 是已索引的 <code>EVENT_ARGS</code>）；</li></ul></li><li><p>data：abi_serialise(EVENT_NON_INDEXED_ARGS)</p><ul><li>（<code>EVENT_NON_INDEXED_ARGS</code> 是未索引的 <code>EVENT_ARGS</code>， <code>abi_serialise</code> 是一个用来从某个函数返回一系列类型值的 ABI 序列化函数，就像上文所讲的那样）。</li></ul></li></ul><p>对于所有定长的 Solidity 类型， <code>EVENT_INDEXED_ARGS</code> 数组会直接包含 32 字节的编码值。</p><p>然而，对于 <em>动态长度的类型</em> ，包含<code>string</code>、 <code>bytes</code> 和数组， <code>EVENT_INDEXED_ARGS</code> 会包含编码值的 <em>Keccak 哈希</em>,而不是直接包含编码值。这样就允许应用程序更有效地查询动态长度类型的值（通过把编码值的哈希设定为主题），但也使应用程序不能对它们还没查询过的已索引的值进行解码。</p><p>对于动态长度的类型，应用程序开发者面临在对预先设定的值（如果参数已被索引）的快速检索和对任意数据的清晰处理（需要参数不被索引）之间的权衡。</p><p>开发者们可以通过定义两个参数（一个已索引、一个未索引）保存同一个值的方式来解决这种权衡，从而既获得高效的检索又能清晰地处理任意数据。</p><h3 id="事件索引参数的编码"><a href="#事件索引参数的编码" class="headerlink" title="事件索引参数的编码"></a>事件索引参数的编码</h3><p>对于不是值类型的事件索引参数，如：数组和结构，是不直接存储的，而是存储一个 keccak256-hash 编码。这个编码被定义如下：</p><ul><li><code>bytes</code> 和 <code>string</code> 的编码只是字符串的内容，没有任何填充或长度前缀。</li><li>结构体的编码是其成员编码的拼接，总是填充为 32 字节的倍数（即便是 <code>bytes</code> 和 <code>string</code> 类型）。</li><li>数组(包含动态和静态大小的数组)的编码是其元素的编码的拼接，总是填充为 32 字节的倍数（即便是 <code>bytes</code> 和 <code>string</code> 类型），并且没有长度前缀</li></ul><p>上面的规范，像往常一样，负数会符号扩展填充，而不是零填充。 <code>bytesNN</code>类型在右边填充，而 <code>uintNN</code> &#x2F; <code>intNN</code> 在左边填充。</p><p>⚠️ 警告: 如果一个结构体包含一个以上的动态大小的数组，那么其编码会模糊有歧义。正因为如此，要经常重新检查事件数据，不能仅仅依靠索引参数的结果。</p><h1 id="错误编码"><a href="#错误编码" class="headerlink" title="错误编码"></a>错误编码</h1><p>在合约内部发生错误的情况下，合约可以使用一个特殊的操作码来中止执行，并恢复所有的状态变化。除了这些效果之外，可以返回描述性数据给调用者。这种描述性数据是对错误及其参数的编码，其方式与函数调用的数据相同。</p><p>例如，让我们考虑以下合约，其 <code>transfer</code> 功能在出现”余额不足”时，提示自定义错误:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract TestToken &#123;</span><br><span class="line">    error InsufficientBalance(uint256 available, uint256 required);</span><br><span class="line">    function transfer(address to, uint amount) public pure &#123;</span><br><span class="line">        revert InsufficientBalance(0, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回错误数据是以函数调用相同的方式编码， <code>InsufficientBalance(0, amount)</code> 与函数 <code>InsufficientBalance(uint256,uint256)</code> 编码一样。 例如为：<code>0xcf479181</code>, <code>uint256(0)</code>, <code>uint256(amount)</code>.</p><p>⚠️ 注意：错误的选择器 <code>0x00000000</code> 和 <code>0xffffffff</code> 被保留将来使用。</p><p>⚠️ 注意：永远不要相信错误数据。默认情况下，错误数据会通过外部调用链向上冒泡，这意味着一个合约可能会收到一个它直接调用的任何合约中没有定义的错误。此外，任何合约都可以通过返回与错误签名相匹配的数据来伪造任何错误，即使该错误没有在任何地方定义。</p><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>合约接口的 JSON 格式是用来描述函数，事件或错误描述的一个数组。</p><h3 id="函数的-JSON"><a href="#函数的-JSON" class="headerlink" title="函数的 JSON"></a>函数的 JSON</h3><p>一个函数的描述是一个有如下字段的 JSON 对象：</p><ul><li><p><code>type</code>： <code>&quot;function&quot;</code>、 <code>&quot;constructor&quot;</code> 或 <code>&quot;fallback&quot;</code></p></li><li><p><code>name</code>：函数名称；</p></li><li><p>inputs：对象数组，每个数组对象会包含：</p><ul><li><code>name</code>：参数名称；</li><li><code>type</code>：参数的权威类型（详见下文）</li><li><code>components</code>：供 元组(tuple) 类型使用（详见下文）</li></ul></li><li><p><code>outputs</code>：一个类似于 <code>inputs</code>的对象数组，如果函数无返回值时可以被省略；</p></li><li><p><code>payable</code>：如果函数接受 以太币 ，为 <code>true</code>；缺省为 <code>false</code>；</p></li><li><p><code>stateMutability</code>：为下列值之一： <code>pure</code> ， <code>view</code>， <code>nonpayable</code> 和 <code>payable</code>。</p></li></ul><p><code>type</code> 可以被省略，缺省为 <code>&quot;function&quot;</code>。</p><p>⚠️ 注意：构造函数 constructor 和 fallback 函数没有 <code>name</code> 或 <code>outputs</code>。fallback 函数也没有 <code>inputs</code>。</p><ul><li>向 non-payable（即不接受 以太币 ）的函数发送非零值的以太币 会回退交易。</li><li>状态可变性 <code>nonpayable</code> 是默认的，不用显示指定。</li></ul><h3 id="事件的-JSON"><a href="#事件的-JSON" class="headerlink" title="事件的 JSON"></a>事件的 JSON</h3><p>一个事件描述是一个有极其相似字段的 JSON 对象：</p><ul><li><p><code>type</code>：总是 <code>&quot;event&quot;</code>；</p></li><li><p><code>name</code>：事件名称；</p></li><li><p>inputs：对象数组，每个数组对象会包含：</p><ul><li><code>name</code>：参数名称；</li><li><code>type</code>：参数的权威类型（相见下文）；</li><li><code>components</code>：供 元组(tuple) 类型使用（详见下文）；</li><li><code>indexed</code>：如果此字段是日志的一个主题，则为 <code>true</code>；否则为<code>false</code>。</li></ul></li><li><p><code>anonymous</code>：如果事件被声明为 <code>anonymous</code>，则为 <code>true</code>。</p></li></ul><h3 id="错误的-JSON"><a href="#错误的-JSON" class="headerlink" title="错误的 JSON"></a>错误的 JSON</h3><p>错误这是一下类似的形式：</p><ul><li><p><code>type</code>: 为 <code>&quot;error&quot;</code></p></li><li><p><code>name</code>: 错误的名称。</p></li><li><p>inputs: 对象数组，每个元素包含：</p><ul><li><code>name</code>: 参数名称。</li><li><code>type</code>: 参数的规范类型（更多详细内容见下文）。</li><li><code>components</code>: 用于元组类型 (更多详细内容见下文).</li></ul></li></ul><p>⚠️ 注意：在 JSON 数组中可能有多个名称相同、甚至签名相同的错误。例如，如果错误来自智能合约中的不同文件，或引用自另一个智能合约。</p><p>对于 ABI 来说，它仅取决于错误的名称，而不是它的定义位置。</p><h3 id="例子演示"><a href="#例子演示" class="headerlink" title="例子演示"></a>例子演示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    bytes32 b;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        b = &quot;0x12&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Event(uint256 indexed a, bytes32 b);</span><br><span class="line">    error InsufficientBalance(uint256 available, uint256 required);</span><br><span class="line"></span><br><span class="line">    function foo(uint256 a) public &#123;</span><br><span class="line">        emit Event(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可由如下 JSON 来表示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;inputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;stateMutability&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nonpayable&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;constructor&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;inputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;internalType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;available&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;internalType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;required&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;InsufficientBalance&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;error&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;anonymous&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;inputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;indexed&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="attr">&quot;internalType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;indexed&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="attr">&quot;internalType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bytes32&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bytes32&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Event&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;event&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;inputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;internalType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;foo&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;outputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;stateMutability&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nonpayable&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;function&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h3 id="处理-元组-tuple-类型"><a href="#处理-元组-tuple-类型" class="headerlink" title="处理 元组(tuple) 类型"></a>处理 元组(tuple) 类型</h3><p>尽管名称被有意地不作为 ABI 编码的一部分，但将它们包含进 JSON 来显示给最终用户是非常合理的。其结构会按下列方式进行嵌套：</p><p>一个拥有 <code>name</code>、 <code>type</code> 和潜在的 <code>components</code>成员的对象描述了某种类型的变量。 直至到达一个 元组(tuple)类型且到那点的存储在 <code>type</code> 属性中的字符串以 <code>tuple</code>为前缀，也就是说，在 <code>tuple</code> 之后紧跟一个 <code>[]</code> 或有整数 <code>k</code> 的<code>[k]</code>，才能确定一个 元组(tuple)。 元组(tuple) 的组件元素会被存储在成员<code>components</code>中，它是一个数组类型，且与顶级对象具有同样的结构，只是在这里不允许已索引的（<code>indexed</code>）数组元素。</p><p>作为例子，代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.7.5 &lt;0.9.0;</span><br><span class="line">pragma abicoder v2;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">  struct S &#123; uint a; uint[] b; T[] c; &#125;</span><br><span class="line">  struct T &#123; uint x; uint y; &#125;</span><br><span class="line">  function f(S memory, T memory, uint) public pure &#123; &#125;</span><br><span class="line">  function g() public pure returns (S memory, T memoryt, uint) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可由如下 JSON 来表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;f&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;function&quot;,</span><br><span class="line">    &quot;inputs&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;s&quot;,</span><br><span class="line">        &quot;type&quot;: &quot;tuple&quot;,</span><br><span class="line">        &quot;components&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;a&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;b&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256[]&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;c&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;tuple[]&quot;,</span><br><span class="line">            &quot;components&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;name&quot;: &quot;x&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;name&quot;: &quot;y&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;t&quot;,</span><br><span class="line">        &quot;type&quot;: &quot;tuple&quot;,</span><br><span class="line">        &quot;components&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;x&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;y&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;a&quot;,</span><br><span class="line">        &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;outputs&quot;: []</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="严格编码模式"><a href="#严格编码模式" class="headerlink" title="严格编码模式"></a>严格编码模式</h1><p>严格的编码模式与上述正式规范中定义的编码完全相同，但使偏移量必须尽可能小，同时不能在数据区域产生重叠，也不允许有间隙。</p><p>通常，ABI 解码器是以直接的方式编写的，只是遵循偏移量指针，但有些解码器可能强制执行严格模式。Solidity ABI 解码器目前并不强制执行严格模式，但编码器总是以严格模式创建数据。</p><h1 id="非标准打包模式"><a href="#非标准打包模式" class="headerlink" title="非标准打包模式"></a>非标准打包模式</h1><p>Non-standard Packed Mode 被称为非标准打包模式，通过 <code>abi.encodePacked()</code>, Solidity 支持一种非标准打包模式处理以下情形：</p><ul><li>长度低于 32 字节的类型，会直接拼接，既不会进行补 0 操作，也不会进行符号扩展</li><li>动态类型会直接进行编码，并且不包含长度信息。</li><li>数组元素会填充，但仍旧会就地编码。</li></ul><p>例如，对 <code>int1, bytes1, uint16, string</code> 用数值<code>-1, 0x42, 0x2424, &quot;Hello, world!&quot;</code> 进行编码将生成如下结果 ::</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0xff42242448656c6c6f2c20776f726c6421</span><br><span class="line">  ^^                                 int1(-1)</span><br><span class="line">    ^^                               bytes1(0x42)</span><br><span class="line">      ^^^^                           uint16(0x2424)</span><br><span class="line">          ^^^^^^^^^^^^^^^^^^^^^^^^^^ string(&quot;Hello, world!&quot;) without a length field</span><br></pre></td></tr></table></figure><p>更具体地说:</p><ul><li>在编码过程中，所有内容均是就地编码，因此在编码中，没有头和尾的区别，而且数组的长度也不会被编码。</li><li><code>abi.encodePacked</code> 的参数以不填充的方式编码，只要它们不是数组（或<code>string</code> 或 <code>bytes</code>）。</li><li>数组的编码是由其元素的编码及其填充（padding）的拼接</li><li>动态大小的类型如 <code>string</code>, <code>bytes</code> 或 <code>uint[]</code> 在编码时，不包含长度字段</li><li><code>string</code> 或 <code>bytes</code> 的编码不会在末尾进行填充（padding），除非它是一个数组或结构的一部分（此时会填充为<br>32 个自己的整数倍 ）</li></ul><p>一般来说，只要有两个动态大小的元素，因为缺少长度字段，编码就会模糊有歧义。</p><p>如果需要填充，可以使用明确的类型转换：<code>abi.encodePacked(uint16(0x12)) == hex&quot;0012&quot;</code>.</p><p>由于在调用函数时没有使用打包模式编码，所以没有特别支持预留函数选择器。由于编码是模糊有歧义的，所以也没有解码方法。</p><p>警告:如果你使用 <code>keccak256(abi.encodePacked(a, b))</code> 并且 <code>a</code> 和 <code>b</code> 都是动态类型， 很容易通过把 <code>a</code> 的一部分移到 <code>b</code>中，从而发生哈希碰撞，反之亦然。</p><p>更具体地说， <code>abi.encodePacked(&quot;a&quot;, &quot;bc&quot;) == abi.encodePacked(&quot;ab&quot;, &quot;c&quot;)</code> 。如果你使用 <code>abi.encodePacked</code> 进行签名，认证或数据完整性检验，请确保总是使用相同的类型并且其中只有最多一个动态类型。除非有令人信服的理由，否则应首选 <code>abi.encode</code> 。</p>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17-metadata元数据</title>
      <link href="/2022/07/25/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/17-metadata%E5%85%83%E6%95%B0%E6%8D%AE/"/>
      <url>/2022/07/25/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/17-metadata%E5%85%83%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>Solidity 编译器在编译的时候自动生成<code>xx_metadata.json</code>的 JSON 文件，中文叫合约的元数据，其中包含了当前合约的相关信息。</p><h1 id="metadata-包含信息"><a href="#metadata-包含信息" class="headerlink" title="metadata 包含信息"></a>metadata 包含信息</h1><p>元数据文件具有以下格式。 下面的例子将以人类可读的方式呈现。正确格式化的元数据应正确使用引号，将空白减少到最小，并对所有对象的键值进行排序以得到唯一的格式。（下面的代码注释是不允许的，这里仅用于解释目的。）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// 必选：元数据格式的版本(注意和Solidity版本不是同一个version )</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 必选：源代码的编程语言，一般会选择规范的“子版本”</span></span><br><span class="line">  <span class="attr">&quot;language&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Solidity&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 必选：编译器的细节，内容视语言而定。</span></span><br><span class="line">  <span class="attr">&quot;compiler&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 对 Solidity 来说是必须的：编译器的版本</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.8.7+commit.e28d00a7&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 可选： 生成此输出的编译器二进制文件的哈希值</span></span><br><span class="line">    <span class="attr">&quot;keccak256&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x123...&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 必选：合约的生成信息</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 必选：合约的 ABI 定义</span></span><br><span class="line">    <span class="attr">&quot;abi&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">/*...*/</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 必选：合约的 NatSpec 用户文档</span></span><br><span class="line">    <span class="attr">&quot;userdoc&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">/*...*/</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 必选：合约的 NatSpec 开发者文档</span></span><br><span class="line">    <span class="attr">&quot;devdoc&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">/*...*/</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 必选：编译器的设置</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;compilationTarget&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;a.sol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Sum&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;evmVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;london&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;libraries&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="comment">// Reflects the setting used in the input json, defaults to false</span></span><br><span class="line">      <span class="attr">&quot;useLiteralContent&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// Reflects the setting used in the input json, defaults to &quot;ipfs&quot;</span></span><br><span class="line">      <span class="attr">&quot;bytecodeHash&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ipfs&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 可选： 优化器的设置（ enabled 默认设为 false ）</span></span><br><span class="line">    <span class="attr">&quot;optimizer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;runs&quot;</span><span class="punctuation">:</span> <span class="number">200</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 对 Solidity 来说是必须的： 已排序的重定向列表</span></span><br><span class="line">    <span class="attr">&quot;remappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;:g/dir&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 必选：编译的源文件／源单位，键值为文件名</span></span><br><span class="line">  <span class="attr">&quot;sources&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;myFile.sol&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="comment">// 必选：源文件的 keccak256 哈希值</span></span><br><span class="line">      <span class="attr">&quot;keccak256&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x123...&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Optional: 在源文件中定义的 SPDX license 标识</span></span><br><span class="line">      <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MIT&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// 必选（除非定义了 content，详见下文）：</span></span><br><span class="line">      <span class="comment">// 已排序的源文件的URL，URL的协议可以是任意的，但建议使用 Swarm 的URL</span></span><br><span class="line">      <span class="attr">&quot;urls&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;bzz-raw://fd33d...&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;dweb:/ipfs/Qme8Vrt&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 可选</span></span><br><span class="line">    <span class="attr">&quot;mortal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="comment">// 必选：源文件的 keccak256 哈希值</span></span><br><span class="line">      <span class="attr">&quot;keccak256&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x234...&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// 必选（除非定义了“urls”）： 源文件的字面内容</span></span><br><span class="line">      <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;contract mortal is owned &#123; function kill() &#123;</span></span><br><span class="line"><span class="string">        if (msg.sender == owner) selfdestruct(owner); &#125; &#125;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="metadata-的作用"><a href="#metadata-的作用" class="headerlink" title="metadata 的作用"></a>metadata 的作用</h3><p>metadata 主要是为了更安全地与合约进行交互并验证其源代码。</p><ul><li>查询编译器版本</li><li>所使用的源代码</li><li>ABI</li><li>natspec 文档</li></ul><p>编译器会将元数据文件的 Swarm 哈希值附加到每个合约的字节码末尾（详情请参阅下文），以便你可以以认证的方式获取该文件，而不必求助于中心化的数据提供者。当然，你必须将元数据文件发布到 Swarm（或其他服务），以便其他人可以访问它。 该文件可以通过使用<code>solc --metadata</code> 来生成，并被命名为 <code>ContractName_meta.json</code> 。 它将包含源代码的在 Swarm 上的引用，因此你必须上传所有源文件和元数据文件。</p><hr><p>⚠️ 警告: 由于生成的合约的字节码包含元数据的哈希值，因此对元数据的任何更改都会导致字节码的更改。<br>此外，由于元数据包含所有使用的源代码的哈希值，所以任何源代码中的，哪怕是一个空格的变化都将导致不同的元数据，并随后产生不同的字节代码。</p><p>⚠️ 警告: 需注意，上面的 ABI 没有固定的顺序，随编译器的版本而不同。</p><h1 id="字节码中元数据哈希的编码"><a href="#字节码中元数据哈希的编码" class="headerlink" title="字节码中元数据哈希的编码"></a>字节码中元数据哈希的编码</h1><p>由于在将来可能会支持其他方式来获取元数据文件， 类似<code>&#123;&quot;bzzr0&quot;：&lt;Swarm hash&gt;&#125;</code> 的键值对，将会以<br>CBOR (<a href="https://tools.ietf.org/html/rfc7049">https://tools.ietf.org/html/rfc7049</a>) 编码来存储。由于这种编码的起始位不容易找到，因此添加两个字节来表述其长度，以大端方式编码。所以，当前版本的 Solidity 编译器，将以下内容添加到部署的字节码的末尾</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0xa2</span><br><span class="line">0x64 &#x27;i&#x27; &#x27;p&#x27; &#x27;f&#x27; &#x27;s&#x27; 0x58 0x22 &lt;34 bytes IPFS hash&gt;</span><br><span class="line">0x64 &#x27;s&#x27; &#x27;o&#x27; &#x27;l&#x27; &#x27;c&#x27; 0x43 &lt;3 byte version encoding&gt;</span><br><span class="line">0x00 0x33</span><br></pre></td></tr></table></figure><p>因此，为了检索数据，可以检查已部署字节码的末尾以匹配该模式，并使用 IPFS 哈希来检索文件。</p><p>solc 的发布版本使用如上所示的版本的 3 字节编码（major, minor and patch version number 版本号各一个字节），而预发布版本将使用完整的版本字符串，包括提交哈希和构建日期。</p><p>CBOR 映射还可以包含其他密钥，因此最好完全解码数据而不是依赖以 <code>0xa264</code> 开头的数据。 例如，如果使用任何影响代码生成的实验性功能，则映射也将包含 <code>&quot;experimental&quot;：true</code>。</p><p>编译器目前默认使用元数据的 IPFS 哈希，但将来也可能使用 bzzr1 哈希或其他一些哈希，因此不要依赖此序列以 <code>0xa2 0x64 &#39;i&#39; &#39;p&#39; &#39;f&#39; &#39;s&#39;</code> 开头 的。 我们可能还会向此 CBOR 结构中添加其他数据，因此最好的选择是使用适当的 CBOR 解析器。</p><h1 id="自动化接口生成和-natspec-使用"><a href="#自动化接口生成和-natspec-使用" class="headerlink" title="自动化接口生成和 natspec 使用"></a>自动化接口生成和 natspec 使用</h1><p>元数据以下列方式使用：通过钱包想要与合约交互时检索合约代码，然后检索文件的 IPFS&#x2F;Swarm 哈希。该文件被 JSON 解码为上面的结构。</p><p>组件可以使用 ABI 自动为合约生成一个基本的用户界面。</p><p>此外，钱包可以使用 NatSpec 用户文档，在用户与合约交互，授权请求签名时候做辅助工作。</p><h1 id="源代码如何验证？"><a href="#源代码如何验证？" class="headerlink" title="源代码如何验证？"></a>源代码如何验证？</h1><p>为了验证编译，可以通过元数据文件中的链接从 IPFS&#x2F;Swarm 中获取源代码。获取到的源码，会根据元数据中指定的设置，被正确版本的编译器所处理。处理得到的字节码会与创建交易的数据或者 <code>CREATE</code> 操作码使用的数据进行比较。这会自动验证元数据，因为它的哈希值是字节码的一部分。而额外的数据，则是与基于接口进行编码并展示给用户的构造输入数据相符的。</p><p>在 <a href="https://github.com/ethereum/sourcify">sourcify</a> 库(<a href="https://www.npmjs.com/package/source-verify">npm package</a>)可以看到如何使用该特性的示例代码。</p>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16-Assembly内联汇编</title>
      <link href="/2022/07/22/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/16-Assembly%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
      <url>/2022/07/22/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/16-Assembly%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<p>使用内联汇编，可以在 Solidity 源程序中嵌入汇编代码，对 EVM 有更细粒度的控制。内联汇编主要用在编写库函数时很有用，一般用于写工具函数，比如椭圆签名解析等。在项目中用汇编编主要是 opensea 的 <a href="https://github.com/ProjectOpenSea/seaport">seaport</a> 合约.</p><p>在合约的内部使用汇编，是在合约内部包含 <code>assembly</code> 关键字进行编写的，在 Solidity <code>inline assembly</code>(内联汇编) 中的语言被称为 Yul。</p><p><a href="https://docs.soliditylang.org/zh/latest/yul.html">Yul</a> 除了在 Solidity 之中作为 inline assembly 的一部分，也能当作独立的直译语言能够被编译成 bytecode 给不同的后端。</p><p>注意：内联汇编是一种在底层访问以太坊虚拟机的语言，由于编译器无法对汇编语句进行检查，所以 Solidity 提供的很多重要安全特性都没办法作用于汇编。写汇编代码相对比较困难，很多时候只有在处理一些相对复杂的问题时才需要使用它，并且开发者需要明确知道自己要做什么。</p><h1 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h1><p>通过 <code>assembly &#123;&#125;</code> 包裹代码。并且内部每一行语句不需要使用<code>;</code>显示的标注结束。Assembly 也支持注释，可以使用 <code>//</code> 和 <code>/* */</code> 来进行注释。</p><p>⚠️ 注意： Inline Assembly 中，代码块之间是不能彼此沟通的，里面声明的变量都是本地变量。</p><h3 id="例子-不同代码块无法互相访问"><a href="#例子-不同代码块无法互相访问" class="headerlink" title="例子: 不同代码块无法互相访问"></a>例子: 不同代码块无法互相访问</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public view returns (uint256) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let x := 2</span><br><span class="line">        &#125;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let y := x // DeclarationError: Identifier &quot;x&quot; not found.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>let 指令执行如下任务：</p><ul><li>创建一个新的堆栈槽位</li><li>为变量保留该槽位</li><li>当到达代码块结束时自动销毁该槽位</li></ul><p>因此，使用 let 指令在汇编代码块中定义的变量，在代码块外部是无法访问的。但是内部代码块可以访问外部代码块的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let x := 3</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                let y := x // success</span><br><span class="line">            &#125; // 到此处会销毁y</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子-简单的加法"><a href="#例子-简单的加法" class="headerlink" title="例子: 简单的加法"></a>例子: 简单的加法</h3><p>下面是一个计算 <code>_x + _y</code> 的两种写法对比，汇编的语法节省了 <code>1.76%</code> 的 gas。 assembly 核心是更细粒度的控制，省 gas 只是它的外在表现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // 输入 1,2 ; 输出 22307 gas</span><br><span class="line">    function addSolidity(uint256 _x, uint256 _y) public pure returns (uint256) &#123;</span><br><span class="line">        return (_x + _y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输入 1,2 ; 输出 21915 gas</span><br><span class="line">    function addAssembly(uint256 _x, uint256 _y) public pure returns (uint256) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // let result 是声明一个变量 result</span><br><span class="line">            // add(_x, _y) 是计算 x + y 的结果</span><br><span class="line">            // := 是将 x + y 的结果赋值给变量 result</span><br><span class="line">            let result := add(_x, _y)</span><br><span class="line"></span><br><span class="line">            // mstore(0x0, result) 在内存 `0x0` 的位置储存 `result`</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line"></span><br><span class="line">            // 从内存索引 0x0 位置返回32字节</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><p>Yul 提供了高级结构，如 <code>for</code> 循环、<code>if</code> 语句 <code>switch</code> 和函数调用等等，下面按照分类进行介绍。</p><p>在 Inline Assembly 中，以下几个点很重要：</p><ul><li>赋值: 使用的是<code>:=</code>，而不是<code>=</code>。</li><li>声明变量: 使用 <code>let</code> 声明；（不是正常带有指定类型的强类型方式）</li></ul><h3 id="声明与赋值"><a href="#声明与赋值" class="headerlink" title="声明与赋值"></a>声明与赋值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (uint256, uint256) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let x := 2  // 声明 x，赋值为2</span><br><span class="line">            let y       // 声明 y，初始化为 0</span><br><span class="line">            y := 5      // 赋值 y 为5</span><br><span class="line"></span><br><span class="line">            mstore(0x0, x) // 内存中储存 x</span><br><span class="line">            mstore(add(0x0, 32), y) // 内存中移动32位，再储存y</span><br><span class="line"></span><br><span class="line">            // 返回内存中 0 - 64 的数据</span><br><span class="line">            return(0x0, 64)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果就是 <code>2,5</code>；</p><p>在 Solidity 汇编中字面量的写法与 Solidity 一致。但是 字符串字面量 最多可以包含 32 个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let a := 0x123 // 16进制</span><br><span class="line">            let b := 42 // 10进制</span><br><span class="line">            let c := &quot;hello world&quot; // 字符串</span><br><span class="line">            let d := &quot;very long string more than 32 bytes&quot; // 长度 35 的 字符串，错误！</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="汇编只能读取局部变量"><a href="#汇编只能读取局部变量" class="headerlink" title="汇编只能读取局部变量"></a>汇编只能读取局部变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint256 a = 2;</span><br><span class="line">    function demoAssembly() public pure &#123;</span><br><span class="line">        uint256 b = 5;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // 可以读取 x 和 y</span><br><span class="line">            let x := add(2, 3)</span><br><span class="line">            let y := 10</span><br><span class="line">            let z := add(x, y)</span><br><span class="line">        &#125;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // 可以读取 x 和 b</span><br><span class="line">            let x := add(2, 3)</span><br><span class="line">            let y := mul(x, b)</span><br><span class="line">        &#125;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let x := add(2, 3)</span><br><span class="line"></span><br><span class="line">            // ❌ TypeError: Only local variables are supported.</span><br><span class="line">            // To access storage variables, use the &quot;.slot&quot; and &quot;.offset&quot; suffixes.</span><br><span class="line">            let y := mul(x, a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><ul><li>if</li><li>switch</li></ul><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>特点如下</p><ul><li>只有 if ，没有 else</li><li>if 语句强制要求代码块使用大括号，<code>&#123;&#125;</code>不允许省略</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure &#123;</span><br><span class="line">        uint256 x;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // success</span><br><span class="line">            if iszero(x) &#123;</span><br><span class="line">                x := sub(1, x)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // fail: 没有使用 &#123;&#125; 包裹代码</span><br><span class="line">            // if iszero(x) revert(0, 0)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要在 Solidity 内联汇编中检查多种条件，可以考虑使用 switch 语句。</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch 语句支持 一个默认分支 default，当表达式的值不匹配任何其他分支条件时，将 执行默认分支的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 x) public pure returns (uint256 result) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            switch x</span><br><span class="line">            case 0 &#123;</span><br><span class="line">                result := 0</span><br><span class="line">            &#125;</span><br><span class="line">            case 1 &#123;</span><br><span class="line">                result := 1</span><br><span class="line">            &#125;</span><br><span class="line">            default &#123;</span><br><span class="line">                result := mul(x, x)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h1><p>for 循环也包含 3 个元素</p><ul><li>初始化：比如<code>let i := 0</code></li><li>执行条件：比如<code>lt(i, n)</code> ，必须是函数风格表达式</li><li>迭代后续步骤：比如<code>add(i, 1)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (uint256 result) &#123;</span><br><span class="line">        uint256 leng = 10;</span><br><span class="line"></span><br><span class="line">        assembly &#123;</span><br><span class="line">            for</span><br><span class="line">            &#123; let i := 0 &#125;</span><br><span class="line">            lt(i, leng)</span><br><span class="line">            &#123; i := add(i, 1) &#125;</span><br><span class="line">            &#123;</span><br><span class="line">                result := add(result, i)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 下面可以省略</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 循环的<strong>初始化部分</strong>和<strong>迭代后续步骤</strong>可以留空 , 改写为下面的格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (uint256 result) &#123;</span><br><span class="line">        uint256 leng = 10;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let i := 0 // 初始条件写在这</span><br><span class="line">            for &#123;&#125; lt(i, leng) &#123;&#125; &#123;</span><br><span class="line">                // 核心部分</span><br><span class="line">                result := add(result, i)</span><br><span class="line"></span><br><span class="line">                // 迭代后续步骤写在这</span><br><span class="line">                i := add(i, 1)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 可以省略</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注: <code>continue</code> or <code>break</code> 语句只能在 <code>for</code> 循环体内使用</p><h1 id="函数的定义和使用"><a href="#函数的定义和使用" class="headerlink" title="函数的定义和使用"></a>函数的定义和使用</h1><p>函数的运行机制如下：</p><ul><li>从堆栈提取参数</li><li>将结果压入堆栈</li><li>和 Solidity 函数不同，不需要指定汇编函数的可见性<ul><li>例如 public 或 private， 因为汇编函数仅在定义所在的汇编代码块内有效。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (uint256 free_memory_pointer) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // 函数定义</span><br><span class="line">            function allocate(length) -&gt; pos &#123;</span><br><span class="line">                pos := mload(0x40)</span><br><span class="line">                mstore(0x40, add(pos, length))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 函数使用</span><br><span class="line">            free_memory_pointer := allocate(64)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="EVM-内置函数-内置操作码"><a href="#EVM-内置函数-内置操作码" class="headerlink" title="EVM 内置函数&#x2F;内置操作码"></a>EVM 内置函数&#x2F;内置操作码</h1><ul><li>算数操作<ul><li><code>add</code>: 加法</li><li><code>mul</code>:</li></ul></li><li>比较操作<ul><li><code>lt</code></li><li><code>gt</code></li></ul></li><li>位操作<ul><li><code>not</code>:</li><li><code>and</code>:</li></ul></li><li>密码学操作，目前仅包含 keccak256</li><li>环境操作，主要指与区块链相关的全局信息，例如 blockhash 或 coinbase 收款账号</li><li>存储、内存和栈操作</li><li>交易与合约调用操作</li><li>停机操作</li><li>日志操作</li></ul><p>下面是详细的列表说明，标记为<code>-</code>的操作不返回结果，其他所有操作码只返回一个值。</p><p>标有 F、H、B、C 、I 和 L 分别自出现的时间，对应的如下</p><ul><li><code>F</code>: Frontier</li><li><code>H</code>: Homestead</li><li><code>B</code>: Byzantium</li><li><code>C</code>: Constantinople</li><li><code>I</code>: Istanbul</li><li><code>L</code>: London</li></ul><p>常见的常量值是 <code>0x20</code> &#x2F; <code>0x40</code> , 代表十进制的 32 和 64。</p><h3 id="数学计算"><a href="#数学计算" class="headerlink" title="数学计算"></a>数学计算</h3><table><thead><tr><th>操作符号</th><th>返回值</th><th>版本</th><th>解释说明</th></tr></thead><tbody><tr><td>add(x, y)</td><td></td><td>F</td><td><code>x + y</code></td></tr><tr><td>sub(x, y)</td><td></td><td>F</td><td><code>x - y</code></td></tr><tr><td>mul(x, y)</td><td></td><td>F</td><td><code>x * y</code></td></tr><tr><td>div(x, y)</td><td></td><td>F</td><td><code>x / y</code> (如果 y 为 0，则结果为 0)</td></tr><tr><td>mod(x, y)</td><td></td><td>F</td><td><code>x % y</code> (如果 y 为 0，则结果为 0)</td></tr><tr><td>exp(x, y)</td><td></td><td>F</td><td><code>x</code> 的 <code>y</code> 次方</td></tr><tr><td>addmod(x, y, m)</td><td></td><td>F</td><td><code>(x + y) % m</code> 任意精度算术，如果 m &#x3D;&#x3D; 0 则为 0</td></tr><tr><td>mulmod(x, y, m)</td><td></td><td>F</td><td><code>(x * y) % m</code> 任意精度算术，如果 m &#x3D;&#x3D; 0 则为 0</td></tr><tr><td>sdiv(x, y)</td><td></td><td>F</td><td><code>x / y</code>, 以二进制补码作为符号 (如果 y 为 0，则结果为 0)</td></tr><tr><td>smod(x, y)</td><td></td><td>F</td><td><code>x % y</code>, 以二进制补码作为符号 (如果 y 为 0，则结果为 0)</td></tr></tbody></table><h4 id="add-加法"><a href="#add-加法" class="headerlink" title="add: 加法"></a>add: 加法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function demoAssembly(uint256 _x, uint256 _y)</span><br><span class="line">    public</span><br><span class="line">    pure</span><br><span class="line">    returns (uint256)</span><br><span class="line">&#123;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        let result := add(_x, _y)</span><br><span class="line">        mstore(0x0, result)</span><br><span class="line">        return(0x0, 32)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面合约函数，传入参数:<code>1,2</code>，返回<code>3</code>。</p><p>这里需要返回<code>uint256</code>类型，assembly 内部返回是，从什么位置开发，返回多少个数据。需要返回两个数据。比如我把 uint256 改为 uint8，代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function demoAssembly(uint8 _x, uint8 _y)</span><br><span class="line">    public</span><br><span class="line">    pure</span><br><span class="line">    returns (uint8)</span><br><span class="line">&#123;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        let result := add(_x, _y)</span><br><span class="line">        mstore(0x0, result)</span><br><span class="line">        return(0x0, 2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相同的参数会报错: <code>error:Failed to decode output: Error: data out-of-bounds (length=2, offset=32, code=BUFFER_OVERRUN, version=abi/5.5.0)</code></p><h4 id="sub-减法"><a href="#sub-减法" class="headerlink" title="sub: 减法"></a>sub: 减法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 _x, uint256 _y)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let result := sub(_x, _y)</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入参数:<code>2,1</code>，返回<code>1</code>。</p><p>注意：这时候如果传参 <code>1,2</code>，会溢出返回，得到的结果不会报错，反而是:<code>115792089237316195423570985008687907853269984665640564039457584007913129639935</code>，因为 assembly 绕过了 solidity 的安全检查。当我们使用 assembly 编码时候，安全问题需要自己控制，不要错误的认为 solidity 的默认机制会保护代码。</p><h4 id="mul-乘法"><a href="#mul-乘法" class="headerlink" title="mul: 乘法"></a>mul: 乘法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 _x, uint256 _y)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let result := mul(_x, _y)</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入参数:<code>2,3</code>，返回<code>6</code>。</p><h4 id="div-除法"><a href="#div-除法" class="headerlink" title="div: 除法"></a>div: 除法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 _x, uint256 _y)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let result := div(_x, _y)</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>传入参数:<code>3,2</code>，返回<code>1</code>。</li><li>传入参数:<code>3,1</code>，返回<code>3</code>。</li><li>传入参数:<code>3,0</code>，返回<code>0</code>。</li></ul><h4 id="mod-求模"><a href="#mod-求模" class="headerlink" title="mod: 求模"></a>mod: 求模</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 _x, uint256 _y)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let result := mod(_x, _y)</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>传入参数:<code>3,2</code>，返回<code>1</code></li><li>传入参数:<code>3,1</code>，返回<code>0</code></li><li>传入参数:<code>3,0</code>,返回<code>0</code></li><li>传入参数:<code>3,30</code>,返回<code>3</code></li></ul><h4 id="exp-次方"><a href="#exp-次方" class="headerlink" title="exp: 次方"></a>exp: 次方</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 _x, uint256 _y)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let result := exp(_x, _y)</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>传入参数:<code>10,2</code>，返回<code>100</code>。</li><li>传入参数:<code>10,3</code>，返回<code>1000</code>。</li></ul><h4 id="addmod-先求和再求模"><a href="#addmod-先求和再求模" class="headerlink" title="addmod: 先求和再求模"></a>addmod: 先求和再求模</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(</span><br><span class="line">        uint256 _x,</span><br><span class="line">        uint256 _y,</span><br><span class="line">        uint256 _m</span><br><span class="line">    ) public pure returns (uint256) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let result := addmod(_x, _y, _m)</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>传入参数:<code>2,3,3</code>，返回<code>2</code>。</li></ul><h4 id="mulmod-先相乘再求模"><a href="#mulmod-先相乘再求模" class="headerlink" title="mulmod: 先相乘再求模"></a>mulmod: 先相乘再求模</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(</span><br><span class="line">        uint256 _x,</span><br><span class="line">        uint256 _y,</span><br><span class="line">        uint256 _m</span><br><span class="line">    ) public pure returns (uint256) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let result := mulmod(_x, _y, _m)</span><br><span class="line">            mstore(0x0, result)</span><br><span class="line">            return(0x0, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>传入参数:<code>2,3,3</code>，返回<code>0</code>。</li></ul><h4 id="二进制补码"><a href="#二进制补码" class="headerlink" title="二进制补码"></a>二进制补码</h4><p>下面两个方法，用法基本和 div &#x2F; mod 差不多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let result := sdiv(_x, _y)</span><br><span class="line">let result := smod(_x, _y)</span><br></pre></td></tr></table></figure><h3 id="比较关系"><a href="#比较关系" class="headerlink" title="比较关系"></a>比较关系</h3><table><thead><tr><th>操作符号</th><th>返回值</th><th>版本</th><th>解释说明</th></tr></thead><tbody><tr><td>gt(x, y)</td><td></td><td>F</td><td>如果 <code>x &gt; y</code> 等于 1, 否则 0</td></tr><tr><td>lt(x, y)</td><td></td><td>F</td><td>如果 <code>x &lt; y</code> 等于 1, 否则 0</td></tr><tr><td>eq(x, y)</td><td></td><td>F</td><td>如果 <code>x == y</code> 等于 1, 否则 0</td></tr><tr><td>iszero(x)</td><td></td><td>F</td><td>如果 <code>x == 0</code> 等于 1, 否则 0</td></tr><tr><td>slt(x, y)</td><td></td><td>F</td><td>如果 <code>x &lt; y</code> 等于 1, 否则 0, 以二进制补码作为符号</td></tr><tr><td>sgt(x, y)</td><td></td><td>F</td><td>如果 <code>x &gt; y</code> 等于 1, 否则 0, 以二进制补码作为符号</td></tr></tbody></table><h4 id="gt-大于"><a href="#gt-大于" class="headerlink" title="gt: 大于"></a>gt: 大于</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 _x, uint256 _y)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bool result)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := gt(_x, _y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>传入参数:<code>1,2</code>，返回 <code>false</code></li><li>传入参数:<code>10,3</code>，返回 <code>true</code></li></ul><h4 id="lt-小于"><a href="#lt-小于" class="headerlink" title="lt: 小于"></a>lt: 小于</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 _x, uint256 _y)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bool result)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := lt(_x, _y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>传入参数:<code>1,2</code>，返回 <code>true</code></li><li>传入参数:<code>10,3</code>，返回 <code>false</code></li></ul><h4 id="eq-等于"><a href="#eq-等于" class="headerlink" title="eq: 等于"></a>eq: 等于</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 _x, uint256 _y)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bool result)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := eq(_x, _y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>传入参数:<code>1,2</code>，返回 <code>false</code></li><li>传入参数:<code>2,2</code>，返回 <code>true</code></li></ul><h4 id="iszero-等于零"><a href="#iszero-等于零" class="headerlink" title="iszero: 等于零"></a>iszero: 等于零</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(uint256 _x)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bool result)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := iszero(_x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意该参数只接收一个参数</p><ul><li>传入参数:<code>1</code>，返回 <code>false</code></li><li>传入参数:<code>0</code>，返回 <code>true</code></li></ul><h3 id="按位-移位"><a href="#按位-移位" class="headerlink" title="按位 &amp; 移位"></a>按位 &amp; 移位</h3><table><thead><tr><th>操作符号</th><th>返回值</th><th>版本</th><th>解释说明</th></tr></thead><tbody><tr><td>not(x)</td><td></td><td>F</td><td>对 x 按位取反,类似<code>~x</code>;<code>x</code> 的按位非</td></tr><tr><td>and(x, y)</td><td></td><td>F</td><td>x 和 y 的按位与</td></tr><tr><td>or(x, y)</td><td></td><td>F</td><td>x 和 y 的按位或</td></tr><tr><td>xor(x, y)</td><td></td><td>F</td><td>x 和 y 的按位异或</td></tr><tr><td>shl(x, y)</td><td></td><td>C</td><td>y 逻辑左移 x 位</td></tr><tr><td>shr(x, y)</td><td></td><td>C</td><td>y 逻辑右移 x 位</td></tr><tr><td>sar(x, y)</td><td></td><td>C</td><td>将 y 算术右移 x 位</td></tr></tbody></table><h4 id="not-按位非"><a href="#not-按位非" class="headerlink" title="not: 按位非"></a>not: 按位非</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly(int256 _x) public pure returns (int256 result) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := not(_x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>传入参数:<code>0</code>，返回 <code>-1</code></li><li>传入参数:<code>1</code>，返回 <code>-2</code></li><li>传入参数:<code>-1</code>，返回 <code>0</code></li><li>传入参数:<code>-11</code>，返回 <code>10</code></li></ul><h4 id="and-按位与"><a href="#and-按位与" class="headerlink" title="and: 按位与"></a>and: 按位与</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (int256 result) &#123;</span><br><span class="line">        int256 _x = 2;</span><br><span class="line">        int256 _y = 3;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := and(_x, _y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是 2</p><h4 id="or-按位或"><a href="#or-按位或" class="headerlink" title="or: 按位或"></a>or: 按位或</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (int256 result) &#123;</span><br><span class="line">        int256 _x = 2;</span><br><span class="line">        int256 _y = 3;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := or(_x, _y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是 3</p><h4 id="xor-按位异或"><a href="#xor-按位异或" class="headerlink" title="xor: 按位异或"></a>xor: 按位异或</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (int256 result) &#123;</span><br><span class="line">        int256 _x = 2;</span><br><span class="line">        int256 _y = 3;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := xor(_x, _y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果 1</p><h4 id="shl-逻辑左移"><a href="#shl-逻辑左移" class="headerlink" title="shl: 逻辑左移"></a>shl: 逻辑左移</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (uint256 result) &#123;</span><br><span class="line">        uint256 A = 2;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := shl(A, 1) // 4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shr-逻辑右移"><a href="#shr-逻辑右移" class="headerlink" title="shr: 逻辑右移"></a>shr: 逻辑右移</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (uint256 result) &#123;</span><br><span class="line">        uint256 A = 2;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := shr(A, 1) // 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sar-算术右移"><a href="#sar-算术右移" class="headerlink" title="sar: 算术右移"></a>sar: 算术右移</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public pure returns (uint256 result) &#123;</span><br><span class="line">        uint256 A = 2;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := sar(A, 1) // 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EVM-区块交易相关"><a href="#EVM-区块交易相关" class="headerlink" title="EVM 区块交易相关"></a>EVM 区块交易相关</h3><table><thead><tr><th>操作符号</th><th>返回值</th><th>版本</th><th>解释说明</th></tr></thead><tbody><tr><td>address()</td><td></td><td>F</td><td>当前合约地址 &#x2F; execution context</td></tr><tr><td>balance(a)</td><td></td><td>F</td><td>地址 a 的 wei 余额</td></tr><tr><td>selfbalance()</td><td></td><td>I</td><td>相当于 <code>balance(address())</code>，但更便宜</td></tr><tr><td>extcodehash(a)</td><td></td><td>C</td><td>地址 a 的代码哈希</td></tr><tr><td><strong>msg 相关</strong></td><td></td><td></td><td></td></tr><tr><td>caller()</td><td></td><td>F</td><td>call sender ( 类似<code>msg.sender</code>？) (excluding <code>delegatecall</code>)</td></tr><tr><td>callvalue()</td><td></td><td>F</td><td>wei sent together with the current call（类似<code>msg.value</code>？）</td></tr><tr><td><strong>block 相关</strong></td><td></td><td></td><td></td></tr><tr><td>chainid()</td><td></td><td>I</td><td>当前网络的链 ID (EIP-1344)</td></tr><tr><td>basefee()</td><td></td><td>L</td><td>当前区块的基本费用 (EIP-3198 and EIP-1559)</td></tr><tr><td>timestamp()</td><td></td><td>F</td><td>当前块的时间戳，自纪元以来的秒数</td></tr><tr><td>coinbase()</td><td></td><td>F</td><td>当前采矿受益人</td></tr><tr><td>number()</td><td></td><td>F</td><td>当前区块号</td></tr><tr><td>difficulty()</td><td></td><td>F</td><td>当前区块的难度</td></tr><tr><td>gaslimit()</td><td></td><td>F</td><td>当前区块的区块 gas limit</td></tr><tr><td><strong>tx 相关</strong></td><td></td><td></td><td></td></tr><tr><td>origin()</td><td></td><td>F</td><td>交易发送方</td></tr><tr><td>gasprice()</td><td></td><td>F</td><td>交易的 gas 价格</td></tr><tr><td><strong>其它</strong></td><td></td><td></td><td></td></tr><tr><td>gas()</td><td></td><td>F</td><td>剩余 gas</td></tr><tr><td>blockhash(b)</td><td></td><td>F</td><td>指定 block 的 hash - 仅适用于最后 256 个块，不包括当前块</td></tr></tbody></table><h4 id="address"><a href="#address" class="headerlink" title="address()"></a>address()</h4><p>相当于 <code>address(this)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public view returns (address ads1, address ads2) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            ads1 := address()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ads2 = address(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回</p><ul><li><code>0:address: ads1 0x3c725134d74D5c45B4E4ABd2e5e2a109b5541288</code></li><li><code>1:address: ads2 0x3c725134d74D5c45B4E4ABd2e5e2a109b5541288</code></li></ul><h4 id="balance-a"><a href="#balance-a" class="headerlink" title="balance(a)"></a>balance(a)</h4><p>相当于 <code>address.balance</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        address sender = msg.sender;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := balance(sender)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result2 = address(sender).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回</p><ul><li><code>0:uint256: result1 99999999999992173039</code></li><li><code>1:uint256: result2 99999999999992173039</code></li></ul><h4 id="selfbalance"><a href="#selfbalance" class="headerlink" title="selfbalance()"></a>selfbalance()</h4><p>相当于 <code>balance(address())</code>，但更便宜</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    constructor() payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := balance(address())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result2 = address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="extcodehash-a"><a href="#extcodehash-a" class="headerlink" title="extcodehash(a)"></a>extcodehash(a)</h4><p>相当于 <code>address.codehash</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (bytes32 result1, bytes32 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        address sender = msg.sender;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := extcodehash(address())</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = address(this).codehash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>0:bytes32: result1 0xcbefd958c5e7814e7e635b599c5859eb893c410292a7f9f82088c3e84ee3c0e9</code></li><li><code>1:bytes32: result2 0xcbefd958c5e7814e7e635b599c5859eb893c410292a7f9f82088c3e84ee3c0e9</code></li></ul><h4 id="caller"><a href="#caller" class="headerlink" title="caller()"></a>caller()</h4><p>相当于 <code>msg.sender</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly() public view returns (address ads1, address ads2) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            ads1 := caller()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ads2 = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="callvalue"><a href="#callvalue" class="headerlink" title="callvalue()"></a>callvalue()</h4><p>相当于 <code>msg.value</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        payable</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := callvalue()</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="chainid"><a href="#chainid" class="headerlink" title="chainid()"></a>chainid()</h4><p>相当于 <code>block.chainid</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := chainid() // 1</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = block.chainid; // 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="basefee"><a href="#basefee" class="headerlink" title="basefee()"></a>basefee()</h4><p>相当于 <code>block.basefee</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := basefee()</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = block.basefee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="timestamp"><a href="#timestamp" class="headerlink" title="timestamp()"></a>timestamp()</h4><p>相当于 <code>block.timestamp</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := timestamp()</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = block.timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="coinbase"><a href="#coinbase" class="headerlink" title="coinbase()"></a>coinbase()</h4><p>相当于 <code>block.coinbase</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (address result1, address result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := coinbase()</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = block.coinbase;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="number"><a href="#number" class="headerlink" title="number()"></a>number()</h4><p>相当于 <code>block.number</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := number()</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = block.number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="difficulty"><a href="#difficulty" class="headerlink" title="difficulty()"></a>difficulty()</h4><p>相当于 <code>block.difficulty</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := difficulty()</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = block.difficulty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="gaslimit"><a href="#gaslimit" class="headerlink" title="gaslimit()"></a>gaslimit()</h4><p>相当于 <code>block.gaslimit</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := gaslimit()</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = block.gaslimit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="origin"><a href="#origin" class="headerlink" title="origin()"></a>origin()</h4><p>相当于 <code>tx.origin</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (address result1, address result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := origin()</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = tx.origin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="gasprice"><a href="#gasprice" class="headerlink" title="gasprice()"></a>gasprice()</h4><p>相当于 <code>tx.gasprice</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := gasprice()</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = tx.gasprice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="gas"><a href="#gas" class="headerlink" title="gas()"></a>gas()</h4><p>相当于 <code>gasleft()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 result1, uint256 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := gas() // 2978815</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 与 assembly 之间的顺序不改变最后的值</span><br><span class="line">        // 所以 assembly 优先执行？</span><br><span class="line">        result2 = gasleft(); // 2978808</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="blockhash-b"><a href="#blockhash-b" class="headerlink" title="blockhash(b)"></a>blockhash(b)</h4><p>相当于 <code>blockhash(number)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function demoAssembly()</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (bytes32 result1, bytes32 result2)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result1 := blockhash(1)</span><br><span class="line">        &#125;</span><br><span class="line">        result2 = blockhash(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><table><thead><tr><th>操作符号</th><th>返回值</th><th>版本</th><th>解释说明</th></tr></thead><tbody><tr><td>sload(p)</td><td></td><td>F</td><td><code>storage[p]</code></td></tr><tr><td>mload(p)</td><td></td><td>F</td><td><code>mem[p…(p+32))</code></td></tr><tr><td>sstore(p, v)</td><td>-</td><td>F</td><td><code>storage[p] := v</code></td></tr><tr><td>mstore(p, v)</td><td>-</td><td>F</td><td><code>mem[p…(p+32)) := v</code></td></tr><tr><td>mstore8(p, v)</td><td>-</td><td>F</td><td><code>mem[p] := v</code> &amp; 0xff (只修改单个字节)</td></tr><tr><td>keccak256(p, n)</td><td></td><td>F</td><td><code>keccak(mem[p…(p+n)))</code></td></tr><tr><td>create(v, p, n)</td><td></td><td>F</td><td>create 创建合约</td></tr><tr><td>create2(v, p, n, s)</td><td></td><td>C</td><td>create2 创建合约</td></tr></tbody></table><p>小例子:</p><ul><li><code>mload(p)</code>: 分配数据</li><li><code>mstore(offset, value)</code>: 在 <code>offset</code> 的位置储存 <code>value</code></li></ul><h4 id="sload-p"><a href="#sload-p" class="headerlink" title="sload(p)"></a>sload(p)</h4><p>sload 是 storage load，<code>sload(key)</code> 是从 storage 的哪个 slot 来 load，详细原理可以在后面介绍的 <strong>状态变量在存储中的布局</strong> 了解更多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint256 public a = 123;</span><br><span class="line">    uint256 public b = 456;</span><br><span class="line"></span><br><span class="line">    function demoAssembly() public view returns (uint256) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // v 是长度是 32 bytes</span><br><span class="line">            // 从 slot #0 读数据 =&gt; 读到的是 123</span><br><span class="line">            // 从 slot #1 读数据 =&gt; 读到的是 456</span><br><span class="line">            let v := sload(0)</span><br><span class="line"></span><br><span class="line">            // 在内存位置 0x80 处储存变量 v 后面的数据</span><br><span class="line">            mstore(0x80, v)</span><br><span class="line"></span><br><span class="line">            // 返回值:从 0x80 位置，返回 32个字节</span><br><span class="line">            return(0x80, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中，<code>slot #0</code> 是 123，<code>slot #1</code> 是 456。</p><p>注意: <code>slot #0</code> 可能是多个状态变量公用的。比如把状态变量改为如下类型,读 <code>slot #0</code> ，该位置储存了<code>a+b</code>;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint128 public a = 1;</span><br><span class="line">uint128 public b = 2;</span><br><span class="line">uint256 public c = 456;</span><br></pre></td></tr></table></figure><h4 id="mload-p"><a href="#mload-p" class="headerlink" title="mload(p)"></a>mload(p)</h4><p>mload 是 memory load，<code>mload(key)</code> 是从 memory 的哪个 slot 来 load，类似 <code>sload</code>。</p><ul><li>问题：内存数据 mload 时为什么从第 32 位开始?<ul><li>答案：前 32 个字节存储的是数据的长度;</li><li>参考: <a href="https://www.cnblogs.com/wanghui-garcia/p/9592807.html">https://www.cnblogs.com/wanghui-garcia/p/9592807.html</a></li></ul></li></ul><h4 id="sstore-p-v"><a href="#sstore-p-v" class="headerlink" title="sstore(p, v)"></a>sstore(p, v)</h4><h4 id="mstore-p-v"><a href="#mstore-p-v" class="headerlink" title="mstore(p, v)"></a>mstore(p, v)</h4><p>下面 name1 和 name2 都返回 “Anbang” 的字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // gas 23471</span><br><span class="line">    bytes6 public name1 = &quot;Anbang&quot;; // 0x416e62616e67</span><br><span class="line"></span><br><span class="line">    // gas 21229</span><br><span class="line">    function name2() public pure returns (string memory) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // 在 0x20 处 储存值 0x20</span><br><span class="line">            mstore(0x20, 0x20)</span><br><span class="line"></span><br><span class="line">            // name1 length = 0x06</span><br><span class="line">            // 参数1: 0x40 + length = 0x40 + 0x06 =&gt; 0x46</span><br><span class="line">            // 参数2: length + name1  = 0x46 + 0x416e62616e67 =&gt; 0x06416e62616e67</span><br><span class="line">            mstore(0x46, 0x06416e62616e67)</span><br><span class="line"></span><br><span class="line">            // 返回 memory 从 0x20处之后的 0x60 长度的数据</span><br><span class="line">            return(0x20, 0x60)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是从<code>0x20</code>处开始写数据，这个位置不是强制的，使用<code>0x00</code>也可以的。</p><h4 id="mstore8-p-v"><a href="#mstore8-p-v" class="headerlink" title="mstore8(p, v)"></a>mstore8(p, v)</h4><h4 id="keccak256-p-n"><a href="#keccak256-p-n" class="headerlink" title="keccak256(p, n)"></a>keccak256(p, n)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // 0x01</span><br><span class="line">    function solidityKeccak(bytes memory _input) public pure returns (bytes32) &#123;</span><br><span class="line">        return keccak256(abi.encodePacked(_input));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 0x01</span><br><span class="line">    function assemblyKeccak(bytes memory _input)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes32 x)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            x := keccak256(add(_input, 0x20), mload(_input))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="create-v-p-n"><a href="#create-v-p-n" class="headerlink" title="create(v, p, n)"></a>create(v, p, n)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> assembly &#123;</span><br><span class="line">    // create(v,p,n);</span><br><span class="line">    // v 是 发送的ETH值</span><br><span class="line">    // p 是 内存中机器码开始的位置</span><br><span class="line">    // n 是 内存中机器码的大小</span><br><span class="line">    // msg.value 不能使用，需要用 callvalue()</span><br><span class="line">    adds := create(callvalue(), add(_code, 0x20), mload(_code))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="create2-v-p-n-s"><a href="#create2-v-p-n-s" class="headerlink" title="create2(v, p, n, s)"></a>create2(v, p, n, s)</h4><p>下面是 <a href="https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Factory.sol">UniswapV2Factory</a> 中创建 pair 核心逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Z &#123;</span><br><span class="line">    bytes6 public name1 = &quot;Anbang&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function addr() public returns (address pair) &#123;</span><br><span class="line">        bytes memory bytecode = type(Z).creationCode;</span><br><span class="line">        // bytes32 salt = keccak256(abi.encodePacked(address(0), address(1)));</span><br><span class="line">        uint256 salt = block.number;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作数据-大小"><a href="#操作数据-大小" class="headerlink" title="操作数据&#x2F;大小"></a>操作数据&#x2F;大小</h3><table><thead><tr><th>操作符号</th><th>返回值</th><th>版本</th><th>解释说明</th></tr></thead><tbody><tr><td>msize()</td><td></td><td>F</td><td>内存大小，即最大访问内存索引</td></tr><tr><td>pc()</td><td></td><td>F</td><td>当前在代码中的位置</td></tr><tr><td>codesize()</td><td></td><td>F</td><td>当前合约的代码大小 &#x2F; execution context</td></tr><tr><td>codecopy(t, f, s)</td><td>-</td><td>F</td><td>从位置 f 的代码复制 s 个字节到位置 t 的内存</td></tr><tr><td>extcodesize(a)</td><td></td><td>F</td><td>获取地址 a 的代码大小</td></tr><tr><td>extcodecopy(a, t, f, s)</td><td>-</td><td>F</td><td>像 codecopy(t, f, s) 但在地址 a 处获取代码</td></tr><tr><td>signextend(i, x)</td><td></td><td>F</td><td>sign extend from <code>(i*8+7)</code>th bit counting from least significant</td></tr><tr><td>byte(n, x)</td><td></td><td>F</td><td>x 的第 n 个字节，这个索引是从 0 开始的</td></tr><tr><td>pop(x)</td><td>-</td><td>F</td><td>丢弃值 x</td></tr></tbody></table><h4 id="msize"><a href="#msize" class="headerlink" title="msize()"></a>msize()</h4><p>内存大小，即最大访问内存索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function test() public pure returns (int256) &#123;</span><br><span class="line">        int8 v0 = 1;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            v0 := msize()</span><br><span class="line">        &#125;</span><br><span class="line">        return int256(v0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pc"><a href="#pc" class="headerlink" title="pc()"></a>pc()</h4><h4 id="codesize"><a href="#codesize" class="headerlink" title="codesize()"></a>codesize()</h4><h4 id="codecopy-t-f-s"><a href="#codecopy-t-f-s" class="headerlink" title="codecopy(t, f, s)"></a>codecopy(t, f, s)</h4><h4 id="extcodesize-a"><a href="#extcodesize-a" class="headerlink" title="extcodesize(a)"></a>extcodesize(a)</h4><h4 id="extcodecopy-a-t-f-s"><a href="#extcodecopy-a-t-f-s" class="headerlink" title="extcodecopy(a, t, f, s)"></a>extcodecopy(a, t, f, s)</h4><h4 id="signextend-i-x"><a href="#signextend-i-x" class="headerlink" title="signextend(i, x)"></a>signextend(i, x)</h4><h4 id="byte-n-x"><a href="#byte-n-x" class="headerlink" title="byte(n, x)"></a>byte(n, x)</h4><h4 id="pop-x"><a href="#pop-x" class="headerlink" title="pop(x)"></a>pop(x)</h4><h3 id="call-相关"><a href="#call-相关" class="headerlink" title="call 相关"></a>call 相关</h3><table><thead><tr><th>操作符号</th><th>返回值</th><th>版本</th><th>解释说明</th></tr></thead><tbody><tr><td>calldataload(p)</td><td></td><td>F</td><td>从位置 p 开始调用数据 (32 bytes)</td></tr><tr><td>calldatasize()</td><td></td><td>F</td><td>调用数据的大小（以字节为单位）</td></tr><tr><td>calldatacopy(t, f, s)</td><td>-</td><td>F</td><td>从位置 f 的 calldata 复制 s 个字节到位置 t 的内存</td></tr><tr><td>call(g, a, v, in, insize, out, outsize)</td><td></td><td>F</td><td>在地址 a 调用合约 <a href="https://www.axihe.com/#yul-call-return-area">See more</a></td></tr><tr><td>callcode(g, a, v, in, insize, out, outsize)</td><td></td><td>F</td><td>与 <code>call</code> 相同，但仅使用 a 中的代码，否则留在当前合约的上下文中 <a href="https://www.axihe.com/#yul-call-return-area">See more</a></td></tr><tr><td>delegatecall(g, a, in, insize, out, outsize)</td><td></td><td>H</td><td>与 <code>callcode</code> 相同，但也保留 <code>caller</code> 和 <code>callvalue</code> <a href="https://www.axihe.com/#yul-call-return-area">See more</a></td></tr><tr><td>staticcall(g, a, in, insize, out, outsize)</td><td></td><td>B</td><td>与 <code>call(g, a, 0, in, insize, out, outsize)</code> 相同，但不允许状态修改 ons <a href="https://www.axihe.com/#yul-call-return-area">See more</a></td></tr></tbody></table><h3 id="结束执行"><a href="#结束执行" class="headerlink" title="结束执行"></a>结束执行</h3><table><thead><tr><th>操作符号</th><th>返回值</th><th>版本</th><th>解释说明</th></tr></thead><tbody><tr><td>return(p, s)</td><td>-</td><td>F</td><td>结束执行, return data mem[p…(p+s))</td></tr><tr><td>stop()</td><td>-</td><td>F</td><td>结束执行, 类似 <code>return(0, 0)</code></td></tr><tr><td>revert(p, s)</td><td>-</td><td>B</td><td>结束执行, revert state changes, return data mem[p…(p+s))</td></tr><tr><td>selfdestruct(a)</td><td>-</td><td>F</td><td>结束执行, destroy current contract and send funds to a</td></tr><tr><td>invalid()</td><td>-</td><td>F</td><td>结束执行 with invalid instruction</td></tr><tr><td>returndatasize()</td><td></td><td>B</td><td>最后返回数据的大小</td></tr><tr><td>returndatacopy(t, f, s)</td><td>-</td><td>B</td><td>将 s 个字节从位置 f 的 returndata 复制到位置 t 的 mem</td></tr></tbody></table><h3 id="log-信息"><a href="#log-信息" class="headerlink" title="log 信息"></a>log 信息</h3><table><thead><tr><th>操作符号</th><th>返回值</th><th>版本</th><th>解释说明</th></tr></thead><tbody><tr><td>log0(p, s)</td><td>-</td><td>F</td><td>log without topics and data mem[p…(p+s))</td></tr><tr><td>log1(p, s, t1)</td><td>-</td><td>F</td><td>log with topic t1 and data mem[p…(p+s))</td></tr><tr><td>log2(p, s, t1, t2)</td><td>-</td><td>F</td><td>log with topics t1, t2 and data mem[p…(p+s))</td></tr><tr><td>log3(p, s, t1, t2, t3)</td><td>-</td><td>F</td><td>log with topics t1, t2, t3 and data mem[p…(p+s))</td></tr><tr><td>log4(p, s, t1, t2, t3, t4)</td><td>-</td><td>F</td><td>log with topics t1, t2, t3, t4 and data mem[p…(p+s))</td></tr></tbody></table><h1 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h1><h3 id="例子-1-一个演示"><a href="#例子-1-一个演示" class="headerlink" title="例子 1:一个演示"></a>例子 1:一个演示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">library VectorSum &#123;</span><br><span class="line">    // 此函数效率较低，因为优化器当前无法删除数组访问中的边界检查。</span><br><span class="line">    function sumSolidity(uint256[] memory data)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256 sum)</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt; data.length; ++i) sum += data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // We know that we only access the array in bounds, so we can avoid the check.</span><br><span class="line">    // 0x20 needs to be added to an array because the first slot contains the</span><br><span class="line">    // array length.</span><br><span class="line">    // 我们知道我们只在边界内访问数组，</span><br><span class="line">    // 所以我们可以避免检查。0x20 需要添加到数组，因为第一个槽包含数组长度。</span><br><span class="line">    function sumAsm(uint256[] memory data) public pure returns (uint256 sum) &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt; data.length; ++i) &#123;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                sum := add(sum, mload(add(add(data, 0x20), mul(i, 0x20))))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Same as above, but accomplish the entire code within inline assembly.</span><br><span class="line">    function sumPureAsm(uint256[] memory data)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256 sum)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // Load the length (first 32 bytes)</span><br><span class="line">            let len := mload(data)</span><br><span class="line"></span><br><span class="line">            // Skip over the length field.</span><br><span class="line">            //</span><br><span class="line">            // Keep temporary variable so it can be incremented in place.</span><br><span class="line">            //</span><br><span class="line">            // NOTE: incrementing data would result in an unusable</span><br><span class="line">            //       data variable after this assembly block</span><br><span class="line">            let dataElementLocation := add(data, 0x20)</span><br><span class="line"></span><br><span class="line">            // Iterate until the bound is not met.</span><br><span class="line">            for &#123;</span><br><span class="line">                let end := add(dataElementLocation, mul(len, 0x20))</span><br><span class="line">            &#125; lt(dataElementLocation, end) &#123;</span><br><span class="line">                dataElementLocation := add(dataElementLocation, 0x20)</span><br><span class="line">            &#125; &#123;</span><br><span class="line">                sum := add(sum, mload(dataElementLocation))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子-2-获取合约代码"><a href="#例子-2-获取合约代码" class="headerlink" title="例子 2:获取合约代码"></a>例子 2:获取合约代码</h3><p>gas 相差无几，重点看一下 code 的背后原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // 24310 gas</span><br><span class="line">    function codeBySolidity(address _addr)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (bytes memory o_code)</span><br><span class="line">    &#123;</span><br><span class="line">        return _addr.code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 24286 gas</span><br><span class="line">    function codeByAssembly(address _addr)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (bytes memory o_code)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // 1.使用 extcodesize 获取合约内的代码大小</span><br><span class="line">            let size := extcodesize(_addr)</span><br><span class="line"></span><br><span class="line">            // 2.使用 mload 分配输出字节数组</span><br><span class="line">            // 类似 o_code = new bytes（size）</span><br><span class="line">            o_code := mload(0x40)</span><br><span class="line"></span><br><span class="line">            // 在 0x40 的位置存入数据</span><br><span class="line">            //      add(size, 0x20) :</span><br><span class="line">            //              size 加 0x20</span><br><span class="line">            //      add(add(size, 0x20), 0x1f)</span><br><span class="line">            //              size 加 0x20,再加 0x1f</span><br><span class="line">            //      not(0x1f)</span><br><span class="line">            //              0x1f 的按位非</span><br><span class="line">            //      and(add(add(size, 0x20), 0x1f), not(0x1f))</span><br><span class="line">            //          &quot;size 加 0x20,再加 0x1f&quot; 和 &quot;0x1f的按位非&quot; 的按位与</span><br><span class="line">            mstore(</span><br><span class="line">                0x40,</span><br><span class="line">                add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f)))</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            // 把长度保存到内存中</span><br><span class="line">            mstore(o_code, size)</span><br><span class="line"></span><br><span class="line">            // 实际获取代码，这需要汇编语言</span><br><span class="line">            extcodecopy(_addr, add(o_code, 0x20), 0, size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子-3-计算数值数组的和"><a href="#例子-3-计算数值数组的和" class="headerlink" title="例子 3:计算数值数组的和"></a>例子 3:计算数值数组的和</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">library VectorSum &#123;</span><br><span class="line">    // 因为目前的优化器在访问数组时无法移除边界检查，</span><br><span class="line">    // 所以这个函数的执行效率比较低。</span><br><span class="line">    function sumSolidity(uint256[] memory _data)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256 o_sum)</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt; _data.length; ++i) o_sum += _data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 我们只能在数组范围内访问数组元素，所以我们可以在内联汇编中不做边界检查。</span><br><span class="line">    // 由于 ABI 编码中数组数据的第一个字（32 字节）的位置保存的是数组长度，</span><br><span class="line">    // 所以我们在访问数组元素时需要加入 0x20 作为偏移量。</span><br><span class="line">    function sumAsm(uint256[] memory _data)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256 o_sum)</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt; _data.length; ++i) &#123;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                o_sum := add(o_sum, mload(add(add(_data, 0x20), mul(i, 0x20))))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 和上面一样，但在内联汇编内完成整个代码。</span><br><span class="line">    function sumPureAsm(uint256[] memory _data)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256 o_sum)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // 取得数组长度（取前 32 字节）</span><br><span class="line">            let len := mload(_data)</span><br><span class="line"></span><br><span class="line">            // 略过长度字段。</span><br><span class="line">            //</span><br><span class="line">            // 保持临时变量以便它可以在原地增加。</span><br><span class="line">            //</span><br><span class="line">            // 注意：对 _data 数值的增加将导致 _data 在这个汇编语句块之后不再可用。</span><br><span class="line">            //      因为无法再基于 _data 来解析后续的数组数据。</span><br><span class="line">            let data := add(_data, 0x20)</span><br><span class="line"></span><br><span class="line">            // 迭代到数组数据结束</span><br><span class="line">            for &#123;</span><br><span class="line">                let end := add(data, mul(len, 0x20))</span><br><span class="line">            &#125; lt(data, end) &#123;</span><br><span class="line">                data := add(data, 0x20)</span><br><span class="line">            &#125; &#123;</span><br><span class="line">                o_sum := add(o_sum, mload(data))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14-Library库</title>
      <link href="/2022/07/20/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/14-Library%E5%BA%93/"/>
      <url>/2022/07/20/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/14-Library%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>library 是智能合约的精简版，像智能合约一样，位于区块链上，包含可以被其他合约使用的代码。库合约有两种使用方法，直接调用和 <code>using...for...</code> 使用。</p><h1 id="库合约与普通智能合约区别"><a href="#库合约与普通智能合约区别" class="headerlink" title="库合约与普通智能合约区别"></a>库合约与普通智能合约区别</h1><p>库与合约类似，库的目的是只需要在特定的地址部署一次，而它们的代码可以通过EVM 的 <code>DELEGATECALL</code> 特性进行重用。这意味着如果库函数被调用，它的代码在调用合约的上下文中执行，即 <code>this</code> 指向调用合约，特别注意，他访问的是调用合约存储的状态。因为每个库都是一段独立的代码，所以它仅能访问调用合约明确提供的状态变量（否则它就无法通过名字访问这些变量）。</p><ul><li><p><strong>库不能有任何状态变量</strong></p></li><li><p><strong>它们也不能继承其他合约</strong>。</p></li><li><p>库合约函数的可视范围通常为internal，可变性为pure，也就是对所有使用它的合约可见。</p><ul><li>定义成 <code>external</code> 毫无意义，因为库合约函数只在内部使用，不独立运行。</li><li>同样定义成 <code>private</code> 也不行，因为其它合约无法使用。</li></ul></li><li><p>禁止使用 <code>fallback</code> &#x2F; <code>receive</code> 函数，所以导致也不能接收以太币</p></li><li><p>Library 被销毁后，则所有方法恢复为初始值，功能失效。</p></li><li><p>使用库 library 的合约，可以将库合约视为隐式的父合约，当然它们不会显式的出现在继承关系中。也就是不用写 <code>is</code> 来继承，直接可以在合约中使用。</p></li><li><p>按照规范，库合约的名字需要首字母大写（大驼峰命名方式）</p></li></ul><p>可以通过类型转换, 将库类型更改为 <code>address</code> 类型, 例如: 使用<code>address(LibraryName)</code>,由于编译器无法知道库的部署位置，编译器会生成<code>__$30bbc0abd4d6364515865950d3e0d10953$__</code>形式的占位符，该占位符是完整的库名称的 keccak256 哈希的十六进制编码的 34 个字符的前缀，例如：如果该库存储在 libraries 目录中名为 bigint.sol 的文件中，则完整的库名称为<code>libraries/bigint.sol:BigInt</code>。</p><p>此类字节码不完整的合约，不应该部署。占位符需要替换为实际地址。你可以通过在编译库时将它们传递给编译器或使用链接器更新已编译的二进制文件来实现。有关如何使用命令行编译器进行链接的信息，请参见 <a href="https://learnblockchain.cn/docs/solidity/using-the-compiler.html#/library-linking"><code>library-linking</code></a> 。</p><h1 id="直接调用库合约方法"><a href="#直接调用库合约方法" class="headerlink" title="直接调用库合约方法"></a>直接调用库合约方法</h1><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例 1"></a>案例 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">library Math &#123;</span><br><span class="line">    function max(uint256 _x, uint256 _y) internal pure returns (uint256) &#123;</span><br><span class="line">        return _x &gt; _y ? _x : _y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function testMax(uint256 _x, uint256 _y) external pure returns (uint256) &#123;</span><br><span class="line">        return Math.max(_x, _y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例 2"></a>案例 2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">library ArrayLib &#123;</span><br><span class="line">    function find(uint256[] storage _arr, uint256 _value)</span><br><span class="line">        internal</span><br><span class="line">        view</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint256 index = 0; index &lt; _arr.length; index++) &#123;</span><br><span class="line">            if (_arr[index] == _value) &#123;</span><br><span class="line">                return index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        revert(&quot;Not Found&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    uint256[] public arr = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19];</span><br><span class="line"></span><br><span class="line">    // 会成功</span><br><span class="line">    function test1() external view returns (uint256) &#123;</span><br><span class="line">        return ArrayLib.find(arr, 15);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 会失败</span><br><span class="line">    function test2() external view returns (uint256) &#123;</span><br><span class="line">        return ArrayLib.find(arr, 99);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="using-for-使用库合约"><a href="#using-for-使用库合约" class="headerlink" title="using...for... 使用库合约"></a><code>using...for...</code> 使用库合约</h1><p>使用库合约还有更方便的方法，那就是 <code>using for</code> 指令。</p><p>例如：<code>using A for B</code> 用来将 A 库里定义的函数附着到类型 B。<strong>这些函数将会默认接收调用函数对象的实例作为第一个参数</strong>。<br>using For 可在文件或合约内部及合约级都是有效的。</p><p>核心如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using ArrayLib for uint256[];</span><br><span class="line">uint256[] public arr = [10, 11, 12, 13, 14,...];</span><br><span class="line">...</span><br><span class="line">arr.find(15); // 直接使用</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">library ArrayLib &#123;</span><br><span class="line">    function find(uint256[] storage _arr, uint256 _value)</span><br><span class="line">        internal</span><br><span class="line">        view</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint256 index = 0; index &lt; _arr.length; index++) &#123;</span><br><span class="line">            if (_arr[index] == _value) &#123;</span><br><span class="line">                return index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        revert(&quot;Not Found&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    // using for 可以让所有 uint256[] 数据，都具有 ArrayLib 内的方法</span><br><span class="line">    using ArrayLib for uint256[];</span><br><span class="line"></span><br><span class="line">    uint256[] public arr = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19];</span><br><span class="line"></span><br><span class="line">    function test1() external view returns (uint256) &#123;</span><br><span class="line">        // return ArrayLib.find(arr, 15);</span><br><span class="line"></span><br><span class="line">        // 可以直接使用 arr.find，而不需要额外修改 ArrayLib 内的代码</span><br><span class="line">        return arr.find(15);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test2() external view returns (uint256) &#123;</span><br><span class="line">        // return ArrayLib.find(arr, 99);</span><br><span class="line">        return arr.find(99);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="using-for-其他用法"><a href="#using-for-其他用法" class="headerlink" title="using for 其他用法"></a>using for 其他用法</h3><p>第一部分 <code>A</code> 可以是以下之一：</p><ul><li>一些库或文件级的函数列表(<code>using &#123;f, g, h, L.t&#125; for uint;</code>)，仅是那些函数被附加到类型。</li><li>库名称 (<code>using L for uint;</code>) ，库里所有的函数(包括 public 和 internal 函数) 被附加到类型上。</li></ul><p>在文件级，第二部分 <code>B</code> 必须是一个显式类型（不用指定数据位置）</p><p>在合约内，你可以使用 <code>using L for *;</code>， 表示库 <code>L</code>中的函数被附加在所有类型上。</p><p>如果你指定一个库，库内所有函数都会被加载，即使它们的第一个参数类型与对象的类型不匹配。类型检查会在函数调用和重载解析时执行。</p><p>如果你使用函数列表 (<code>using &#123;f, g, h, L.t&#125; for uint;</code>)， 那么类型<br>(<code>uint</code>) 会隐式的转换为这些函数的第一个参数。<br>即便这些函数中没有一个被调用，这个检查也会进行。</p><p><code>using A for B;</code> 指令仅在当前作用域有效（要么是合约中，或当前模块、或源码单元），包括在作用域内的所有函数，在合约或模块之外则无效。</p><p>当 <code>using for</code> 指令在文件级别使用，并应用于一个用户定义类型（在用一个文件定义的文件级别的用户类型），<code>global</code> 关键字可以添加到末尾。产生的效果是，这些函数被附加到使用该类型的任何地方（包括其他文件），而不仅仅是声明处所在的作用域。</p><p>在下面的例子中，我们将使用库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">library Search &#123;</span><br><span class="line">    function indexOf(uint[] storage self, uint value)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint)</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint i = 0; i &lt; self.length; i++)</span><br><span class="line">            if (self[i] == value) return i;</span><br><span class="line">        return type(uint).max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">using Search for uint[];</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using Search for uint[];</span><br><span class="line">    uint[] data;</span><br><span class="line"></span><br><span class="line">    function append(uint value) public &#123;</span><br><span class="line">        data.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function replace(uint from, uint to) public &#123;</span><br><span class="line">        // 执行库函数调用</span><br><span class="line">        uint index = data.indexOf(from);</span><br><span class="line">        if (index == type(uint).max)</span><br><span class="line">            data.push(to);</span><br><span class="line">        else</span><br><span class="line">            data[index] = to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，所有 external 库调用都是实际的 EVM 函数调用。这意味着如果传递内存或值类型，都将产生一个副本，即使是 <code>self</code> 变量。 引用存储变量或者 internal 库调用 是唯一不会发生拷贝的情况。</p><h1 id="直接调用-和-using-for-对比"><a href="#直接调用-和-using-for-对比" class="headerlink" title="直接调用 和 using for 对比"></a>直接调用 和 using for 对比</h1><ul><li>using for 更符合语义化</li><li>库合约使用 using for 比直接使用更省 gas</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">library Sum &#123;</span><br><span class="line">    function sum(uint256[] memory _data) public pure returns (uint256 temp) &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt; _data.length; ++i) &#123;</span><br><span class="line">            temp += _data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    using Sum for uint256[];</span><br><span class="line">    uint256[] data;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        data.push(1);</span><br><span class="line">        data.push(2);</span><br><span class="line">        data.push(3);</span><br><span class="line">        data.push(4);</span><br><span class="line">        data.push(5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 43874 gas</span><br><span class="line">    function sumA1() external view returns (uint256) &#123;</span><br><span class="line">        return Sum.sum(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 43531 gas</span><br><span class="line">    function sumA2() external view returns (uint256) &#123;</span><br><span class="line">        return data.sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="销毁合约库"><a href="#销毁合约库" class="headerlink" title="销毁合约库"></a>销毁合约库</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">library Math &#123;</span><br><span class="line">    function max(uint256 _x, uint256 _y) internal pure returns (uint256) &#123;</span><br><span class="line">        return _x &gt; _y ? _x : _y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function kill() internal &#123;</span><br><span class="line">        selfdestruct(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Libraries cannot have fallback functions.</span><br><span class="line">    // fallback() external &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // Libraries cannot have receive ether functions.</span><br><span class="line">    // receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function testMax(uint256 _x, uint256 _y) external pure returns (uint256) &#123;</span><br><span class="line">        return Math.max(_x, _y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testKill() external &#123;</span><br><span class="line">        return Math.kill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行 <code>Test.testMax</code></li><li>执行 <code>Test.testKill</code></li><li>再次执行 <code>Test.testMax</code>，发现结果是默认值</li></ul><h1 id="扩展-库的调用保护"><a href="#扩展-库的调用保护" class="headerlink" title="扩展:库的调用保护"></a>扩展:库的调用保护</h1><p>如果库的代码是通过 <code>CALL</code> 来执行，而不是 <code>DELEGATECALL</code> 那么执行的结果会被回退，除非是对 <code>view</code> 或者 <code>pure</code> 函数的调用。EVM 没有为合约提供检测是否使用 <code>CALL</code> 的直接方式，但是合约可以使用<code>ADDRESS</code> 操作码找出正在运行的”位置”。生成的代码通过比较这个地址和构造时的地址来确定调用模式。</p><p>更具体地说，库的运行时代码总是从一个 push 指令开始，它在编译时是 20 字节的零。当运行部署代码时，这个常数被内存中的当前地址替换，修改后的代码存储在合约中。在运行时，部署时地址就成为了第一个被 push 到堆栈上的常数， 对于任何 non-view 和 non-pure 函数，调度器代码都将对比当前地址与这个常数是否一致。这意味着库在链上存储的实际代码与编译器输出的 <code>deployedBytecode</code> 的编码是不同。</p>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13-interface接口</title>
      <link href="/2022/07/17/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/13-interface%E6%8E%A5%E5%8F%A3/"/>
      <url>/2022/07/17/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/13-interface%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>很多时候，我们需要调用已经部署在链上的已经合约，这时候可以通过接口合约实现部分调用的逻辑，我们只需要写一个与之对应的接口合约，就可以调用了。</p><p>在 solidity 语言中，只要某个合约有和接口种相同的函数声明，就可以被此合约所接受。接口就是起到一个桥接的作用；类似手机的接口，只要匹配，可以进行充电，也可以进行听歌。</p><p>interface 类似于<a href="https://www.axihe.com/source/10.inheritance.html#abstract">抽象合约</a> ，但它们不能实现任何功能。还有其他限制。 <code>interface</code>内的函数被隐式标记为virtual</p><h1 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h1><ul><li><p>无法实现任何功能，没有函数体。</p></li><li><p>无法定义构造函数。</p></li><li><p>无法定义状态变量。</p></li><li><p>无法定义结构（<code>struct</code>）（<code>0.5.0</code> 版本开始接口里可以支持声明 <code>enum</code> 类型）。</p></li><li><p>不可以声明修改器。</p></li><li><p>所有声明的函数必须是external的，尽管在合约里可以是 public</p><ul><li>文档说：将来可能会解除这里的某些限制。</li></ul></li></ul><p>⚠️ 注意： interface 可以基于别的 interface，可以继承其他合约。比如 <code>interface IERC20Metadata is IERC20&#123;&#125;</code>,定义 <code>IERC20Metadata</code> 基于 <code>IERC20</code> 接口。</p><h1 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h1><p>接口需要有 interface 关键字，并且内部只需要有函数的声明，不用实现。只要某合约中有和词接口相同的函数声明，就可以被此合约所接受。语法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line">    函数声明;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口基本上仅限于合约 ABI 可以表示的内容，并且 ABI 和接口之间的转换不应该丢失任何信息。</p><p>在下面的例子中，定义了 cat 合约以及 dog 合约。他们都有 eat 方法.以此他们都可以被上面的 animalEat 接口所接收。</p><h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Cat &#123;</span><br><span class="line">    uint256 public age;</span><br><span class="line"></span><br><span class="line">    function eat() public returns (string memory) &#123;</span><br><span class="line">        age++;</span><br><span class="line">        return &quot;cat eat fish&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sleep1() public pure returns (string memory) &#123;</span><br><span class="line">        return &quot;sleep1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Dog &#123;</span><br><span class="line">    uint256 public age;</span><br><span class="line"></span><br><span class="line">    function eat() public returns (string memory) &#123;</span><br><span class="line">        age += 2;</span><br><span class="line">        return &quot;dog miss you&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sleep2() public pure returns (string memory) &#123;</span><br><span class="line">        return &quot;sleep2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface AnimalEat &#123;</span><br><span class="line">    function eat() external returns (string memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Animal &#123;</span><br><span class="line">    function test(address _addr) external returns (string memory) &#123;</span><br><span class="line">        AnimalEat general = AnimalEat(_addr);</span><br><span class="line">        return general.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试流程:</p><ol><li><p>部署 Cat 合约</p></li><li><p>部署 Dog 合约</p></li><li><p>部署 Animal 合约</p></li><li><p>调用Animal.test,参数是 Cat 合约地址</p><ol><li>返回 <code>&quot;string: cat eat fish&quot;</code></li><li>在 Cat 合约内查看 <code>age</code> 返回的数字</li></ol></li><li><p>调用Animal.test,参数是 Dog 合约地址</p><ol><li>返回 <code>&quot;string: dog miss you&quot;</code></li></ol></li><li><p>在 Dog 合约内查看 <code>age</code> 返回的数字</p></li></ol><p>在合约 Animal 中，调用函数 test，如果传递的是部署的 Cat 的合约地址，那么我们在调用接口的 eat 方法时，实则调用了 Cat 合约的 eat 方法。 同理，如果传递的是部署的 Dog 的合约地址，那么我们在调用接口的 eat 方法时，实则调用了 dog 合约的 eat 方法。</p><h3 id="隐式的标记为virtual"><a href="#隐式的标记为virtual" class="headerlink" title="隐式的标记为virtual"></a>隐式的标记为<code>virtual</code></h3><p>就像继承其他合约一样，合约可以继承接口。接口中的函数都会隐式的标记为<code>virtual</code> ，意味着他们会被重写并不需要 <code>override</code> 关键字。<br>但是不表示重写（overriding）函数可以再次重写，仅仅当重写的函数标记为<code>virtual</code> 才可以再次重写。</p><p>接口可以继承其他的接口，遵循同样继承规则。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">interface ParentA &#123;</span><br><span class="line">    function test() external returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ParentB &#123;</span><br><span class="line">    function test() external returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SubInterface is ParentA, ParentB &#123;</span><br><span class="line">    // 必须重新定义 test 函数，以表示兼容父合约含义</span><br><span class="line">    function test() external override(ParentA, ParentB) returns (uint256);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="全局属性-type-I-interfaceId"><a href="#全局属性-type-I-interfaceId" class="headerlink" title="全局属性 type(I).interfaceId"></a>全局属性 <code>type(I).interfaceId</code></h1><p>返回接口<code>I</code> 的 bytes4 类型的接口 ID，接口 ID 参考： EIP-165 定义的， 接口 ID 被定义为 XOR （异或） 接口内所有的函数的函数选择器（除继承的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">interface ParentA &#123;</span><br><span class="line">    function test() external returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function interfaceId() public pure returns (bytes4) &#123;</span><br><span class="line">    //0xf8a8fd6d</span><br><span class="line">        return type(ParentA).interfaceId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ERC20-标准"><a href="#ERC20-标准" class="headerlink" title="ERC20 标准"></a>ERC20 标准</h1><h3 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h3><p><strong>问题: 如何判断一个 Token 合约是否为标准的 ERC20 合约？</strong></p><ul><li>只要含有 ERC20 接口规定的所有内容，就算标准的 ERC20 合约。<ul><li>至于方法内的逻辑是如何实现的，是不做判断。</li></ul></li></ul><p>详情参考: <a href="https://eips.ethereum.org/EIPS/eip-20">https://eips.ethereum.org/EIPS/eip-20</a></p><h3 id="标准-ERC20-接口"><a href="#标准-ERC20-接口" class="headerlink" title="标准 ERC20 接口"></a>标准 ERC20 接口</h3><ul><li><p>3 个查询</p><ul><li><code>balanceOf</code>: 查询指定地址的 Token 数量</li><li><code>totalSupply</code>: 查询当前合约的 Token 总量</li><li><code>allowance</code>: 查询指定地址对另外一个地址的剩余授权额度</li></ul></li><li><p>2 个交易</p><ul><li><code>transfer</code>: 从当前调用者地址发送指定数量的 Token 到指定地址,这是一个写入方法，所以还会抛出一个 <code>Transfer</code> 事件。</li><li><code>transferFrom</code>: 当向另外一个合约地址存款时，对方合约必须调用 transferFrom 才可以把 Token 拿到它自己的合约中。</li></ul></li><li><p>2 个事件</p><ul><li><code>Transfer</code></li><li><code>Approval</code></li></ul></li><li><p>1 个授权</p><ul><li><code>approve</code>: 授权指定地址可以操作调用者的最大 Token 数量。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line">    // 1个授权</span><br><span class="line">    function approve(address spender, uint256 amount) external returns (bool);</span><br><span class="line"></span><br><span class="line">    // 2个事件</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 amount);</span><br><span class="line">    event Approval(</span><br><span class="line">        address indexed owner,</span><br><span class="line">        address indexed spender,</span><br><span class="line">        uint256 amount</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 2个交易</span><br><span class="line">    function transfer(address recipient, uint256 amount)</span><br><span class="line">        external</span><br><span class="line">        returns (bool);</span><br><span class="line"></span><br><span class="line">    function transferFrom(</span><br><span class="line">        address sender,</span><br><span class="line">        address recipient,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) external returns (bool);</span><br><span class="line"></span><br><span class="line">    // 3个查询</span><br><span class="line">    function totalSupply() external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    function balanceOf(address account) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    function allowance(address owner, address spender)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (uint256);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ERC20-标准合约实现"><a href="#ERC20-标准合约实现" class="headerlink" title="ERC20 标准合约实现"></a>ERC20 标准合约实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line">    // 1个授权</span><br><span class="line">    function approve(address spender, uint256 amount) external returns (bool);</span><br><span class="line"></span><br><span class="line">    // 2个事件</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 amount);</span><br><span class="line">    event Approval(</span><br><span class="line">        address indexed owner,</span><br><span class="line">        address indexed spender,</span><br><span class="line">        uint256 amount</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 2个交易</span><br><span class="line">    function transfer(address recipient, uint256 amount)</span><br><span class="line">        external</span><br><span class="line">        returns (bool);</span><br><span class="line"></span><br><span class="line">    function transferFrom(</span><br><span class="line">        address sender,</span><br><span class="line">        address recipient,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) external returns (bool);</span><br><span class="line"></span><br><span class="line">    // 3个查询</span><br><span class="line">    function totalSupply() external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    function balanceOf(address account) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    function allowance(address owner, address spender)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ERC20 is IERC20 &#123;</span><br><span class="line">    // 状态变量</span><br><span class="line">    string public name;</span><br><span class="line">    string public symbol;</span><br><span class="line">    uint8 public immutable decimals;</span><br><span class="line"></span><br><span class="line">    address public immutable owner;</span><br><span class="line"></span><br><span class="line">    // uint256 public immutable totalSupply; // 不增加总量</span><br><span class="line">    uint256 public totalSupply; // 总价总量</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">    // 函数修改器</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;not owner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 构造函数</span><br><span class="line">    constructor(</span><br><span class="line">        string memory _name,</span><br><span class="line">        string memory _symbol,</span><br><span class="line">        uint8 _decimals,</span><br><span class="line">        uint256 _totalSupply</span><br><span class="line">    ) &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        name = _name;</span><br><span class="line">        symbol = _symbol;</span><br><span class="line">        decimals = _decimals;</span><br><span class="line">        totalSupply = _totalSupply;</span><br><span class="line">        balanceOf[msg.sender] = _totalSupply;</span><br><span class="line">        emit Transfer(address(0), msg.sender, _totalSupply);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1个授权</span><br><span class="line">    function approve(address spender, uint256 amount) external returns (bool) &#123;</span><br><span class="line">        allowance[msg.sender][spender] = amount;</span><br><span class="line">        emit Approval(msg.sender, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2个交易</span><br><span class="line">    function transfer(address recipient, uint256 amount)</span><br><span class="line">        external</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">        balanceOf[recipient] += amount;</span><br><span class="line">        emit Transfer(msg.sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(</span><br><span class="line">        address sender,</span><br><span class="line">        address recipient,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) external returns (bool) &#123;</span><br><span class="line">        // msg.sender 也就是当前调用者，是被批准者</span><br><span class="line">        allowance[sender][msg.sender] -= amount;</span><br><span class="line">        balanceOf[sender] -= amount;</span><br><span class="line">        balanceOf[recipient] += amount;</span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1个铸币 - 非必须</span><br><span class="line">    function mint(uint256 amount) external onlyOwner returns (bool) &#123;</span><br><span class="line">        totalSupply += amount;</span><br><span class="line">        balanceOf[msg.sender] += amount;</span><br><span class="line">        emit Transfer(address(0), msg.sender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1个销毁 - 非必须</span><br><span class="line">    function burn(uint256 amount) external returns (bool) &#123;</span><br><span class="line">        totalSupply -= amount;</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">        emit Transfer(msg.sender, address(0), amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 转移 owner 权限等其他一些操作均是看各自业务，非必需的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ERC721-标准"><a href="#ERC721-标准" class="headerlink" title="ERC721 标准"></a>ERC721 标准</h1><p>参考资料:</p><ul><li><a href="https://eips.ethereum.org/EIPS/eip-721">https://eips.ethereum.org/EIPS/eip-721</a></li><li><a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-721/">https://ethereum.org/zh/developers/docs/standards/tokens/erc-721/</a></li></ul><h3 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h3><p>非同质化代币（NFT）用于以唯一的方式标识某人或者某物。 此类型的代币可以被完美地用于出售下列物品的平台：收藏品、密钥、彩票、音乐会座位编号、体育比赛等。 这种类型的代币有着惊人的潜力，因此它需要一个适当的标准。ERC-721 就是为解决这个问题而来！</p><p>所有 NFTs 都有一个 <code>uint256</code> 变量，名为 <code>tokenId</code>，所以对于任何 ERC-721 合约，这对值 <code>contract address, tokenId</code> 必须是全局唯一的。 也就是说，去中心化应用程序可以有一个“转换器”， 使用 tokenId 作为输入并输出一些很酷的事物图像，例如僵尸、武器、技能或神奇的小猫咪！</p><h3 id="合约代码"><a href="#合约代码" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @dev ERC165 标准的接口 https://eips.ethereum.org/EIPS/eip-165</span><br><span class="line"> * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified</span><br><span class="line"> */</span><br><span class="line">interface IERC165 &#123;</span><br><span class="line">    /// @notice 查询合约是否实现接口</span><br><span class="line">    /// @param interfaceID ERC-165 中指定的接口标识符</span><br><span class="line">    /// @dev 接口标识在 ERC-165 中指定。此功能需要低于 30,000 gas。</span><br><span class="line">    /// @return 如果合约实现了 interfaceID 且 interfaceID 不是 0xffffffff，则为 true，否则为 false</span><br><span class="line">    function supportsInterface(bytes4 interfaceID) external view returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// @title ERC-721 Non-Fungible Token Standard</span><br><span class="line">/// @dev See https://eips.ethereum.org/EIPS/eip-721</span><br><span class="line">///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.</span><br><span class="line">interface IERC721 is IERC165 &#123;</span><br><span class="line">    /**</span><br><span class="line">     @dev 当任何 NFT 的所有权通过任何形式发生变化时，需要触发该事件。</span><br><span class="line">     当 NFT 创建（`from` == 0）和销毁（`to` == 0）时会触发此事件。</span><br><span class="line">     例外情况：在合约创建期间，可以创建和分配任意数量的 NFT，而不会发出 Transfer。</span><br><span class="line">     在任何形式的资产转移时，该 NFT如果有批准地址将重置为无。</span><br><span class="line">    */</span><br><span class="line">    event Transfer(</span><br><span class="line">        address indexed _from,</span><br><span class="line">        address indexed _to,</span><br><span class="line">        uint256 indexed _tokenId</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当 NFT 的批准地址被更改或重新确认时，它会发出。</span><br><span class="line">     * 零地址表示没有批准的地址。</span><br><span class="line">     * 当 Transfer 事件发出时，这也表明该 NFT 如果有批准地址被重置为无。</span><br><span class="line">     */</span><br><span class="line">    event Approval(</span><br><span class="line">        address indexed _owner,</span><br><span class="line">        address indexed _approved,</span><br><span class="line">        uint256 indexed _tokenId</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /// @dev 当为所有者启用或禁用操作员时，它会发出。 运营者可以管理所有者的所有 NFT。</span><br><span class="line">    event ApprovalForAll(</span><br><span class="line">        address indexed _owner,</span><br><span class="line">        address indexed _operator,</span><br><span class="line">        bool _approved</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /// @notice 所有者的 NFT 数量</span><br><span class="line">    /// @dev 分配给零地址的 NFT 被认为是无效的，并且该函数抛出有关零地址的查询。</span><br><span class="line">    /// @param _owner 查询余额的地址</span><br><span class="line">    /// @return `_owner` 拥有的 NFT 数量，可能为零</span><br><span class="line">    function balanceOf(address _owner) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    /// @notice 找到 NFT 的所有者</span><br><span class="line">    /// @dev 分配给零地址的 NFT 被认为是无效的，并且对它们的查询确实会抛出异常。</span><br><span class="line">    /// @param _tokenId NFT 的标识符</span><br><span class="line">    /// @return NFT所有者的地址</span><br><span class="line">    function ownerOf(uint256 _tokenId) external view returns (address);</span><br><span class="line"></span><br><span class="line">    /// @notice 将 NFT 的所有权从一个地址转移到另一个地址</span><br><span class="line">    /// @dev Throws unless `msg.sender` is the current owner, an authorized</span><br><span class="line">    ///  operator, or the approved address for this NFT. Throws if `_from` is</span><br><span class="line">    ///  not the current owner. Throws if `_to` is the zero address. Throws if</span><br><span class="line">    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function</span><br><span class="line">    ///  checks if `_to` is a smart contract (code size &gt; 0). If so, it calls</span><br><span class="line">    ///  `onERC721Received` on `_to` and throws if the return value is not</span><br><span class="line">    ///  `bytes4(keccak256(&quot;onERC721Received(address,address,uint256,bytes)&quot;))`.</span><br><span class="line">    /// @param _from NFT的当前所有者</span><br><span class="line">    /// @param _to 新 owner</span><br><span class="line">    /// @param _tokenId 转移的 NFT</span><br><span class="line">    /// @param data 没有指定格式的附加数据，在调用 _to 时发送</span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address _from,</span><br><span class="line">        address _to,</span><br><span class="line">        uint256 _tokenId,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external payable;</span><br><span class="line"></span><br><span class="line">    /// @notice 将 NFT 的所有权从一个地址转移到另一个地址</span><br><span class="line">    /// @dev 这与具有额外数据参数的其他函数的工作方式相同，只是此函数只是将数据设置为“”。</span><br><span class="line">    /// @param _from NFT的当前所有者</span><br><span class="line">    /// @param _to 新 owner</span><br><span class="line">    /// @param _tokenId 转移的 NFT</span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address _from,</span><br><span class="line">        address _to,</span><br><span class="line">        uint256 _tokenId</span><br><span class="line">    ) external payable;</span><br><span class="line"></span><br><span class="line">    /// @notice 转移 NFT 的所有权——调用者有责任确认 `_to` 能够接收 NFT，否则它们可能会永久丢失</span><br><span class="line">    /// @dev Throws unless `msg.sender` is the current owner, an authorized</span><br><span class="line">    ///  operator, or the approved address for this NFT. Throws if `_from` is</span><br><span class="line">    ///  not the current owner. Throws if `_to` is the zero address. Throws if</span><br><span class="line">    ///  `_tokenId` is not a valid NFT.</span><br><span class="line">    /// @param _from NFT的当前所有者</span><br><span class="line">    /// @param _to 新 owner</span><br><span class="line">    /// @param _tokenId 转移的 NFT</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address _from,</span><br><span class="line">        address _to,</span><br><span class="line">        uint256 _tokenId</span><br><span class="line">    ) external payable;</span><br><span class="line"></span><br><span class="line">    /// @notice 更改或重申 NFT 的批准地址</span><br><span class="line">    /// @dev The zero address indicates there is no approved address.</span><br><span class="line">    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized</span><br><span class="line">    ///  operator of the current owner.</span><br><span class="line">    /// @param _approved 新批准的 NFT 控制器</span><br><span class="line">    /// @param _tokenId NFT 批准</span><br><span class="line">    function approve(address _approved, uint256 _tokenId) external payable;</span><br><span class="line"></span><br><span class="line">    /// @notice 启用或禁用对第三方（“操作员”）的批准以管理所有 `msg.sender` 的资产</span><br><span class="line">    /// @dev 发出 ApprovalForAll 事件。 合同必须允许每个所有者有多个操作员。</span><br><span class="line">    /// @param _operator 添加到授权运营商集中的地址</span><br><span class="line">    /// @param _approved 如果运营商获得批准，则为 True，如果撤消批准，则为 false</span><br><span class="line">    function setApprovalForAll(address _operator, bool _approved) external;</span><br><span class="line"></span><br><span class="line">    /// @notice 获取单个 NFT 的认可地址</span><br><span class="line">    /// @dev 如果 _tokenId 不是有效的 NFT，则抛出。</span><br><span class="line">    /// @param _tokenId NFT寻找批准的地址</span><br><span class="line">    /// @return 此 NFT 的批准地址，如果没有则为零地址</span><br><span class="line">    function getApproved(uint256 _tokenId) external view returns (address);</span><br><span class="line"></span><br><span class="line">    /// @notice 查询一个地址是否是另一个地址的授权操作员</span><br><span class="line">    /// @param _owner 拥有 NFT 的地址</span><br><span class="line">    /// @param _operator 代表所有者的地址</span><br><span class="line">    /// @return 如果 _operator 是 _owner 的批准运算符，则为真，否则为假</span><br><span class="line">    function isApprovedForAll(address _owner, address _operator)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (bool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ERC1155-标准"><a href="#ERC1155-标准" class="headerlink" title="ERC1155 标准"></a>ERC1155 标准</h1><p>参考资料:</p><ul><li><a href="https://eips.ethereum.org/EIPS/eip-1155">https://eips.ethereum.org/EIPS/eip-1155</a></li><li><a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-1155/">https://ethereum.org/zh/developers/docs/standards/tokens/erc-1155/</a></li></ul><h3 id="场景说明-1"><a href="#场景说明-1" class="headerlink" title="场景说明"></a>场景说明</h3><p>用于多种代币管理的合约标准接口。单个部署的合约可以包括同质化代币、非同质化代币或其他配置（如半同质化代币）的任何组合。</p><p>它的目的很单纯，就是创建一个智能合约接口，可以代表和控制任何数量的同质化和非同质化代币类型。 这样一来，ERC-1155 代币就具有与 ERC-20 和 ERC-721 代币相同的功能，甚至可以同时使用这两者的功能。 而最重要的是，它能改善这两种标准的功能，使其更有效率，并纠正 ERC-20 和 ERC-721 标准上明显的实施错误。</p><h3 id="合约代码-1"><a href="#合约代码-1" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @dev ERC165 标准的接口 https://eips.ethereum.org/EIPS/eip-165</span><br><span class="line"> * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified</span><br><span class="line"> */</span><br><span class="line">interface IERC165 &#123;</span><br><span class="line">    /// @notice 查询合约是否实现接口</span><br><span class="line">    /// @param interfaceID ERC-165 中指定的接口标识符</span><br><span class="line">    /// @dev 接口标识在 ERC-165 中指定。此功能需要低于 30,000 gas。</span><br><span class="line">    /// @return 如果合约实现了 interfaceID 且 interfaceID 不是 0xffffffff，则为 true，否则为 false</span><br><span class="line">    function supportsInterface(bytes4 interfaceID) external view returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">    @title ERC-1155 Multi Token Standard</span><br><span class="line">    @dev See https://eips.ethereum.org/EIPS/eip-1155</span><br><span class="line">    Note: The ERC-165 identifier for this interface is 0xd9b67a26.</span><br><span class="line"> */</span><br><span class="line">interface IERC1155 is IERC165 &#123;</span><br><span class="line">    /**</span><br><span class="line">        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred,</span><br><span class="line">        including zero value transfers as well as minting or burning (see &quot;Safe Transfer Rules&quot; section of the standard).</span><br><span class="line">        The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).</span><br><span class="line">        The `_from` argument MUST be the address of the holder whose balance is decreased.</span><br><span class="line">        The `_to` argument MUST be the address of the recipient whose balance is increased.</span><br><span class="line">        The `_id` argument MUST be the token type being transferred.</span><br><span class="line">        The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.</span><br><span class="line">        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).</span><br><span class="line">        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).</span><br><span class="line">    */</span><br><span class="line">    event TransferSingle(</span><br><span class="line">        address indexed _operator,</span><br><span class="line">        address indexed _from,</span><br><span class="line">        address indexed _to,</span><br><span class="line">        uint256 _id,</span><br><span class="line">        uint256 _value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred,</span><br><span class="line">        including zero value transfers as well as minting or burning (see &quot;Safe Transfer Rules&quot; section of the standard).</span><br><span class="line">        The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).</span><br><span class="line">        The `_from` argument MUST be the address of the holder whose balance is decreased.</span><br><span class="line">        The `_to` argument MUST be the address of the recipient whose balance is increased.</span><br><span class="line">        The `_ids` argument MUST be the list of tokens being transferred.</span><br><span class="line">        The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids)</span><br><span class="line">        the holder balance is decreased by and match what the recipient balance is increased by.</span><br><span class="line">        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).</span><br><span class="line">        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).</span><br><span class="line">    */</span><br><span class="line">    event TransferBatch(</span><br><span class="line">        address indexed _operator,</span><br><span class="line">        address indexed _from,</span><br><span class="line">        address indexed _to,</span><br><span class="line">        uint256[] _ids,</span><br><span class="line">        uint256[] _values</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        @dev 必须在批准第二方/运营商地址管理所有者地址的所有令牌时启用或禁用（没有事件假定禁用）</span><br><span class="line">    */</span><br><span class="line">    event ApprovalForAll(</span><br><span class="line">        address indexed _owner,</span><br><span class="line">        address indexed _operator,</span><br><span class="line">        bool _approved</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        @dev 必须在为令牌 ID 更新 URI 时发出。</span><br><span class="line">        URI 在 RFC 3986 中定义。</span><br><span class="line">        URI 必须指向符合“ERC-1155 元数据 URI JSON 模式”的 JSON 文件。</span><br><span class="line">    */</span><br><span class="line">    event URI(string _value, uint256 indexed _id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        @notice Transfers `_value` amount of an `_id` from the `_from` address</span><br><span class="line">                to the `_to` address specified (with safety call).</span><br><span class="line">        @dev Caller must be approved to manage the tokens being transferred</span><br><span class="line">        out of the `_from` account (see &quot;Approval&quot; section of the standard).</span><br><span class="line">        MUST revert if `_to` is the zero address.</span><br><span class="line">        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.</span><br><span class="line">        MUST revert on any other error.</span><br><span class="line">        MUST emit the `TransferSingle` event to reflect the balance change (see &quot;Safe Transfer Rules&quot; section of the standard).</span><br><span class="line">        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size &gt; 0). If so,</span><br><span class="line">        it MUST call `onERC1155Received` on `_to` and act appropriately (see &quot;Safe Transfer Rules&quot; section of the standard).</span><br><span class="line">        @param _from    Source address</span><br><span class="line">        @param _to      Target address</span><br><span class="line">        @param _id      ID of the token type</span><br><span class="line">        @param _value   Transfer amount</span><br><span class="line">        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`</span><br><span class="line">    */</span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address _from,</span><br><span class="line">        address _to,</span><br><span class="line">        uint256 _id,</span><br><span class="line">        uint256 _value,</span><br><span class="line">        bytes calldata _data</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        @notice 将 `_ids` 的 `_values` 数量从 `_from` 地址转移到指定的 `_to` 地址（使用安全调用）。</span><br><span class="line">        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see &quot;Approval&quot; section of the standard).</span><br><span class="line">        MUST revert if `_to` is the zero address.</span><br><span class="line">        MUST revert if length of `_ids` is not the same as length of `_values`.</span><br><span class="line">        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.</span><br><span class="line">        MUST revert on any other error.</span><br><span class="line">        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see &quot;Safe Transfer Rules&quot; section of the standard).</span><br><span class="line">        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).</span><br><span class="line">        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size &gt; 0). If so,</span><br><span class="line">        it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see &quot;Safe Transfer Rules&quot; section of the standard).</span><br><span class="line">        @param _from    Source address</span><br><span class="line">        @param _to      Target address</span><br><span class="line">        @param _ids     每个令牌类型的 ID（顺序和长度必须匹配 _values 数组）</span><br><span class="line">        @param _values  每种代币类型的转账金额（顺序和长度必须匹配 _ids 数组）</span><br><span class="line">        @param _data    没有指定格式的额外数据，必须在调用 _to 上的 `ERC1155TokenReceiver` 钩子时原封不动地发送</span><br><span class="line">    */</span><br><span class="line">    function safeBatchTransferFrom(</span><br><span class="line">        address _from,</span><br><span class="line">        address _to,</span><br><span class="line">        uint256[] calldata _ids,</span><br><span class="line">        uint256[] calldata _values,</span><br><span class="line">        bytes calldata _data</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        @notice 获取帐户令牌的余额。</span><br><span class="line">        @param _owner  令牌持有者的地址</span><br><span class="line">        @param _id     ID of the token</span><br><span class="line">        @return        请求的代币类型的所有者余额</span><br><span class="line">     */</span><br><span class="line">    function balanceOf(address _owner, uint256 _id)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (uint256);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        @notice 获取多个账户/代币对的余额</span><br><span class="line">        @param _owners 代币持有者的地址</span><br><span class="line">        @param _ids    ID of the tokens</span><br><span class="line">        @return        请求的令牌类型的 _owner 余额（即每个 (owner, id) 对的余额）</span><br><span class="line">     */</span><br><span class="line">    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (uint256[] memory);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        @notice 启用或禁用对第三方（“操作员”）的批准以管理所有调用者的令牌。</span><br><span class="line">        @dev 必须在成功时发出 ApprovalForAll 事件。</span><br><span class="line">        @param _operator  添加到授权运营商集中的地址</span><br><span class="line">        @param _approved  如果运营商获得批准，则为 True，如果撤消批准，则为 false</span><br><span class="line">    */</span><br><span class="line">    function setApprovalForAll(address _operator, bool _approved) external;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        @notice 查询给定所有者的操作员的批准状态。</span><br><span class="line">        @param _owner     The owner of the tokens</span><br><span class="line">        @param _operator  授权操作员的地址</span><br><span class="line">        @return           如果操作员被批准则为真，否则为假</span><br><span class="line">    */</span><br><span class="line">    function isApprovedForAll(address _owner, address _operator)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (bool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ERC3525-标准"><a href="#ERC3525-标准" class="headerlink" title="ERC3525 标准"></a>ERC3525 标准</h1><p>每个符合 EIP-3525 的合约都必须实现 EIP-3525、EIP-721 和 EIP-165 接口</p><p>参考资料:</p><ul><li><a href="https://eips.ethereum.org/EIPS/eip-3525">https://eips.ethereum.org/EIPS/eip-3525</a></li></ul><h3 id="场景说明-2"><a href="#场景说明-2" class="headerlink" title="场景说明"></a>场景说明</h3><p>描述一组具有相同类型，但是有轻微不同的东西。比如相同的 100 元人民币，一共 100 张，每一张都是价值 100 的纸币，大部分的防伪等等都不同，但是每一张都编号都不同。</p><h3 id="合约代码-2"><a href="#合约代码-2" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title EIP-3525 Semi-Fungible Token Standard</span><br><span class="line"> * Note: the EIP-165 identifier for this interface is 0xd5358140.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">interface IERC3525  /* is IERC165, IERC721 */ &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @dev MUST emit when value of a token is transferred to another token with the same slot,</span><br><span class="line">     *  including zero value transfers (_value == 0) as well as transfers when tokens are created</span><br><span class="line">     *  (`_fromTokenId` == 0) or destroyed (`_toTokenId` == 0).</span><br><span class="line">     * @param _fromTokenId The token id to transfer value from</span><br><span class="line">     * @param _toTokenId The token id to transfer value to</span><br><span class="line">     * @param _value The transferred value</span><br><span class="line">     */</span><br><span class="line">    event TransferValue(</span><br><span class="line">        uint256 indexed _fromTokenId,</span><br><span class="line">        uint256 indexed _toTokenId,</span><br><span class="line">        uint256 _value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev MUST emit when the approval value of a token is set or changed.</span><br><span class="line">     * @param _tokenId The token to approve</span><br><span class="line">     * @param _operator The operator to approve for</span><br><span class="line">     * @param _value The maximum value that `_operator` is allowed to manage</span><br><span class="line">     */</span><br><span class="line">    event ApprovalValue(</span><br><span class="line">        uint256 indexed _tokenId,</span><br><span class="line">        address indexed _operator,</span><br><span class="line">        uint256 _value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev MUST emit when the slot of a token is set or changed.</span><br><span class="line">     * @param _tokenId The token of which slot is set or changed</span><br><span class="line">     * @param _oldSlot The previous slot of the token</span><br><span class="line">     * @param _newSlot The updated slot of the token</span><br><span class="line">     */</span><br><span class="line">    event SlotChanged(</span><br><span class="line">        uint256 indexed _tokenId,</span><br><span class="line">        uint256 indexed _oldSlot,</span><br><span class="line">        uint256 indexed _newSlot</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice Get the number of decimals the token uses for value - e.g. 6, means the user</span><br><span class="line">     *  representation of the value of a token can be calculated by dividing it by 1,000,000.</span><br><span class="line">     *  Considering the compatibility with third-party wallets, this function is defined as</span><br><span class="line">     *  `valueDecimals()` instead of `decimals()` to avoid conflict with EIP-20 tokens.</span><br><span class="line">     * @return The number of decimals for value</span><br><span class="line">     */</span><br><span class="line">    function valueDecimals() external view returns (uint8);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice Get the value of a token.</span><br><span class="line">     * @param _tokenId The token for which to query the balance</span><br><span class="line">     * @return The value of `_tokenId`</span><br><span class="line">     */</span><br><span class="line">    function balanceOf(uint256 _tokenId) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice Get the slot of a token.</span><br><span class="line">     * @param _tokenId The identifier for a token</span><br><span class="line">     * @return The slot of the token</span><br><span class="line">     */</span><br><span class="line">    function slotOf(uint256 _tokenId) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice Allow an operator to manage the value of a token, up to the `_value`.</span><br><span class="line">     * @dev MUST revert unless caller is the current owner, an authorized operator, or the approved</span><br><span class="line">     *  address for `_tokenId`.</span><br><span class="line">     *  MUST emit the ApprovalValue event.</span><br><span class="line">     * @param _tokenId The token to approve</span><br><span class="line">     * @param _operator The operator to be approved</span><br><span class="line">     * @param _value The maximum value of `_toTokenId` that `_operator` is allowed to manage</span><br><span class="line">     */</span><br><span class="line">    function approve(</span><br><span class="line">        uint256 _tokenId,</span><br><span class="line">        address _operator,</span><br><span class="line">        uint256 _value</span><br><span class="line">    ) external payable;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice Get the maximum value of a token that an operator is allowed to manage.</span><br><span class="line">     * @param _tokenId The token for which to query the allowance</span><br><span class="line">     * @param _operator The address of an operator</span><br><span class="line">     * @return The current approval value of `_tokenId` that `_operator` is allowed to manage</span><br><span class="line">     */</span><br><span class="line">    function allowance(uint256 _tokenId, address _operator)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (uint256);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice Transfer value from a specified token to another specified token with the same slot.</span><br><span class="line">     * @dev Caller MUST be the current owner, an authorized operator or an operator who has been</span><br><span class="line">     *  approved the whole `_fromTokenId` or part of it.</span><br><span class="line">     *  MUST revert if `_fromTokenId` or `_toTokenId` is zero token id or does not exist.</span><br><span class="line">     *  MUST revert if slots of `_fromTokenId` and `_toTokenId` do not match.</span><br><span class="line">     *  MUST revert if `_value` exceeds the balance of `_fromTokenId` or its allowance to the</span><br><span class="line">     *  operator.</span><br><span class="line">     *  MUST emit `TransferValue` event.</span><br><span class="line">     * @param _fromTokenId The token to transfer value from</span><br><span class="line">     * @param _toTokenId The token to transfer value to</span><br><span class="line">     * @param _value The transferred value</span><br><span class="line">     */</span><br><span class="line">    function transferFrom(</span><br><span class="line">        uint256 _fromTokenId,</span><br><span class="line">        uint256 _toTokenId,</span><br><span class="line">        uint256 _value</span><br><span class="line">    ) external payable;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice 转移将指定数量的代币到新地址。调用者应确认 _to 能够接收 EIP-3525 资产。</span><br><span class="line">     * @dev This function MUST create a new EIP-3525 token with the same slot for `_to`,</span><br><span class="line">     *  or find an existing token with the same slot owned by `_to`, to receive the transferred value.</span><br><span class="line">     *  MUST revert if `_fromTokenId` is zero token id or does not exist.</span><br><span class="line">     *  MUST revert if `_to` is zero address.</span><br><span class="line">     *  MUST revert if `_value` exceeds the balance of `_fromTokenId` or its allowance to the</span><br><span class="line">     *  operator.</span><br><span class="line">     *  MUST emit `Transfer` and `TransferValue` events.</span><br><span class="line">     * @param _fromTokenId The token to transfer value from</span><br><span class="line">     * @param _to The address to transfer value to</span><br><span class="line">     * @param _value The transferred value</span><br><span class="line">     * @return ID of the token which receives the transferred value</span><br><span class="line">     */</span><br><span class="line">    function transferFrom(</span><br><span class="line">        uint256 _fromTokenId,</span><br><span class="line">        address _to,</span><br><span class="line">        uint256 _value</span><br><span class="line">    ) external payable returns (uint256);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>更多关于 3525 协议的内容，参考 <a href="https://cloud.tencent.com/developer/article/2155201">https://cloud.tencent.com/developer/article/2155201</a></p>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12-合约部署合约</title>
      <link href="/2022/07/15/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/12-%E5%90%88%E7%BA%A6%E9%83%A8%E7%BD%B2%E5%90%88%E7%BA%A6/"/>
      <url>/2022/07/15/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/12-%E5%90%88%E7%BA%A6%E9%83%A8%E7%BD%B2%E5%90%88%E7%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="通过-new-创建合约-create"><a href="#通过-new-创建合约-create" class="headerlink" title="通过 new 创建合约 &#x2F; create"></a>通过 <code>new</code> 创建合约 &#x2F; <code>create</code></h1><p>使用关键字 <code>new</code> 可以创建一个新合约。待创建合约的完整代码必须事先知道，因此递归的创建依赖是不可能的。<code>create</code>主要有以下三种表现形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract D &#123;</span><br><span class="line">    uint x;</span><br><span class="line">     constructor(uint256 a) payable&#123;</span><br><span class="line">        x = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    // 1.将作为合约的一部分执行</span><br><span class="line">    D d = new D(4);</span><br><span class="line"></span><br><span class="line">    // 2.方法内创建</span><br><span class="line">    function createD1(uint arg) public &#123;</span><br><span class="line">        D newD = new D(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.方法内创建，并转账</span><br><span class="line">    function createD2(uint arg, uint amount) public payable &#123;</span><br><span class="line">        //随合约的创建发送 ether</span><br><span class="line">        D newD = (new D)&#123;value:amount&#125;(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如示例中所示，通过使用 <code>value</code> 选项创建 <code>D</code> 的实例时可以附带发送 Ether，但是不能限制 gas 的数量。 如果创建失败（可能因为栈溢出，或没有足够的余额或其他问题），会引发异常。</p><p>这种方式也被称为 Factory 创建。工厂合约部署，也被称为 <code>create</code>，批量创建的时候使用，比如批量创建交易池，DeFi 类产品中批量创建借贷池等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Account &#123;</span><br><span class="line">    address public deployer;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor(address _owner) payable &#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">        deployer = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() external view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract AccountFactory &#123;</span><br><span class="line">    Account[] public accounts;</span><br><span class="line"></span><br><span class="line">    function deploy(address _owner) external payable &#123;</span><br><span class="line">        Account account = new Account&#123;value: msg.value&#125;(_owner);</span><br><span class="line">        accounts.push(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="通过-salt-创建合约-create2"><a href="#通过-salt-创建合约-create2" class="headerlink" title="通过 salt 创建合约 &#x2F; create2"></a>通过 <code>salt</code> 创建合约 &#x2F; <code>create2</code></h1><p>在创建合约时，将根据创建合约的地址和每次创建合约交易时的 <code>nonce</code> 来计算合约的地址。如果你指定了一个可选的 <code>salt</code> （一个 bytes32 值），那么合约创建将使用另一种机制(<code>create2</code>)来生成新合约的地址：它将根据给定的 <code>salt</code> ，创建合约的字节码和构造函数参数来计算创建合约的地址。特别注意，这里不再使用 <code>nonce</code>。</p><p>create2 的意义：可以在创建合约时提供更大的灵活性：你可以在创建新合约之前就推导出将要创建的合约地址。 甚至是还可以依赖此地址（即便它还不存在）来创建其他合约。一个主要用例场景是<strong>充当链下交互仲裁合约，仅在有争议时才需要创建。</strong></p><h3 id="案例演示-1"><a href="#案例演示-1" class="headerlink" title="案例演示 1"></a>案例演示 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract D &#123;</span><br><span class="line">    uint256 public x;</span><br><span class="line"></span><br><span class="line">    constructor(uint256 a) &#123;</span><br><span class="line">        x = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function createDSalted(bytes32 salt, uint256 arg) public &#123;</span><br><span class="line">        // 最新的语法</span><br><span class="line">        D d = new D&#123;salt: salt&#125;(arg);</span><br><span class="line"></span><br><span class="line">        // 之前的写法</span><br><span class="line">        // 这个复杂的表达式只是告诉我们，如何预先计算地址。</span><br><span class="line">        // 这里仅仅用来说明。 实际上，现在仅需要使用 `new D&#123;salt: salt&#125;(arg)` 即可.</span><br><span class="line">        address predictedAddress = address(</span><br><span class="line">            uint160(</span><br><span class="line">                uint256(</span><br><span class="line">                    keccak256(</span><br><span class="line">                        abi.encodePacked(</span><br><span class="line">                            bytes1(0xff),</span><br><span class="line">                            address(this),</span><br><span class="line">                            salt,</span><br><span class="line">                            keccak256(</span><br><span class="line">                                abi.encodePacked(type(D).creationCode, arg)</span><br><span class="line">                            )</span><br><span class="line">                        )</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        require(address(d) == predictedAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>create2</code> 创建合约还有一些特别之处。 合约销毁后可以在同一地址重新创建。不过，即使创建字节码（creation bytecode）相同（这是要求，因为否则地址会发生变化），该新创建的合约也可能有不同的部署字节码（deployed bytecode）。 这是因为构造函数可以使用两次创建合约之间可能已更改的外部状态，并在存储合约时将其合并到部署字节码中。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这种也被称为操作码部署，<code>create</code> 可以通过加入 salt，来预测即将生成的地址。这种创建就能预测生成地址的方式也被称为 <code>create2</code> 创建。</p><ul><li>加 salt ,salt 决定了合约地址，不能重复使用<ul><li>除非之前 salt 生成的合约被销毁了。</li></ul></li><li>即将部署的合约地址计算<ul><li><code>uint160</code> 格式就是地址格式了</li></ul></li></ul><p>下面是两者的简短总结：</p><ul><li><strong>普通合约</strong>的地址生成方式: 部署者的<code>地址</code> + <code>地址 nonce</code></li><li><strong>预测合约地址的方式</strong>:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bytes32 hash = keccak256(</span><br><span class="line">    abi.encodePacked(</span><br><span class="line">        bytes1(0xff), // 固定字符串</span><br><span class="line">        address(this), // 当前工厂合约地址，固定写法</span><br><span class="line">        _salt, // salt</span><br><span class="line">        keccak256(bytecode) //部署合约的 bytecode</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line">return address(uint160(uint256(hash)));</span><br></pre></td></tr></table></figure><h3 id="案例代码-2"><a href="#案例代码-2" class="headerlink" title="案例代码 2"></a>案例代码 2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract DeployWithCreate2 &#123;</span><br><span class="line">    address public deployer;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor(address _owner) payable &#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">        deployer = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() external view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract AccountFactory &#123;</span><br><span class="line">    DeployWithCreate2[] public accounts;</span><br><span class="line"></span><br><span class="line">    function deploy(uint256 _salt) external payable &#123;</span><br><span class="line">        DeployWithCreate2 account = new DeployWithCreate2&#123;</span><br><span class="line">            salt: bytes32(_salt), // uint256 需要转为 bytes32</span><br><span class="line">            value: msg.value</span><br><span class="line">        &#125;(msg.sender);</span><br><span class="line">        accounts.push(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取即将部署的地址</span><br><span class="line">    function getAddress(bytes memory bytecode, uint256 _salt)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (address)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes32 hash = keccak256(</span><br><span class="line">            abi.encodePacked(</span><br><span class="line">                bytes1(0xff), // 固定字符串</span><br><span class="line">                address(this), // 当前工厂合约地址</span><br><span class="line">                _salt, // salt</span><br><span class="line">                keccak256(bytecode) //部署合约的 bytecode</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        return address(uint160(uint256(hash)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取合约的 bytecode</span><br><span class="line">    function getBytecode(address _owner) external pure returns (bytes memory) &#123;</span><br><span class="line">        bytes memory bytecode = type(DeployWithCreate2).creationCode;</span><br><span class="line">        // 连接的参数使用 abi.encode</span><br><span class="line">        return abi.encodePacked(bytecode, abi.encode(_owner));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合约测试"><a href="#合约测试" class="headerlink" title="合约测试"></a>合约测试</h3><ul><li><p>address1部署合约</p><ul><li>address1: <code>0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</code></li></ul></li><li><p>使用 <code>address1</code> 作为参数，获取 <code>getBytecode</code> 返回值。</p></li><li><p>调用 getAddress</p><ul><li>bytecode 参数是 <code>getBytecode</code> 返回值</li><li>salt 参数是 1</li><li>计算结果是: <code>0x0022172A008CEdf60B1770dDD987888e5663D1Cc</code></li></ul></li><li><p>调用 deploy，salt 参数是 1</p></li><li><p>调用 accounts[0]</p><ul><li>返回的合约地址是 <code>0x0022172A008CEdf60B1770dDD987888e5663D1Cc</code>，和计算的完全一样。</li></ul></li><li><p>再次调用 deploy，salt 参数是 1</p><ul><li>返回失败 <code>transact to AccountFactory.deploy errored: VM error: revert.</code></li></ul></li></ul><h1 id="用-assembly-做-create"><a href="#用-assembly-做-create" class="headerlink" title="用 assembly 做 create"></a>用 assembly 做 create</h1><h3 id="create-部署"><a href="#create-部署" class="headerlink" title="create 部署"></a>create 部署</h3><ul><li>Proxy: 部署合约的方法，和修改 owner</li><li>Helper: 生成部署用的 bytecode 和修改 owner 的 data</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test1 &#123;</span><br><span class="line">    address public owner = msg.sender;</span><br><span class="line"></span><br><span class="line">    function setOwner(address _owner) public &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;now owner&quot;);</span><br><span class="line">        owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test2 &#123;</span><br><span class="line">    address public owner = msg.sender;</span><br><span class="line">    uint256 public value = msg.value;</span><br><span class="line">    uint256 public x;</span><br><span class="line">    uint256 public y;</span><br><span class="line"></span><br><span class="line">    constructor(uint256 _x, uint256 _y) &#123;</span><br><span class="line">        x = _x;</span><br><span class="line">        y = _y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// contract Proxy &#123;</span><br><span class="line">//     function depolyTest1() external &#123;</span><br><span class="line">//         new Test1();</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     function depolyTest2() external payable &#123;</span><br><span class="line">//         new Test2(1, 2);</span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// assembly 部署</span><br><span class="line">contract Proxy &#123;</span><br><span class="line">    event Depoly(address);</span><br><span class="line"></span><br><span class="line">    // fallback() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function depoly(bytes memory _code)</span><br><span class="line">        external</span><br><span class="line">        payable</span><br><span class="line">        returns (address adds)</span><br><span class="line">    &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // create(v,p,n);</span><br><span class="line">            // v 是 发送的ETH值</span><br><span class="line">            // p 是 内存中机器码开始的位置</span><br><span class="line">            // n 是 内存中机器码的大小</span><br><span class="line">            // msg.value 不能使用，需要用 callvalue()</span><br><span class="line">            adds := create(callvalue(), add(_code, 0x20), mload(_code))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        require(adds != address(0), &quot;Depoly Failed&quot;);</span><br><span class="line">        emit Depoly(adds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 跳用</span><br><span class="line">    function execute(address _target, bytes memory _data) external payable &#123;</span><br><span class="line">        (bool success, ) = _target.call&#123;value: msg.value&#125;(_data);</span><br><span class="line">        require(success, &quot;Failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Helper &#123;</span><br><span class="line">    // 生成 type(contract).creationCode</span><br><span class="line">    function getBytescode1() external pure returns (bytes memory bytecode) &#123;</span><br><span class="line">        bytecode = type(Test1).creationCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 生成构造函数带有参数的 bytecode，参数连接后面就可以了</span><br><span class="line">    function getBytescode2(uint256 _x, uint256 _y)</span><br><span class="line">        external</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes memory)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes memory bytecode = type(Test2).creationCode;</span><br><span class="line">        // abi 全局变量</span><br><span class="line">        return abi.encodePacked(bytecode, abi.encode(_x, _y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用合约方法的calldata，使用 abi.encodeWithSignature</span><br><span class="line">    function getCalldata(address _owner) external pure returns (bytes memory) &#123;</span><br><span class="line">        return abi.encodeWithSignature(&quot;setOwner(address)&quot;, _owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试部署"><a href="#测试部署" class="headerlink" title="测试部署"></a>测试部署</h3><p>前提条件：部署 Helper 和 Proxy 合约。</p><ol><li>通过 getBytescode1 ，获取 Test1 需要的 bytecode</li><li>部署 Test1</li><li>获取 Test1 合约地址</li><li>At Test1 Address</li><li>获取 Test1 owner 地址</li><li>通过 getCalldata ，获取 Test1 setOwner 需要的 bytecode。参数是想要设置的 Owner 地址。</li><li>执行 execute(),参数是 Test1 合约地址 和 getCalldata 返回值。</li></ol><p>合约 2</p><ol><li>通过 getBytescode2 ，获取 Test2 需要的 bytecode</li><li>部署 Test2，需要设置 x, y 的值，可以选择支付 ETH。</li><li>获取 Test2 合约地址</li><li>At Test2 Address</li><li>查看 Test2 的值</li></ol><h1 id="用-assembly-做-create2"><a href="#用-assembly-做-create2" class="headerlink" title="用 assembly 做 create2"></a>用 assembly 做 create2</h1><p>UniswapV2Factory 的创建 pair 代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function createPair(address tokenA, address tokenB) external returns (address pair) &#123;</span><br><span class="line">    require(tokenA != tokenB, &#x27;UniswapV2: IDENTICAL_ADDRESSES&#x27;);</span><br><span class="line">    (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span><br><span class="line">    require(token0 != address(0), &#x27;UniswapV2: ZERO_ADDRESS&#x27;);</span><br><span class="line"></span><br><span class="line">    // single check is sufficient</span><br><span class="line">    require(getPair[token0][token1] == address(0), &#x27;UniswapV2: PAIR_EXISTS&#x27;);</span><br><span class="line">    bytes memory bytecode = type(UniswapV2Pair).creationCode;</span><br><span class="line">    bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">    assembly &#123;</span><br><span class="line">        pair := create2(0, add(bytecode, 32), mload(bytecode), salt)</span><br><span class="line">    &#125;</span><br><span class="line">    IUniswapV2Pair(pair).initialize(token0, token1);</span><br><span class="line">    getPair[token0][token1] = pair;</span><br><span class="line">    getPair[token1][token0] = pair; // populate mapping in the reverse direction</span><br><span class="line">    allPairs.push(pair);</span><br><span class="line">    emit PairCreated(token0, token1, pair, allPairs.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11-合约调用合约</title>
      <link href="/2022/07/10/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/11-%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8%E5%90%88%E7%BA%A6/"/>
      <url>/2022/07/10/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/11-%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8%E5%90%88%E7%BA%A6/</url>
      
        <content type="html"><![CDATA[<ul><li><p>Solidity 支持一个合约调用另一个合约。两个合约既可以位于同一文件内，也可以位于不同的两个文件中。还能调用已经上链的其它合约。</p></li><li><p>调用内部合约</p><ul><li>内部合约指：位于同一 sol 文件中的合约，它们不需要额外的声明就可以直接调用。</li></ul></li><li><p>调用外部合约</p><ul><li>外部合约指：位于不同文件的外部合约，以及上链的合约。</li><li>方法一: 通过接口方式调用</li><li>方法二: 通过签名方式调用</li></ul></li></ul><p>了解上面的调用后，可以扩展了解<strong>多次调用</strong></p><h1 id="调用内部合约"><a href="#调用内部合约" class="headerlink" title="调用内部合约"></a>调用内部合约</h1><p>地址转换为合约对象的防范：</p><ul><li><p>方法 1: 通过ContractName(_ads)将传入的地址，转为合约对象</p><ul><li><p><code>Test(_ads).setX(_x);</code></p></li><li><p>如果为了代码逻辑，也可以分开写，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test temp = Test(_ads);</span><br><span class="line">temp.setX(_x);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>方法 2: 可以通过参数中指定合约名字进行转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function setX2(Test _ads, uint256 _x) public &#123;</span><br><span class="line">    _ads.setX(_x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用并发送 ETH: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fnName&#123;value: msg.value&#125;();</span><br></pre></td></tr></table></figure><ul><li><code>Test(_ads).setYBySendEth&#123;value: msg.value&#125;();</code></li></ul></li></ul><p>例子演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    uint256 public x = 1;</span><br><span class="line">    uint256 public y = 2;</span><br><span class="line"></span><br><span class="line">    function setX(uint256 _x) public &#123;</span><br><span class="line">        x = _x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getX() public view returns (uint256) &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setYBySendEth() public payable &#123;</span><br><span class="line">        y = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getXandY() public view returns (uint256, uint256) &#123;</span><br><span class="line">        return (x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CallTest &#123;</span><br><span class="line">    // 第1种方法: 229647 / 27858 gas</span><br><span class="line">    function setX1(address _ads, uint256 _x) public &#123;</span><br><span class="line">        Test(_ads).setX(_x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 第2种方法:   27923 gas</span><br><span class="line">    function setX2(Test _ads, uint256 _x) public &#123;</span><br><span class="line">        _ads.setX(_x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getX(address _ads) public view returns (uint256) &#123;</span><br><span class="line">        return Test(_ads).getX();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setYBySendEth(address _ads) public payable &#123;</span><br><span class="line">        Test(_ads).setYBySendEth&#123;value: msg.value&#125;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getXandY(address _ads)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 __x, uint256 __y)</span><br><span class="line">    &#123;</span><br><span class="line">        (__x, __y) = Test(_ads).getXandY();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="调用外部合约"><a href="#调用外部合约" class="headerlink" title="调用外部合约"></a>调用外部合约</h1><h2 id="2-1-通过接口方式调用"><a href="#2-1-通过接口方式调用" class="headerlink" title="2.1 通过接口方式调用"></a>2.1 通过接口方式调用</h2><p>核心代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface AnimalEat &#123;</span><br><span class="line">    function eat() external returns (string memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Animal &#123;</span><br><span class="line">    function test(address _addr) external returns (string memory) &#123;</span><br><span class="line">        AnimalEat general = AnimalEat(_addr);</span><br><span class="line">        return general.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-通过签名方式调用"><a href="#2-2-通过签名方式调用" class="headerlink" title="2.2 通过签名方式调用"></a>2.2 通过签名方式调用</h2><p>通过签名方式调用合约，只需要传入被调用者的地址和调用方法声明。</p><p><strong>call 核心代码如下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bytes memory data = abi.encodeWithSignature(</span><br><span class="line">    &quot;setNameAndAge(string,uint256)&quot;,</span><br><span class="line">    _name,</span><br><span class="line">    _age</span><br><span class="line">);</span><br><span class="line">(bool success, bytes memory _bys) = _ads.call&#123;value: msg.value&#125;(data);</span><br><span class="line">require(success, &quot;Call Failed&quot;);</span><br><span class="line">bys = _bys;</span><br></pre></td></tr></table></figure><p>用给定的有效载荷（payload）发出低级 <code>CALL</code> 调用，并<strong>返回交易成功状态和返回数据</strong>（调用合约的方法并转账）, 格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.call(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure><p><strong>DelegateCall 核心代码如下</strong></p><ul><li>委托调用后，所有变量修改都是发生在委托合约内部，并不会保存在被委托合约中。<ul><li>利用这个特性，可以通过更换被委托合约，来升级委托合约。</li></ul></li><li>委托调用合约内部，需要和被委托合约的内部参数完全一样，否则容易导致数据混乱<ul><li>可以通过顺序来避免这个问题，但是推荐完全一样</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function set(address _ads, uint256 _num) external payable &#123;</span><br><span class="line">    sender = msg.sender;</span><br><span class="line">    value = msg.value;</span><br><span class="line">    num = _num;</span><br><span class="line">    // 第1种 encode</span><br><span class="line">    // 不需知道合约名字，函数完全自定义</span><br><span class="line">    bytes memory data1 = abi.encodeWithSignature(&quot;set(uint256)&quot;, _num);</span><br><span class="line">    // 第2种 encode</span><br><span class="line">    // 需要合约名字，可以避免函数和参数写错</span><br><span class="line">    // bytes memory data2 = abi.encodeWithSelector(Test1.set.selector, _num);</span><br><span class="line"></span><br><span class="line">    (bool success, bytes memory _data) = _ads.delegatecall(data1);</span><br><span class="line"></span><br><span class="line">    require(success, &quot;DelegateCall set failed&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>staticcall 核心代码如下</strong>: 它与 call 基本相同，<strong>但如果被调用的函数以任何方式修改状态变量，都将回退</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 被调用的合约</span><br><span class="line">contract Hello &#123;</span><br><span class="line">    function echo() external pure returns (string memory) &#123;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用者合约</span><br><span class="line">contract SoldityTest &#123;</span><br><span class="line">    function callHello(address _ads) external view returns (string memory) &#123;</span><br><span class="line">        // 编码被调用者的方法签名</span><br><span class="line">        bytes4 methodId = bytes4(keccak256(&quot;echo()&quot;));</span><br><span class="line"></span><br><span class="line">        // 调用合约</span><br><span class="line">        (bool success, bytes memory data) = _ads.staticcall(</span><br><span class="line">            abi.encodeWithSelector(methodId)</span><br><span class="line">        );</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            return abi.decode(data, (string));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;error&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MultiCall-多次调用"><a href="#MultiCall-多次调用" class="headerlink" title="MultiCall&#x2F;多次调用"></a>MultiCall&#x2F;多次调用</h1><ul><li>把多个合约的多次函数的调用，打包在一个里面对合约进行调用。RPC 对调用有限制，这样可以绕开限制。</li><li>多次调用里面，对方的内部, <code>msg.sender</code> 是 MultiCall 合约，而不是用户地址。</li></ul><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>调用的地址</li><li>调用的 data</li></ul><h3 id="合约代码"><a href="#合约代码" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function fn1()</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (</span><br><span class="line">            uint256,</span><br><span class="line">            address,</span><br><span class="line">            uint256</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        return (1, msg.sender, block.timestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fn2()</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (</span><br><span class="line">            uint256,</span><br><span class="line">            address,</span><br><span class="line">            uint256</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        return (2, msg.sender, block.timestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getFn1Data() external pure returns (bytes memory) &#123;</span><br><span class="line">        // 两种签名方法都可以</span><br><span class="line">        // abi.encodeWithSignature(&quot;fn1()&quot;);</span><br><span class="line">        return abi.encodeWithSelector(this.fn1.selector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getFn2Data() external pure returns (bytes memory) &#123;</span><br><span class="line">        return abi.encodeWithSelector(this.fn2.selector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MultiCall &#123;</span><br><span class="line">    function multiCall(address[] calldata targets, bytes[] calldata data)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (bytes[] memory)</span><br><span class="line">    &#123;</span><br><span class="line">        require(targets.length == data.length, &quot;targets.length != data.length&quot;);</span><br><span class="line">        bytes[] memory results = new bytes[](data.length);</span><br><span class="line">        for (uint256 index = 0; index &lt; targets.length; index++) &#123;</span><br><span class="line">            (bool success, bytes memory result) = targets[index].staticcall(</span><br><span class="line">                data[index]</span><br><span class="line">            );</span><br><span class="line">            require(success, &quot;call faild&quot;);</span><br><span class="line">            results[index] = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><ul><li><p>部署 <code>Test</code>: <code>0x1c91347f2A44538ce62453BEBd9Aa907C662b4bD</code></p><ul><li>使用 <code>getFn1Data</code> 获取 fn1 data</li><li>使用 <code>getFn2Data</code> 获取 fn2 data</li></ul></li><li><p>部署 <code>MultiCall</code>: <code>0x93f8dddd876c7dBE3323723500e83E202A7C96CC</code></p></li><li><p>调用 multiCall 方法</p><ul><li>参数 1: <code>[&quot;Test 地址&quot;,&quot;Test 地址&quot;]</code></li><li>参数 2: <code>[&quot;fn1 data&quot;,&quot;fn2 data&quot;]</code></li></ul></li><li><p>返回值如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000001</span><br><span class="line">00000000000000000000000093f8dddd876c7dbe3323723500e83e202a7c96cc</span><br><span class="line">00000000000000000000000000000000000000000000000000000000630c7834,</span><br><span class="line">0x</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">00000000000000000000000093f8dddd876c7dbe3323723500e83e202a7c96cc</span><br><span class="line">00000000000000000000000000000000000000000000000000000000630c7834</span><br></pre></td></tr></table></figure></li></ul><h1 id="MultiDelegatecall-多次委托调用"><a href="#MultiDelegatecall-多次委托调用" class="headerlink" title="MultiDelegatecall &#x2F; 多次委托调用"></a>MultiDelegatecall &#x2F; 多次委托调用</h1><p>为什么使用 MultiDelegatecall ，不使用 MultiCall?是为了让被调用的合约内，<code>msg.sender</code> 是用户合约，而不是中转合约的地址。</p><p>但是委托调用的缺点是，合约必须是自己编写的，不能是别人编写的。</p><p>多次委托调用，存在漏洞，不要在里面多次累加余额。或者多重委托禁止接受资金。</p><h3 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract MultiDelegatecall &#123;</span><br><span class="line">    function multiDelegatecall(bytes[] calldata data)</span><br><span class="line">        external</span><br><span class="line">        returns (bytes[] memory)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes[] memory results = new bytes[](data.length);</span><br><span class="line">        for (uint256 index = 0; index &lt; data.length; index++) &#123;</span><br><span class="line">            (bool success, bytes memory result) = address(this).delegatecall(</span><br><span class="line">                data[index]</span><br><span class="line">            );</span><br><span class="line">            require(success, &quot;call faild&quot;);</span><br><span class="line">            results[index] = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test is MultiDelegatecall &#123;</span><br><span class="line">    function fn1()</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (</span><br><span class="line">            uint256,</span><br><span class="line">            address,</span><br><span class="line">            uint256</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        return (1, msg.sender, block.timestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fn2()</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (</span><br><span class="line">            uint256,</span><br><span class="line">            address,</span><br><span class="line">            uint256</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        return (2, msg.sender, block.timestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getFn1Data() external pure returns (bytes memory) &#123;</span><br><span class="line">        // 两种签名方法都可以</span><br><span class="line">        // abi.encodeWithSignature(&quot;fn1()&quot;);</span><br><span class="line">        return abi.encodeWithSelector(this.fn1.selector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getFn2Data() external pure returns (bytes memory) &#123;</span><br><span class="line">        return abi.encodeWithSelector(this.fn2.selector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>合约测试</strong></p><ul><li><p>部署 Test 合约</p></li><li><p>获取 getFn1Data: <code>0x648fc804</code></p></li><li><p>获取 getFn2Data: <code>0x98d26a11</code></p></li><li><p>调用 <code>multiDelegatecall</code></p><ul><li>[“0x648fc804”,“0x98d26a11”]</li></ul></li><li><p>得到 decoded output，发现地址是用户的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000001</span><br><span class="line">0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4</span><br><span class="line">00000000000000000000000000000000000000000000000000000000630c8ebc,</span><br><span class="line">0x</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4</span><br><span class="line">00000000000000000000000000000000000000000000000000000000630c8ebc</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-合约继承</title>
      <link href="/2022/07/06/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/10-%E5%90%88%E7%BA%A6%E7%BB%A7%E6%89%BF/"/>
      <url>/2022/07/06/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/10-%E5%90%88%E7%BA%A6%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>实现继承的方式是通过复制包括多态的代码到子类来实现的。合约继承通过关键字 <code>is</code> 来实现。</p><p>由于 Solidity 继承的实现方案是代码拷贝，所以合约继承后，部署到网络时，将变成一个合约，代码将从父类拷贝到子类中。</p><ul><li>修饰符可以继承</li><li>事件不可以继承，但是可以重载</li><li><code>fallback</code> 可以继承，但是需要保持原有的 <code>payable/nonpayable</code></li><li><code>receive</code> 可以继承，但是需要保持原有的 <code>payable/nonpayable</code></li></ul><h1 id="使用-is-实现继承"><a href="#使用-is-实现继承" class="headerlink" title="使用 is 实现继承"></a>使用 <code>is</code> 实现继承</h1><p>当一个合约从多个合约继承时，在区块链上只有一个合约被创建，所有基类合约（或称为父合约）的代码被编译到创建的合约中。这意味着对基类合约函数的所有内部调用也只是使用内部函数调用（super.f（..）将使用 JUMP 跳转而不是消息调用）。</p><ul><li>继承: <strong>派生合约</strong>继承<strong>基础合约</strong>的属性和方法</li><li>基础合约通常也被称为<strong>父合约</strong>，派生合约通常也称作<strong>子合约</strong>。</li><li>下面是: “男人”继承”人”的演示。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Person &#123;</span><br><span class="line">    string internal name;</span><br><span class="line">    uint256 age; // 状态变量默认是internal权限</span><br><span class="line"></span><br><span class="line">    event Log(string funName);</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() virtual &#123;</span><br><span class="line">        age = 1;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable virtual &#123;</span><br><span class="line">        emit Log(&quot;fallback by Person&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable virtual &#123;</span><br><span class="line">        emit Log(&quot;receive by Person&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Man is Person &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        name = &quot;Anbang&quot;;</span><br><span class="line">        age = 18;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Log(string funName, address _ads);</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() override &#123;</span><br><span class="line">        age = 99;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getName() external view returns (string memory) &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getAge() external view returns (uint256) &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getAge2() external onlyOwner returns (uint256) &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable override &#123;</span><br><span class="line">        emit Log(&quot;fallback by man&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable override &#123;</span><br><span class="line">        emit Log(&quot;receive by Man&quot;, msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>父合约必须写在子合约的前面，否则会报错: <code>TypeError: Definition of base has to precede definition of derived contract</code></li></ul><h1 id="子类可以继承父类哪些数据？"><a href="#子类可以继承父类哪些数据？" class="headerlink" title="子类可以继承父类哪些数据？"></a>子类可以继承父类哪些数据？</h1><p>子类可以访问父类的权限修饰符只有：<code>public/internal</code>，不能是 <code>external/private</code>。</p><ul><li><p>如果父类的状态变量和函数是private和external，则子类不可以继承和访问。</p><p>如果子类调用父类 <code>external</code> 修饰的函数，会报错:<code>Cannot call function via contract type name.</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Person &#123;</span><br><span class="line">    string internal name;</span><br><span class="line">    uint256 age; // 状态变量默认是internal权限</span><br><span class="line">    uint256 public hand = 2;</span><br><span class="line">    uint256 private privateState = 99;</span><br><span class="line"></span><br><span class="line">    function publicFn() public pure returns (uint256) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function internalFn() internal pure returns (uint256) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function privateFn() private pure returns (uint256) &#123;</span><br><span class="line">        return 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Man is Person &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        name = &quot;Anbang&quot;;</span><br><span class="line">        age = 18;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getInfo()</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (</span><br><span class="line">            string memory,</span><br><span class="line">            uint256,</span><br><span class="line">            uint256</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        return (name, age, hand);</span><br><span class="line">        // privateState 不可以访问</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getPublicFn() external pure returns (uint256) &#123;</span><br><span class="line">        return publicFn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getInternalFn() external pure returns (uint256) &#123;</span><br><span class="line">        return internalFn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 不可以访问 privateFn 的方法</span><br><span class="line">    // function getPrivateFn() external pure returns (uint256) &#123;</span><br><span class="line">    //     return privateFn(); // Undeclared identifier.</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多重继承中的重名"><a href="#多重继承中的重名" class="headerlink" title="多重继承中的重名"></a>多重继承中的重名</h1><ul><li>一个合约同时继承 2 个合约时，这种情况叫多重继承</li><li>多重继承中不允许出现相同的<strong>函数名</strong>、<strong>事件名</strong>、<strong>修改器名</strong>以及<strong>状态变量名</strong>等。</li></ul><p>如下继承会报错，不允许编译:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    string internal name;</span><br><span class="line">    event log();</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test() internal &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    string internal name;</span><br><span class="line">    event log();</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test() internal &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C is A, B &#123;&#125;</span><br></pre></td></tr></table></figure><p>多重继承函数中 getter 函数重名也不可以，如下是<strong>比较隐蔽的冲突情况</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    uint256 public data = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    // data函数之所以出错</span><br><span class="line">    // 是因为和 A 中状态变量 data 的 getter 函数重名。</span><br><span class="line">    function data() public returns (uint256) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C is A, B &#123;&#125;</span><br></pre></td></tr></table></figure><p>当继承时合约出现了一下相同名字会被认为是一个错误：</p><ul><li>函数 和 修改器&#x2F;modifier 同名</li><li>函数 和 事件同名</li><li>事件和 修改器&#x2F;modifier 同名</li><li>有一种例外情况，状态变量的 <code>getter</code> 函数可以覆盖 <code>external</code> 函数。</li></ul><h1 id="重写函数"><a href="#重写函数" class="headerlink" title="重写函数"></a>重写函数</h1><p>solidity 引入了 <code>abstract</code>, <code>virtual</code>, <code>override</code> 几个关键字，用于重写函数。父合约标记为 <code>virtual</code>函数可以在继承合约里重写(overridden)以更改他们的行为。重写的函数需要使用关键字 <code>override</code> 修饰。</p><p>继承的方法重写需要注意的点:</p><ul><li><p>父合约方法需要标示为<strong>可修改</strong>，使用关键字 <code>virtual</code>，</p></li><li><p>子合约方法需要标示为覆盖，使用关键词override</p><ul><li>对于多重继承，如果有多个父合约有相同定义的函数， override 关键字后必须指定所有父合约名。</li></ul></li><li><p>基础合约中可以包含没有实现代码的函数，也就是纯虚函数，那么基础合约必须声明为 <code>abstract</code>。</p></li><li><p>继承多个合约时，所有同名的可修改函数都需要重写</p></li><li><p>继承后重写合约方法，各个合约内的函数可见性需要一致</p></li><li><p>可变性可以按照以下顺序更改为更严格的一种： <code>nonpayable</code> 可以被 <code>view</code> 和<code>pure</code> 覆盖。 <code>view</code> 可以被 <code>pure</code> 覆盖。 <code>payable</code>是一个例外，不能更改为任何其他可变性。</p></li></ul><h2 id="4-1-virtual-和-override"><a href="#4-1-virtual-和-override" class="headerlink" title="4.1 virtual 和 override"></a>4.1 virtual 和 override</h2><p>以下例子，B 继承 A，C 继承 B</p><ul><li>A 是爷爷</li><li>B 是爸爸</li><li>C 是孙子</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function test1() public pure virtual returns (string memory) &#123;</span><br><span class="line">        return &quot;test1 from A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用 public 和 external 都可以</span><br><span class="line">    function test2() external pure virtual returns (string memory) &#123;</span><br><span class="line">        return &quot;test2 from A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test3() public pure virtual returns (string memory) &#123;</span><br><span class="line">        return &quot;test3 from A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B is A &#123;</span><br><span class="line">    function test1() public pure virtual override returns (string memory) &#123;</span><br><span class="line">        return &quot;test1 from B&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test2() external pure override returns (string memory) &#123;</span><br><span class="line">        return &quot;test2 from B&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C is B &#123;</span><br><span class="line">    function test1() public pure override returns (string memory) &#123;</span><br><span class="line">        return &quot;test1 from C&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于多重继承，如果有多个父合约有相同定义的函数， <code>override</code> 关键字后必须指定所有父合约名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Base1</span><br><span class="line">&#123;</span><br><span class="line">    function foo() virtual public &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base2</span><br><span class="line">&#123;</span><br><span class="line">    function foo() virtual public &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Inherited is Base1, Base2</span><br><span class="line">&#123;</span><br><span class="line">    // 继承自两个基类合约定义的foo(), 必须显示的指定 override</span><br><span class="line">    function foo() public override(Base1, Base2) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过如果（重写的）函数继承自一个公共的父合约， <code>override</code> 是可以不用显示指定的。 例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract A &#123; function f() public pure&#123;&#125; &#125;</span><br><span class="line">contract B is A &#123;&#125;</span><br><span class="line">contract C is A &#123;&#125;</span><br><span class="line">// 不用显示  override</span><br><span class="line">contract D is B, C &#123;&#125;</span><br></pre></td></tr></table></figure><p>更正式地说，如果存在父合约是签名函数的所有重写路径的一部分，则不需要重写（直接或间接）从多个基础继承的函数，并且（1）父合约实现了该函数，从当前合约到父合约的路径都没有提到具有该签名的函数，或者（2）父合约没有实现该函数，并且存在从当前合约到该父合约的所有路径中，最多只能提及该函数。</p><p>从这个意义上说，签名函数的重写路径是通过继承图的路径，该路径始于所考虑的合约，并终止于提及具有该签名的函数的合约。</p><p>如果函数没有标记为 <code>virtual</code> ，那么派生合约将不能更改函数的行为（即不能重写）。</p><blockquote><p><code>private</code> 的函数是不可以标记为 <code>virtual</code> 的。</p></blockquote><blockquote><p>除接口之外（因为接口会自动作为 <code>virtual</code> ），没有实现的函数必须标记为<code>virtual</code></p></blockquote><p>如果 getter 函数的参数和返回值都和外部函数一致时，外部（external）函数是可以被 public 的状态变量被重写的，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract A</span><br><span class="line">&#123;</span><br><span class="line">    function f() external view virtual returns(uint) &#123; return 5; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B is A</span><br><span class="line">&#123;</span><br><span class="line">    uint public override f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ : 尽管 public 的状态变量可以重写外部函数，但是 public 的状态变量不能被重写。</p><h2 id="4-2-abstract（抽象合约）"><a href="#4-2-abstract（抽象合约）" class="headerlink" title="4.2 abstract（抽象合约）"></a>4.2 abstract（抽象合约）</h2><p>基础合约中可以包含没有实现代码的函数，也就是纯虚函数，那么基础合约必须声明为 <code>abstract</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">abstract contract IERC20 &#123;</span><br><span class="line">    function transfer() external virtual returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ERC20 is IERC20 &#123;</span><br><span class="line">    function transfer() external pure override returns (bool) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展: 这里的 <code>abstract</code>，也可以使用 <code>interface</code> 来解决。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line">    function transfer() external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ERC20 is IERC20 &#123;</span><br><span class="line">    function transfer() external pure returns (bool) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承中两种构造函数传参方式"><a href="#继承中两种构造函数传参方式" class="headerlink" title="继承中两种构造函数传参方式"></a>继承中两种构造函数传参方式</h1><p>继承的父合约，如果有构造函数并且需要传入参数，我们有以下几种方法进行参数传入</p><ul><li><p>方法 1: 固定值传参。（该方式不能在部署时动态输入）。</p><ul><li>如果我们已经知道基类初始化参数，那么就可以在派生类的继承声明中，直接传递参数给基类的构造函数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract C is A(&quot;n&quot;),B(&quot;v&quot;) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法 2: 动态传参</p><ul><li>如果我们需要在部署时或者运行时，由调用方传递基类初始化参数。在这种情况下，我们需要编写一个新的构造函数，传递参数给基类。</li><li>部署子合约的时候，传入参数到构造函数，该种方法是动态的值，可以部署的时候动态输入</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract D is A &#123;</span><br><span class="line">  constructor(string memory _name) A(_name) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>混写: 方法 1 和方法 2 可以混合使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract E is A, B(&quot;EEEEEEEEEEEEE&quot;) &#123;</span><br><span class="line">  constructor(string memory _name) A(_name) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>例子如下:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    string public nameA;</span><br><span class="line"></span><br><span class="line">    constructor(string memory _name) &#123;</span><br><span class="line">        nameA = _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    string public nameB;</span><br><span class="line"></span><br><span class="line">    constructor(string memory _name) &#123;</span><br><span class="line">        nameB = _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法1: 继承时候直接传入参数，该种方法是固定值，不能动态输入</span><br><span class="line">contract C is A(&quot;Name From C&quot;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法2: 部署子合约的时候，传入参数到构造函数，该种方法是动态的值，可以部署的时候动态输入</span><br><span class="line">contract D is A &#123;</span><br><span class="line">    constructor(string memory _name) A(_name) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  混合使用</span><br><span class="line">contract E is A, B(&quot;EEEEEEEEEEEEE&quot;) &#123;</span><br><span class="line">    constructor(string memory _name) A(_name) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="两种子合约调用父合约的方法"><a href="#两种子合约调用父合约的方法" class="headerlink" title="两种子合约调用父合约的方法"></a>两种子合约调用父合约的方法</h1><p>有两种方法可以调用</p><ol><li><p>直接使用合约名调用 <code>ParentContractName.functionName()</code>;</p></li><li><p>使用 super 关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super.functionName()</span><br></pre></td></tr></table></figure><ul><li>super 会自动寻找父合约，并执行对应的方法；</li><li><strong>如果是多个父级，那么父级都会执行。但有时候又不会，执行顺序的原理，这些需要详细的了解</strong></li><li>如果 super 导致 2 个父级同时触发同一个爷爷合约的相同方法；则爷爷的方法只执行一次。一个合约的同一个方法只会执行一次，不会执行多次。</li></ul></li></ol><h2 id="6-1-直接使用合约名调用"><a href="#6-1-直接使用合约名调用" class="headerlink" title="6.1 直接使用合约名调用"></a>6.1 直接使用合约名调用</h2><p>执行顺序:像水中的冒泡一样，由下向上进行执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    event Log(string msg);</span><br><span class="line"></span><br><span class="line">    function test1() public virtual &#123;</span><br><span class="line">        emit Log(&quot;A.test1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B is A &#123;</span><br><span class="line">    function test1() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;B.test1&quot;);</span><br><span class="line">        A.test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子执行顺序是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. B.test1</span><br><span class="line">2. A.test1</span><br></pre></td></tr></table></figure><h2 id="6-2-使用-super-关键字调用"><a href="#6-2-使用-super-关键字调用" class="headerlink" title="6.2 使用 super 关键字调用"></a>6.2 使用 super 关键字调用</h2><h3 id="6-2-1-基础继承"><a href="#6-2-1-基础继承" class="headerlink" title="6.2.1 基础继承"></a>6.2.1 基础继承</h3><p>执行顺序：像水中的冒泡一样，由下向上进行执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    event Log(string msg);</span><br><span class="line"></span><br><span class="line">    function test1() public virtual &#123;</span><br><span class="line">        emit Log(&quot;A.test1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C is A &#123;</span><br><span class="line">    function test1() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;C.test1&quot;);</span><br><span class="line">        super.test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子执行顺序是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. C.test1</span><br><span class="line">2. A.test1</span><br></pre></td></tr></table></figure><h3 id="6-2-2-多重继承"><a href="#6-2-2-多重继承" class="headerlink" title="6.2.2 多重继承"></a>6.2.2 多重继承</h3><p>写一个如下逻辑的继承</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   A</span><br><span class="line"> /   \</span><br><span class="line">B     C</span><br><span class="line"> \   /</span><br><span class="line">   D</span><br><span class="line"> */</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    event Log(string msg);</span><br><span class="line"></span><br><span class="line">    function test1() public virtual &#123;</span><br><span class="line">        emit Log(&quot;A.test1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B is A &#123;</span><br><span class="line">    function test1() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;B.test1&quot;);</span><br><span class="line">        A.test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C is A &#123;</span><br><span class="line">    function test1() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;C.test1&quot;);</span><br><span class="line">        super.test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract D is B, C &#123;</span><br><span class="line">    function test1() public override(B, C) &#123;</span><br><span class="line">        emit Log(&quot;D.test1&quot;);</span><br><span class="line">        // 因为 B 和 C 都是 D 的父级，所以B和C都会执行</span><br><span class="line">        super.test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行顺序：像水中的冒泡一样，由下向上进行执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. D.test1</span><br><span class="line">1. C.test1</span><br><span class="line">1. B.test1</span><br><span class="line">1. A.test1 (这里 A 只执行一次)</span><br></pre></td></tr></table></figure><p><strong>警告</strong> : 为什么先输出 C，后输出 B ?</p><p>上面的例子，如果代码中 B 和 C 换顺序，还是执行的 <code>DCBA</code>。开始怀疑和函数名字的 hash 结果顺序有关系，看完下面的继续研究代码，可以得出结论，复杂继承的时候，supper 方式就像一个疯子一样没有规律可言。我们能做的就是避开使用它。</p>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09-事件</title>
      <link href="/2022/07/02/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/09-%E4%BA%8B%E4%BB%B6/"/>
      <url>/2022/07/02/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/09-%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>事件是能方便地调用以太坊虚拟机日志功能的接口。应用程序可以通过以太坊客户端的 RPC 接口订阅和监听这些事件。</p><p><strong>重点:记录区块链的日志，可以使用状态变量，也可以使用事件 Event，但 Event 使用的 gas 费比状态变量低。</strong></p><p>原则：改变状态变量时，一定要触发事件。</p><p>Soliddity Event 事件是以太坊虚拟机(EVM)日志基础设施提供的一个便利接口。当被发送事件（调用）时，会触发参数存储到交易的日志中。这些日志与合约的地址关联，并记录到区块链中。每个交易收据包含 0 到多个 log 记录，log 表明着智能合约所触发的事件。</p><h1 id="Event-语法"><a href="#Event-语法" class="headerlink" title="Event 语法"></a>Event 语法</h1><p><strong>事件的定义</strong>:使用 <code>event</code> 关键字来定义一个事件 Event，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event EventName(&lt;parameter list&gt;);</span><br></pre></td></tr></table></figure><p><strong>事件的触发</strong>:只能使用 <code>emit</code> 关键字来触发事件 Event，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emit EventName(&lt;parameter list&gt;);</span><br></pre></td></tr></table></figure><h1 id="四种事件定义方式"><a href="#四种事件定义方式" class="headerlink" title="四种事件定义方式"></a>四种事件定义方式</h1><ol><li>不带参数的 event</li><li>带参数的 event</li><li>带参数名的 event</li><li>带 indexed 参数名的 event<ol><li>这种事件也被称为<strong>索引事件</strong></li><li>语法:<code>event EventName(TypeName indexed varibleName....);</code></li><li>事件中 indexed 标记过的参数，可以在链外进行搜索查询。</li><li>一个事件中 indexed 标记过的参数最多有 3 个。</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Event &#123;</span><br><span class="line">    // 普通 event</span><br><span class="line">    event Log1(address, string);</span><br><span class="line"></span><br><span class="line">    // 带名字的 event</span><br><span class="line">    event Log2(address ads, string msg);</span><br><span class="line"></span><br><span class="line">    // 带 indexed 的event</span><br><span class="line">    event Log3(address indexed ads, string msg);</span><br><span class="line"></span><br><span class="line">    // indexed 在一个事件内使用次数不能超过3次</span><br><span class="line">    event Transfer(</span><br><span class="line">        address indexed from,</span><br><span class="line">        address indexed to,</span><br><span class="line">        uint256 indexed amount</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    function log1() external &#123;</span><br><span class="line">        emit Log1(msg.sender, &quot;Log111&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function log2() external &#123;</span><br><span class="line">        emit Log2(msg.sender, &quot;Log222&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function log3() external &#123;</span><br><span class="line">        emit Log3(msg.sender, &quot;Log333&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address _to, uint256 amount) external &#123;</span><br><span class="line">        emit Transfer(msg.sender, _to, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-不带参数的-event"><a href="#2-1-不带参数的-event" class="headerlink" title="2.1 不带参数的 event"></a>2.1 不带参数的 event</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x7874d94b8f9E2a28FCceCE404666C984f33a82b8&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x1732d0c17008d342618e7f03069177d8d39391d79811bb4e706d7c6c84108c0f&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Log1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h2 id="2-2-带参数的-event"><a href="#2-2-带参数的-event" class="headerlink" title="2.2 带参数的 event"></a>2.2 带参数的 event</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x7874d94b8f9E2a28FCceCE404666C984f33a82b8&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x54010eb0426bdddd13273086604fca7ba750a84093c6839732d954056646e81b&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Log2&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Log222&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h2 id="2-3-带参数名的-event"><a href="#2-3-带参数名的-event" class="headerlink" title="2.3 带参数名的 event"></a>2.3 带参数名的 event</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x7874d94b8f9E2a28FCceCE404666C984f33a82b8&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x940879bf2d29cdfe8084f2f033d2168f5859a6e10530b61fb84dc1c5ddc9ca40&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Log3&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Log333&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;ads&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Log333&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h2 id="2-4-带-indexed-参数名的-event"><a href="#2-4-带-indexed-参数名的-event" class="headerlink" title="2.4 带 indexed 参数名的 event"></a>2.4 带 indexed 参数名的 event</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xfB72aAdB17a855D27A68B565ee0a84CB30A387e4&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xf485c071883274befba21423da7f60203f9df753bf614bca26c4763ed4b240fb&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Log4&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Log444&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;ads&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Log444&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xfB72aAdB17a855D27A68B565ee0a84CB30A387e4&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Transfer&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;amount&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h1 id="indexed-的作用"><a href="#indexed-的作用" class="headerlink" title="indexed 的作用"></a>indexed 的作用</h1><p>indexed 数据会被记录到 <code>topics</code> 中，可以用于检索。已索引的部分，最多有 3 个（对于非匿名事件）或 4 个（对于匿名事件）</p><p>对于非匿名事件，最多三个参数可以接收 <code>indexed</code>属性（它是一个特殊的名为: “主题” 的数据结构，而不作为日志的数据部分）。主题仅有 32 字节， 因此如果:引用类型 标记为索引项，则它们的 keccak-256 哈希值会被作为 主题（topic） 保存。</p><p>主题（topic）让我们可以可以搜索事件，比如在为某些事件过滤一些区块，还可以按发起事件的合同地址来过滤事件。</p><p>例如, 使用如下的 web3.js <code>subscribe(&quot;logs&quot;)方法</code> 去过滤符合特定地址的 主题（topic） ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line"><span class="attr">fromBlock</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">address</span>: web3.<span class="property">eth</span>.<span class="property">defaultAccount</span>,</span><br><span class="line"><span class="attr">topics</span>: [<span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>],</span><br><span class="line">&#125;;</span><br><span class="line">web3.<span class="property">eth</span></span><br><span class="line">.<span class="title function_">subscribe</span>(<span class="string">&quot;logs&quot;</span>, options, <span class="keyword">function</span> (<span class="params">error, result</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!error) <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="keyword">function</span> (<span class="params">log</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(log);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">on</span>(<span class="string">&quot;changed&quot;</span>, <span class="keyword">function</span> (<span class="params">log</span>) &#123;&#125;);</span><br></pre></td></tr></table></figure><p>主要用在链下服务，可以通过 RPC 获取，比如 web3 的以下方法:</p><ul><li><pre><code>myContract.once<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - https://web3js.readthedocs.io/en/v1.7.5/web3-eth-contract.html</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  myContract.events.MyEvent</span><br></pre></td></tr></table></figure>- https://web3js.readthedocs.io/en/v1.7.5/web3-eth-contract.html#contract-events</code></pre></li><li><pre><code>myContract.getPastEvents<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - https://web3js.readthedocs.io/en/v1.7.5/web3-eth-contract.html#getpastevents</span><br><span class="line"></span><br><span class="line"># log 的使用</span><br><span class="line"></span><br><span class="line">除非你用 `anonymous` 声明事件，否则事件签名的哈希值是一个 主题（topic）。同时也意味着对于匿名事件无法通过名字来过滤，仅能按合约地址过滤。匿名事件的优势是他们部署和调用的成本更低。它也允许你声明 4 个索引参与而不是 3 个。</span><br><span class="line"></span><br><span class="line">⚠️：由于交易日志只存储事件数据而不存储类型。你必须知道事件的类型，包括哪个参数被索引，以及该事件是否是匿名的，以便正确解释数据。尤其是，有可能使用一个匿名事件来&quot;伪造&quot;另一个事件的签名。</span><br><span class="line"></span><br><span class="line">```solidity</span><br><span class="line">pragma solidity  &gt;=0.4.21 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract ClientReceipt &#123;</span><br><span class="line">    event Deposit(</span><br><span class="line">        address indexed from,</span><br><span class="line">        bytes32 indexed id,</span><br><span class="line">        uint value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    function deposit(bytes32 id) public payable &#123;</span><br><span class="line">        // 事件使用 emit 触发事件。</span><br><span class="line">        // 我们可以过滤对 `Deposit` 的调用，从而用 Javascript API 来查明对这个函数的任何调用（甚至是深度嵌套调用）。</span><br><span class="line">        emit Deposit(msg.sender, id, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>使用 JavaScript API 调用事件的用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abi = <span class="comment">/* abi 由编译器产生 */</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ClientReceipt</span> = web3.<span class="property">eth</span>.<span class="title function_">contract</span>(abi);</span><br><span class="line"><span class="keyword">var</span> clientReceipt = <span class="title class_">ClientReceipt</span>.<span class="title function_">at</span>(<span class="string">&quot;0x1234...xlb67&quot;</span> <span class="comment">/* 地址 */</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> depositEvent = clientReceipt.<span class="title class_">Deposit</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听变化</span></span><br><span class="line">depositEvent.<span class="title function_">watch</span>(<span class="keyword">function</span>(<span class="params">error, result</span>) &#123;</span><br><span class="line">    <span class="comment">// 结果包含 非索引参数 以及 主题 topic</span></span><br><span class="line">    <span class="keyword">if</span> (!error)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者通过传入回调函数，立即开始听监</span></span><br><span class="line"><span class="keyword">var</span> depositEvent = clientReceipt.<span class="title class_">Deposit</span>(<span class="keyword">function</span>(<span class="params">error, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的输出如下所示（有删减）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;returnValues&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x1111…FFFFCCCC&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x50…sd5adb20&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x420042&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;raw&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x7f…91385&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;topics&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;0xfd4…b4ead7&quot;</span><span class="punctuation">,</span> <span class="string">&quot;0x7f…1a91385&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="Log-重载"><a href="#Log-重载" class="headerlink" title="Log 重载"></a>Log 重载</h1><p>Log 可以像函数一样重载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Event &#123;</span><br><span class="line">    event Log(address ads);</span><br><span class="line">    event Log(address indexed ads, string msg); // 重载</span><br><span class="line"></span><br><span class="line">    function log1() external &#123;</span><br><span class="line">        emit Log(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function log2() external &#123;</span><br><span class="line">        emit Log(msg.sender, &quot;Log111&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07-流程控制</title>
      <link href="/2022/06/30/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/07-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/06/30/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/07-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h1><h2 id="1-1-if"><a href="#1-1-if" class="headerlink" title="1.1 if"></a>1.1 if</h2><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式) &#123;</span><br><span class="line">   被执行语句(如果条件为真)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Solidity 中<strong>非布尔类型数值</strong>不能转换为布尔类型，因此 <code>if (1) &#123; ... &#125;</code> 的写法在 Solidity 中 无效 。</p><p><strong>例子</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function greaterThan10(uint256 _x) external pure returns (bool) &#123;</span><br><span class="line">        if (_x &gt; 10) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-if-else"><a href="#1-2-if-else" class="headerlink" title="1.2 if else"></a>1.2 if else</h2><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式) &#123;</span><br><span class="line">   被执行语句(如果条件为真)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   被执行语句(如果条件为假)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function greaterThan10(uint256 _x) external pure returns (bool) &#123;</span><br><span class="line">        if (_x &gt; 10) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-if…else-if…else"><a href="#1-3-if…else-if…else" class="headerlink" title="1.3 if…else if…else"></a>1.3 if…else if…else</h2><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式 1) &#123;</span><br><span class="line">   被执行语句(如果条件 1 为真)</span><br><span class="line">&#125; else if (条件表达式 2) &#123;</span><br><span class="line">   被执行语句(如果条件 2 为真)</span><br><span class="line">&#125; else if (条件表达式 3) &#123;</span><br><span class="line">   被执行语句(如果条件 3 为真)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   被执行语句(如果所有条件为假)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function example(uint256 _x) external pure returns (uint256) &#123;</span><br><span class="line">        if (_x &lt; 10) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else if (_x &lt; 20) &#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return 3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-if…else-if"><a href="#1-4-if…else-if" class="headerlink" title="1.4 if…else if"></a>1.4 if…else if</h2><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式 1) &#123;</span><br><span class="line">   被执行语句(如果条件 1 为真)</span><br><span class="line">&#125; else if (条件表达式 2) &#123;</span><br><span class="line">   被执行语句(如果条件 2 为真)</span><br><span class="line">&#125; else if (条件表达式 3) &#123;</span><br><span class="line">   被执行语句(如果条件 3 为真)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   被执行语句(如果所有条件为假)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function example(uint256 _x) external pure returns (uint256) &#123;</span><br><span class="line">        if (_x &lt; 10) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else if (_x &lt; 20) &#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125; else if (_x &lt; 30) &#123;</span><br><span class="line">            return 3;</span><br><span class="line">        &#125;</span><br><span class="line">        return 999;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h1><p>之前有介绍过三元运算符，这个相当于是 if else 的简洁版。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract IfElse&#123;</span><br><span class="line">    function example2 (uint _x) external pure returns (uint)&#123;</span><br><span class="line">        return _x&lt;10 ? 1 : 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08-循环与迭代</title>
      <link href="/2022/06/30/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/08-%E5%BE%AA%E7%8E%AF%E4%B8%8E%E8%BF%AD%E4%BB%A3/"/>
      <url>/2022/06/30/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/08-%E5%BE%AA%E7%8E%AF%E4%B8%8E%E8%BF%AD%E4%BB%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h1><h2 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (初始化; 测试条件; 迭代语句) &#123;</span><br><span class="line">   // 如果表达式的结果为真，就循环执行以下语句</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract For &#123;</span><br><span class="line">    // 输入5    输出15</span><br><span class="line">    function test1(uint256 _x) external pure returns (uint256 temp) &#123;</span><br><span class="line">        for (uint256 i = 1; i &lt;= _x; i++) &#123;</span><br><span class="line">            temp += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-循环控制"><a href="#1-2-循环控制" class="headerlink" title="1.2 循环控制"></a>1.2 循环控制</h2><ul><li><pre><code>continue<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  退出当前迭代</span><br><span class="line"></span><br><span class="line">  - 语句可以用来继续执行（跳过代码块的剩余部分并进入下一循环）。</span><br><span class="line"></span><br><span class="line">- `break` 终止循环</span><br><span class="line"></span><br><span class="line">```solidity</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract For &#123;</span><br><span class="line">    // 输入5    输出15</span><br><span class="line">    function test1(uint256 _x) external pure returns (uint256 temp) &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt;= _x; i++) &#123;</span><br><span class="line">            temp += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输入5    输出7</span><br><span class="line">    function test2(uint256 _x) external pure returns (uint256 temp) &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt;= _x; i++) &#123;</span><br><span class="line">            if (i == 3) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i == 5) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h2 id="1-3-使用-i-可以省-gas"><a href="#1-3-使用-i-可以省-gas" class="headerlink" title="1.3 使用 ++i 可以省 gas"></a>1.3 使用 ++i 可以省 gas</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract For &#123;</span><br><span class="line">    function test1(uint256 _x) external pure returns (uint256 temp) &#123;</span><br><span class="line">        for (uint256 i = 1; i &lt;= _x; i++) &#123;</span><br><span class="line">            temp += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function test2(uint256 _x) external pure returns (uint256 temp) &#123;</span><br><span class="line">        for (uint256 i = 1; i &lt;= _x; ++i) &#123;</span><br><span class="line">            temp += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>运行 test1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 输入 5    : 23658 gas</span><br><span class="line">// 输入 100  : 58713 gas</span><br></pre></td></tr></table></figure></li><li><p>运行 test2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 输入 5    : 23655 gas</span><br><span class="line">// 输入 100  : 58235 gas</span><br></pre></td></tr></table></figure></li></ul><h1 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h1><h3 id="2-1-语法"><a href="#2-1-语法" class="headerlink" title="2.1 语法"></a>2.1 语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (表达式) &#123;</span><br><span class="line">   // 如果表达式的结果为真，就循环执行以下语句</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract For &#123;</span><br><span class="line">    function test1(uint256 _x) external pure returns (uint256 temp) &#123;</span><br><span class="line">        uint256 i = 0;</span><br><span class="line">        while (i &lt;= _x) &#123;</span><br><span class="line">            temp += i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h1><h2 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">   // 如果表达式的结果为真，就循环执行以下语句</span><br><span class="line">   ......</span><br><span class="line">&#125; while (表达式);</span><br></pre></td></tr></table></figure><p><strong>例子</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract For &#123;</span><br><span class="line">    function test1(uint256 _x) external pure returns (uint256 temp) &#123;</span><br><span class="line">        uint256 i = 0;</span><br><span class="line">        while (i &lt;= _x) &#123;</span><br><span class="line">            temp += i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test2(uint256 _x) external pure returns (uint256 temp) &#123;</span><br><span class="line">        uint256 i = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">            temp += i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; while (i &lt;= _x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06-错误处理</title>
      <link href="/2022/06/27/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/06-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
      <url>/2022/06/27/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/06-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Solidity 如果遇到异常错误，是通过回退状态的方式来进行处理。发生异常时，会撤消当前调用和所有子调用改变的状态变量，同时给调用者返回一个错误标识。</p><p>调用者调用某个函数方法，要么成功修改了所有状态变量，要么遇到异常不修改任何状态变量，不存在成功修改部分变量的情况，</p><p>Solidity 提供了 <strong>require</strong> 、<strong>assert</strong> 和 <strong>revert</strong> 来处理异常。同时可以使用 <code>error</code> 关键字来实现错误。</p><p>跟用错误字符串相比， error 更便宜并且允许你编码额外的数据，还可以用 <code>NatSpec</code> 为用户去描述错误。</p><p>Solidity 使用状态恢复异常来处理错误。这种异常将撤消对当前调用（及其所有子调用）中的状态所做的所有更改，并且还向调用者标记错误。</p><p>如果异常在子调用发生，那么异常会自动冒泡到顶层（例如：异常会重新抛出），除非他们在 <code>try/catch</code> 语句中捕获了错误。 但是如果是在 <code>send</code> 和 低级 <code>call</code>, <code>delegatecall</code> 和 <code>staticcall</code> 的调用里发生异常时， 他们会返回 <code>false</code> （第一个返回值） 而不是冒泡异常。</p><p>警告注意：根据 EVM 的设计，如果被调用的地址不存在，低级别函数 <code>call</code>, <code>delegatecall</code> 和 <code>staticcall</code> 第一个返回值同样是 <code>true</code>。 如果需要，请在调用之前检查账号的存在性。</p><p>异常可以包含错误数据，以 error 示例 的形式传回给调用者。 内置的错误 <code>Error(string)</code> 和 <code>Panic(uint256)</code> 被作为特殊函数使用，下面将解释。 <code>Error</code> 用于 “常规” 错误条件，而 <code>Panic</code> 用于在（无 bug）代码中不应该出现的错误。</p><p>函数 assert 和 require 可用于检查条件并在条件不满足时抛出异常。</p><h1 id="require"><a href="#require" class="headerlink" title="require"></a>require</h1><p>require 用来严查某些条件，如果不满足这些雕件，就会回退所有状态的变化。</p><h2 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(condition[, &#x27;Something bad happened&#x27;])</span><br></pre></td></tr></table></figure><p>如果条件不满足则撤销状态更改 ，用于检查由输入或者外部组件引起的错误。可以同时提供一个错误消息。</p><ul><li>require 函数常常用来检查输入变量或状态变量是否满足条件，以及验证调用外部合约的返回值。</li><li>require 可以有返回值，例如：<code>require(condition, &#39;Something bad happened&#39;);</code>。</li><li>require 的返回值不宜过长，因为返回信息需要消耗 gas。<ul><li>并没有证明长度越长，消耗的 gas 越多。</li></ul></li></ul><p><strong>注解</strong> <code>require</code> 是一个像其他函数一样可被执行的函数。意味着，所有的参数在函数被执行之前就都会被执行。 尤其，在<br><code>require(condition, f())</code> 里，函数 <code>f</code> 会被执行，即便 <code>condition</code> 为 True .</p><h2 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h2><ul><li>验证用户输入，例如：<code>require(input_var&gt;100)</code></li><li>验证外部合约的调用结果，例如：<code>require(external.send(amount))</code></li><li>在执行状态更改操作之前验证状态条件，例如：<code>require(block.number &gt; 49999)</code> 或 <code>require(balance[msg.sender]&gt;=amount)</code></li><li>require() 语句的失败报错，应该被看作一个正常的判断语句流程不能通过的事件。</li></ul><p>一般来说，使用 <code>require()</code> 的频率更多，通常应用于函数的开头和函数修改器内。</p><p>一句话: <strong>require() 函数用于检测输入变量或状态变量是否满足条件，以及验证调用外部合约的返回值。</strong></p><h1 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h1><h2 id="2-1-语法"><a href="#2-1-语法" class="headerlink" title="2.1 语法"></a>2.1 语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(bool condition)</span><br></pre></td></tr></table></figure><p>如果不满足条件，则会导致 Panic 错误，则撤销状态更改 - 用于检查内部错误。</p><p><code>assert()</code>与 <code>require()</code> 语句都需要满足括号中的条件，才能进行后续操作，若不满足则抛出错误。</p><ul><li>assert：断言，不能包括报错信息的。</li></ul><p><strong>例子</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint256 public amount = 0;</span><br><span class="line"></span><br><span class="line">    function test1(uint256 _x) external &#123;</span><br><span class="line">        require(_x &lt; 10, &quot;My error info 1&quot;); // _x &gt;= 10 时候会报错</span><br><span class="line">        amount = _x;</span><br><span class="line">        assert(amount == _x); // 必须等于_x，否则抛出错误</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-使用场景"><a href="#2-2-使用场景" class="headerlink" title="2.2 使用场景"></a>2.2 使用场景</h2><ul><li>检查溢出</li><li>检查不变量</li><li>更改后验证状态</li><li>预防永远不会发生的情况</li><li>assert()语句的失败报错，意味着发生了代码层面的错误事件，很大可能是合约中有一个 bug 需要修复。</li><li>也可以智能合约写测试。</li></ul><p>一般来说，使用 <code>assert()</code>的频率较少，通常用于函数的结尾。基本上，<code>require()</code> 应该用于检查条件，而 <code>assert()</code> 只是为了防止发生任何非常糟糕的事情。</p><h2 id="2-3-扩展"><a href="#2-3-扩展" class="headerlink" title="2. 3 扩展"></a>2. 3 扩展</h2><p>assert 函数会创建一个 <code>Panic(uint256)</code> 类型的错误。同样的错误在以下列出的特定情形会被编译器创建。</p><p>assert 函数应该只用于测试内部错误，检查不变量，正常的函数代码永远不会产生 Panic, 甚至是基于一个无效的外部输入时。 如果发生了，那就说明出现了一个需要你修复的 bug。如果使用得当，语言分析工具可以识别出那些会导致 Panic 的 assert 条件和函数调用。</p><p>下列情况将会产生一个 Panic 异常： 错误数据会提供的错误码编号，用来指示 Panic 的类型：</p><ol><li>0x00: 用于常规编译器插入的 Panic。</li><li>0x01: 如果你调用 <code>assert</code> 的参数（表达式）结果为 false 。</li><li>0x11: 在 <code>unchecked &#123; ... &#125;</code> 外，如果算术运算结果向上或向下溢出。</li><li>0x12; 如果你用零当除数做除法或模运算（例如 <code>5 / 0</code> 或 <code>23 % 0</code> ）。</li><li>0x21: 如果你将一个太大的数或负数值转换为一个枚举类型。</li><li>0x22: 如果你访问一个没有正确编码的存储 byte 数组.</li><li>0x31: 如果在空数组上 <code>.pop()</code> 。</li><li>0x32: 如果你访问 <code>bytesN</code> 数组（或切片）的索引太大或为负数。(例如：<br><code>x[i]</code> 而 <code>i &gt;= x.length</code> 或 <code>i &lt; 0</code>).</li><li>0x41: 如果你分配了太多的内内存或创建了太大的数组。</li><li>0x51: 如果你调用了零初始化内部函数类型变量。</li></ol><h1 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h1><p>语法: <code>revert([string memory reason])</code></p><ul><li><p>使用 revert：抛出错误,它使用圆括号接受一个字符串：语句将一个自定义的错误作为直接参数，没有括号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">revert();</span><br><span class="line">revert(&quot;description&quot;);</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>revert()</code> 会触发一个没有任何错误数据的回退，而 <code>revert(&quot;description&quot;)</code> 会产生一个 <code>Error(string)</code> 错误。</p></li><li><p>使用 revert：触发自定义错误 ·</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revert CustomError(arg1, arg2);</span><br></pre></td></tr></table></figure><ul><li>可以接收参数，方便判断。比如可以传入 <code>msg.sender</code> &#x2F; 函数参数 等</li></ul></li></ul><p>终止运行并撤销状态更改。可以同时提供一个解释性的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract ErrorDemo &#123;</span><br><span class="line">    // 自定义错误</span><br><span class="line">    error MyError(address call, uint256 _i);</span><br><span class="line"></span><br><span class="line">    function testCustomError(uint256 _x) external view &#123;</span><br><span class="line">        if (_x &gt; 10) &#123;</span><br><span class="line">            revert MyError(msg.sender, _x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要参数没有额外的附加效果，使用 <code>if (!condition) revert(...);</code> 和 <code>require(condition, ...);</code> 是等价的，例如当参数是字符串的情况。</p><h1 id="三种方式的总结"><a href="#三种方式的总结" class="headerlink" title="三种方式的总结"></a>三种方式的总结</h1><h2 id="4-1-require、assert-不同点"><a href="#4-1-require、assert-不同点" class="headerlink" title="4.1 require、assert 不同点"></a>4.1 require、assert 不同点</h2><ul><li><code>require(false)</code> 编译为 <code>0xfd</code>，这是 <code>revert()</code> 的操作码，<strong>所以会退还所有剩余的 gas，同时可以返回一个自定义的报错信息</strong>。</li><li><code>assert(false)</code> 编译为 <code>0xfe</code>，这是一个无效的操作码，<strong>所以会消耗掉所有剩余的 gas，并恢复所有的操作</strong>。</li><li><code>require</code> 的 gas 消耗要小于 <code>assert</code>，而且可以有返回值，使用更为灵活。</li></ul><p>错误信息：<code>require</code> 函数可以创建无错误提示的错误，也可以创建一个 <code>Error(string)</code>类型的错误。 <code>require</code>函数应该用于确认条件有效性，例如输入变量，或合约状态变量是否满足条件，或验证外部合约调用返回的值。</p><p>当前不可以使用混合使用 require 和自定义错误，而是需要使用 <code>if (!condition) revert CustomError();</code> 。</p><p>下列情况将会产生一个 <code>Error(string)</code>（或无错误提示）的错误：</p><ol><li>如果你调用 <code>require(x)</code> ，而 <code>x</code> 结果为 <code>false</code> 。</li><li>如果你使用 <code>revert()</code> 或者 <code>revert(&quot;description&quot;)</code> 。</li><li>如果你在不包含代码的合约上执行外部函数调用。</li><li>如果你通过合约接收以太币，而又没有 <code>payable</code>修饰符的公有函数（包括构造函数和 fallback 函数）。</li><li>如果你的合约通过公有 getter 函数接收 Ether 。</li></ol><p>在下面的情况下，来自外部调用的错误数据（如果提供的话）被转发，这意味可能<code>Error</code> 或 <code>Panic</code> 都有可能触发。</p><ol><li>如果 <code>.transfer()</code> 失败。</li><li>如果你通过消息调用调用某个函数，但该函数没有正确结束（例如, 它耗尽了gas，没有匹配函数，或者本身抛出一个异常），不包括使用低级别 <code>call</code>， <code>send</code> ， <code>delegatecall</code> ， <code>callcode</code> 或 <code>staticcall</code><br>的函数调用。低级操作不会抛出异常，而通过返回 <code>false</code> 来指示失败。</li><li>如果你使用 <code>new</code> 关键字创建合约，但合约创建没有正确结束。</li></ol><p>你可以选择给 <code>require</code> 提供一个消息字符串，但 <code>assert</code> 不行。</p><p>如果你没有为 <code>require</code> 提供一个字符串参数，它会用空错误数据进行 revert， 甚至不包括错误选择器。</p><p>在下例中，你可以看到如何轻松使用 <code>require</code> 检查输入条件以及如何使用<code>assert</code> 检查内部错误.</p><p>在内部， Solidity 对异常执行回退操作（指令 <code>0xfd</code> ），从而让 EVM 回退对状态所做的所有更改。回退的原因是无法安全地继续执行，因为无法达到预期的结果。 因为我们想要保持交易的原子性，最安全的动作是回退所有的更改，并让整个交易（或至少调用）没有任何新影响。</p><p>在这两种情况下，调用者都可以使用 <code>try</code>&#x2F; <code>catch</code>来应对此类失败，但是被调用函数的更改将始终被还原。</p><h2 id="4-2-require、assert、revert-共同点"><a href="#4-2-require、assert、revert-共同点" class="headerlink" title="4.2 require、assert、revert 共同点"></a>4.2 require、assert、revert 共同点</h2><p>以下三个语句的功能完全相同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// revert</span><br><span class="line">if(msg.sender != owner) &#123;</span><br><span class="line">   revert();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">// require</span><br><span class="line">require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">// assert</span><br><span class="line">assert(msg.sender == owner);</span><br></pre></td></tr></table></figure><h1 id="自定义-Error"><a href="#自定义-Error" class="headerlink" title="自定义 Error"></a>自定义 Error</h1><p>Solidity 中的错误（关键字 error）提供了一种方便且省 gas 的方式来向用户解释为什么一个操作会失败。它们可以被定义在合约（包括接口和库）内部和外部。</p><ul><li><strong><code>error</code> 只能通过 <code>revert</code> 触发</strong></li><li>使用自定义 error 抛出错误，向调用者描述错误信息。</li><li>开发者可以在任何时候，任何条件下触发自定义 Error</li><li>error 花费更少的 gas。</li><li><code>error</code> 可以定义在 contract 之外。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 自定义错误</span><br><span class="line">error MyError1(address call, uint256 _i);</span><br><span class="line"></span><br><span class="line">contract ErrorDemo &#123;</span><br><span class="line">    // 自定义错误</span><br><span class="line">    error MyError2(address call, uint256 _i);</span><br><span class="line"></span><br><span class="line">    function testCustom1(uint256 _x) external view &#123;</span><br><span class="line">        if (_x &gt; 10) &#123;</span><br><span class="line">            revert MyError1(msg.sender, _x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误必须与 revert 语句 一起使用。它会还原当前调用中的发生的所有变化，并将错误数据传回给调用者。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">/// 转账时，没有足够的余额。</span><br><span class="line">/// @param available balance available.</span><br><span class="line">/// @param required requested amount to transfer.</span><br><span class="line">error InsufficientBalance(uint256 available, uint256 required);</span><br><span class="line"></span><br><span class="line">contract TestToken &#123;</span><br><span class="line">    mapping(address =&gt; uint) balance;</span><br><span class="line">    function transfer(address to, uint256 amount) public &#123;</span><br><span class="line">        if (amount &gt; balance[msg.sender])</span><br><span class="line">            revert InsufficientBalance(&#123;</span><br><span class="line">                available: balance[msg.sender],</span><br><span class="line">                required: amount</span><br><span class="line">            &#125;);</span><br><span class="line">        balance[msg.sender] -= amount;</span><br><span class="line">        balance[to] += amount;</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误不能被重写或覆盖，但是可以继承。只要作用域不同，同一个错误可以在多个地方定义。只能使用 <code>revert</code> 语句创建错误实例。</p><p>错误产生的数据，会通过 revert 操作传递给调用者，可以交由链外组件处理或在 try&#x2F;catch 语句 中捕获它。</p><p>注意，只有外部调用的错误才能被捕获。发生在内部调用或同一函数内的 revert 不能被捕获。</p><h1 id="Natspec-Error"><a href="#Natspec-Error" class="headerlink" title="Natspec Error"></a>Natspec Error</h1><p>使用一个自定义的错误实例通常会比字符串描述便宜得多。因为你可以使用错误名来描述它，它只被编码为四个字节。更长的描述可以通过 NatSpec 提供，这不会产生任何费用。</p><p>通过三个斜杠 <code>///</code> 定义的错误，它比<code>require</code>更省 gas。推荐代替 require 使用。</p><p>如果错误没有任何参数，错误只需要四个字节的数据，你可以使用 NatSpec，来进一步解释错误背后的原因，NatSpec 不会存储在链上。这个方式使得它同时也是一个非常便宜和方便的错误报告功能。</p><p>更具体地说，一个错误实例的 ABI 编码方式与调用相同名称和类型的函数的方式相同，它作为<code>revert</code> 操作码的返回数据使用。 这意味着错误数据由一个 4 字节的选择器和 ABI-encoded 数据组成。选择器是错误的签名的 keccak256 哈希的前四个字节组成。</p><p>代码结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// this is netspec error info</span><br><span class="line">error MyError1();</span><br></pre></td></tr></table></figure><p>例子如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract ErrorDemo &#123;</span><br><span class="line">    // netspec error</span><br><span class="line">    /// this is netspec error info,this is netspec error info,this is netspec error info,this is netspec error info</span><br><span class="line">    error MyError1();</span><br><span class="line"></span><br><span class="line">    /// 这是一个错误！老铁，你的输入参数错啦，必须要大于10的数字才可以通过！</span><br><span class="line">    error MyError2();</span><br><span class="line"></span><br><span class="line">    // 21647 gas</span><br><span class="line">    function test1(uint256 _x) external pure &#123;</span><br><span class="line">        if (_x &lt; 10) &#123;</span><br><span class="line">            revert MyError1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 21691 gas</span><br><span class="line">    function test2(uint256 _x) external pure &#123;</span><br><span class="line">        if (_x &lt; 10) &#123;</span><br><span class="line">            revert MyError2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 22036 gas</span><br><span class="line">    function test3(uint256 _x) external pure &#123;</span><br><span class="line">        require(</span><br><span class="line">            _x &gt; 10,</span><br><span class="line">            &quot;this is netspec error info,this is netspec error info,this is netspec error info,this is netspec error info&quot;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 21974 gas</span><br><span class="line">    function test4(uint256 _x) external pure &#123;</span><br><span class="line">        require(</span><br><span class="line">            _x &gt; 10,</span><br><span class="line">            unicode&quot;这是一个错误！老铁，你的输入参数错啦，必须要大于10的数字才可以通过！&quot;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h1><p>在当前合约发起对外部合约的调用，如果外部合约调用执行失败被 revert，外部合约状态会被回滚，当前合约状态也会被回滚。这是正常的逻辑。</p><p>但有时候我们并不想这样，要是能够捕获外部合约调用异常，然后根据情况做自己的处理会更好吗！所以，这种场景下适应于使用 <code>try...catch</code> 语句。</p><p><code>try catch</code>仅用于外部函数调用和合约创建调用。</p><ul><li>外部函数调用</li><li>合约创建调用</li></ul><h2 id="7-1-语法"><a href="#7-1-语法" class="headerlink" title="7.1 语法"></a>7.1 语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try this.count() &#123;</span><br><span class="line">    // 成功逻辑</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125; catch Error(string memory reason) &#123;</span><br><span class="line">    // 失败的逻辑: require / revert</span><br><span class="line">    // 调用 count() 失败时执行，通常是不满足 require 语句条件或触发 revert 语句时所引起的调用失败</span><br><span class="line">    return reason;</span><br><span class="line">&#125; catch (bytes memory) &#123;</span><br><span class="line">    // 失败逻辑</span><br><span class="line">    // 调用 count() 异常时执行，通常是触发 assert 语句或除 0 等比较严重错误时会执行</span><br><span class="line">    return &quot;assert error&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的逻辑也可以简写如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try this.count() &#123;</span><br><span class="line">    // 成功逻辑</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125; catch (bytes memory) &#123;</span><br><span class="line">    // 失败逻辑: require / revert / assert</span><br><span class="line">     return &quot;assert error&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Manager &#123;</span><br><span class="line">    function count() public pure returns (int256) &#123;</span><br><span class="line">         require(1 == 2, &quot;require error&quot;);</span><br><span class="line">         return 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function count() public pure returns (int256) &#123;</span><br><span class="line">        assert(1 == 2);</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test() public view returns (string memory) &#123;</span><br><span class="line">        // this 代表当前函数</span><br><span class="line">        try this.count() &#123;</span><br><span class="line">            return &quot;success&quot;;</span><br><span class="line">        &#125; catch Error(string memory reason) &#123;</span><br><span class="line">            // reason 是出错原因</span><br><span class="line">            // 调用 count() 失败时执行，通常是不满足 require 语句条件</span><br><span class="line">            // 或触发 revert 语句时所引起的调用失败</span><br><span class="line">            return reason;</span><br><span class="line">        &#125; catch (bytes memory) &#123;</span><br><span class="line">            // 调用 count() 异常时执行，通常是触发 assert 语句或除 0 等比较严重错误时会执行</span><br><span class="line">            return &quot;assert error&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外部调用的失败，可以通过 try&#x2F;catch 语句来捕获，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> // SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.8.1;</span><br><span class="line"></span><br><span class="line">interface DataFeed &#123; function getData(address token) external returns (uint value); &#125;</span><br><span class="line"></span><br><span class="line">contract FeedConsumer &#123;</span><br><span class="line">    DataFeed feed;</span><br><span class="line">    uint errorCount;</span><br><span class="line">    function rate(address token) public returns (uint value, bool success) &#123;</span><br><span class="line">        // 如果错误超过 10 次，永久关闭这个机制</span><br><span class="line">        require(errorCount &lt; 10);</span><br><span class="line">        try feed.getData(token) returns (uint v) &#123;</span><br><span class="line">            return (v, true);</span><br><span class="line">        &#125; catch Error(string memory reason) &#123;</span><br><span class="line">            // This is executed in case</span><br><span class="line">            // revert was called inside getData</span><br><span class="line">            // and a reason string was provided.</span><br><span class="line">            errorCount++;</span><br><span class="line">            return (0, false);</span><br><span class="line">        &#125;  catch Panic(uint errorCode) &#123;</span><br><span class="line">            // This is executed in case of a panic,</span><br><span class="line">            // i.e. a serious error like division by zero</span><br><span class="line">            // or overflow. The error code can be used</span><br><span class="line">            // to determine the kind of error.</span><br><span class="line">            errorCount++;</span><br><span class="line">            return (0, false);</span><br><span class="line">        &#125; catch (bytes memory lowLevelData) &#123;</span><br><span class="line">            // This is executed in case revert() was used。</span><br><span class="line">            errorCount++;</span><br><span class="line">            return (0, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Solidity 根据错误的类型，支持不同种类的捕获代码块：</p><ul><li><code>catch Error(string memory reason) &#123; ... &#125;</code>: 如果错误是由 <code>revert(&quot;reasonString&quot;)</code> 或 <code>require(false, &quot;reasonString&quot;)</code>（或导致这种异常的内部错误）引起的，则执行这个 catch 子句。</li><li><code>catch Panic(uint errorCode) &#123; ... &#125;</code>: 如果错误是由 panic 引起的（如： <code>assert</code> 失败，除以 0，无效的数组访问，算术溢出等），将执行这个 catch 子句。</li><li><code>catch (bytes memory lowLevelData) &#123; ... &#125;</code>: 如果错误签名不符合任何其他子句，如果在解码错误信息时出现了错误，或者如果异常没有一起提供错误数据。在这种情况下，子句声明的变量提供了对低级错误数据的访问。</li><li><code>catch &#123; ... &#125;</code>: 如果你对错误数据不感兴趣，你可以直接使用 <code>catch &#123; ... &#125;</code> (甚至是作为唯一的 catch 子句) 而不是前面几个 catch 子句。</li></ul><p>有计划在未来支持其他类型的错误数据。 <code>Error</code> 和 <code>Panic</code> 字符串目前是按原样解析的，不作为标识符处理。</p><p>为了捕捉所有的错误情况，你至少要有子句 <code>catch &#123; ... &#125;</code> 或 <code>catch (bytes memory lowLevelData) &#123; ... &#125;</code>.</p><p>在 <code>returns</code> 和 <code>catch</code> 子句中声明的变量只在后面的块的范围内有效。</p><p><strong>注解</strong>: 如果在 try&#x2F;catch 语句内部返回的数据解码过程中发生错误，这将导致当前执行的合约出现异常，如此，它不会在 catch 子句中被捕获到。如果在 <code>catch Error(string memory reason)</code> 的解码过程中出现错误，并且有一个低级的 catch 子句，那么这个错误就会在低级 catch 子句被捕获。</p><p><strong>注解</strong>: 如果执行到一个 catch 子句，那么外部调用的状态改变已经被回退了。如果执行到了成功块，那么外部调用的状态改变是有效的。如果状态改变已经被回退，那么要么在 catch 块中继续执行，要么是 try&#x2F;catch 语句的执行本身被回退（例如由于上面提到的解码失败或由于没有提供低级别的 catch 子句时）。</p><p><strong>注解</strong>:调用失败背后的原因可能是多方面的。请不要认为错误信息是直接来自被调用的合约。错误可能发生在调用链的更深处，而被调用的合约只是转发了（冒泡）错误。<br>另外，这可能是由于 out-of-gas 情况，而不是一个逻辑错误状况：调用者总是在调用中保留至少 1&#x2F;64 的 gas，这样即使被调合约 gas 用完，调用方仍有一些 gas 预留（处理剩余逻辑）</p>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05-运算操作符</title>
      <link href="/2022/06/24/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/05-%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2022/06/24/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/05-%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h1><ul><li><code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>(取余,取模)，</li><li><code>++</code>(递增),<code>--</code>(递减),<code>+=</code>(加法赋值),<code>-=</code>(减法赋值)</li><li><code>**</code>（次方）</li></ul><h2 id="1-1-unchecked"><a href="#1-1-unchecked" class="headerlink" title="1.1 unchecked"></a>1.1 unchecked</h2><p>默认情况下，算术运算都会进行溢出检查，但是也可以禁用检查，可以通过 <code>unchecked block</code> 来禁用检查，此时会返回截断的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function f(uint a, uint b) pure public returns (uint) &#123;</span><br><span class="line">    // 减法溢出会返回“截断”的结果</span><br><span class="line">    unchecked &#123; return a - b; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>溢出的检查功能是在 <code>0.8.0</code> 版本加入的，在此版本之前，请使用 <strong>OpenZepplin SafeMath</strong> 库。</p><h2 id="1-2-一元运算负"><a href="#1-2-一元运算负" class="headerlink" title="1.2 一元运算负 -"></a>1.2 一元运算负 <code>-</code></h2><p>表达式 <code>-x</code> 相当于 <code>(T(0) - x)</code> 这里 <code>T</code> 是指 <code>x</code> 的类型。 <code>-x</code> 只能应用在有符号型的整数上。 如果 <code>x</code> 为负数， <code>-x</code> 为正数。</p><p>由于使用两进制补码表示数据，你还需要小心:如果有 <code>int x = type(int).min;</code>， 那 <code>-x</code> 将不在正数取值的范围内。 这意味着这个检测 </p><p><code>unchecked &#123; assert(-x == x); &#125;</code> 是可以通过的（即这种情况下，不能假设它的负数会是正数），如果是 checked 模式，则会触发异常。</p><h2 id="1-3-除法运算"><a href="#1-3-除法运算" class="headerlink" title="1.3 除法运算"></a>1.3 除法运算</h2><p>除法运算结果的类型始终是其中一个操作数的类型，整数除法总是产生整数。在 Solidity 中，分数会取零。 这意味着 <code>int256(-5) / int256(2) == int256(-2)</code> 。</p><h2 id="1-4-模运算（取余）"><a href="#1-4-模运算（取余）" class="headerlink" title="1.4 模运算（取余）"></a>1.4 模运算（取余）</h2><p>模运算 <code>a％n</code> 是在操作数 <code>a</code> 的除以 <code>n</code> 之后产生余数 <code>r</code> ，其中 <code>q = int(a / n)</code> 和 <code>r = a - (n * q)</code> 。 这意味着模运算结果与左操作数相同的符号相同（或零）。 对于 负数的 a : <code>a % n == -(-a % n)</code>， 几个例子：</p><ul><li><code>int256(5) % int256(2) == int256(1)</code></li><li><code>int256(5) % int256(-2) == int256(1)</code></li><li><code>int256(-5) % int256(2) == int256(-1)</code></li><li><code>int256(-5) % int256(-2) == int256(-1)</code></li></ul><p>对 0 取模会发生错误 <code>Panic</code> 错误，该检查不能通过<code>unchecked &#123; … &#125;</code> 。</p><h2 id="1-5-幂运算"><a href="#1-5-幂运算" class="headerlink" title="1.5 幂运算"></a>1.5 幂运算</h2><p>幂运算仅适用于无符号类型。 结果的类型总是等于基数的类型. 请注意类型足够大以能够容纳幂运算的结果，要么发生潜在的 assert 异常或者使用截断模式。</p><p>在 <code>checked</code> 模式下，幂运算仅会为小基数使用相对便宜的 <code>exp</code> 操作码。 例如 <code>x**3</code> 的例子，表达式 <code>x*x*x</code> 也许更便宜。 在任何情况下，都建议进行 <code>gas</code> 消耗测试和使用优化器。</p><p>注意 <code>0**0</code> 在 EVM 中定义为 1 。</p><h2 id="1-6-i-和-i-区别"><a href="#1-6-i-和-i-区别" class="headerlink" title="1.6 i++ 和 ++i 区别"></a>1.6 i++ 和 ++i 区别</h2><ul><li><code>a = i++</code>: 先把 i 的值赋予 a，然后在执行 i&#x3D;i+1；</li><li><code>a = ++i</code>: 先执行 i&#x3D;i+1，然后在把 i 的值赋予 a；</li></ul><h2 id="1-7-for-循环中，-i-更省钱"><a href="#1-7-for-循环中，-i-更省钱" class="headerlink" title="1.7 for 循环中，++i 更省钱"></a>1.7 for 循环中，++i 更省钱</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    // 25153 gas</span><br><span class="line">    function test1() public pure returns (uint256 temp) &#123;</span><br><span class="line">        for (uint256 index = 0; index &lt; 10; index++) &#123;</span><br><span class="line">            temp += index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 25081 gas</span><br><span class="line">    function test2() public pure returns (uint256 temp) &#123;</span><br><span class="line">        for (uint256 index = 0; index &lt; 10; ++index) &#123;</span><br><span class="line">            temp += index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-8-赋值运算符"><a href="#1-8-赋值运算符" class="headerlink" title="1.8 赋值运算符"></a>1.8 赋值运算符</h2><ul><li><code>= </code>(简单赋值)</li><li><code>+=</code> (相加赋值)</li><li><code>−=</code> (相减赋值)</li><li><code>*=</code> (相乘赋值)</li><li><code>/=</code> (相除赋值)</li><li><code>%=</code> (取模赋值)</li></ul><p>注意： 同样的逻辑也适用于位运算符，因此它们将变成 <code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&gt;&gt;=</code>、<code>&amp;=</code>、<code>|=</code>和<code>^=</code>。</p><p><code>a += e</code> 等同于 <code>a = a + e</code>。其它运算符如 <code>-=</code>， <code>*=</code>， <code>/=</code>， <code>%=</code>， <code>|=</code>， <code>&amp;=</code> ， <code>^=</code> ， <code>&lt;&lt;=</code> 和 <code>&gt;&gt;=</code> 都是如此定义的。</p><ul><li><code>a++</code> 和 <code>a--</code> 分别等同于 <code>a += 1</code> 和 <code>a -= 1</code>，但表达式本身的值等于 <code>a</code> 在计算之前的值。</li><li>与之相反， <code>--a</code> 和 <code>++a</code> 虽然最终 <code>a</code> 的结果与之前的表达式相同，但表达式的返回值是计算之后的值。</li></ul><h1 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h1><p>关系运算符一共有六种：分别为： 大于 、小于 、 大于等于 、 小于等于 、 等于 和 不等于 。</p><ul><li><code>&gt;</code> (大于)</li><li><code>&lt;</code> (小于)</li><li><code>&gt;=</code> (大于等于)</li><li><code>&lt;=</code> (小于等于)</li><li><code>==</code> (等于)</li><li><code>!=</code> (不等于)</li></ul><p><strong>返回的结果是一个布尔值；</strong></p><h2 id="2-1-布尔类型-支持的运算符"><a href="#2-1-布尔类型-支持的运算符" class="headerlink" title="2.1 布尔类型 支持的运算符"></a>2.1 布尔类型 支持的运算符</h2><ul><li><p>包括：<code>!</code>逻辑非</p></li><li><p><code>==</code>等于，<code>!=</code> 不等于</p></li><li><p>&amp;&amp;逻辑与，||逻辑或</p><ul><li><code>&amp;&amp;</code>，<code>||</code> 为短路运算符</li></ul></li></ul><h2 id="2-2-定长字节数组支持的运算符"><a href="#2-2-定长字节数组支持的运算符" class="headerlink" title="2.2 定长字节数组支持的运算符"></a>2.2 定长字节数组支持的运算符</h2><ul><li>比较运算符： <code>&lt;=</code>， <code>&lt;</code>， <code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code> （返回布尔型）</li><li>位运算符： <code>&amp;</code>， <code>|</code>， <code>^</code> （按位异或）， <code>~</code> （按位取反）</li><li>移位运算符： <code>&lt;&lt;</code> （左移位）， <code>&gt;&gt;</code> （右移位）</li><li>索引访问：如果 <code>x</code> 是 <code>bytesI</code> 类型，那么 <code>x[k]</code> （其中 0 &lt;&#x3D; k &lt; I）返回第 k 个字节（只读）。</li></ul><p>该类型可以和作为右操作数的无符号整数类型进行移位运算（但返回结果的类型和左操作数类型相同），右操作数表示需要移动的位数。 进行有符号整数位移运算会引发运行时异常。</p><h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><h2 id="3-1-基础用法"><a href="#3-1-基础用法" class="headerlink" title="3.1 基础用法"></a>3.1 基础用法</h2><ul><li>&amp;&amp; (逻辑与)<ul><li>如果两个操作数都是 true ，则条件为真。</li></ul></li><li>|| (逻辑或)<ul><li>如果两个操作数有一个为 true ，则条件为真。</li></ul></li><li>! (逻辑非)<ul><li>反转操作数的逻辑状态。如果条件为真，则逻辑非操作将使其为假。</li></ul></li></ul><h2 id="3-2-和-的短路用法"><a href="#3-2-和-的短路用法" class="headerlink" title="3.2 &amp;&amp; 和 || 的短路用法"></a>3.2 <code>&amp;&amp;</code> 和 <code>||</code> 的短路用法</h2><p>原理:</p><ul><li><code>A &amp;&amp; B</code>,如果 A 为 false，B 就不执行了</li><li><code>A || B</code>,如果 A 为 true，B 就不执行了</li></ul><p>合理的使用短路操作，可以省一些 gas 费。</p><h1 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h1><p>三元运算符是一个表达是形式： <code>&lt;expression&gt; ? &lt;trueExpression&gt; : &lt;falseExpression&gt;</code> 。 它根据 <code>&lt;expression&gt;</code> 的执行结果，选择后两个给定表达式中的一个。 如果 <code>&lt;expression&gt;</code> 执行结果 true ，那么 <code>&lt;trueExpression&gt;</code> 将被执行，否则 <code>&lt;falseExpression&gt;</code> 被执行。</p><p>代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    uint256 public a = 20;</span><br><span class="line">    uint256 public b = 10;</span><br><span class="line"></span><br><span class="line">    function test1() public view returns (bool) &#123;</span><br><span class="line">        uint256 temp = a + b;</span><br><span class="line">        return temp &gt; 25 ? true : false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test2() public view returns (bool) &#123;</span><br><span class="line">        uint256 temp = a + b;</span><br><span class="line">        return temp &lt; 25 ? true : false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三元运算符的结果类型是由两个操作数的类型决定的，方法与上面一样，如果需要的话，首先转换为它们的最小可容纳类型（mobile type ）。</p><p>因此， <code>255 + (true ? 1 : 0)</code> 将由于算术溢出而被回退。 原因是 <code>(true ? 1 : 0)</code> 是 uint8 类型，这迫使加法也要在 <code>uint8</code> 中执行。 而 <code>256</code> 超出了这个类型所允许的范围。</p><p>另一个结果是，像 <code>1.5 + 1.5</code> 这样的表达式是有效的，但 <code>1.5 + (true ? 1.5 : 2.5)</code> 则无效。 这是因为前者是以无限精度来进行有理表达式运算，只有它的最终结果值才是重要的。 后者涉及到将小数有理数转换为整数，这在目前是不允许的。</p><h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>位运算在数字的二进制补码表示上执行。 这意味着： <code>~int256(0)== int256(-1)</code>。</p><p>假设 A 等于 2；B 等于 3。</p><ul><li><p>&amp;(位与): 对其整数参数的每个位执行位与操作。</p><ul><li>例: (A &amp; B) 为 2.</li></ul></li><li><p>|(位或): 对其整数参数的每个位执行位或操作。</p><ul><li>例: (A | B) 为 3.</li></ul></li><li><p>^(位异或): 对其整数参数的每个位执行位异或操作。</p><ul><li>例: (A ^ B) 为 1.</li></ul></li><li><p>~(位非): 一元操作符，反转操作数中的所有位。</p><ul><li>例: (~B) 为 -4.</li></ul></li><li><p>&lt;&lt;(左移位)): 将第一个操作数中的所有位向左移动，移动的位置数由第二个操作数指定，新的位由 0 填充。将一个值向左移动一个位置相当于乘以 2，移动两个位置相当于乘以 4，以此类推。</p><ul><li>例: (A « 1) 为 4.</li></ul></li><li><p><code>&gt;&gt;</code>(右移位): 左操作数的值向右移动，移动位置数量由右操作数指定</p><ul><li>例: (A » 1) 为 1.</li></ul></li></ul><p>如果两个中的任一个数是小数，则不允许进行位运算。如果指数是小数的话，也不支持幂运算（因为这样可能会得到一个无理数）。</p><h1 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h1><p><code>delete a</code> 的结果是将 <code>a</code> 类型初始值赋值给<code>a</code>。换句话说，在 <code>delete a</code> 之后 <code>a</code> 的值与在没有赋值的情况下声明 <code>a</code> 的情况相同。</p><p><code>delete</code> 适用于整型，数组，结构体映射。</p><ul><li>对于整型变量：相当于 <code>a = 0</code>。</li><li>对于动态数组：是将重置为数组长度为 0 的数组</li><li>对于静态数组：是将数组中的所有元素重置为初始值。</li><li>对于数组而言：<code>delete a[x]</code> 仅删除数组索引 <code>x</code> 处的元素，其他的元素和长度不变，这为数组留出了一个空位。如果打算删除项，映射可能是更好的选择。</li><li>对于结构体：则将结构体中的所有属性(成员)重置。</li><li>mapping : 是将所选择的 key 重置为初始值。</li></ul><p>需要注意以下几点：</p><p><code>delete</code> 对整个映射是无效的（因为映射的键可以是任意的，通常也是未知的）。因此在你删除一个结构体时，结果将重置所有的非映射属性（成员），这个过程是递归进行的，除非它们是映射。然而，单个的键及其映射的值是可以被删除的。</p><p>理解 <code>delete a</code> 的效果就像是给 <code>a</code> 赋值很重要，换句话说，这相当于在 <code>a</code>中存储了一个新的对象。</p><p>当 <code>a</code> 是应用变量时，我们可以看到这个区别， <code>delete a</code> 它只会重置 <code>a</code> 本身，而不是更改它之前引用的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract DeleteLBC &#123;</span><br><span class="line">    uint256 data;</span><br><span class="line">    uint256[] dataArray;</span><br><span class="line"></span><br><span class="line">    function f() public &#123;</span><br><span class="line">        uint256 x = data;</span><br><span class="line">        delete x; // 将 x 设为 0，并不影响数据</span><br><span class="line">        delete data; // 将 data 设为 0，并不影响 x，因为它仍然有个副本</span><br><span class="line">        uint256[] storage y = dataArray;</span><br><span class="line">        delete dataArray;</span><br><span class="line">        // 将 dataArray.length 设为 0，但由于 uint[] 是一个复杂的对象，y 也将受到影响，</span><br><span class="line">        // 因为它是一个存储位置是 storage 的对象的别名。</span><br><span class="line">        // 另一方面：&quot;delete y&quot; 是非法的，引用了 storage 对象的局部变量只能由已有的 storage 对象赋值。</span><br><span class="line">        assert(y.length == 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ul><li></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-函数</title>
      <link href="/2022/06/21/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/04-%E5%87%BD%E6%95%B0/"/>
      <url>/2022/06/21/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/04-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h1><p>函数由关键字 <code>function</code> 声明，后面跟<strong>函数名</strong>、<strong>参数</strong>、<strong>可视范围</strong>、<strong>状态可变性</strong>、<strong>返回值</strong>的定义。函数可以定义在合约内部，也可以定义在合约外部。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fnName(&lt;parameter list&gt;)</span><br><span class="line">    &lt;visibility&gt;</span><br><span class="line">    &lt;state mutability&gt;</span><br><span class="line">    [returns(&lt;return type&gt;)] &#123;</span><br><span class="line">    //语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fnName(&lt;parameter types&gt;)</span><br><span class="line">    &#123;internal|external&#125;</span><br><span class="line">    [pure|view|payable]</span><br><span class="line">    [returns (&lt;return types&gt;)]&#123;</span><br><span class="line">        //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>function</code>: 声明函数的固定关键字</li><li><code>fnName</code> : 函数名，推荐小驼峰写法,更多参考</li><li><code>&lt;parameter list&gt;</code> : 参数列表(参数类型 + 参数名字)</li><li><code>&lt;visibility&gt;</code>: 可见性，public、external、internal、private</li><li><code>&lt;state mutability&gt;</code>: 状态可变性，pure、view、payable，不写 <code>pure/view/payable</code> 中任何一个，代表，函数既可以读取也可以写入状态变量。</li><li><code>returns (&lt;return types&gt;)</code>:返回值和返回参数类型</li></ul><h2 id="1-1-合约函数"><a href="#1-1-合约函数" class="headerlink" title="1.1 合约函数"></a>1.1 合约函数</h2><p>注意：可以在合约内部或外部定义函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Fun &#123;</span><br><span class="line">//合约内的函数</span><br><span class="line">    function add(uint256 x, uint256 y) external pure returns (uint256) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//合约之外的函数（也称为“自由函数”）始终具有隐式的 `internal` 可见性。 它们的代码包含在所有调用它们合约中，类似于内部库函数</span><br><span class="line">function sum(uint256[] memory arr) pure returns (uint256 s) &#123;</span><br><span class="line">    for (uint256 i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        s += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在合约之外定义的函数仍然在合约的上下文内执行。他们仍然可以访问变量 <code>this</code> ，也可以调用其他合约，将其发送以太币或销毁调用它们合约等其他事情。</p><p>与在合约中定义的函数的主要区别为：自由函数不能直接访问存储变量和不在他们的作用域范围内函数。</p><h2 id="1-2-函数的输入参数"><a href="#1-2-函数的输入参数" class="headerlink" title="1.2 函数的输入参数"></a>1.2 函数的输入参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    uint256 sum;</span><br><span class="line"></span><br><span class="line">// 普通用法</span><br><span class="line">    function add(uint256 a, uint256 b) public &#123;</span><br><span class="line">        sum = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function demo(uint256 _a) public pure returns (uint256) &#123;</span><br><span class="line">    //函数参数可用在等号左边被赋值</span><br><span class="line">        _a = 22;</span><br><span class="line">        return _a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //使用数组作为函数参数</span><br><span class="line">    function demo(uint256[] memory _a) public returns (uint256[] memory) &#123;</span><br><span class="line">        a = _a;</span><br><span class="line">        return _a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>构造函数关键字 <code>constructor</code>，Solidity 构造函数是一个特殊函数，它仅能在智能合约部署的时候调用一次，创建之后就不能再次被调用。</p><p>构造函数是可选的，只允许有一个构造函数，这意味着不支持重载。</p><p><strong>用处</strong>: <strong>Solidity 构造函数常用来进行状态变量的初始化工作。</strong></p><ul><li>比如设置合约的 owner 权限</li><li>设置状态变量的初始值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract ErrorModifier&#123;</span><br><span class="line">     address public owner;</span><br><span class="line">    uint public count = 0;</span><br><span class="line"></span><br><span class="line">     constructor(uint _x)&#123;</span><br><span class="line">         owner = msg.sender;</span><br><span class="line">         count = _x;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：在合约创建的过程中，它的代码还是空的，所以直到构造函数执行结束，我们都不应该在其中调用合约自己的函数。(我们可以调用，但是不推荐调用)</p><p><strong>请注意</strong>：不可以在构造函数中通过 this 来调用函数，因为此时真实的合约实例还没有被创建。</p><h1 id="mutability-状态可变性"><a href="#mutability-状态可变性" class="headerlink" title="mutability:状态可变性"></a>mutability:状态可变性</h1><ul><li><p>pure: 既<strong>不读取也不修改状态变量</strong></p><ul><li>这种函数被称为<strong>纯函数</strong></li></ul></li><li><p>view: 读取状态变量，但是不修改状态变量</p><ul><li>这种函数被称为<strong>视图函数</strong></li><li>状态变量的 Getter 方法默认是 view 函数。</li></ul></li><li><p>payable：用 payable 声明的函数可以接受发送给合约的以太币.</p><ul><li>如果未指定，该函数将自动拒绝所有发送给它的以太币</li></ul></li></ul><h2 id="3-1-pure-不允许的操作"><a href="#3-1-pure-不允许的操作" class="headerlink" title="3.1 pure 不允许的操作"></a>3.1 pure 不允许的操作</h2><p>声明为 pure 函数，可以在函数声明里，添加 pure 关键字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint256 a, uint256 b) public pure returns (uint256) &#123;</span><br><span class="line">        return a * (b + 42);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数中存在以下语句，则被视为读取状态，编译器将抛出警告。</p><ul><li><strong>读取状态变量。</strong><ul><li><strong>这也意味着读取 <code>immutable</code> 变量也不是一个 <code>pure</code> 操作。</strong></li></ul></li><li><strong>访问 <code>address(this).balance</code> 或 <code>&lt;address&gt;.balance</code></strong></li><li><strong>访问 <code>block</code>，<code>tx</code>， <code>msg</code> 中任意成员 （除 <code>msg.sig</code> 和 <code>msg.data</code> 之外）。</strong></li><li><strong>调用任何未标记为 <code>pure</code> 的函数。</strong></li><li><strong>使用包含特定操作码的内联汇编。</strong><ul><li><strong><code>TODO:</code> 这个不了解，需要用例子加深印象。</strong></li></ul></li><li><strong>使用操作码 <code>STATICCALL</code> , 这并不保证状态未被读取, 但至少不被修改。</strong></li></ul><p>如果发生错误，<code>pure</code> 函数可以使用 <code>revert()</code>和 <code>require()</code> 函数来还原潜在的状态更改。还原状态更改不被视为 <strong>状态修改</strong>, 因为它只还原以前在没有<code>view</code> 或 <code>pure</code> 限制的代码中所做的状态更改, 并且代码可以选择捕获 revert 并不传递还原。这种行为也符合 STATICCALL 操作码。</p><p><strong>警告</strong>:不可能在 EVM 级别阻止函数读取状态, 只能阻止它们写入状态 (即只能在 EVM 级别强制执行 <code>view</code> , 而 <code>pure</code> 不能强制)。</p><h2 id="3-2-view-不允许的操作"><a href="#3-2-view-不允许的操作" class="headerlink" title="3.2 view 不允许的操作"></a>3.2 view 不允许的操作</h2><p>可以将函数声明为 view 类型，这种情况下要保证不修改状态。声明为 view 图函数，可以在函数声明里，添加 view 关键字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint256 a, uint256 b) public view returns (uint256) &#123;</span><br><span class="line">        return a * (b + 42) + block.timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注解</strong>: Getter 方法自动被标记为 view。</p><p>如果函数中存在以下语句，则被视为修改状态，编译器将抛出警告。</p><ul><li><strong>修改状态变量。</strong></li><li><strong>触发事件。</strong></li><li><strong>创建其它合约。</strong></li><li><strong>使用 <code>selfdestruct</code>。</strong></li><li><strong>通过调用发送以太币。</strong></li><li><strong>调用任何没有标记为 view 或者 pure 的函数。</strong></li><li><strong>使用底层调用</strong><ul><li><strong>(TODO:这里是 call 操作么？)</strong></li></ul></li><li><strong>使用包含某些操作码的内联程序集。</strong></li></ul><h2 id="3-3-payable"><a href="#3-3-payable" class="headerlink" title="3.3 payable"></a>3.3 payable</h2><h3 id="一个加和减的-DEMO"><a href="#一个加和减的-DEMO" class="headerlink" title="一个加和减的 DEMO"></a>一个加和减的 DEMO</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Counter&#123;</span><br><span class="line">    uint public count ;</span><br><span class="line"></span><br><span class="line">    function add() external &#123;</span><br><span class="line">        count+=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function minus() external &#123;</span><br><span class="line">        count-=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态可变性的类型转换"><a href="#状态可变性的类型转换" class="headerlink" title="状态可变性的类型转换"></a>状态可变性的类型转换</h3><p>如果满足下列条件，函数类型 A 可以隐式转换为函数类型:</p><ul><li>它们的参数类型相同，返回类型相同，它们的内部&#x2F;外部属性是相同的，并且 A 的状态可变性比 B 的状态可变性更具限制性</li></ul><p>比如：</p><ul><li>pure 函数可以转换为 view 和 non-payable 函数</li><li>view 函数可以转换为 non-payable 函数</li><li>payable 函数可以转换为 non-payable 函数</li><li>其他的转换则不可以。</li></ul><p>关于 <code>payable</code> 和 <code>non-payable</code> 的规则可能有点令人困惑，如果一个函数是 <code>payable</code> ，这意味着它也接受零以太的支付，因此它也是 <code>non-payable</code> 。 另一方面，<code>non-payable</code> 函数将拒绝发送给它的 以太币 Ether ， 所以 <code>non-payable</code> 函数不能转换为 <code>payable</code> 函数。</p><h1 id="函数的签名-函数标识符"><a href="#函数的签名-函数标识符" class="headerlink" title="函数的签名&#x2F;函数标识符"></a>函数的签名&#x2F;函数标识符</h1><p>在变量的全局变量那一章，我们介绍了 <code>msg.data</code> <code>msg.sig</code>,分别是调用合约的完整的 calldata，以及<strong>函数标识符</strong>（calldata 的前四个字节）</p><h3 id="查看-msg-data"><a href="#查看-msg-data" class="headerlink" title="查看 msg.data"></a>查看 msg.data</h3><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Receiver &#123;</span><br><span class="line">    event Log(bytes data1, bytes4 data2);</span><br><span class="line"></span><br><span class="line">    function transfer(address recipient, uint256 amount)</span><br><span class="line">        external</span><br><span class="line">        payable</span><br><span class="line">        returns (address, uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        emit Log(msg.data, msg.sig);</span><br><span class="line">        return (msg.sender, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>输入:</p><ul><li><code>0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</code></li><li><code>1</code></li></ul></li><li><p>logs 结果:</p><ul><li><p>data1</p><p> （为了方便阅读，我拆分成如下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xa9059cbb</span><br><span class="line">0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000001</span><br></pre></td></tr></table></figure></li><li><p>data2</p><p> 结果如下</p><ul><li><code>0xa9059cbb</code></li></ul></li></ul></li><li><p>output 结果:</p><ul><li><code>0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</code></li></ul></li><li><p><code>0</code></p></li></ul><h3 id="msg-data-中函数标识符的实现逻辑"><a href="#msg-data-中函数标识符的实现逻辑" class="headerlink" title="msg.data 中函数标识符的实现逻辑"></a>msg.data 中<strong>函数标识符</strong>的实现逻辑</h3><p>核心: <code>bytes4(keccak256(bytes(&quot;transfer(address,uint256)&quot;)))</code></p><p>一个函数调用数据的前 4 字节，指定了要调用的函数。这就是某个函数签名的 Keccak 哈希的前 4 字节（bytes32 类型是从左取值）。</p><p>函数签名被定义为基础原型的规范表达，而基础原型是<strong>函数名称加上由括号括起来的参数类型列表，参数类型间由一个逗号分隔开，且没有空格。</strong>.</p><p>代码如下，获取 Hash 后的值，和截取后的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract FunctionSelector &#123;</span><br><span class="line">    function getSelector(string calldata _func)</span><br><span class="line">        external</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes32, bytes4)</span><br><span class="line">    &#123;</span><br><span class="line">        // _func 字符串通过 bytes 转为 bytes</span><br><span class="line">        // 使用 keccak256 进行 Hash值运算</span><br><span class="line">        // 使用 bytes4 截取 keccak256 返回的32位数据</span><br><span class="line">        return (keccak256(bytes(_func)), bytes4(keccak256(bytes(_func))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><ol><li>部署</li><li>输入 <code>&quot;transfer(address,uint256)&quot;</code></li><li>获取结构<ol><li><code>0xa9059cbb2ab09eb219583f4a59a5d0623ade346d962bcd4e46b11da047c9049b</code></li><li><code>0xa9059cbb</code></li></ol></li></ol><p>注意：以上仅仅是背后的原理展示，如果想要获取值，可以通过<code>.selector</code> 返回 ABI 函数选择器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">library L &#123;</span><br><span class="line">    function f(uint256) external &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function g() public pure returns (bytes4) &#123;</span><br><span class="line">        return L.f.selector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管可以对 public 或 external 的库函数进行外部调用，但此类调用会被视为 Solidity 的内部调用，与常规的 contract ABI 规则不同。外部库函数比外部合约函数支持更多的参数类型，例如递归结构和指向存储的指针。</p><p>因此，计算用于计算 4 字节选择器的函数签名遵循内部命名模式以及可对合约 ABI 中不支持的类型的参数使用内部编码。</p><p>以下标识符可以作为函数签名中的类型：</p><ul><li>值类型, 非存储的（non-storage） <code>string</code> 及非存储的 <code>bytes</code>使用和合约 ABI 中同样的标识符。</li><li>非存储的数组类型遵循合约 ABI 中同样的规则，例如 <code>&lt;type&gt;[]</code>为动态数组以及 <code>&lt;type&gt;[M]</code> 为 <code>M</code> 个元素的动态数组。</li><li>非存储的结构体使用完整的命名引用，例如 <code>C.S</code> 用于<code>contract C &#123; struct S &#123; ... &#125; &#125;</code>.</li><li>存储的映射指针使用 <code>mapping(&lt;keyType&gt; =&gt; &lt;valueType&gt;) storage</code> 当<code>&lt;keyType&gt;</code> 和 <code>&lt;valueType&gt;</code> 是映射的键和值类型。</li><li>其他的存储的指针类型使用其对应的非存储类型的类型标识符，但在其后面附加一个空格及<code>storage</code> 。</li></ul><h1 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h1><p>Solidity 的函数重载，是指同一个作用域内，相同函数名可以定义多个函数。</p><p><strong>这些相同函数名的函数，参数(参数类型或参数数量)必须不一样。</strong>，因为只有这样上一节介绍的函数签名中，才能签出来不同的函数选择器。</p><p>合约可以具有多个不同参数的同名函数，称为”重载”（overloading），这也适用于继承函数。</p><h4 id="选择重载函数-参数匹配"><a href="#选择重载函数-参数匹配" class="headerlink" title="选择重载函数 &amp; 参数匹配"></a>选择重载函数 &amp; 参数匹配</h4><p>选择重载函数：通过将当前范围内的函数声明与函数调用中提供的参数相匹配，这样就可以选择重载函数。</p><p>如果所有参数都可以隐式地转换为预期类型，则该函数作为重载候选项。如果一个匹配的都没有，解析失败。</p><p>⚠️：返回参数不作为重载解析的依据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function f(uint8 val) public pure returns (uint8 out) &#123;</span><br><span class="line">        out = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f(uint256 val) public pure returns (uint256 out) &#123;</span><br><span class="line">        out = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    A a;</span><br><span class="line"></span><br><span class="line">    // Member &quot;f&quot; not unique after argument-dependent lookup in contract A.</span><br><span class="line">    // function test1() public view returns (uint256) &#123;</span><br><span class="line">    //     uint256 tar = a.f(8);</span><br><span class="line">    //     return tar;</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    function test2() public view returns (uint256) &#123;</span><br><span class="line">        uint256 tar = a.f(256);</span><br><span class="line">        return tar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Remix 里,部署 A 合约，会将两个方法都渲染出来，调用 <code>f(50)</code>&#x2F;<code>f(256)</code> 都可以。</p><p>但是实际调用里，在其他合约内调用 <code>f(50)</code> 会导致类型错误，因为 <code>50</code> 既可以被隐式转换为 <code>uint8</code>也可以被隐式转换为 <code>uint256</code>。 另一方面，调用 <code>f(256)</code> 则会解析为<code>f(uint256)</code> 重载，因为 <code>256</code> 不能隐式转换为 <code>uint8</code>。</p><h1 id="modifier-函数修改器"><a href="#modifier-函数修改器" class="headerlink" title="modifier:函数修改器"></a>modifier:函数修改器</h1><p>Solidity 中关键字 <code>modifier</code> 用于声明一个函数修改器。</p><ul><li><p><strong>意义</strong>:我们可以将一些通用的操作提取出来，包装为函数修改器，来提高代码的复用性，改善编码效率。是函数高内聚，低耦合的延伸。</p></li><li><p>作用: 常用于在函数执行前检查某种前置条件。</p><ul><li>比如地址对不对，余额是否充足，参数值是否允许等</li><li>修改器内可以写逻辑</li></ul></li><li><p>特点:是一种合约属性，可被继承，同时还可被派生的合约重写(override)。（修改器 modifier 是合约的可继承属性，并可能被派生合约覆盖 , 但前提是它们被标记为 virtual）。</p><ul><li><code>_</code> 符号可以在修改器中出现多次，每处都会替换为函数体。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract ErrorModifier&#123;</span><br><span class="line">     address public owner;</span><br><span class="line">    uint public count = 0;</span><br><span class="line">    </span><br><span class="line">     constructor()&#123;</span><br><span class="line">         owner = msg.sender;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     function add() external&#123;</span><br><span class="line">     //普通判断,非常的啰嗦</span><br><span class="line">         require(msg.sender==owner,&quot;must owner address&quot;);</span><br><span class="line">         count++;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     // 下面就是函数修改器</span><br><span class="line">     modifier onlyOwner()&#123;</span><br><span class="line">         require(msg.sender==owner,&quot;must owner address&quot;);</span><br><span class="line">         _;</span><br><span class="line">     &#125;</span><br><span class="line">     function add() external onlyOwner&#123;</span><br><span class="line">         count++;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     // 函数修改器:带参数</span><br><span class="line">      modifier greaterThan(uint _x)&#123;</span><br><span class="line">         require(_x &gt; 10,&quot;must be greater than 10&quot;);</span><br><span class="line">         _;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     function fnA(uint _x) external onlyOwner greaterThan( _x)&#123;</span><br><span class="line">         count=_x;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     //防重载的函数修改器，这种使用方法，在低版本的 solidity 中可以防止重入攻击。</span><br><span class="line">      modifier noReentrant() &#123;</span><br><span class="line">        require(!locked, &quot;no reentrant&quot;);</span><br><span class="line">        locked = true;</span><br><span class="line">        _;</span><br><span class="line">        locked = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想访问定义在合约 C 的 修改器 modifier m ， 可以使用 C.m 去引用它，而不需要使用虚拟表查找。</p><p>只能使用在当前合约或在基类合约中定义的 修改器 modifier , 修改器 modifier 也可以定义在库里面，但是他们被限定在库函数使用。</p><p>如果同一个函数有多个 修改器 modifier，它们之间以空格隔开，修改器 modifier 会依次检查执行。</p><p>修改器不能隐式地访问或改变它们所修饰的函数的参数和返回值。 这些值只能在调用时明确地以参数传递。</p><p>修改器 modifier 或函数体中显式的 return 语句仅仅跳出当前的 修改器 modifier 和函数体。 返回变量会被赋值，但整个执行逻辑会从前一个 修改器 modifier 中的定义的 <code>_</code> 之后继续执行。</p><p>警告:在早期的 Solidity 版本中，有 修改器 modifier 的函数， return 语句的行为表现不同。用 <code>return</code>; 从修改器中显式返回并不影响函数返回值。 然而，修改器可以选择完全不执行函数体，在这种情况下，返回的变量被设置为默认值，就像该函数是空函数体一样。</p><p><code>_</code> 符号可以在修改器中出现多次，每处都会替换为函数体。</p><p>修改器 modifier 的参数可以是任意表达式，在此上下文中，所有在函数中可见的符号，在 修改器 modifier 中均可见。 在 修改器 modifier 中引入的符号在函数中不可见（可能被重载改变）。</p><h1 id="全局：数学和密码学函数"><a href="#全局：数学和密码学函数" class="headerlink" title="全局：数学和密码学函数"></a>全局：数学和密码学函数</h1><p>在全局命名空间中已经预设了一些特殊的变量和函数，他们主要用来提供关于区块链的信息或一些通用的工具函数。后续会详细介绍，这里简单的介绍几个全局函数</p><h2 id="7-1-数学和密码学函数"><a href="#7-1-数学和密码学函数" class="headerlink" title="7.1 数学和密码学函数"></a>7.1 数学和密码学函数</h2><p>Solidity 也提供了内置的数学和密码学函数：</p><p>数学函数：</p><ul><li><pre><code>addmod(uint x, uint y, uint k) returns (uint)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 计算 `(x + y) % k`，加法会在任意精度下执行，并且加法的结果即使超过 `2**256` 也不会被截取。从 0.5.0 版本的编译器开始会加入对 `k != 0` 的校验（assert）。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  mulmod(uint x, uint y, uint k) returns (uint)</span><br></pre></td></tr></table></figure>- 计算 `(x * y) % k`，乘法会在任意精度下执行，并且乘法的结果即使超过 `2**256` 也不会被截取。从 0.5.0 版本的编译器开始会加入对 `k != 0` 的校验（assert）。</code></pre></li></ul><p>密码学函数：</p><ul><li><pre><code>keccak256((bytes memory) returns (bytes32)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 计算 Keccak-256 哈希，之前 keccak256 的别名函数 **sha3** 在 **0.5.0** 中已经移除。。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  sha256(bytes memory) returns (bytes32)</span><br></pre></td></tr></table></figure>- 计算参数的 SHA-256 哈希。</code></pre></li><li><pre><code>ripemd160(bytes memory) returns (bytes20)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 计算参数的 RIPEMD-160 哈希。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</span><br></pre></td></tr></table></figure>- 利用椭圆曲线签名恢复与公钥相关的地址，错误返回零值。- 函数参数对应于 ECDSA 签名的值:  - r = 签名的前 32 字节  - s = 签名的第 2 个 32 字节  - v = 签名的最后一个字节- ecrecover 返回一个 address, 而不是 address payable。- `ecrecover` 的[使用案例](https://ethereum.stackexchange.com/questions/1777/workflow-on-signing-a-string-with-private-key-followed-by-signature-verificatio)</code></pre></li></ul><h2 id="7-2-密码学函数"><a href="#7-2-密码学函数" class="headerlink" title="7.2 密码学函数"></a>7.2 密码学函数</h2><h3 id="密码学-keccak256-和-encodePacked-encode"><a href="#密码学-keccak256-和-encodePacked-encode" class="headerlink" title="密码学 keccak256 和 encodePacked&#x2F;encode"></a>密码学 keccak256 和 encodePacked&#x2F;encode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keccak256((bytes memory) returns (bytes32)</span><br></pre></td></tr></table></figure><p><strong>keccak256</strong>: 返回结果是 bytes32</p><p>这些编码函数可以用来构造函数调用数据，而不用实际进行调用。此外，<code>keccak256(abi.encodePacked(a, b))</code> 是一种计算结构化数据的哈希值（尽管我们也应该关注到：使用不同的函数参数类型也有可能会引起“哈希冲突” ）的方式，不推荐使用的 <code>keccak256(a, b)</code> 。</p><p>如果是多个参数，推荐使用 <code>encode</code>；<code>encodePacked</code> 因为哈希碰撞，容易导致参数不同，结果相同</p><blockquote><p>[AAA,BB] 和 [AA,ABB] 通过 encodePacked 得到的结果相同</p></blockquote><h3 id="密码学-ecrecover"><a href="#密码学-ecrecover" class="headerlink" title="密码学: ecrecover"></a>密码学: ecrecover</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</span><br></pre></td></tr></table></figure><p>利用椭圆曲线签名恢复与公钥相关的地址，错误返回零值。</p><p>函数参数对应于 ECDSA 签名的值:</p><ul><li>r &#x3D; 签名的前 32 字节</li><li>s &#x3D; 签名的第 2 个 32 字节</li><li>v &#x3D; 签名的最后一个字节</li></ul><p><code>ecrecover</code> 返回一个 address, 而不是 <code>address payable</code> 。他们之前的转换参考 <code>address payable</code> ，如果需要转移资金到恢复的地址。<a href="https://ethereum.stackexchange.com/questions/1777/workflow-on-signing-a-string-with-private-key-followed-by-signature-verificatio">参考案例</a></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果你使用 <code>ecrecover</code> ，需要了解，在不需要知道相应的私钥下，签名也可以转换为另一个有效签名（可能是另外一个数据的签名）。在 Homestead 硬分叉，这个问题对于 <em>transaction</em> 签名已经解决了(查阅 EIP-2)。 不过 <code>ecrecover</code> 没有更改。</p><p>除非需要签名是唯一的，否则这通常不是问题，或者是用它们来识别物品。 OpenZeppelin 有一个 <a href="https://docs.openzeppelin.com/contracts/2.x/api/cryptography#ECDSA">ECDSA</a> 助手库 ，可以将其用作 <code>ecrecover</code> 的”包装“，而不会出现此问题。</p><p>在一个私链上，你很有可能碰到由于 sha256、ripemd160 或者 ecrecover 引起的 <strong>Out-of-Gas</strong>。这个原因就是他们被当做所谓的预编译合约而执行，并且在第一次收到消息后这些合约才真正存在（尽管合约代码是硬代码）。发送到不存在的合约的消息非常昂贵，所以实际的执行会导致 Out-of-Gas 错误。在你的合约中实际使用它们之前，给每个合约发送一点儿以太币，比如 1 Wei。这在官方网络或测试网络上不是问题。</p><p><strong>ecrecover</strong>:这个比较复杂，请在下面的 <strong>通过智能合约验证签名</strong> 例子详细查看；</p><h3 id="案例-1-通过智能合约验证签名"><a href="#案例-1-通过智能合约验证签名" class="headerlink" title="案例 1:通过智能合约验证签名"></a>案例 1:通过智能合约验证签名</h3><p>做一个 DEMO：链上对任意消息进行加密，加密消息在链下使用私钥再次加密，然后对再次加密的信息进行校验。</p><ol><li><p>获取消息的 Hash 值</p><ul><li><code>hash = msgHash(_message);</code></li></ul></li><li><p>在【链下】将 hash 使用 MetaMask 进行私钥签名;</p><ul><li><code>_signature = metaMaskSignHash(hash,addressPrivateKey)</code></li><li>这里相当于在 Metamask 对 hash 做第二次的 <strong>keccak256 Hash</strong> 转换，转换时添加了<code>&quot;\x19Ethereum Signed Message:\n32&quot;</code></li></ul></li><li><p>使用ecrecover方法恢复签名地址</p><ul><li><code>ecrecoverAddress = recoverAds(hash,_signature)</code></li><li>这里可以恢复 MetaMask 签名时候使用的地址</li></ul></li><li><p>校验签名结果是否正确<br>ecrecoverAddress &#x3D;&#x3D; addressPublicKey ? “验证成功” : “验证失败”;</p></li></ol><h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract VerifySig &#123;</span><br><span class="line">    /**</span><br><span class="line">    功能:校验签名结果是否正确</span><br><span class="line">    注意 _signature 是 bytes 类型的</span><br><span class="line">     */</span><br><span class="line">    function verify(</span><br><span class="line">        address addressPublicKey,</span><br><span class="line">        string calldata _message,</span><br><span class="line">        bytes calldata _signature</span><br><span class="line">    ) external pure returns (bool) &#123;</span><br><span class="line">        bytes32 hash = msgHash(_message);</span><br><span class="line">        // bytes32 _signature = metaMaskSignHash(hash,addressPrivateKey); // 这是在链下操作</span><br><span class="line">        address ecrecoverAddress = recoverAds(hash, _signature);</span><br><span class="line">        return ecrecoverAddress == addressPublicKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function msgHash(string calldata _message)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes32 keccakFirst)</span><br><span class="line">    &#123;</span><br><span class="line">        keccakFirst = keccak256(abi.encodePacked(_message));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function msgHash2(bytes32 _msgHash)</span><br><span class="line">        internal</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes32 keccakSecond)</span><br><span class="line">    &#123;</span><br><span class="line">        // 两次2次签名，据说是数学层面上1次签名有被破解的可能。[我没有亲自验证过]</span><br><span class="line">        keccakSecond = keccak256(</span><br><span class="line">            abi.encodePacked(&quot;\x19Ethereum Signed Message:\n32&quot;, _msgHash)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function recoverAds(bytes32 _msgHash, bytes calldata _signature)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (address)</span><br><span class="line">    &#123;</span><br><span class="line">        // metamsk 签名会在原有消息上添加  &quot;\x19Ethereum Signed Message:\n32&quot;，所以需要处理一下</span><br><span class="line">        bytes32 metamaskInputHash = msgHash2(_msgHash);</span><br><span class="line">        // r为点的x坐标，s为点的y坐标，v是坐标的奇偶检验标识符</span><br><span class="line">        // v是用于说明那个点才是真正符合结果的点</span><br><span class="line">        // https://www.cnblogs.com/wanghui-garcia/p/9662140.html</span><br><span class="line">        // https://www.jianshu.com/p/090f605f1842/</span><br><span class="line">        (bytes32 r, bytes32 s, uint8 v) = _split(_signature);</span><br><span class="line"></span><br><span class="line">        address ecrecoverAddress = ecrecover(metamaskInputHash, v, r, s);</span><br><span class="line">        return ecrecoverAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _split(bytes memory _signature)</span><br><span class="line">        internal</span><br><span class="line">        pure</span><br><span class="line">        returns (</span><br><span class="line">            bytes32 r,</span><br><span class="line">            bytes32 s,</span><br><span class="line">            uint8 v</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        // 需要内联汇编进行分割，合约没有别的方法</span><br><span class="line">        require(_signature.length == 65, &quot;invalid signature length&quot;);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r := mload(add(_signature, 32))</span><br><span class="line">            s := mload(add(_signature, 64))</span><br><span class="line">            // v := mload(add(_signature, 96))</span><br><span class="line">            // 因为 v 不是 bytes32，是 uint8数字，uint8数字只占1位，所以使用 byte(0)转换</span><br><span class="line">            v := byte(0, mload(add(_signature, 96)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链下签名和-Remix-验证"><a href="#链下签名和-Remix-验证" class="headerlink" title="链下签名和 Remix 验证"></a>链下签名和 Remix 验证</h4><p>使用浏览器控制台进行签名，需要安装 MateMask</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 1.打开 ethereum</span><br><span class="line">ethereum.enable()</span><br><span class="line"></span><br><span class="line">// 2.赋值地址。这里的地址是 MateMask 的默认地址</span><br><span class="line">const address = &quot;0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac&quot;;</span><br><span class="line"></span><br><span class="line">// 3.赋值Hash。 使用 msgHash1 方法，输入 &quot;ABC&quot; 获取到的结果</span><br><span class="line">const hash = &quot;0xe1629b9dda060bb30c7908346f6af189c16773fa148d3366701fbaa35d54f3c8&quot;</span><br><span class="line"></span><br><span class="line">// 4. 呼起 MataMask 签名</span><br><span class="line">ethereum.request(&#123;method:&quot;personal_sign&quot;,params:[address,hash]&#125;);</span><br><span class="line"></span><br><span class="line">// 5. 打开返回的 Promise &#123;&lt;pending&gt;&#125;，拷贝 PromiseResult 值</span><br><span class="line">0x66029be70a055a4abc293072c76550ffaecb2adb9fc3be2366d78bc498e008d06b6ddbfef97392a27a58737c33b059e09bb069261bdc41f9f0d8d1bc6e0b7ae31c</span><br><span class="line"></span><br><span class="line">// 6. 在 recoverAds 中验证恢复的地址是否为签名地址。</span><br><span class="line">上面的 PromiseResult 值是 _signature</span><br><span class="line">上面的 hash 值是 _msgHash</span><br><span class="line"></span><br><span class="line">// 7. 在 verify 中再次校验</span><br></pre></td></tr></table></figure><p>扩展阅读: 在线进行签名的网站: <a href="https://metamask.github.io/test-dapp/">https://metamask.github.io/test-dapp/</a></p><h2 id="7-3-全局：ABI-编码及解码函数"><a href="#7-3-全局：ABI-编码及解码函数" class="headerlink" title="7.3 全局：ABI 编码及解码函数"></a>7.3 全局：ABI 编码及解码函数</h2><p>ABI 全名 Application Binary Interface。ABI 用于底层调用的辅助使用；在合约调用合约的时候使用，可以不知道对方的合约源码，只需要知道链上逻辑即可。</p><ul><li>ABI 编码<ul><li><code>abi.encode(...) returns (bytes)</code>： :ref:<code>ABI &lt;ABI&gt;</code> - 对给定参数进行编码</li><li><code>abi.encodePacked(...) returns (bytes)</code>：对给定参数执行 :ref:<code>紧打包编码 &lt;abi_packed_mode&gt;</code> ，注意，可以不明确打包编码。</li><li><code>abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)</code>： :ref:<code>ABI &lt;ABI&gt;</code> - 对给定第二个开始的参数进行编码，并以给定的函数选择器作为起始的 4 字节数据一起返回</li><li><code>abi.encodeWithSignature(string signature, ...) returns (bytes)</code>：等价于 <code>abi.encodeWithSelector(bytes4(keccak256(signature), ...)</code></li><li><code>abi.encodeCall(function functionPointer, (...)) returns (bytes memory)</code>: 使用 tuple 类型参数 ABI 编码调用 <code>functionPointer</code> 。执行完整的类型检查, 确保类型匹配函数签名。结果和 <code>abi.encodeWithSelector(functionPointer.selector, (...))</code> 一致。</li></ul></li><li>ABI 解码<ul><li><code>abi.decode(bytes memory encodedData, (...)) returns (...)</code>: 对给定的数据进行 ABI 解码，而数据的类型在括号中第二个参数给出 。 例如: <code>(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))</code></li></ul></li></ul><h3 id="7-3-1-encode-会补零"><a href="#7-3-1-encode-会补零" class="headerlink" title="7.3.1 encode: 会补零"></a>7.3.1 encode: 会补零</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract AbiDecode &#123;</span><br><span class="line">    function encode(string memory a, string memory b)</span><br><span class="line">        external</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes memory)</span><br><span class="line">    &#123;</span><br><span class="line">        return abi.encode(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">输入如下参数和返回结果</span><br><span class="line">1.AA,BB</span><br><span class="line">    0x</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000040</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000080</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">    4141000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">    4242000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">2.AAA,BB</span><br><span class="line">    0x</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000040</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000080</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000003</span><br><span class="line">    4141410000000000000000000000000000000000000000000000000000000000</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">    4242000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">3.AA,ABB</span><br><span class="line">    0x</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000040</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000080</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">    4141000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">    0000000000000000000000000000000000000000000000000000000000000003</span><br><span class="line">    4142420000000000000000000000000000000000000000000000000000000000</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="7-3-2-encodePacked不会补零"><a href="#7-3-2-encodePacked不会补零" class="headerlink" title="7.3.2 encodePacked不会补零"></a>7.3.2 encodePacked不会补零</h3><p>不补零，容易导致碰撞错误。（两个参数拼在一起，导致参数不同，结果相同）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract AbiDecode &#123;</span><br><span class="line">    function encodePacked(string memory a, string memory b)</span><br><span class="line">        external</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes memory)</span><br><span class="line">    &#123;</span><br><span class="line">        return abi.encodePacked(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">输入如下参数和返回结果</span><br><span class="line">1.AA,BB</span><br><span class="line">    0x41414242</span><br><span class="line">2.AAA,BB</span><br><span class="line">    0x4141414242</span><br><span class="line">3.AA,ABB</span><br><span class="line">    0x4141414242</span><br><span class="line">[AAA,BB] 和 [AA,ABB] 得到的结果相同</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h4 id="解决-encodePacked-的哈希碰撞问题"><a href="#解决-encodePacked-的哈希碰撞问题" class="headerlink" title="解决 encodePacked 的哈希碰撞问题"></a>解决 <code>encodePacked</code> 的哈希碰撞问题</h4><p>可以在要编码的数据中间加一个固定的值，如果</p><p><strong>代码如下:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract AbiDecode &#123;</span><br><span class="line">    function encodePacked(string calldata _test1, string calldata _test2)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes memory)</span><br><span class="line">    &#123;</span><br><span class="line">        uint256 x = 123;</span><br><span class="line">        return abi.encodePacked(_test1, x, _test2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果如下:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">输入如下参数和返回结果</span><br><span class="line">1.AA,BB</span><br><span class="line">    0x4141000000000000000000000000000000000000000000000000000000000000007b4242</span><br><span class="line">2.AAA,BB</span><br><span class="line">    0x414141000000000000000000000000000000000000000000000000000000000000007b4242</span><br><span class="line">3.AA,ABB</span><br><span class="line">    0x4141000000000000000000000000000000000000000000000000000000000000007b414242</span><br><span class="line">[AAA,BB] 和 [AA,ABB] 因为间隔了数据，所以得到的结果不相同</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>这些编码函数可以用来构造函数调用数据，而不用实际进行调用。此外，<code>keccak256(abi.encodePacked(a, b))</code> 是一种计算结构化数据的哈希值（尽管我们也应该关注到：使用不同的函数参数类型也有可能会引起“哈希冲突” ）的方式，不推荐使用的 <code>keccak256(a, b)</code> 。</p><h3 id="7-3-3-decode"><a href="#7-3-3-decode" class="headerlink" title="7.3.3 decode"></a>7.3.3 decode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract AbiDecode &#123;</span><br><span class="line">    struct MyStruct &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint256[2] nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function encode(</span><br><span class="line">        uint256 x,</span><br><span class="line">        address addr,</span><br><span class="line">        uint256[] calldata arr,</span><br><span class="line">        MyStruct calldata myStruct</span><br><span class="line">    ) external pure returns (bytes memory) &#123;</span><br><span class="line">        return abi.encode(x, addr, arr, myStruct);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function decode(bytes calldata data)</span><br><span class="line">        external</span><br><span class="line">        pure</span><br><span class="line">        returns (</span><br><span class="line">            uint256 x,</span><br><span class="line">            address addr,</span><br><span class="line">            uint256[] memory arr,</span><br><span class="line">            MyStruct memory myStruct</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        (x, addr, arr, myStruct) = abi.decode(</span><br><span class="line">            data,</span><br><span class="line">            (uint256, address, uint256[], MyStruct)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>合约测试</strong></p><ul><li><p>部署</p></li><li><pre><code>encode<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 参数如下:</span><br><span class="line">  - `1`</span><br><span class="line">  - `0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac`</span><br><span class="line">  - `[1,2,3]`</span><br><span class="line">  - `[&quot;Anbang&quot;,[2,3]]`</span><br><span class="line"></span><br><span class="line">- 得到的结果，进行 `decode`</span><br><span class="line"></span><br><span class="line">### 7.3.4 abi.encodeWithSelector</span><br><span class="line"></span><br><span class="line">这是获取函数签名使用的，第一个参数为函数选择，如下是第二章在介绍地址类型的时候，staticcall 静态调用 用法的参数，需要由 `abi.encodeWithSelector` 计算出来。函数的参数按照顺序写在函数名之后即可。</span><br><span class="line"></span><br><span class="line">```solidity</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 被调用的合约</span><br><span class="line">contract Hello &#123;</span><br><span class="line">    function echo() external pure returns (string memory) &#123;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用者合约</span><br><span class="line">contract SoldityTest &#123;</span><br><span class="line">    function callHello(address _ads) external view returns (string memory) &#123;</span><br><span class="line">        // 编码被调用者的方法签名</span><br><span class="line">        bytes4 methodId = bytes4(keccak256(&quot;echo()&quot;));</span><br><span class="line"></span><br><span class="line">        // 调用合约</span><br><span class="line">        (bool success, bytes memory data) = _ads.staticcall(</span><br><span class="line">            abi.encodeWithSelector(methodId)</span><br><span class="line">        );</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            return abi.decode(data, (string));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;error&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h3 id="7-3-5-abi-encodeWithSignature"><a href="#7-3-5-abi-encodeWithSignature" class="headerlink" title="7.3.5 abi.encodeWithSignature"></a>7.3.5 abi.encodeWithSignature</h3><p>这是获取函数签名使用的，第一个参数为函数的名字和参数类型，如下是第二章在介绍地址类型的时候，call 用法的参数，需要由 <code>abi.encodeWithSignature</code> 计算出来。函数的参数按照顺序写在函数名之后即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function call_Test1_setNameAndAge(</span><br><span class="line">    address _ads,</span><br><span class="line">    string memory _name,</span><br><span class="line">    uint256 _age</span><br><span class="line">) external payable &#123;</span><br><span class="line">    bytes memory data = abi.encodeWithSignature(</span><br><span class="line">        &quot;setNameAndAge(string,uint256)&quot;,</span><br><span class="line">        _name,</span><br><span class="line">        _age</span><br><span class="line">    );</span><br><span class="line">    (bool success, bytes memory _bys) = _ads.call&#123;value: msg.value&#125;(data);</span><br><span class="line">    require(success, &quot;Call Failed&quot;);</span><br><span class="line">    bys = _bys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-变量</title>
      <link href="/2022/06/20/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/03-%E5%8F%98%E9%87%8F/"/>
      <url>/2022/06/20/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/03-%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="变量基础知识"><a href="#变量基础知识" class="headerlink" title="变量基础知识"></a>变量基础知识</h1><p>回顾一下前面两章提到的变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract DataTypes &#123;</span><br><span class="line">    string public myString = &quot;hello world&quot;;</span><br><span class="line">    bool public b = true;</span><br><span class="line">    uint256 public u = 123;</span><br><span class="line"></span><br><span class="line">    int256 public i = -123;</span><br><span class="line">    int256 public minInt = type(int256).min; // 获取最小值</span><br><span class="line">    int256 public maxInt = type(int256).max; // 获取最大值</span><br><span class="line">    address public ads = 0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac;</span><br><span class="line">    bytes32 public bys32 = &quot;abc&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-1-初始默认值"><a href="#1-1-初始默认值" class="headerlink" title="1.1 初始默认值"></a>1.1 初始默认值</h2><p><strong>Solidity 是一种静态类型语言</strong>，这意味着需要在声明期间指定变量类型。</p><p>在 Solidity 中没有 null 或者 undefined 的概念，但是新声明的变量总是有一个默认值，具体的默认值跟类型相关，比如 int 类型的默认值为 0。每个变量声明时，都有一个基于其类型的默认值。</p><h4 id="默认值总结"><a href="#默认值总结" class="headerlink" title="默认值总结"></a>默认值总结</h4><ul><li>string: <code>&quot;&quot;</code></li><li>bool: <code>false</code></li><li>int256: <code>0</code></li><li>uint256: <code>0</code></li><li>address: <code>0x0000000000000000000000000000000000000000</code></li><li>bytes32: <code>0x0000000000000000000000000000000000000000000000000000000000000000</code></li><li>enum: <code>0</code></li><li>动态数组: <code>[]</code></li><li>定长数组: 每个元素的默认值</li><li><code>mapping</code> &#x2F; <code>strucr</code> 均为所在类型的默认值</li></ul><h2 id="1-2-作用域和声明"><a href="#1-2-作用域和声明" class="headerlink" title="1.2 作用域和声明"></a>1.2 作用域和声明</h2><p>Solidity 中的作用域规则遵循了 C99：</p><h3 id="1-2-1-作用域的规则"><a href="#1-2-1-作用域的规则" class="headerlink" title="1.2.1 作用域的规则"></a>1.2.1 作用域的规则</h3><ul><li>变量将会从它们被声明之后可见，直到一对 <code>&#123;&#125;</code> 块的结束。</li><li>对于参数形式的变量（例如：函数参数、修饰器参数、catch 参数等等）在其后接着的代码块内有效。<ul><li>这些代码块是函数的实现，catch 语句块等。</li><li>有一个例外，在 for 循环语句中初始化的变量，其可见性仅维持到 <code>for</code> 循环的结束。</li></ul></li><li>那些定义在代码块之外的变量，比如函数、合约、自定义类型等等，并不会影响它们的作用域特性。<ul><li>意味着你可以在实际声明状态变量的语句之前就使用它们，并且递归地调用函数。</li></ul></li></ul><p>在 Solidity 中，如果在内部作用域中使用和外层相同的变量名，会收到警告信息。这种警告是告诉开发者<code>外层声明的变量被“覆盖”</code>了，谨慎检查下是不是期望的。</p><p>上面例子中的 f 函数的 return 值 可以改写为下面的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f() public pure returns (uint256 x) &#123;</span><br><span class="line">    x = 1;</span><br><span class="line">    &#123;</span><br><span class="line">        x = 2;</span><br><span class="line">        uint256 x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-必须先声明再赋值"><a href="#1-2-2-必须先声明再赋值" class="headerlink" title="1.2.2 必须先声明再赋值"></a>1.2.2 必须先声明再赋值</h3><p>在 Solidity 现在的版本中，变量必须先声明再赋值，顺序不能倒。</p><p>0.5.0 版本之前，一个变量声明在函数的任意位置，都可以使他在整个函数范围内可见。从 0.5.0 版本开始以后就不能这样了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    // ✅</span><br><span class="line">    function t() public pure returns (uint256) &#123;</span><br><span class="line">        uint256 x;</span><br><span class="line">        x = 2;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ❌</span><br><span class="line">    function f() public pure returns (uint256) &#123;</span><br><span class="line">        // DeclarationError: Undeclared identifier.</span><br><span class="line">        // &quot;x&quot; is not (or not yet) visible at this point.</span><br><span class="line">        x = 2;</span><br><span class="line">        uint256 x;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-3-合约外定义的类型和函数"><a href="#1-2-3-合约外定义的类型和函数" class="headerlink" title="1.2.3 合约外定义的类型和函数"></a>1.2.3 合约外定义的类型和函数</h3><ul><li>合约外面可以定义函数和数据结构<ul><li>定义在合约外面的函数，叫自由函数</li><li>定义在合约外面的类型，可以被多个合约使用</li></ul></li><li>不可以定义变量<ul><li>但是可以定义常量，常量那一节有介绍</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 结构:</span><br><span class="line">//      定义在合约外面</span><br><span class="line">//      可以被多个合约同时使用</span><br><span class="line">struct Book &#123;</span><br><span class="line">    string title;</span><br><span class="line">    string author;</span><br><span class="line">    uint256 book_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 自由函数:</span><br><span class="line">//      定义在合约外面</span><br><span class="line">//      没有可见性</span><br><span class="line">function getBalance() view returns (uint256) &#123;</span><br><span class="line">    return address(msg.sender).balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function add(uint256 a_, uint256 b_) pure returns (uint256) &#123;</span><br><span class="line">    return a_+b_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Demo1 &#123;</span><br><span class="line">    Book public book1 = Book(&quot;Solidity&quot;, &quot;Anbang&quot;, 1);</span><br><span class="line">    function f() public view returns (uint256) &#123;</span><br><span class="line">        return getBalance();</span><br><span class="line">    &#125;</span><br><span class="line">    function test() public pure returns (uint256) &#123;</span><br><span class="line">        return add(100,200);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Demo2 &#123;</span><br><span class="line">    Book public book2 = Book(&quot;Solidity 2&quot;, &quot;Anbang&quot;, 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-变量的三种状态"><a href="#1-3-变量的三种状态" class="headerlink" title="1.3 变量的三种状态"></a>1.3 变量的三种状态</h2><p>按作用域划分，状态可以分为下面三种状态：</p><ul><li>状态变量:<ul><li>变量值永久保存在智能合约存储空间中，相当于属于已经写入到区块链中，可以随时调用，除非该条链消失。</li><li>特点:定义在智能合约的存储空间中</li></ul></li><li>局部变量:<ul><li>变量值仅在函数执行过程中有效,供函数内部使用；调用函数时，在虚拟机的内存中；函数退出后，变量无效。类似”闭包”的特性。</li><li>特点: 定义在函数内部</li></ul></li><li>全局变量:<ul><li>保存在全局命名空间，用于获取区块链相关信息的特殊变量。</li><li>特点:存在于 EVM 虚拟机中，不用定义，直接获取即可。</li></ul></li></ul><h3 id="1-3-1-状态变量"><a href="#1-3-1-状态变量" class="headerlink" title="1.3.1 状态变量"></a>1.3.1 状态变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Var&#123;</span><br><span class="line">    uint256 public myUint = 123;</span><br><span class="line">    function changeMyUint (uint256 x) external returns (uint256 )&#123;</span><br><span class="line">        myUint = x;</span><br><span class="line">        return myUint;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-2-局部变量"><a href="#1-3-2-局部变量" class="headerlink" title="1.3.2 局部变量"></a>1.3.2 局部变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Var&#123;</span><br><span class="line">     function test() external pure returns (uint256)&#123;</span><br><span class="line">        uint256 local = 2;// 局部变量</span><br><span class="line">        return local;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-3-全局变量"><a href="#1-3-3-全局变量" class="headerlink" title="1.3.3 全局变量"></a>1.3.3 全局变量</h3><ul><li><code>msg.sender</code></li><li><code>msg.value</code></li><li><code>block.timestamp</code></li><li><code>block.number</code></li></ul><p>先简单了解下，后面会有一节进行详细介绍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line">contract Demo1 &#123;</span><br><span class="line">    address public owner = msg.sender; // 在状态变量中使用</span><br><span class="line"></span><br><span class="line">    // 在函数内使用</span><br><span class="line">    function global() external view returns(address,uint256,uint256)&#123;</span><br><span class="line">        return(msg.sender,block.timestamp,block.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Constant-常量"><a href="#Constant-常量" class="headerlink" title="Constant 常量"></a>Constant 常量</h1><ul><li>普通变量与常量:普通的状态变量，添加 <code>constant</code> 关键词即可声明为常量</li><li>与常规状态变量相比，<strong>常量的 gas 要低很多</strong>。</li><li>常量名字一般使用<strong>全大写</strong>。</li><li>常量<strong>赋值后不可以修改</strong>。</li><li>常量必须<strong>声明和初始化一起完成</strong>，否则编译不通过。</li><li>常量的值储存原理<ul><li>常量的值在编译器确定，因为在编译器确定，所以<strong>不能定义在函数内</strong>。</li><li>编译器并不会为 <code>constant</code> 常量在 <code>storage</code> 上预留空间，它们的每次出现都会被替换为相应的常量表达式（它可能被优化器计算为实际的某个值）。</li><li>因为不是储存在<code>storage</code> 上，所以函数内读取常量不算<code>view</code>，可以使用 pure</li><li>因为不是储存在<code>storage</code> 上，所以可以在任意位置定义常量，比如在合约外面</li><li>也可以在文件级别定义 constant 变量（0.7.2 之后的特性）。</li></ul></li><li>引用类型只支持字符串<ul><li>不是所有的类型都支持常量，当前支持的仅有<strong>值类型（包括地址类型）&#x2F;字符串&#x2F;bytes</strong>。</li></ul></li><li>可以使用内建函数赋值常量</li></ul><h2 id="2-1-常见的赋值方式"><a href="#2-1-常见的赋值方式" class="headerlink" title="2.1 常见的赋值方式"></a>2.1 常见的赋值方式</h2><p>如果状态变量声明为 <code>constant</code>(常量)。在这种情况下，只能使用那些在编译时有确定值的表达式来给它们赋值。</p><ul><li>允许可能对内存分配产生 side effect（副作用）的表达式，但那些可能对其他内存对象产生副作用的表达式则不允许。<ul><li>内建（built-in）函数 <code>keccak256</code> ， <code>sha256</code> ， <code>ripemd160</code> ，<code>ecrecover</code> ， <code>addmod</code> 和 <code>mulmod</code>是允许的（即使他们确实会调用外部合约， <code>keccak256</code> 除外）。</li><li>允许内存分配器的副作用的原因是它可以构造复杂的对象，例如：查找表（lookup-table）。 此功能尚不完全可用。</li></ul></li></ul><h3 id="2-1-1-运算符赋值"><a href="#2-1-1-运算符赋值" class="headerlink" title="2.1.1 运算符赋值"></a>2.1.1 运算符赋值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo1 &#123;</span><br><span class="line">    uint256 public constant VERSION = 1+1;</span><br><span class="line"></span><br><span class="line">    // 100个ETH</span><br><span class="line">    // 100000000000000000000</span><br><span class="line">    uint256 public  constant VALUE = 100 * 10**18; // 运算符赋值</span><br><span class="line"></span><br><span class="line">    // 1小时</span><br><span class="line">    uint256 public  constant H = 60 * 60;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-密码学函数赋值"><a href="#2-1-2-密码学函数赋值" class="headerlink" title="2.1.2 密码学函数赋值"></a>2.1.2 密码学函数赋值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 public constant a = addmod(4, 5, 3);</span><br><span class="line">    uint256 public constant b = mulmod(4, 5, 3);</span><br><span class="line">    bytes32 public constant c1 = sha256(&quot;Hello&quot;);</span><br><span class="line">    bytes32 public constant c2 = ripemd160(&quot;Hello&quot;);</span><br><span class="line">    bytes32 public constant myBytes32 = keccak256(&quot;Hello&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-3-禁止的一些赋值"><a href="#2-1-3-禁止的一些赋值" class="headerlink" title="2.1.3  禁止的一些赋值"></a>2.1.3  禁止的一些赋值</h3><p>不允许使用状态变量&#x2F;区块链数据来赋值，也不允许外部合约调用来赋值。</p><p>任何通过访问 storage，区块链数据（例如 <code>block.timestamp</code>,<code>address(this).balance</code> 或者 <code>block.number</code>）或执行数据（ <code>msg.value</code> 或<code>gasleft()</code> ） 或对外部合约的调用来给它们赋值都是不允许的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    address public ads1 = msg.sender;</span><br><span class="line">    // address public constant ads2 = msg.sender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Immutable-不可变量"><a href="#Immutable-不可变量" class="headerlink" title="Immutable 不可变量"></a>Immutable 不可变量</h1><p>上一节我们学习了常量，常量的值是在编译器确定，因为在编译器确定，常量必须声明和初始化一起做掉，否则编译不通过。这就给很多只需要一次赋值，但是又必须需要动态赋值的场景带来了不变。比如合约的 owner 地址等场景。</p><p>然后上面的苦恼，可以通过不可变量来解决。如果我们想要一个变量，赋值后就不可以修改，而且值是部署时候动态赋值，那么可以使用不可变量的类型。通过 <code>immutable</code> 关键字可以声明为不可变量，不可变量的限制要比声明为常量(<code>constant</code>) 的变量的限制少：</p><p>不可变量<strong>可以声明和赋值一起做掉，也可以 storage 中声明</strong>，在合约的构造函数中赋值。无论在哪里赋值，只能赋值一次，也带来更多的安全性。</p><ul><li><p>原理: 在部署的时候确定变量的值，它是一个运行时赋值。</p></li><li><p>特点:它既有 constant 常量不可修改和 Gas 费用低的优势，又有变量动态赋值的优势。</p></li><li><p>原则:</p><ul><li><code>immutable</code> 可以声明和初始化一起做掉，也可以部署时在<code>constructor</code>中做掉。</li><li><code>immutable</code> 必须在<code>constructor</code>运行截止时就赋值</li><li><code>immutable</code>不能用在引用数据类型上</li></ul></li></ul><h2 id="3-1-部署后不可以修改"><a href="#3-1-部署后不可以修改" class="headerlink" title="3.1 部署后不可以修改"></a>3.1 部署后不可以修改</h2><p>注意点：不可变量只能赋值一次，以后就不能再次改变了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    address public immutable adsImmut;</span><br><span class="line">    address public immutable ads = address(0);</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        adsImmut = msg.sender;</span><br><span class="line"></span><br><span class="line">        // Immutable state variable already initialized.</span><br><span class="line">        // ads = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // immutable 部署后不可以修改，如果尝试修改immutable类型变量，会报错</span><br><span class="line">    // Cannot write to immutable here: Immutable variables can only</span><br><span class="line">    // be initialized inline or assigned directly in the constructor.</span><br><span class="line">    // function changeImmutable() external &#123;</span><br><span class="line">    //     adsImmut = msg.sender;</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-不可以在赋值前读取"><a href="#3-2-不可以在赋值前读取" class="headerlink" title="3.2 不可以在赋值前读取"></a>3.2 不可以在赋值前读取</h2><p>并且在赋值之后才可以读取 immutable 变量，如果赋值之前读取会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    address public immutable adsImmut;</span><br><span class="line">    address public ads;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        // Immutable variables cannot be read before they are initialized.</span><br><span class="line">        // ads = adsImmut;</span><br><span class="line"></span><br><span class="line">        adsImmut = msg.sender;</span><br><span class="line">        ads = adsImmut;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-不可以在-constructor-之外赋值其他不可变量"><a href="#3-3-不可以在-constructor-之外赋值其他不可变量" class="headerlink" title="3.3 不可以在 constructor 之外赋值其他不可变量"></a>3.3 不可以在 <code>constructor</code> 之外赋值其他不可变量</h2><p>不可变量可以在声明时赋值，不过只有在合约的构造函数执行时才被视为视为初始化。这意味着，你不能用一个依赖于不可变量的值初始化另一个不可变量。</p><p>因为不可变量在构造函数中才真正赋值，所以在合约的构造函数中这样做。这样的机制是为了防止对状态变量初始化和构造函数顺序的不同解释，特别是继承时，出现问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint256 public a1 = 1;</span><br><span class="line">    uint256 public a2 = a1;</span><br><span class="line"></span><br><span class="line">    uint256 public immutable b1 = 1;</span><br><span class="line">    // Immutable variables cannot be read before they are initialized.</span><br><span class="line">    // uint256 public b2 = b1;</span><br><span class="line">    uint256 public b2;</span><br><span class="line"></span><br><span class="line">    uint256 public immutable b3;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        b2 = b1;</span><br><span class="line">        b3 = b1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心：在部署的时候确定变量的值，它是一个运行时赋值。</p><h2 id="3-4constant-和-immutable-总结"><a href="#3-4constant-和-immutable-总结" class="headerlink" title="3.4constant 和 immutable 总结"></a>3.4constant 和 immutable 总结</h2><h4 id="值的确定时机不同"><a href="#值的确定时机不同" class="headerlink" title="值的确定时机不同"></a>值的确定时机不同</h4><p>状态变量声明为 constant (常量)或者 immutable （不可变量），在这两种情况下，合约一旦部署之后，变量将不在修改。</p><ul><li>对于 constant 常量, 他的值在编译器确定.</li><li>对于 immutable, 它的值在部署时确定。</li></ul><h4 id="gas-不同"><a href="#gas-不同" class="headerlink" title="gas 不同"></a>gas 不同</h4><p>与常规状态变量相比，常量和不可变量的 gas 成本要低得多。</p><ul><li>对于常量，赋值给它的表达式将复制到所有访问该常量的位置，并且每次都会对其进行重新求值。这样可以进行本地优化。</li><li>不可变变量在构造时进行一次求值，并将其值复制到代码中访问它们的所有位置。 对于这些值，将保留 32 个字节，即使它们适合较少的字节也是如此。很多时候常量的 gas 更低。</li></ul><p>如果可以使用常量的时候，推荐使用常量。</p><h4 id="支持的数据不同"><a href="#支持的数据不同" class="headerlink" title="支持的数据不同"></a>支持的数据不同</h4><p>不是所有类型的状态变量都支持用 <code>constant</code> 或 <code>immutable</code> 来修饰</p><ul><li>当前<code>constant</code>仅支持值类型和引用类型中的 string 和 bytes</li><li><code>immutable</code>仅支持值类型</li></ul><h1 id="变量名的命名规则"><a href="#变量名的命名规则" class="headerlink" title="变量名的命名规则"></a>变量名的命名规则</h1><p>在为变量命名时，请记住以下规则：</p><ul><li>禁止使用<strong>保留关键字</strong>作为变量名。</li><li>变量名首字母禁止使用数字，必须以字母或下划线开头。</li><li>变量名大小写敏感。</li></ul><h3 id="1-禁止使用保留关键字作为变量名"><a href="#1-禁止使用保留关键字作为变量名" class="headerlink" title="1.禁止使用保留关键字作为变量名"></a>1.禁止使用<strong>保留关键字</strong>作为变量名</h3><p>禁止使用<strong>保留关键字</strong>作为变量名。例如：<code>break</code> &#x2F; <code>boolean</code> &#x2F; <code>contract</code> 这些是无效的变量名。</p><ul><li>abstract</li><li>after</li><li>alias</li><li>apply</li><li>auto</li><li>case</li><li>catch</li><li>copyof</li><li>default</li><li>define</li><li>final</li><li>immutable</li><li>implements</li><li>in</li><li>inline</li><li>let</li><li>macro</li><li>match</li><li>mutable</li><li>null</li><li>of</li><li>override</li><li>partial</li><li>promise</li><li>reference</li><li>relocatable</li><li>sealed</li><li>sizeof</li><li>static</li><li>supports</li><li>switch</li><li>try</li><li>typedef</li><li>typeof</li><li>unchecked</li></ul><h3 id="2-变量名必须以字母或者下划线开头"><a href="#2-变量名必须以字母或者下划线开头" class="headerlink" title="2.变量名必须以字母或者下划线开头"></a>2.变量名必须以字母或者下划线开头</h3><p>禁止使用数字作为变量名的开始，例如：<code>123abc</code> 是一个无效的变量名，但是 <code>_123abc</code> 是一个有效的变量名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint8 public abc = 1;</span><br><span class="line">    uint8 public _123abc = 1;</span><br><span class="line"></span><br><span class="line">    // Expected identifier but got &#x27;ILLEGAL&#x27;</span><br><span class="line">    uint8 public 123abc = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-变量名大小写敏感"><a href="#3-变量名大小写敏感" class="headerlink" title="3.变量名大小写敏感"></a>3.变量名大小写敏感</h3><p>例如：Name 和 name 是两个不同的变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    string public name = &quot;Anbang&quot;;</span><br><span class="line">    string public constant Name = &quot;Anbang&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变量的可见性"><a href="#变量的可见性" class="headerlink" title="变量的可见性"></a>变量的可见性</h1><p>可见性仅存在于状态变量和函数中</p><ul><li>局部变量的可见性仅限于定义它们的函数，函数有四可见型，分别是 <code>private</code> &#x2F; <code>external</code> &#x2F; <code>internal</code> &#x2F; <code>public</code></li><li>状态变量可以有三种可见型，分别是 <code>private</code> &#x2F; <code>internal</code> &#x2F; <code>public</code></li></ul><p>我们这里重点介绍状态变量可见型。</p><p>internal 和 private 类型的变量不能被外部访问，而 public 变量能够被外部访问。</p><p>警告: 设置为 <code>private</code>或 <code>internal</code>，只能防止其他合约读取或修改信息，但它仍然可以在链外查看到。你不要想着通过设置可见型，让别人看不到你的代码。反编译可以得到大部分需要的逻辑。</p><h2 id="5-1-private"><a href="#5-1-private" class="headerlink" title="5.1 private"></a>5.1 private</h2><p><strong>private</strong>: 私有，仅在当前合约中可以访问</p><p>在继承的合约内不可访问，私有状态变量就像内部变量一样，但它们在派生合约中是不可见的。</p><h2 id="5-2-internal-默认"><a href="#5-2-internal-默认" class="headerlink" title="5.2 internal(默认)"></a>5.2 internal(默认)</h2><p><strong>internal</strong>: 内部可视(合约内部和被继承的子合约中都可视)</p><ul><li>状态变量如果不显示声明，<strong>默认是 internal 权限</strong></li><li>内部可见性状态变量只能在它们所定义的合约和派生合同中访问。 它们不能被外部访问。 这是状态变量的默认可见性。</li></ul><h2 id="5-3-external"><a href="#5-3-external" class="headerlink" title="5.3 external"></a>5.3 external</h2><p><strong>external</strong>: 外部可视(合约外部可视，在内部是不可见)</p><p><strong><code>external</code> 不能声明在状态变量上，只能标识在函数上</strong>,因为如果一个状态变量在合约自身如果没有办法读取的话，那就没有存在的必要了。</p><h2 id="5-4-public"><a href="#5-4-public" class="headerlink" title="5.4 public"></a>5.4 public</h2><p><strong>public</strong>: 公开可视(合约内部，被继承的，外部都可以调用)</p><h1 id="全局：时间单位"><a href="#全局：时间单位" class="headerlink" title="全局：时间单位"></a>全局：时间单位</h1><p>在做时间相关业务时候可以使用 分钟，小时，天，周的概念。</p><h2 id="6-1-基本用法"><a href="#6-1-基本用法" class="headerlink" title="6.1 基本用法"></a>6.1 基本用法</h2><p>秒是缺省时间单位,可以不写，在时间单位之间，数字后面带有 <code>seconds</code>、 <code>minutes</code>、 <code>hours</code>、 <code>days</code>、 <code>weeks</code> 可以进行换算，基本换算关系如下：</p><ul><li><code>1 == 1 seconds</code></li><li><code>1 minutes == 60 seconds</code></li><li><code>1 hours == 60 minutes</code></li><li><code>1 days == 24 hours</code></li><li><code>1 weeks == 7 days</code></li></ul><h2 id="6-2-两种时间逻辑"><a href="#6-2-两种时间逻辑" class="headerlink" title="6.2 两种时间逻辑"></a>6.2 两种时间逻辑</h2><p>注意：由于闰年造成的每年不都是 365 天、每天不都是 24 小时，所以<strong>如果你要使用这些单位计算日期和时间</strong>，请注意这个问题。因为是无法预测的，所以需要借助外部的预言机来对一个确定的日期代码库进行时间矫正。</p><p>时间在项目中有两种逻辑</p><ol><li>像之前众筹合约里介绍的那样，使用持续时间来代表时间。比如持续 2 两小时结束，常见于众筹&#x2F;拍卖合约</li><li>到某个时间点开始抢购活动，比如到 XX 年 XX 月 XX 日 XX 分 XX 秒，开启抢购，这种需要借助预言机才能正确完成</li></ol><p>请按照自己的业务需求选择合适的时间方式。</p><h1 id="全局：区块和交易属性"><a href="#全局：区块和交易属性" class="headerlink" title="全局：区块和交易属性"></a>全局：区块和交易属性</h1><p>分别是 <code>block</code> &#x2F; <code>msg</code> &#x2F; <code>tx</code> 三个全局变量，因为功能相似，我们把 <code>blockhash()</code> 和 <code>gasleft()</code> 这两个全局函数也一起介绍。</p><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><table><thead><tr><th>名称 (返回值)</th><th>返回</th></tr></thead><tbody><tr><td>block.basefee (uint256)</td><td>当前区块的基本费用（ <a href="https://eips.ethereum.org/EIPS/eip-3198">EIP-3198</a> 和 <a href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559</a>）</td></tr><tr><td>block.chainid (uint256)</td><td>当前链 id</td></tr><tr><td>block.difficulty (uint256)</td><td>当前区块的难度</td></tr><tr><td>block.gaslimit (uint256)</td><td>当前区块的 gaslimit</td></tr><tr><td>block.number (uint256)</td><td>当前区块的 number</td></tr><tr><td>block.timestamp (uint256)</td><td>当前区块的时间戳，为 unix 纪元以来的秒</td></tr><tr><td>block.coinbase (address payable)</td><td>当前区块矿工的地址</td></tr><tr><td>msg.sender (address)</td><td>消息发送者 (当前 caller)</td></tr><tr><td>msg.value (uint256)</td><td>当前消息的 wei 值</td></tr><tr><td>msg.data (bytes calldata)</td><td>完整的 calldata</td></tr><tr><td>msg.sig (bytes4)</td><td>calldata 的前四个字节 – (function identifier&#x2F;即函数标识符)</td></tr><tr><td>tx.gasprice (uint256)</td><td>交易的 gas 价格</td></tr><tr><td>tx.origin (address)</td><td>交易的发送方 （完整的调用链）</td></tr><tr><td>blockhash(uint256 blockNumber) returns (bytes32)</td><td>给定区块的哈希值 – 只适用于 256 最近区块, 不包含当前区块</td></tr><tr><td>gasleft() returns (uint256)</td><td>剩余 gas</td></tr><tr><td>blockhash() 获取给定区块的哈希值</td><td>给定区块的哈希值;在 0.5.0 版本中删除,现使用<code>blockhash()</code>获取</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-数据</title>
      <link href="/2022/06/15/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/02-%E6%95%B0%E6%8D%AE/"/>
      <url>/2022/06/15/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/02-%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="数据与变量"><a href="#数据与变量" class="headerlink" title="数据与变量"></a>数据与变量</h1><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>如果上面 <code>uint256 u = 123;</code> 改为 <code>uint256 u = &quot;Hello&quot;;</code>，将会收到错误 <code>Type literal_string &quot;Hello&quot; is not implicitly convertible to expected type uint256.</code>，因为这两种类型不能隐式转换的；</p><p>如果上面 <code>uint256 u = 123;</code> 改为 <code>uint256 u = uint8(123);</code>，就不会有问题，因为<code>uint8</code>类型可以隐式转换为<code>uint256</code>类型。后面介绍类型转换的时候会详细的介绍。</p><h1 id="两种类型的数据"><a href="#两种类型的数据" class="headerlink" title="两种类型的数据"></a>两种类型的数据</h1><p>Solidity 按照数据类型可以分为<strong>值类型</strong>和<strong>引用类型</strong>。</p><ul><li>值类型: 值类型传值时会将值拷贝一份，传递的是值本身，对其修改时并不会对原来值有影响。<ul><li>始终按值来传递，当被用作函数参数或者用在赋值语句中时，总会进行值拷贝。</li><li>值类型里有两个比较特殊的类型是函数和地址（包括合约），会分为单独的部分介绍。</li></ul></li><li>引用类型: 引用类型进行传递时，传递的是其指针，而引用类型进行传递时<strong>可以为值传递</strong>，<strong>也可以为引用传递</strong>。</li></ul><h1 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h1><ol><li>Boolean</li><li>Integer:uint&#x2F;int</li><li>定长字节数组(固定大小字节数组):bytes1-bytes32</li><li>Enum:枚举</li><li>地址（Address）</li><li>合约类型</li><li>函数（Function Types）</li></ol><h2 id="3-1-Boolean-布尔类型"><a href="#3-1-Boolean-布尔类型" class="headerlink" title="3.1 Boolean 布尔类型"></a>3.1 Boolean 布尔类型</h2><p>布尔型使用 <code>bool</code>表示，该类型只有两个值，分别是 <code>true</code>&#x2F;<code>false</code>。</p><p>布尔值除了赋值得到外，还可以通过<strong>运算符</strong>的计算结果得到。</p><p>支持的运算符:<code>!</code>逻辑非，<code>==</code>等于，<code>!=</code> 不等于,<code>&amp;&amp;</code>逻辑与 ,<code>||</code>逻辑或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo2 &#123;</span><br><span class="line">    bool public a = false;</span><br><span class="line">    bool public b = !a; // 仅用于布尔值</span><br><span class="line">    bool public c = a == b;</span><br><span class="line">    bool public d = a != b;</span><br><span class="line">    bool public e = a &amp;&amp; b;</span><br><span class="line">    bool public f = a || b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运算符 <code>||</code> 和 <code>&amp;&amp;</code> 都遵循同样的短路（ short-circuiting ）规则。就是说在表达式 <code>f(x) || g(y)</code> 中， 如果 <code>f(x)</code> 的值为 true ，那么 <code>g(y)</code> 就不会被执行，</p><h3 id="3-1-1-使用短路规则节省-gas"><a href="#3-1-1-使用短路规则节省-gas" class="headerlink" title="3.1.1 使用短路规则节省 gas"></a>3.1.1 使用短路规则节省 gas</h3><p>借助短路规则，可以让合约少执行一些逻辑。</p><ul><li><code>||</code> 如果第一个表达式是<code>true</code>，则第二个表达式不再执行。（因为两个表达式有一个为 true，结果就为 true，不需要计算第二个表达式就知道结果了）</li><li><code>&amp;&amp;</code> 如果第一个表达式是<code>false</code>，则第二个表达式不再执行。（两个表达式必须都为 true，结果才能 true，如果第一个为 false，不需要计算第二个表达式就知道结果了）</li></ul><h2 id="3-2-Integer-整数类型"><a href="#3-2-Integer-整数类型" class="headerlink" title="3.2 Integer 整数类型"></a>3.2 Integer 整数类型</h2><p>整数类型分为有符号整型，用 int 标示；和无符号整型，用 uint 标示；</p><ul><li>int 是有符号整型，支持 int8 到 int256。</li><li>uint 是无符号整型，支持从 uint8 到 uint256。</li><li><code>uint</code> 和 <code>int</code> 分别是 <code>uint256</code> 和 <code>int256</code> 的别名。</li></ul><h3 id="3-2-1-属性"><a href="#3-2-1-属性" class="headerlink" title="3.2.1 属性"></a>3.2.1 属性</h3><p>对于整型 T 有下面的全局属性可访问：</p><blockquote><p>获取整型 T 的最小值:type(T).min<br>获取整型 T 的最大值:type(T).max</p></blockquote><h3 id="3-2-2-uint-类型"><a href="#3-2-2-uint-类型" class="headerlink" title="3.2.2 uint 类型"></a>3.2.2 uint 类型</h3><p>uint 无符号整数，只能表示非负数；<code>包括数字0</code>；其中 uint256 与 uint 相同，推荐使用 uint256；支持 int8 到 int256，后面的数字是 8 的倍数。</p><ul><li><code>uint8</code>: 最小值是 0，最大值是 <code>2**8-1</code></li><li><code>uint256</code>:最小值是 0，最大值是 <code>2**256-1</code></li><li>可以使用 <code>type(uint8).max</code> 获取该类型的最大值</li><li>可以使用 <code>type(uint8).min</code> 获取该类型的最小值</li></ul><h3 id="3-2-3-int-类型"><a href="#3-2-3-int-类型" class="headerlink" title="3.2.3 int 类型"></a>3.2.3 int 类型</h3><p>int 是有符号整数，其中 int256 与 int 相同，推荐使用 int256； 8 位到 256 位的带符号整型数。8 的倍数。</p><ul><li><code>int8</code>: 最小值是 <code>-128</code>，最大值是 <code>127</code></li><li><code>int256</code>: 最小值是 <code>-(2**256/2)</code>，最大值是 <code>(2**256/2)-1</code></li><li>可以使用 <code>type(int8).max</code> 获取该类型的最大值</li><li>可以使用 <code>type(int8).min</code> 获取该类型的最小值。</li></ul><p>计算中最小一级的信息单位是 byte 和 bit: <strong>其中字节(Byte)为最小存储容量单位</strong>，<strong>位(bit)是最小储存信息的单位,也被称为最小的数据传输单位</strong>；一个位就代表一个 0 或 1（即二进制）；每 8 个 bit(简写为 b）组成一个字节 Byte（简写为 B）；所以 <code>uint256</code> 和 <code>bytes32</code> 可以转换</p><ul><li><code>bytes1 对应 uint8</code></li><li><code>bytes2 对应 uint16</code></li><li>…</li><li><code>bytes32 对应 uint256</code></li></ul><h3 id="3-2-4-checked-模式"><a href="#3-2-4-checked-模式" class="headerlink" title="3.2.4 checked 模式"></a>3.2.4 checked 模式</h3><p>⚠️: 在 Solidity 之前的版本中，当对无限制整数执行算术运算，其结果超出结果类型的范围，这是就发生了上溢出或下溢出。在 Solidity 0.8.0 之前，算术运算总是会在发生溢出的情况下进行“截断”，而不是抛出异常。这就会导致一些麻烦的事情，可能导致未知的错误，所以我们不得不靠引入额外检查库来解决这个问题（最常见的如 OpenZepplin 的 SafeMath）</p><p>而从 <code>Solidity 0.8.0</code> 开始，所有的算术运算默认就会进行溢出检查，额外引入库将不再必要。0.8.0 开始，算术运算有两种计算模式：一种是<code>checked</code>（检查）模式，另一种是 <code>unchecked</code>（不检查）模式。</p><p>默认情况下，算术运算在 <code>checked</code> 模式下，即都会进行溢出检查，如果结果落在取值范围之外，调用会通过 失败异常 回退。</p><h3 id="3-2-5-unchecked-非检查模式"><a href="#3-2-5-unchecked-非检查模式" class="headerlink" title="3.2.5 unchecked 非检查模式"></a>3.2.5 unchecked 非检查模式</h3><p>如果依然想要之前“截断”的效果，而不是抛出异常错误，那么可以使用 <code>unchecked&#123;&#125;</code> 代码块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 public a = type(uint256).max;</span><br><span class="line">    uint8 public b = 1;</span><br><span class="line"></span><br><span class="line">    function f1() public view returns (uint256) &#123;</span><br><span class="line">        // 减法溢出会返回“截断”的结果</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f2() public view returns (uint256) &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return a + 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g() public view returns (uint256) &#123;</span><br><span class="line">        // 溢出会抛出异常</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>g()</code> 会触发失败异常， 调用 <code>f1()/f2()</code> 分别是截断效果,</p><p>⚠️: <code>unchecked</code> 代码块可以在代码块中的任何位置使用，但不可以替代整个函数代码块，同样不可以嵌套。切此设置仅影响语法上位于 <code>unchecked</code> 块内的语句。 在块中调用的函数不会此影响。</p><p>⚠️: 为避免歧义，不能在 unchecked 块中使用 <code>_;</code>, 该表示方法仅用于函数修改器。</p><blockquote><p> 触发溢出检查的运算符:++<code>, </code>–<code>, </code>+<code>, </code>减 -<code>, </code>负 -<code>, </code><em><code>, </code>&#x2F;<code>, </code>%<code>, </code>**, +&#x3D;<code>,</code>-&#x3D;<code>, </code></em>&#x3D;<code>, </code>&#x2F;&#x3D;<code>, </code>%&#x3D;</p></blockquote><blockquote><p> 除 <code>0</code>（或<code>除 0取模</code>）的异常是不能被 <code>unchecked</code> 忽略的。会发生 <code>Panic</code> 错误。</p></blockquote><blockquote><p> 位运算不会执行上溢或下溢检查</p></blockquote><blockquote><p> -int 值需要注意:因为负数的范围比正整数的范围大 1。</p></blockquote><h2 id="3-3-Integer-整数字面常量"><a href="#3-3-Integer-整数字面常量" class="headerlink" title="3.3 Integer 整数字面常量"></a>3.3 Integer 整数字面常量</h2><h3 id="3-3-1-常量中用-增加可读性"><a href="#3-3-1-常量中用-增加可读性" class="headerlink" title="3.3.1 常量中用_增加可读性"></a>3.3.1 常量中用<code>_</code>增加可读性</h3><p>为了提高可读性可以在数字之间加上下划线。 例如，十进制 <code>123_000</code>，十六进制 <code>0x2eff_abde</code>，科学十进制表示 <code>1_2e12</code> 都是有效的。</p><p>需要注意以下几点：</p><ul><li>下划线仅允许在两位数之间，并且不允许下划线连续出现。</li><li>添加到数字文字中下划线没有额外的语义，仅仅只是为了可读性.</li><li>下划线会被编译器忽略。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo&#123;</span><br><span class="line">    uint public count1 = 123_456_789; // 23503 gas</span><br><span class="line">    uint public count2 = 123_456_789; // 23493 gas</span><br><span class="line">    uint public count3 = 123456789; // 23537 gas</span><br><span class="line">    int public count4 = -123456789; // 23559 gas</span><br><span class="line">    int public count5 = -123_456_789; // 23471 gas</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过测试发现，带有<code>_</code>数字的变量，读取时候花费 gas 更少</p><h3 id="3-3-2-字面常量支持任意精度"><a href="#3-3-2-字面常量支持任意精度" class="headerlink" title="3.3.2 字面常量支持任意精度"></a>3.3.2 字面常量支持任意精度</h3><p>数值字面常量表达式本身支持任意精度，直到被转换成了非常量类型（例如，在常量变量表达式之外有运算，或发生了显示转换）。 这意味着在数值常量表达式中, 计算不会溢出而除法也不会截断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint8 public a = (2**800 + 1) - 2**800;</span><br><span class="line">    uint8 public b = 0.5 * 8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>(2**800 + 1) - 2**800</code> 的结果是字面常量 1 （属于 uint8 类型），尽管计算的中间结果已经超过了 以太坊虚拟机的机器字长度。 此外， <code>0.5 * 8</code> 的结果是整型 <code>4</code> （尽管有非整型参与了计算）。</p><p>⚠️: 数 值字面常量表达式只要在非字面常量表达式中使用就会转换成非字面常量类型。 在下面的例子中，尽管我们知道 b 的值是一个整数，但 <code>2.5 + a</code> 这部分表达式并不进行类型检查，因此编译不能通过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint128 a = 1;</span><br><span class="line">uint128 b = 2.5 + a + 0.5;</span><br></pre></td></tr></table></figure><h3 id="3-3-3-除法截断"><a href="#3-3-3-除法截断" class="headerlink" title="3.3.3 除法截断"></a>3.3.3 除法截断</h3><p>注意除法截断: 在智能合约中，在 字面常量 会保留精度（保留小数位）。</p><p>整数的除法会被截断（例如：<code>1/4</code> 结果为 0）,但是使用字面量的方式不会被截断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract IntegerTest &#123;</span><br><span class="line">    function test1() public pure returns (uint256, uint256) &#123;</span><br><span class="line">        uint256 a = 1;</span><br><span class="line">        uint256 b = 4;</span><br><span class="line">        uint256 c1 = (1 / 4) * 4; // 1 =&gt; 未截断</span><br><span class="line">        uint256 c2 = (a / b) * b; // 0 =&gt; 截断</span><br><span class="line">        return (c1, c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释: 表达式 <code>type(int).min / (-1)</code> 是仅有的整除会发生向上溢出的情况。 在算术检查模式下，这会触发一个失败异常，在截断模式下，表达式的值将是 <code>type(int).min</code> 。</p><h3 id="3-3-4-优先使用较小类型计算"><a href="#3-3-4-优先使用较小类型计算" class="headerlink" title="3.3.4 优先使用较小类型计算"></a>3.3.4 优先使用较小类型计算</h3><p>虽然大多数运算符在字面常量运算时都会产生一个字面常量表达式，但有一些运算符并不遵循这种模式：</p><ul><li>三元运算符 <code>(... ? ... : ...)</code>,</li><li>数组下标访问 (<code>&lt;array&gt;[&lt;index&gt;]</code>).</li></ul><p>你可能认为像<code>255 + (true ? 1 : 0)</code> 或 <code>255 + [1, 2, 3][0]</code> 这样的表达式等同于直接使用 256 字面常量。 但事实上，它们是在 <code>uint8</code> 类型中计算的，会溢出。</p><h2 id="3-4-Fixed-定长浮点型"><a href="#3-4-Fixed-定长浮点型" class="headerlink" title="3.4 Fixed 定长浮点型"></a>3.4 Fixed 定长浮点型</h2><p>Solidity 还没有完全支持定长浮点型，可以声明定长浮点型的变量，但不能给它们赋值或把它们赋值给其他变量。。</p><p>可以通过用户定义的值类型的 wrap &#x2F; unwrap 来模拟出来，后面介绍用户自定义类型时候会介绍。</p><p><code>fixed / ufixed</code>：表示各种大小的有符号和无符号的定长浮点型。 在关键字 <code>ufixedMxN</code> 和 <code>fixedMxN</code> 中，<code>M</code> 表示该类型占用的位数，<code>N</code> 表示可用的小数位数。 <code>M</code> 必须能整除 8，即 8 到 256 位。 <code>N</code> 则可以是从 0 到 80 之间的任意数。</p><h2 id="3-5-BytesN-定长字节数组"><a href="#3-5-BytesN-定长字节数组" class="headerlink" title="3.5 BytesN 定长字节数组"></a>3.5 BytesN 定长字节数组</h2><p>定义方式 <code>bytesN</code>，其中 N 可取 <code>1~32</code> 中的任意整数;</p><p>bytes1 代表只能存储一个字节。</p><p>⚠ 注意：一旦声明，其内部的字节长度不可修改，内部字节不可修改。</p><p><code>bytesN</code>: 是定长的字节数组，是值类型</p><p><code>bytes</code>: 是变长字节数组，是引用类型。</p><h3 id="3-5-1-属性"><a href="#3-5-1-属性" class="headerlink" title="3.5.1 属性"></a>3.5.1 属性</h3><ul><li><pre><code class="solidity">length<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  （只读）返回字节个数，可以通过索引读取对应索引的字节。</span><br><span class="line"></span><br><span class="line">- 索引访问:</span><br><span class="line"></span><br><span class="line">  ```solidity</span><br><span class="line">  bytesN[index]</span><br></pre></td></tr></table></figure>- index 取值范围`[0, N]`，其中 N 表示长度。</code></pre></li><li><p>如果 <code>x</code> 是 <code>bytesI</code> 类型，那么 <code>x[k]</code> （其中 0 &lt;&#x3D; k &lt; I）返回第 k 个字节（只读）。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    // 固定长度的字节数组</span><br><span class="line">    bytes1 public a1 = 0x61;</span><br><span class="line">    bytes2 public a2 = 0x6100;</span><br><span class="line"></span><br><span class="line">    // length</span><br><span class="line">    uint256 public n1 = a1.length;</span><br><span class="line">    uint256 public n2 = a2.length;</span><br><span class="line"></span><br><span class="line">    // 索引</span><br><span class="line">    function getIndex(uint8 index_) public view returns(bytes1)&#123;</span><br><span class="line">        return a2[index_];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 不修可以修改,编译会报错</span><br><span class="line">    //function setIndex(uint8 index_,bytes1 value_) public view&#123;</span><br><span class="line">    //     a2[index_] = value_;</span><br><span class="line">    //&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-字符串字面常量及类型"><a href="#3-6-字符串字面常量及类型" class="headerlink" title="3.6 字符串字面常量及类型"></a>3.6 字符串字面常量及类型</h2><p>字符串字面常量只能包含可打印的 ASCII 字符，这意味着他是介于 0x20 和 0x7E 之间的字符。</p><p>字符串字面常量是指由双引号或单引号引起来的字符串（ <code>&quot;foo&quot;</code> 或者 <code>&#39;bar&#39;</code>）;</p><h3 id="3-6-1-字符串字面量"><a href="#3-6-1-字符串字面量" class="headerlink" title="3.6.1 字符串字面量"></a>3.6.1 字符串字面量</h3><p>转换: 和整数字面常量一样，字符串字面常量的类型也可以发生改变，它们可以隐式地转换成<code>bytes1</code>，……， <code>bytes32</code>，如果合适的话，还可以转换成 <code>bytes</code> 以及 <code>string</code>。</p><p>比如 <code>bytes1 public a8 = &quot;a&quot;;</code> 和 <code>bytes2 public b2 = &quot;a&quot;;</code>。字符串字面常量在赋值给 <code>bytesN</code> 时被解释为<strong>原始的字节形式</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    bytes1 public b1 = &quot;a&quot;;</span><br><span class="line">    string public b2 = &quot;a&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-2-转义字符"><a href="#3-6-2-转义字符" class="headerlink" title="3.6.2 转义字符"></a>3.6.2 转义字符</h3><p>但是我们写特殊字符串时候遇到一个问题，比如我想输出一个 <code>fo&quot;o</code>和<code>fo&#39;o</code> 的字符串就很难弄，因为莫认为<code>&quot;</code>和<code>&#39;</code> 是字符串的结尾。如果想要输出这种特殊的字符串，就需要转义字符了。</p><p>此外，字符串字面常量支持下面的转义字符：</p><ul><li><code>\&#39;</code> (单引号)</li><li><code>\&quot;</code> (双引号)</li><li><code>\\</code> (反斜杠)</li><li><code>\&lt;newline&gt;</code> (转义实际换行)</li><li><code>\b</code> (退格)</li><li><code>\f</code> (换页)</li><li><code>\n</code> (换行符)</li><li><code>\r</code> (回车)</li><li><code>\t</code> (标签 tab)</li><li><code>\v</code> (垂直标签)</li><li><code>\xNN</code> (十六进制转义，见下文)</li><li><code>\uNNNN</code> (unicode 转义，见下文)</li></ul><p><code>\xNN</code> 表示一个 16 进制值，最终转换成合适的字节，而 <code>\uNNNN</code> 表示 Unicode 编码值，最终会转换为 UTF-8 的序列。</p><p>问答题:下面字符串长度为多少字节？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    string public a1 = &quot;\n\&quot;&#x27;\\abc\def&quot;;</span><br><span class="line">    bytes32 public a2 = &quot;\n\&quot;&#x27;\\abc\def&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串长度为十个字节，它以换行符开头，后跟双引号，单引号，反斜杠字符，以及（没有分隔符）字符序列 <code>&quot;&#39;\abcdef</code> 。</p><h3 id="3-6-3-用空格分开的字符串"><a href="#3-6-3-用空格分开的字符串" class="headerlink" title="3.6.3 用空格分开的字符串"></a>3.6.3 用空格分开的字符串</h3><p>用空格分开的 <code>&quot;foo&quot; &quot;bar&quot;</code> 等效于 <code>&quot;foobar&quot;</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    string public a = &quot;a&quot; &quot;b&quot;;//ab</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-7-Unicode-字面常量"><a href="#3-7-Unicode-字面常量" class="headerlink" title="3.7 Unicode 字面常量"></a>3.7 Unicode 字面常量</h2><p>常规字符串文字只能包含 ASCII，而 Unicode 文字（以关键字 unicode 为前缀）可以包含任何有效的 UTF-8 序列。 它们还支持与转义序列完全相同的字符作为常规字符串文字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    string  public a = unicode&quot;同志们好&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-8-十六进制字面常量"><a href="#3-8-十六进制字面常量" class="headerlink" title="3.8 十六进制字面常量"></a>3.8 十六进制字面常量</h2><p>十六进制字面常量以关键字 <code>hex</code> 打头，后面紧跟着用单引号或双引号引起来的字符串（例如，<code>hex&quot;001122FF&quot;</code> ）。 字符串的内容必须是一个十六进制的字符串，它们的值将使用二进制表示。</p><h3 id="3-8-1-基本用法"><a href="#3-8-1-基本用法" class="headerlink" title="3.8.1 基本用法"></a>3.8.1 基本用法</h3><p>它们的内容必须是十六进制数字，可以选择使用单个下划线作为字节边界分隔符。 <strong>字面常量的值将是十六进制序列的二进制表示形式</strong>。</p><p>用空格分隔的多个十六进制字面常量被合并为一个字面常量： <code>hex&quot;61&quot; hex&quot;61&quot;</code> 等同于 <code>hex&quot;6161&quot;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    bytes1 public a3 = 0x61;</span><br><span class="line">    bytes1 public a4 = hex&quot;61&quot;;</span><br><span class="line">    bytes2 public a = hex&quot;61&quot; hex&quot;61&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-9-Enum-枚举"><a href="#3-9-Enum-枚举" class="headerlink" title="3.9 Enum:枚举"></a>3.9 Enum:枚举</h2><p><code>enum</code> 是一种用户自定义类型，用于表示多种状态，枚举可用来创建由一定数量的“常量值”构成的自定义类型。主要作用是用于限制某个事务的有限选择。比如将咖啡的容量大小限制为：大、中、小，这将确保任何人不能购买其他容量的咖啡，只能在这里选择。</p><p>枚举默认值是第一个成员，所以<strong>枚举类型至少需要一个成员，枚举不能多于 256 个成员</strong>。枚举默认的类型为 <code>uint8</code>，当枚举数足够多时，它会自动变成 <code>uint16</code>..等变大。可以通过 remix 部署后，函数的输入值内查看类型 <code>uint8</code> &#x2F; <code>uint16</code></p><ul><li>枚举类型，返回值是索引，默认值是 0;</li><li>枚举类型的默认值是第一个值。<ul><li>枚举类型 enum 至少应该有一名成员。</li></ul></li><li>设置的时候，可以设置为索引，也可以对应的枚举名称;</li><li>枚举类型 enum 可以与整数进行显式转换，但不能进行隐式转换。<ul><li>显示转换会在运行时检查数值范围，如果不匹配，将会引起异常。</li></ul></li></ul><p><strong>例子</strong>:考虑一个限制，将交易的状态限制为：<code>None</code>&#x2F;<code>Pending</code>&#x2F;<code>Shiped</code>&#x2F;<code>Completed</code>&#x2F;<code>Rejected</code>&#x2F;<code>Canceled</code> 这几种。这将确保交易状态仅在列出的状态内。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Enum &#123;</span><br><span class="line">    // 枚举类型的默认值是第一个值。</span><br><span class="line">    // 结构</span><br><span class="line">    enum Status &#123;</span><br><span class="line">        None, // 0</span><br><span class="line">        Pending, // 1</span><br><span class="line">        Shiped,// 2</span><br><span class="line">        Completed,</span><br><span class="line">        Rejected,</span><br><span class="line">        Canceled</span><br><span class="line">    &#125;</span><br><span class="line">    // 变量</span><br><span class="line">    Status public status;</span><br><span class="line"></span><br><span class="line">    // 设置索引值</span><br><span class="line">    function set(Status _status) external &#123;</span><br><span class="line">        status = _status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 由于枚举类型不属于 |ABI| 的一部分，因此对于所有来自 Solidity 外部的调用，</span><br><span class="line">    // &quot;getStatus&quot; 的签名会自动被改成 &quot;getStatus() returns (uint8)&quot;。</span><br><span class="line">    function getStatus() public view returns (Status) &#123;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getDefaultStatus() public view returns (uint256) &#123;</span><br><span class="line">        return uint256(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置</span><br><span class="line">    function ship() external &#123;</span><br><span class="line">        status = Status.Shiped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 恢复为0</span><br><span class="line">    function reset() external &#123;</span><br><span class="line">        delete status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多人感觉 enum 很少用，一是因为应用场景确实比较窄，二是因为可以被其他数据类型所代替；但按照编码规范，限制选择范围场景，除了 bool 以外的，推荐使用 enum 类型来定义。</p><p>枚举是显示所有整型相互转换，但不允许隐式转换。从整型显式转换枚举，会在运行时检查整数时候在枚举范围内，否则会导致异常（ Panic 异常 ）。</p><p>枚举还可以在合约或库定义之外的文件级别上声明。</p><h3 id="3-9-1-方法"><a href="#3-9-1-方法" class="headerlink" title="3.9.1 方法"></a>3.9.1 方法</h3><ul><li><code>type(NameOfEnum).min</code></li><li><code>type(NameOfEnum).max</code></li></ul><p>使用 <code>type(NameOfEnum).min</code> 和 <code>type(NameOfEnum).max</code> 你可以得到给定枚举的最小值和最大值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Enum &#123;</span><br><span class="line">    // 枚举类型的默认值是第一个值。</span><br><span class="line">    enum Status &#123;</span><br><span class="line">        None,//0</span><br><span class="line">        Pending,//1</span><br><span class="line">        Shiped,//2</span><br><span class="line">        Completed,//3</span><br><span class="line">        Rejected,//4</span><br><span class="line">        Canceled// 5</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getLargestValue() public pure returns (Status) &#123;</span><br><span class="line">        return type(Status).max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getSmallestValue() public pure returns (Status) &#123;</span><br><span class="line">        return type(Status).min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-10-用户定义的值类型"><a href="#3-10-用户定义的值类型" class="headerlink" title="3.10 用户定义的值类型"></a>3.10 用户定义的值类型</h2><p>Solidity 允许在一个基本的值类型上创建一个零成本的抽象。这类似于一个别名，但有更严格的类型要求。</p><p>用户定义值类型使用 <code>type UserType is DefaultType</code> 来定义。</p><p>其中 <code>UserType</code> 是新引入的类型的名称， <code>DefaultType</code> 必须是内置的<strong>值类型</strong>（”底层类型”）。自定义类型的值的数据表示则继承自底层类型，并且 <strong>ABI 中也使用底层类型。</strong></p><p>⚠️: 用户定义的类型 <code>UserType</code> 没有任何运算符或绑定成员函数。即使是操作符 <code>==</code> 也没有定义。也不允许与其他类型进行显式和隐式转换。</p><h3 id="3-10-1-方法"><a href="#3-10-1-方法" class="headerlink" title="3.10.1  方法"></a>3.10.1  方法</h3><ul><li><code>UserType.wrap()</code>: 用来从底层类型转换到自定义类型</li><li><code>UserType.unwrap()</code>: 从自定义类型转换到底层类型。</li></ul><p>案例：一个 18 位小数、256 bit 的浮点类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 使用用户定义的值类型表示 18 位小数、256 bit的浮点类型。</span><br><span class="line">type UFixed256x18 is uint256;</span><br><span class="line"></span><br><span class="line">/// 在 UFixed256x18 上进行浮点操作的精简库。</span><br><span class="line">library FixedMath &#123;</span><br><span class="line">    uint constant multiplier = 10**18;</span><br><span class="line"></span><br><span class="line">    /// 两个 UFixed256x18 数相加，</span><br><span class="line">    /// 溢出时恢复，依赖于 uint256 上的检查算术</span><br><span class="line">     function add(UFixed256x18 a, UFixed256x18 b) internal pure returns (UFixed256x18) &#123;</span><br><span class="line">        return UFixed256x18.wrap(UFixed256x18.unwrap(a) + UFixed256x18.unwrap(b));</span><br><span class="line">    &#125;</span><br><span class="line">    /// 将 UFixed256x18 和 uint256 相乘.</span><br><span class="line">    /// 溢出时恢复，依赖于 uint256 上的检查算术</span><br><span class="line">     function mul(UFixed256x18 a, uint256 b) internal pure returns (UFixed256x18) &#123;</span><br><span class="line">        return UFixed256x18.wrap(UFixed256x18.unwrap(a) * b);</span><br><span class="line">    &#125;</span><br><span class="line">    ///  UFixed256x18 向下取整.</span><br><span class="line">    /// @return 不超过 `a` 的最大整数。</span><br><span class="line">    function floor(UFixed256x18 a) internal pure returns (uint256) &#123;</span><br><span class="line">        return UFixed256x18.unwrap(a) / multiplier;</span><br><span class="line">    &#125;</span><br><span class="line">    /// 将 uint256 转换为相同值的 UFixed256x18。</span><br><span class="line">    /// 如果整数太大，则还原。</span><br><span class="line">    function toUFixed256x18(uint256 a) internal pure returns (UFixed256x18) &#123;</span><br><span class="line">        return UFixed256x18.wrap(a * multiplier);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    uint256 a = 1;</span><br><span class="line">    uint256 b = 2;</span><br><span class="line"></span><br><span class="line">    function testAdd() external view returns (UFixed256x18) &#123;</span><br><span class="line">        return FixedMath.add(FixedMath.toUFixed256x18(a), FixedMath.toUFixed256x18(b));</span><br><span class="line">    &#125;</span><br><span class="line">    function testMul() external view returns (UFixed256x18) &#123;</span><br><span class="line">        return FixedMath.mul(FixedMath.toUFixed256x18(a),b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>UFixed256x18.wrap</code> 和 <code>FixedMath.toUFixed256x18</code> 的签名相同，但执行的是两个完全不同的操作：</p><ul><li><code>UFixed256x18.wrap</code> 函数返回一个与输入的数据表示相同的自定义值类型（<code>UFixed256x18</code>）。</li><li><code>FixedMath.toUFixed256x18</code>则返回一个具有相同数值的 <code>UFixed256x18</code> 。</li></ul><h1 id="值类型-地址类型"><a href="#值类型-地址类型" class="headerlink" title="值类型:地址类型"></a>值类型:地址类型</h1><p>地址分为外部地址和合约地址，每个地址都有<strong>一块持久化内存区</strong>称为存储。</p><p>地址类型也是值类型，因为比较特殊，所以单独拿出来讲。地址类型是 Solidity 语言独有的数据类型，表示以太坊的地址类型。用 address 表示地址，长度是 20 个字节</p><h2 id="4-1-地址字面常量"><a href="#4-1-地址字面常量" class="headerlink" title="4.1 地址字面常量"></a>4.1 地址字面常量</h2><p>通常的地址类型是 <code>0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac</code> 。 而没有通过校验测试, 长度在 39 到 41 个数字之间的十六进制字面常量，会产生一个错误, 比如 <code>0XFFD0D80C48F6C3C5387B7CFA7AA03970BDB926AC</code> 就是一个错误 address 类型，会提示正确的地址</p><h2 id="4-2-address-uint160-bytes32-之间的转换"><a href="#4-2-address-uint160-bytes32-之间的转换" class="headerlink" title="4.2 address&#x2F;uint160&#x2F;bytes32 之间的转换"></a>4.2 address&#x2F;uint160&#x2F;bytes32 之间的转换</h2><ul><li><p>1 字节 8 位，一个 address 是 20 个字节，是 160 位，所以 <strong>address 可以用 uint160 表示</strong>。</p></li><li><p>1 字节可以表示为两个连续的十六进制数字，所以 <strong>address 可以用连续的 40 个十六进制数字表示</strong>。</p></li><li><p>address 不允许任何算数操作</p><p>如果将使用较大字节数组类型转换为 <code>address</code> ，例如 <code>bytes32</code> ，那么 <code>address</code> 将被截断。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    bytes32 public a =</span><br><span class="line">        0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC;</span><br><span class="line"></span><br><span class="line">    // 0x111122223333444455556666777788889999aAaa</span><br><span class="line">    address public b = address(uint160(bytes20(a)));</span><br><span class="line"></span><br><span class="line">    // 0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc</span><br><span class="line">    address public c = address(uint160(uint256(a)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️：为了减少转换歧义，我们在转换中显式截断处理。 以 32bytes 值 <code>0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC</code> 为例， 如果使用 <code>address(uint160(bytes20(b)))</code> 结果是 <code>0x111122223333444455556666777788889999aAaa</code>， 而使用 <code>address(uint160(uint256(b)))</code> 结果是 <code>0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc</code> 。</p><h2 id="4-3-两种形式的地址"><a href="#4-3-两种形式的地址" class="headerlink" title="4.3 两种形式的地址"></a>4.3 两种形式的地址</h2><ul><li><code>address</code>：保存一个 20 字节的值（以太坊地址的大小）。</li><li><code>address payable</code> ：可支付地址，与 <code>address</code> 相同，不过有成员函数 <code>transfer</code> 和 <code>send</code> 。</li></ul><p>如果你需要 <code>address</code> 类型的变量，并计划发送以太币给这个地址，那么声明类型为 <code>address payable</code> 可以明确表达出你的需求。 同样，尽量更早对他们进行区分或转换。</p><p>这种区别背后的思想是 <code>address payable</code> 可以向其发送以太币，而不能向一个普通的 <code>address</code> 发送以太币。比如，它可能是一个智能合约地址，并且不支持接收以太币。</p><h3 id="两种形式的地址转换"><a href="#两种形式的地址转换" class="headerlink" title="两种形式的地址转换"></a>两种形式的地址转换</h3><p>允许从 <code>address payable</code> 到 <code>address</code> 的隐式转换，而从 <code>address</code> 到 <code>address payable</code> 必须显示的 通过 <code>payable(&lt;address&gt;)</code> 进行转换。也只能通过 <code>payable(...)</code> 表达式把 <code>address</code> 类型和合约类型转换为 <code>address payable</code>。</p><p>在介绍地址 payable 方法时候会具体介绍，转换的时候注意下面两个点：</p><ol><li>只有能接收以太币的合约类型，才能够进行此转换，合约要么有 receive 或可支付的回退函数。</li><li><code>payable(0)</code> 是有效的，这是此规则的例外。</li></ol><h2 id="4-4-地址属性"><a href="#4-4-地址属性" class="headerlink" title="4.4 地址属性"></a>4.4 地址属性</h2><p>address 拥有如下属性；</p><ol><li><p>.balance : 以 Wei 为单位的余额。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.balance    returns(uint256)</span><br></pre></td></tr></table></figure></li><li><p>.code : 地址上的代码(可以为空)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.code        returns(bytes memory)</span><br></pre></td></tr></table></figure></li><li><p>.codehash : 地址的 codehash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.codehash    returns(bytes32)</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-4-1-balance-属性"><a href="#4-4-1-balance-属性" class="headerlink" title="4.4.1 balance 属性"></a>4.4.1 balance 属性</h3><p>获取地址的余额，wei 单位。如下例子是获取指定地址的 ETH 余额，和当前调用者的余额。（基于当前使用的网络）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function getBalance1(address addr) public view returns (uint256) &#123;</span><br><span class="line">        return addr.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    function getBalance2() external view returns (uint256) &#123;</span><br><span class="line">        return address(msg.sender).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 <code>address(this).balance</code> 查询当前合约的余额，获取合约本身的 ETH 余额如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function getBalance() external view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️: 在版本 0.5.0 之前，Solidity 允许通过合约实例来访问地址的成员，例如 <code>this.balance</code> ，不过现在禁止这样做，必须显式转换为地址后访问，如： <code>address(this).balance</code> 。</p><h3 id="4-4-2-code-属性"><a href="#4-4-2-code-属性" class="headerlink" title="4.4.2 code 属性"></a>4.4.2 code 属性</h3><p>可以查询任何智能合约的部署代码。使用 <code>.code</code> 来获取 EVM 的字节码，其返回 <code>bytes memory</code> ，值可能是空。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function getCode() public view returns (bytes memory) &#123;</span><br><span class="line">        return address(this).code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 外部地址 code 内容是空，</span><br><span class="line">    // 可以通过这个来判断地址是否为合约</span><br><span class="line">    function getAdsCode(address a_) public view returns (bytes memory) &#123;</span><br><span class="line">        return address(a_).code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:合约没有完全创建，也就是 constructor 没有完全执行完的时候，code 也是空。</p><h3 id="4-4-3-codehash-属性"><a href="#4-4-3-codehash-属性" class="headerlink" title="4.4.3 codehash 属性"></a>4.4.3 codehash 属性</h3><p>使用 <code>.codehash</code> 获得合约代码的 <code>Keccak-256 哈希值</code> (为 bytes32 )。</p><p>注意， <code>addr.codehash</code> 比使用 <code>keccak256(addr.code)</code> 更便宜。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function getCode() public view returns (bytes memory) &#123;</span><br><span class="line">        return address(this).code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getCodeByKeccak256() public view returns (bytes32) &#123;</span><br><span class="line">        return keccak256(address(this).code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getCodehash() public view returns (bytes32) &#123;</span><br><span class="line">        return address(this).codehash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-地址方法"><a href="#4-5-地址方法" class="headerlink" title="4.5 地址方法"></a>4.5 地址方法</h2><p>address 拥有如下方法；</p><ol><li><code>address()</code>: 可以将地址转换到地址类型。</li><li><code>payable()</code>: 将普通地址转为可支付地址。</li><li><code>.transfer(uint256 amount)</code>: 将余额转到当前地址（合约地址转账）</li><li><code>.send(uint256 amount)</code>: 将余额转到当前地址，并<strong>返回交易成功状态</strong>（合约地址转账）</li><li><code>.call(bytes memory)</code>: 用给定的有效载荷（payload）发出低级 <code>CALL</code> 调用，并<strong>返回交易成功状态和返回数据</strong>（调用合约的方法并转账）</li><li><code>.delegatecall(bytes memory)</code>: 用给定有效载荷（payload）发出低级 <code>DELEGATECALL</code> 调用，返回交易成功状态和返回数据**（调用合约的方法并转账）</li><li><code>staticcall(bytes memory)</code>: 用给定的有效载荷（payload）发出低级 <code>STATICCALL</code> 调用，并<strong>返回交易成功状态和返回数据</strong>（调用合约的方法并转账）</li></ol><h3 id="4-5-1-address"><a href="#4-5-1-address" class="headerlink" title="4.5.1 address()"></a>4.5.1 address()</h3><p><strong>1.获取当前合约地址:address(this)</strong></p><p><strong>2.uint 值转换成地址</strong></p><h3 id="4-5-2-payable"><a href="#4-5-2-payable" class="headerlink" title="4.5.2 payable()"></a>4.5.2 payable()</h3><p>注意：支付的时候，地址必须 <code>payable</code> 类型！从 <code>address</code> 到 <code>address payable</code> 的转换。可以通过 <code>payable(x)</code> 进行 ，其中 <code>x</code> 必须是 <code>address</code> 类型。</p><p>让普通地址为 payable 有两种方式</p><ul><li><p>方式一: 参数中 地址标注 address payable ,并且函数状态可变性标为payable</p><ul><li>这种更省 gas (<strong>推荐</strong>)</li></ul></li><li><p>方式二: 仅在内部进行 <code>payable(address)</code> 显示转换</p></li></ul><h3 id="4-5-3-transfer"><a href="#4-5-3-transfer" class="headerlink" title="4.5.3 transfer()"></a>4.5.3 transfer()</h3><p>将余额转到当前地址（合约地址转账）,语法如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address payable&gt;.transfer(uint256 amount)</span><br></pre></td></tr></table></figure><ol><li>需要 payable address</li><li>使用固定（不可调节）的 2300 gas 的矿工费，错误会 reverts （回滚所有状态）<ol><li>2300 gas 足够转账，但是如果接收合约内的 <code>fallback</code> 和 <code>receive</code> 函数有恶意代码，复杂代码。容易导致 gas 耗尽的错误。</li></ol></li><li>失败时抛出异常<ol><li>如果当前合约的余额不够多，则 <code>transfer</code> 函数会执行失败，或者如果以太转移被接收帐户拒绝， <code>transfer</code> 函数同样会失败而进行回退。</li></ol></li><li>如果目标地址是一个合约，那么目标合约内部的 receive&#x2F;fallback 函数会随着调用 <code>transfer</code>函数一起执行，这是 EVM 的特性，没办法阻止。</li></ol><h3 id="4-5-4-send"><a href="#4-5-4-send" class="headerlink" title="4.5.4 send()"></a>4.5.4 send()</h3><p>将余额转到当前地址，并<strong>返回交易成功状态</strong>（合约地址转账）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;address payable&gt;.send(uint256 amount) returns (bool)</span><br><span class="line">send` 是 `transfer` 的低级版本。如果执行失败，当前的合约不会因为异常而终止。`transfer` 等价于`require(send())</span><br></pre></td></tr></table></figure><ol><li><p>需要 payable address</p></li><li><p>使用固定（不可调节）的 2300 gas 的矿工费。</p><ol><li>gas 同<code>transfer</code>一样的是 2300 gas ；足够转账，但是如果接收合约内的 <code>fallback</code> 和 <code>receive</code> 函数有恶意代码，复杂代码。容易导致 gas 耗尽的错误。</li></ol></li><li><p>失败时仅会返回false,不会终止执行（合约地址转账）;</p><ol><li><code>send()</code> 执行有一些风险：为了保证安全，必须检查 send 的返回值，如果交易失败，会回退以太币。</li></ol></li><li><p>补充：send 与 transfer 对应，但 <strong>send 更底层</strong>。如果执行失败，transfer 会因异常停止，而 send 会返回 false,transfer 相对 send 较安全</p></li></ol><h3 id="4-5-5-call-delegatecall-staticcall"><a href="#4-5-5-call-delegatecall-staticcall" class="headerlink" title="4.5.5 call&#x2F;delegatecall&#x2F;staticcall"></a>4.5.5 call&#x2F;delegatecall&#x2F;staticcall</h3><p>为了与不知道 ABI 的合约进行交互，Solidity 提供了函数 <code>call</code>&#x2F;<code>delegatecall</code>&#x2F;<code>staticcall</code> 直接控制编码。它们都带有一个 <code>bytes memory</code> 参数和返回执行<strong>成功状态</strong>（bool）和<strong>数据</strong>（bytes memory）。</p><p>函数 <code>abi.encode</code>，<code>abi.encodePacked</code>，<code>abi.encodeWithSelector</code> 和 <code>abi.encodeWithSignature</code> 可用于编码结构化数据。</p><p><strong>它们可以接受任意类型，任意数量的参数</strong>。这些参数会被打包到以 32 字节为单位的连续区域中存放。其中一个<strong>例外是当第一个参数被编码成正好 4 个字节的情况</strong>。 在这种情况下，这个参数后边不会填充后续参数编码，以允许使用函数签名。</p><p>下面具体的介绍三种 call。</p><h4 id="4-5-5-1-call"><a href="#4-5-5-1-call" class="headerlink" title="4.5.5.1 call()"></a>4.5.5.1 call()</h4><p>用给定的有效载荷（payload）发出低级 <code>CALL</code> 调用，并<strong>返回交易成功状态和返回数据</strong>（调用合约的方法并转账）, 格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.call(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure><ol><li><p>低级CALL调用：不需要 payable address, 普通地址即可</p><ol><li>注意: 调用 <code>call</code> 的时候，地址可以不具备 payable 属性</li></ol></li><li><p>返回两个参数，一个 <code>bool</code> 值代表成功或者失败，另外一个是可能存在的 <code>data</code></p></li><li><p>发送所有可用 gas，也可以自己调节 gas。</p><ol><li>如果 <code>fallback</code> 和 <code>receive</code> 内的代码相对复杂也可以，但是如果是恶意代码，需要考虑消耗的 gas 是否值得执行。</li><li><code>_ads.call&#123;value: msg.value,gas:2300&#125;(data)</code></li></ol></li><li><p>当合约调用合约时，不知道对方源码和 ABI 时候，可以使用 call 调用对方合约</p></li><li><p>推荐使用 call 转账 ETH，但是不推荐使用 call 来调用其他合约。</p><ol><li>原因是: call 调用的时候，将合约控制权交给对方，如果碰到恶意代码，或者不安全的代码就很容易凉凉。</li></ol></li><li><p>当调用不存在的合约方法时候，会触发对方合约内的fallback或receive</p><ol><li>我们的合约也可以在 <code>fallback</code> &#x2F; <code>receive</code> 这两个方法内抛出事件，查看是否有人对其做了什么操作。</li></ol></li><li><p>三种方法都提供 <code>gas</code> 选项，而 <code>value</code> 选项仅 <code>call</code> 支持 。三种 call 里只有 <code>call</code> 可以进行 ETH 转账，其他两种不可以进行转账。</p></li></ol><p><strong>例子 （重要）：调用其他合约方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test1 &#123;</span><br><span class="line">    string public name;</span><br><span class="line">    uint256 public age;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function setNameAndAge(string memory name_, uint256 age_)</span><br><span class="line">        external</span><br><span class="line">        payable</span><br><span class="line">        returns (string memory __name, uint256 __age)</span><br><span class="line">    &#123;</span><br><span class="line">        name = name_;</span><br><span class="line">        age = age_;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        return (name_, age_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CallTest &#123;</span><br><span class="line">    // 需要一个网页，动态的解析 _bys</span><br><span class="line">    bytes public bys;</span><br><span class="line"></span><br><span class="line">    function call_Test1_setNameAndAge(</span><br><span class="line">        address ads_,</span><br><span class="line">        string memory name_,</span><br><span class="line">        uint256 age_</span><br><span class="line">    ) external payable &#123;</span><br><span class="line">        bytes memory data = abi.encodeWithSignature(</span><br><span class="line">            &quot;setNameAndAge(string,uint256)&quot;,</span><br><span class="line">            name_,</span><br><span class="line">            age_</span><br><span class="line">        );</span><br><span class="line">        (bool success, bytes memory _bys) = ads_.call&#123;value: msg.value&#125;(data);</span><br><span class="line">        require(success, &quot;Call Failed&quot;);</span><br><span class="line">        bys = _bys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说下这个例子的原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    普通调用:用户A 调用 CallTest 合约, 发送 100 wei ; </span><br><span class="line">    CallTest 调用 Test1, 发送 50 wei此时在 Test1 合约内部</span><br><span class="line">        msg.sender = CallTest</span><br><span class="line">        msg.value = 50</span><br><span class="line">        Test1 内部如果有状态变量修改，则会被修改</span><br><span class="line">        发送到 Test1 内的ETH主币也会被留在Test1内</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h4 id="4-5-5-2-delegatecall-委托调用"><a href="#4-5-5-2-delegatecall-委托调用" class="headerlink" title="4.5.5.2 delegatecall() 委托调用"></a>4.5.5.2 delegatecall() 委托调用</h4><p>发出低级函数 <code>DELEGATECALL</code>，失败时返回 false，发送所有可用 gas，也可以自己调节 gas。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.delegatecall(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure><p><code>delegatecall</code> 使用方法和 <code>call</code> 完全一样。区别在于，<code>delegatecall</code> 只调用给定地址的代码（函数），其他状态属性如（存储，余额 …）都来自当前合约。<code>delegatecall</code> 的目的是使用另一个合约中的库代码。</p><p>委托调用是：<strong>委托对方调用自己数据的</strong>。类似授权转账，比如我部署一个 Bank 合约， 授权 ContractA 使用 Bank 地址内的资金，ContractA 只拥有控制权，但是没有拥有权。</p><ul><li>委托调用后，所有变量修改都是发生在委托合约内部，并不会保存在被委托合约中。<ul><li>利用这个特性，可以通过更换被委托合约，来升级委托合约。</li></ul></li><li>委托调用合约内部，需要和被委托合约的内部参数完全一样，否则容易导致数据混乱<ul><li>可以通过顺序来避免这个问题，但是推荐完全一样</li></ul></li></ul><p><strong>例子 1（重要）</strong></p><p>代码如下:</p><ul><li><code>DelegateCall</code> 是委托合约</li><li><code>TestVersion1</code> 是第 1 次被委托合约</li><li><code>TestVersion2</code> 是第 2 次被委托合约</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 合约版本 V.1</span><br><span class="line">contract TestVersion1 &#123;</span><br><span class="line">    address public sender;</span><br><span class="line">    uint256 public value;</span><br><span class="line">    uint256 public num;</span><br><span class="line"></span><br><span class="line">    function set(uint256 num_) external payable &#123;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">        value = msg.value;</span><br><span class="line">        num = num_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 合约版本 V.2</span><br><span class="line">contract TestVersion2 &#123;</span><br><span class="line">    address public sender;</span><br><span class="line">    uint256 public value;</span><br><span class="line">    uint256 public num;</span><br><span class="line"></span><br><span class="line">    function set(uint256 num_) external payable &#123;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">        value = msg.value;</span><br><span class="line">        num = num_ * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 委托调用测试</span><br><span class="line">contract DelegateCall &#123;</span><br><span class="line">    address public sender;</span><br><span class="line">    uint256 public value;</span><br><span class="line">    uint256 public num;</span><br><span class="line"></span><br><span class="line">    function set(address _ads, uint256 num_) external payable &#123;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">        value = msg.value;</span><br><span class="line">        num = num_;</span><br><span class="line">        // 第1种 encode</span><br><span class="line">        // 不需知道合约名字，函数完全自定义</span><br><span class="line">        bytes memory data1 = abi.encodeWithSignature(&quot;set(uint256)&quot;, num_);</span><br><span class="line">        // 第2种 encode</span><br><span class="line">        // 需要合约名字，可以避免函数和参数写错</span><br><span class="line">        bytes memory data2 = abi.encodeWithSelector(TestVersion1.set.selector, num_);</span><br><span class="line"></span><br><span class="line">        (bool success, bytes memory _data) = _ads.delegatecall(data2);</span><br><span class="line"></span><br><span class="line">        require(success, &quot;DelegateCall set failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说下这个例子的原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    委托调用</span><br><span class="line">    用户A 调用 DelegateCall 合约, 发送 100 wei ; DelegateCall 委托调用 Test1</span><br><span class="line">    此时在 Test1 合约内部</span><br><span class="line">        msg.sender = A</span><br><span class="line">        msg.value = 100</span><br><span class="line">        Test1 内部如果有状态变量修改，也不会被修改，会在DelegateCallB 内改变</span><br><span class="line">        发送到 Test1 内的ETH主币，会被留在 DelegateCallB 内，不会在Test1 内</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h4 id="4-5-5-3-staticcall-静态调用"><a href="#4-5-5-3-staticcall-静态调用" class="headerlink" title="4.5.5.3 staticcall() 静态调用"></a>4.5.5.3 staticcall() 静态调用</h4><p>用给定的有效载荷（payload）发出低级 <code>STATICCALL</code> 调用，并<strong>返回交易成功状态和返回数据</strong>（调用合约的方法并转账）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.staticcall(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure><p>它与 call 基本相同，发送所有可用 gas，也可以自己调节 gas，<strong>但如果被调用的函数以任何方式修改状态变量，都将回退</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 被调用的合约</span><br><span class="line">contract Hello1 &#123;</span><br><span class="line">    function echo() external pure returns (string memory) &#123;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hello2 &#123;</span><br><span class="line">    uint8 public a;</span><br><span class="line">    function echo() external returns (string memory) &#123;</span><br><span class="line">        a = 1;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用者合约</span><br><span class="line">contract SoldityTest &#123;</span><br><span class="line">    function callHello(address ads_) external view returns (string memory) &#123;</span><br><span class="line">        // 编码被调用者的方法签名</span><br><span class="line">        bytes4 methodId = bytes4(keccak256(&quot;echo()&quot;));</span><br><span class="line"></span><br><span class="line">        // 调用合约</span><br><span class="line">        (bool success, bytes memory data) = ads_.staticcall(</span><br><span class="line">            abi.encodeWithSelector(methodId)</span><br><span class="line">        );</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            return abi.decode(data, (string));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;error&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-三种-call-的总结"><a href="#4-6-三种-call-的总结" class="headerlink" title="4.6 三种 call 的总结"></a>4.6 三种 call 的总结</h3><ol><li><code>call</code> ， <code>delegatecall</code> 和 <code>staticcall</code> 都是非常低级的函数，应该只把它们当作最后一招来使用，它们破坏了 Solidity 的类型安全性。</li><li>三种方法都提供 <code>gas</code> 选项，而 <code>value</code> 选项仅 <code>call</code> 支持 。所以三种 call 里只有 <code>call</code> 可以进行 ETH 转账，其他两种不可以进行转账。</li><li>不管是读取状态还是写入状态，最好避免在合约代码中硬编码使用的 gas 值。这可能会引入<strong>错误</strong>，而且 gas 的消耗也是动态改变的。</li><li>如果在通过低级函数 <code>delegatecall</code> 发起调用时需要访问存储中的变量，那么这两个合约的存储布局需要一致，以便被调用的合约代码可以正确地通过变量名访问合约的存储变量。 这不是指在库函数调用（高级的调用方式）时所传递的存储变量指针需要满足那样情况。</li></ol><blockquote><p>⚠️ 注意: 在 0.5.0 版本以前, <code>.call</code>, <code>.delegatecall</code> and <code>.staticcall</code> 仅仅返回成功状态，没有返回值。</p></blockquote><blockquote><p>⚠️ 在 0.5.0 版本以前, 还有一个 <code>callcode</code> 函数，现在已经去除。</p></blockquote><h3 id="4-7-transfer-send-call-三种转账的总结"><a href="#4-7-transfer-send-call-三种转账的总结" class="headerlink" title="4.7 transfer &#x2F; send &#x2F; call 三种转账的总结"></a>4.7 transfer &#x2F; send &#x2F; call 三种转账的总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function byTransfer() public &#123;</span><br><span class="line">        payable(msg.sender).transfer(100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bySend() public &#123;</span><br><span class="line">        bool success = payable(msg.sender).send(100);</span><br><span class="line">        require(success, &quot;Send Fail&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果使用 transfer 或 send 函数必须添加fallback回退函数</span><br><span class="line">    fallback() external &#123;&#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>低级CALL调用<strong>不需要<code>payable address</code></strong>,transfer 和 send <strong>只能是 <code>payable address</code></strong></p><p>call的 gas 可以动态调整,transfer 和 send 只能是固定制 <code>2300</code></p><p>call除了可以转账外，可以还可以调用不知道 ABI 的方法，还可以调用的时候转账</p><ul><li>当调用不存在的合约方法时候，会触发对方合约内的 <code>fallback</code> 或者 <code>receive</code>。</li><li>如果使用 <code>_to.call&#123;value: 100&#125;(data)</code>，那么<code>data</code>中被调用的方法必须添加 <code>payable</code> 修饰符，否则转账失败！</li><li>因为可以调用方法，所以 call 有两个参数，除了一个 <code>bool</code> 值代表成功或者失败，另外一个是可能存在的 <code>data</code>，比如创建合约时候得到部署的地址，调用函数时候得到的函数放回值</li></ul><h3 id="4-8-注意事项"><a href="#4-8-注意事项" class="headerlink" title="4.8 注意事项"></a>4.8 注意事项</h3><p>使用 send 有很多危险：如果调用栈深度已经达到 1024（这总是可以由调用者所强制指定），转账会失败；并且如果接收者用光了 gas，转账同样会失败。为了保证以太币转账安全，总是检查 send 的返回值，利用 transfer 或者下面更好的方式： 用这种接收者取回钱的模式。</p><p><strong>call</strong>:在执行另一个合约函数时，应该尽可能避免使用 .call() ，因为它绕过了类型检查，函数存在检查和参数打包。</p><p>由于 EVM 会把对一个不存在的合约的调用作为是成功的。 Solidity 会在执行外部调用时使用 extcodesize 操作码进行额外检查。 这确保了即将被调用的合约要么实际存在（它包含代码）或者触发一个异常。低级调用不 包括这个检查，<strong>这使得它们在 GAS 方面更便宜，但也更不安全</strong>。</p><p>上面的这三个 call 方法都是底层的消息传递调用，最好仅在万不得已才进行使用，因为他们破坏了 Solidity 的类型安全。</p><h1 id="值类型-合约类型"><a href="#值类型-合约类型" class="headerlink" title="值类型:合约类型"></a>值类型:合约类型</h1><p>⚠️ 注意：合约不支持任何运算符。</p><h2 id="5-1-合约的属性"><a href="#5-1-合约的属性" class="headerlink" title="5.1 合约的属性"></a>5.1 合约的属性</h2><p>合约类型的成员是合约的外部函数及 public 的 状态变量。</p><p>对于合约 C 可以使用 type(C) 获取合约的类型信息，获得合约名</p><ul><li><pre><code class="solidity">type(C).name<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```solidity</span><br><span class="line">  type(C).creationCode</span><br></pre></td></tr></table></figure>- 获得包含创建合约字节码的内存字节数组。- 该值和合约内使用 `address(this).code;` 结果一样。- 它可以在内联汇编中构建自定义创建例程，尤其是使用 `create2` 操作码。- 不能在合约本身或派生的合约访问此属性。 因为会引起循环引用。</code></pre></li><li><pre><code class="solidity">type(C).runtimeCode<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 获得合约的运行时字节码的内存字节数组。这是通常由 `C` 的构造函数部署的代码。</span><br><span class="line">  - 如果 `C` 有一个使用内联汇编的构造函数，那么可能与实际部署的字节码不同。</span><br><span class="line">  - 还要注意库在部署时修改其运行时字节码以防范定期调用（guard against regular calls）。 与 `.creationCode` 有相同的限制，不能在合约本身或派生的合约访问此属性。 因为会引起循环引用。</span><br><span class="line"></span><br><span class="line"># 引用类型的额外注解:数据位置</span><br><span class="line"></span><br><span class="line">在讲引用类型之前，先介绍数据位置。这是因为在 Solidity 中，引用类型是由简单数据类型组合而成，相比于简单的值类型，这些类型通常通过名称引用。这些类型涉及到的数据量较大，复制它们可能要消耗大量 Gas，所以我们在使用引用数据类型时，必须考虑存储位置。我们需要仔细考虑数据是保存在内存中，还是在 EVM 存储区中。这就是线介绍数据位置的原因。</span><br><span class="line"></span><br><span class="line">**注意：所有的引用类型，都有数据位置这个额外的注解来指定存储在哪里，所以一定要掌握好。**</span><br><span class="line"></span><br><span class="line">## 6.1 数据位置的基础介绍</span><br><span class="line"></span><br><span class="line">在合约中声明和使用的变量都有一个数据位置，合约变量的数据位置将会影响 Gas 消耗量。</span><br><span class="line"></span><br><span class="line">Solidity 提供的有三种如下数据位置。</span><br><span class="line"></span><br><span class="line">- 存储 storage : 状态变量保存的位置，只要合约存在就一直存储．</span><br><span class="line">- 内存 memory : 即数据在内存中，因此数据仅在其生命周期内（函数调用期间）有效。不能用于外部调用。</span><br><span class="line">- 调用数据 calldata : 用来保存函数参数的特殊数据位置，是一个**只读位置**。</span><br><span class="line">  - 调用数据 calldata 是不可修改的、非持久的函数参数存储区域，效果大多类似 内存 memory 。</span><br><span class="line">  - 主要用于外部函数的参数，但也可用于其他变量，无论外部内部函数都可以使用。</span><br><span class="line"></span><br><span class="line">核心：更改数据位置或类型转换将始终产生自动进行一份拷贝，而在同一数据位置内（对于 存储 storage 来说）的复制仅在某些情况下进行拷贝。</span><br><span class="line"></span><br><span class="line">### 6.1.1 storage</span><br><span class="line"></span><br><span class="line">```solidity</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract DataLocation &#123;</span><br><span class="line">    // storage</span><br><span class="line">    uint256 stateVariable = 1;</span><br><span class="line">    uint256[] stateArray = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">    // uint storage stateVariable; // Expected identifier but got &#x27;storage&#x27;</span><br><span class="line">    // uint[] memory stateArray; // Expected identifier but got &#x27;memory&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>该存储位置存储永久数据，这意味着该数据可以被合约中的所有函数访问。可以把它视为计算机的硬盘数据，所有数据都永久存储。保存在存储区(storage)中的变量，以智能合约的状态存储，并且在函数调用之间保持持久性。与其他数据位置相比，存储区数据位置的成本较高。</p><p>storage 是永久存储在以太坊区块链中，更具体地说存储在存储 Merkle Patricia 树中，<strong>形成帐户状态信息的一部分</strong>。一旦使用这个类型，数据将永远存在。</p><p><strong>重点:状态变量总是存储在存储区(storage)中,并且不能显式地标记状态变量的位置。</strong>。状态变量是强制为 storage。</p><h3 id="6-1-2-memory"><a href="#6-1-2-memory" class="headerlink" title="6.1.2  memory"></a>6.1.2  memory</h3><p>内存位置是临时数据，比存储位置便宜。它只能在函数中访问。通常，内存数据用于保存临时变量，以便在函数执行期间进行计算。一旦函数执行完毕，它的内容就会被丢弃。你可以把它想象成每个单独函数的内存(RAM)。</p><p>memory：<strong>存储在内存中，即分配、即使用，越过作用域则不可访问，等待被回收</strong>。</p><h5 id="重点-1-函数参数-包括返回参数-都存储在内存中。"><a href="#重点-1-函数参数-包括返回参数-都存储在内存中。" class="headerlink" title="重点 1:函数参数(包括返回参数)都存储在内存中。"></a><strong>重点 1:函数参数(包括返回参数)都存储在内存中。</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract DataLocation &#123;</span><br><span class="line">    function add(uint256 num1, uint256 num2)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256 result)</span><br><span class="line">    &#123;</span><br><span class="line">        return num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中: 函数参数 <code>uint num1</code> 与 <code>uint num2</code>，返回值 <code>uint result</code> 都存储在内存中。</p><h5 id="重点-2-引用类型的局部变量，需要显式指定数据位置-storage-memory"><a href="#重点-2-引用类型的局部变量，需要显式指定数据位置-storage-memory" class="headerlink" title="重点 2:引用类型的局部变量，需要显式指定数据位置(storage&#x2F;memory)"></a><strong>重点 2:引用类型的局部变量，需要显式指定数据位置(storage&#x2F;memory)</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Locations &#123;</span><br><span class="line">    struct Book &#123;</span><br><span class="line">        string title;</span><br><span class="line">        string author;</span><br><span class="line">        uint256 book_id;</span><br><span class="line">    &#125;</span><br><span class="line">    Book public java; // 一本 java 书</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function test() public &#123;</span><br><span class="line">        /* 此处都是局部变量  */</span><br><span class="line">        // 值类型:所以它们被存储在内存中</span><br><span class="line">        bool flag = true;</span><br><span class="line">        uint256 number = 1;</span><br><span class="line">        address account = 0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac;</span><br><span class="line">        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff)));</span><br><span class="line"></span><br><span class="line">        // Data location can only be specified for array, struct or mapping types,</span><br><span class="line">        // but &quot;memory&quot; was given.</span><br><span class="line">        // bool memory flag2; // 错误:值类型的数据不能标示 memory</span><br><span class="line"></span><br><span class="line">        // 引用类型:需要显示指定数据位置，此处指定为内存</span><br><span class="line">        uint256[] memory localArray; // array</span><br><span class="line">        // uint8[] memory nums = [1, 2, 3]; // 内存中不能创建动态数组</span><br><span class="line">        uint8[3] memory numsFixed = [1, 2, 3];</span><br><span class="line">        uint256[] memory a = new uint256[](5); // 推荐</span><br><span class="line">        a[1] = 1;</span><br><span class="line">        a[2] = 2;</span><br><span class="line">        a[3] = 3;</span><br><span class="line">        a[4] = 4;</span><br><span class="line"></span><br><span class="line">        string memory myStr = &quot;hello&quot;; // string</span><br><span class="line"></span><br><span class="line">        // 映射不能在函数中动态创建，您必须从状态变量中分配它们。</span><br><span class="line">        // mapping(address =&gt; bool) memory myMapping;</span><br><span class="line">        mapping(address =&gt; uint256) storage ref = balances; // mapping</span><br><span class="line">        java = Book(&#123;title: &quot;Solidity&quot;, author: &quot;Anbang&quot;, book_id: 1&#125;); // struct</span><br><span class="line">        bytes memory bc = bytes(&quot;!&quot;); //</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mapping 和 struct 类型，不能在函数中动态创建，必须从状态变量中分配它们。</li><li>内存中不能创建动态数组</li></ul><h5 id="重点-3-函数的输入和输出参数如果是数组-使用-memory"><a href="#重点-3-函数的输入和输出参数如果是数组-使用-memory" class="headerlink" title="重点 3:函数的输入和输出参数如果是数组,使用 memory"></a><strong>重点 3:函数的输入和输出参数如果是数组,使用 memory</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract DataLocations &#123;</span><br><span class="line">    // name_ 是 string ，所以使用 memory</span><br><span class="line">    // mm_ 是 uint256[] ，所以使用 memory</span><br><span class="line">    // 输出相同，也是使用 memory</span><br><span class="line">    function examples2(string memory name_, uint256[] memory mm_)</span><br><span class="line">        external</span><br><span class="line">        pure</span><br><span class="line">        returns (uint256[] memory memArr, string memory myName)</span><br><span class="line">    &#123;</span><br><span class="line">        memArr = new uint256[](mm_.length);</span><br><span class="line">        myName = name_;</span><br><span class="line">        for (uint256 index = 0; index &lt; mm_.length; index++) &#123;</span><br><span class="line">            memArr[index] = mm_[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="重点-4-引用类型的局部变量-指定-storage-和-memory-的区别"><a href="#重点-4-引用类型的局部变量-指定-storage-和-memory-的区别" class="headerlink" title="重点 4:引用类型的局部变量:指定 storage 和 memory 的区别"></a><strong>重点 4:引用类型的局部变量:指定 storage 和 memory 的区别</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract DataLocations &#123;</span><br><span class="line">    struct MyStruct &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint256 age;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(address =&gt; MyStruct) public myStructs;</span><br><span class="line"></span><br><span class="line">    function test1() external returns (MyStruct memory) &#123;</span><br><span class="line">        myStructs[msg.sender] = MyStruct(&#123;name: &quot;Anbang1&quot;, age: 18&#125;);</span><br><span class="line"></span><br><span class="line">        // storage 会修改状态变量</span><br><span class="line">        MyStruct storage myStruct1 = myStructs[msg.sender];</span><br><span class="line">        myStruct1.age++;</span><br><span class="line">        return myStruct1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test2() external returns (MyStruct memory) &#123;</span><br><span class="line">        myStructs[msg.sender] = MyStruct(&#123;name: &quot;Anbang2&quot;, age: 18&#125;);</span><br><span class="line"></span><br><span class="line">        // memory 函数运行完后即消失，修改的值也不会储存在状态变量中</span><br><span class="line">        MyStruct memory myStruct2 = myStructs[msg.sender];</span><br><span class="line">        myStruct2.age++;</span><br><span class="line">        return myStruct2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>storage</code>修改引用数据: 会修改状态变量</li><li><code>memory</code>修改引用数据: 函数运行完后即消失，修改的值也不会储存在状态变量中</li></ul><h3 id="6-1-3-calldata"><a href="#6-1-3-calldata" class="headerlink" title="6.1.3  calldata"></a>6.1.3  calldata</h3><p>calldata 是不可修改的非持久性数据位置，所有传递给函数的值，都存储在这里。此外，<code>calldata</code> 是外部函数(external function)的参数的默认位置。外部函数(external function)的参数存储在 calldata 中。函数的返回值中也可以使用 calldata 数据位置的数组和结构，但是无法给其分配空间。</p><ul><li><strong>要点: calldata 只能用在函数的输入和输出参数中</strong></li><li><strong>要点: calldata 用在输入参数中，比 memorg 更省 gas</strong></li><li><strong>要点: calldata 的参数不允许修改，但是 memorg 参数允许修改</strong></li></ul><p>存储函数参数，它是只读的，不会永久存储的一个数据位置。外部函数(external function)的参数被强制指定为 calldata，效果与 memory 类似。</p><blockquote><p>注解: 如果可以的话，请尽量使用 calldata 作为数据位置，因为它将避免复制，并确保不能修改数据。</p></blockquote><h3 id="6-1-4-stack"><a href="#6-1-4-stack" class="headerlink" title="6.1.4 stack"></a>6.1.4 stack</h3><p>堆栈是由 EVM (Ethereum 虚拟机)维护的非持久性数据。EVM 使用堆栈数据位置在执行期间加载变量。堆栈位置最多有 1024 个级别的限制。</p><h3 id="6-1-5-小结"><a href="#6-1-5-小结" class="headerlink" title="6.1.5 小结"></a>6.1.5 小结</h3><p>按照关键字:</p><ul><li>storage: 存储区: 状态变量总是储存在<strong>存储区</strong>上</li><li>memory: 内存区: 局部变量使用，只在内存中生效。<ul><li>值类型的局部变量，存储在<strong>内存</strong>中。</li><li><strong>引用类型局部变量，需要显式地指定数据位置</strong>。</li><li>函数的输入参数如果是数组或者 string，必须是 <code>memory</code> 或 <code>calldata</code></li><li>内存中的数组必须是定长数组（不能使用 push 赋值），动态数组只能储存在状态变量中。</li></ul></li><li>calldata<ul><li>和 memory 类似，但是 calldata 只能用在函数的输入参数中。</li><li>相比使用 memory ,合约输入参数如果使用 calldata, 可以节约 gas</li></ul></li></ul><p>按照函数参数:</p><ul><li>内部函数参数: (包括返回参数)都存储在<strong>memory（内存）</strong>中。</li><li>外部函数参数: (不包括返回参数)存储在 <code>calldata</code> 中。</li></ul><h2 id="6-2-不同数据位置之间的赋值规则"><a href="#6-2-不同数据位置之间的赋值规则" class="headerlink" title="6.2 不同数据位置之间的赋值规则"></a>6.2 不同数据位置之间的赋值规则</h2><p>本小节总结如下:</p><ol><li><p>将存储变量赋值给存储变量</p><ul><li><code>值 类 型</code>: 创建一个新副本。</li><li><code>引用类型</code>: 创建一个新副本。</li></ul></li><li><p>将内存变量赋值给存储变量</p><ul><li><code>值 类 型</code>: 创建一个新副本。</li><li><code>引用类型</code>: 创建一个新副本。</li></ul></li><li><p>将存储变量赋值给内存变量</p><ul><li><code>值 类 型</code>: 创建一个新副本。</li><li><code>引用类型</code>: 创建一个新副本。</li></ul></li><li><p>将内存变量赋值给内存变量 (同类型)</p><ul><li><p><code>值 类 型</code>: 创建一个新副本。</p></li><li><p><code>引用类型</code>: 不会创建副本。(<strong>重要</strong>)</p></li></ul></li></ol><h2 id="6-3-calldata-和-memeory-区别"><a href="#6-3-calldata-和-memeory-区别" class="headerlink" title="6.3 calldata 和 memeory 区别"></a>6.3 calldata 和 memeory 区别</h2><p><strong>函数调用函数时的区别</strong>: <code>calldata可以隐式转换为memory</code></p><ul><li>calldata 参数可以隐式转换为 memory</li><li>memory 参数不可以隐式转换为 calldata</li></ul><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><ul><li><p>array</p><ul><li>基本类型组成的数组集合。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint256[5] public T1 = [1, 2, 3, 4, 5];</span><br><span class="line">address[5] public A = [0xff...6ac];</span><br><span class="line">byte[5] public A = [0xff...6ac];</span><br></pre></td></tr></table></figure><ul><li>字符串与 bytes 是特殊的数组，所以也是引用类型</li></ul></li><li><p>string: 是一个动态尺寸的 utf-8 编码字符串</p><ul><li>他其实是一个特殊的可变字节数组，同时其也是一个引用类型</li></ul></li><li><p>bytes: 动态十六进制字节数组</p><ul><li>bytes 类似于 <code>byte[]</code>，但它在 calldata 中被紧密地打包。因此，相比于 <code>byte[]</code>，bytes 应该优先使用，因为更便宜。</li><li>string 等价于 bytes，但不允许长度或索引访问。</li></ul></li><li><p>mapping</p></li><li><p>struct：为了允许 evm 的优化，请确保 storage 中的变量和 <code>struct</code> 成员的书写顺序允许它们被紧密地打包。例如，应该按照 <code>uint128，uint128，uint256</code> 的顺序来声明状态变量，而不是使用 <code>uint128，uint256，uint128</code>，因为前者只占用两个存储插槽，而后者将占用三个。</p></li></ul><h2 id="7-1-array-数组"><a href="#7-1-array-数组" class="headerlink" title="7.1 array 数组"></a>7.1 array 数组</h2><p>数组是存储<strong>同类元素的有序集合</strong>。数组声明时可以是固定大小的，也可以是动态调整长度。</p><p>下面是 array 的总结:</p><ul><li><p>声明和初始化数组</p><ul><li>数组元素可以是任何类型，包括映射或结构体。对类型的限制是映射只能存储在存储 storage 中，并且公开访问函数的参数需要是 ABI 类型。</li></ul></li><li><p>访问和修改数组元素</p><ul><li><pre><code class="solidity">arr[_index]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 通过索引进行获取特定元素</span><br><span class="line"></span><br><span class="line">  - 可以通过索引修改值</span><br><span class="line"></span><br><span class="line">  - 状态变量标记 `public` 的数组，Solidity 创建一个 `getter函数` 。 下标的索引数字就是 `getter函数` 的参数。</span><br><span class="line"></span><br><span class="line">  - 访问超出数组长度的元素会导致异常（assert 类型异常 ）。 可以使用 .push() 方法在末尾追加一个新元素，其中 .push() 追加一个零初始化的元素并返回对它的引用。</span><br><span class="line"></span><br><span class="line">- 函数中返回数组</span><br><span class="line"></span><br><span class="line">  - 如果想把数组全部返回，需要通过函数进行操作。在函数中返回数组</span><br><span class="line"></span><br><span class="line">- 动态数组和定长数组</span><br><span class="line"></span><br><span class="line">  - 动态数组只能存在于状态变量中</span><br><span class="line">  - 内存中只能创建定长数组</span><br><span class="line"></span><br><span class="line">- 创建内存数组</span><br><span class="line"></span><br><span class="line">  - 对于 storage 数组，元素可以是任意类型(其他数组、映射或结构)。</span><br><span class="line">  - 对于 memory 数组，元素类型不能是映射类型，如果它是一个 public 函数的参数，那么元素类型必须是 ABI 类型。</span><br><span class="line"></span><br><span class="line">- 数组的属性</span><br><span class="line"></span><br><span class="line">  - `length`: 获取数组的长度</span><br><span class="line"></span><br><span class="line">- 数组的方法</span><br><span class="line"></span><br><span class="line">  - push : 只有动态数组可以使用，只能用在动态数组上</span><br><span class="line">  - pop: 删除最后一个长度，只能用在动态数组上</span><br><span class="line">  - delete: 清空对应的索引；清空不是删除，并不会改变长度，索引位置的值会改为默认值。</span><br><span class="line">  - 数组切片: `x[start:end]`</span><br><span class="line"></span><br><span class="line">### 7.1.1 数组的创建</span><br><span class="line"></span><br><span class="line">数组长度上分为 **固定长度数组** 和 **可变长度数组**，类型上分为**一维数组**和**多维数组**；</span><br><span class="line"></span><br><span class="line">一个元素类型为 `T`，固定长度为 `k` 的数组可以声明为 `T[k]`，而动态数组声明为 `T[]`。</span><br><span class="line"></span><br><span class="line">```solidity</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    // 固定长度数组</span><br><span class="line">    address[5] public A =   [0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac];</span><br><span class="line">    uint256[10] public arr1 = [0, 1, 2]; // 赋值的数组长度不超过10都可以</span><br><span class="line">    uint256[10] public arr2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br><span class="line">    </span><br><span class="line">    //先声明再赋值</span><br><span class="line">    uint256[10] public arr1;</span><br><span class="line">    function test() external &#123;</span><br><span class="line">        arr1[0] = 1;</span><br><span class="line">        arr1[1] = 10;</span><br><span class="line">        arr1[2] = 100;</span><br><span class="line">        arr1[9] = 900;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 可变长度数组</span><br><span class="line">    /*</span><br><span class="line">         用方式 2 创建数组时，若数组为成员变量, 则默认为 storage 类型；</span><br><span class="line">         若为局部变量默认为 `memory` 类型，`memory` 类型的数组，必须声明长度，并且长度创建后不可变。</span><br><span class="line">         `push` 方法不能用在 `memeory` 的数组上,只能逐个索引的赋值。</span><br><span class="line">     */</span><br><span class="line">    uint256[] public T1 = [1, 2, 3, 4, 5]; // 方式 1</span><br><span class="line">    uint256[] public T2 = new uint256[](5); // 方式 2</span><br><span class="line">    </span><br><span class="line">    //二维数组:创建（注意这里跟其它语言比，数组长度的声明位置是反的）</span><br><span class="line">    uint256[2][3] public T = [[1, 2], [3, 4], [5, 6]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p><strong>如果能使用定长数组，就使用定长数组，因为它很便宜。</strong></p><h3 id="7-1-2-数组常量"><a href="#7-1-2-数组常量" class="headerlink" title="7.1.2 数组常量"></a>7.1.2 数组常量</h3><p>正常看到下方代码应该没什么问题，但是注意:函数 s 中数组类型是<code>uint256</code>，而函数 t 中输入的数组类型是<code>uint8</code>, 这里需要将 uint8 转换一下<code>s([uint256(1), uint256(2)]);</code>;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract T &#123;</span><br><span class="line">    function s(uint256[2] memory _arr) public &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function t() public &#123;</span><br><span class="line">        // s([1, 2]); // 默认这么写不行的 ❌</span><br><span class="line">        s([uint256(1), uint256(2)]); // ✅</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能转成小的类型，就不会转成大的，这是数组常量的<strong>懒惰性</strong>。如下是一个比较经典的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract T &#123;</span><br><span class="line">    int8[2] public a = [1, -1];</span><br><span class="line">    // int8[2] public a = [int8(1), -1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组常量 <code>[1, -1]</code> 是无效的，因为第一个表达式类型是 <code>uint8</code> 而第二个类似是 <code>int8</code> 他们不可以隐式的相互转换。 为了确保可以运行，你是可以使用例如： <code>[int8(1), -1]</code> 。</p><p>由于不同类型的固定大小的内存数组不能相互转换(尽管基础类型可以)，如果你想使用二维数组常量，你必须显式地指定一个基础类型:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function f() public pure returns (uint24[2][4] memory) &#123;</span><br><span class="line">        // 下面代码无法工作，因为没有匹配内部类型</span><br><span class="line">        // uint[2][4] memory x = [[0x1, 1], [0xffffff, 2], [0xff, 3], [0xffff, 4]];</span><br><span class="line"></span><br><span class="line">        uint24[2][4] memory x = [</span><br><span class="line">            [uint24(0x1), 1],</span><br><span class="line">            [0xffffff, 2],</span><br><span class="line">            [uint24(0xff), 3],</span><br><span class="line">            [uint24(0xffff), 4]</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-1-2-数组的属性"><a href="#7-1-2-数组的属性" class="headerlink" title="7.1.2 数组的属性"></a>7.1.2 数组的属性</h3><h5 id="length数组有-length-属性表示当前数组的长度。-一经创建，内存-memory-数组的大小就是固定的（但却是动态的，也就是说，它可以根据运行时的参数创建）。"><a href="#length数组有-length-属性表示当前数组的长度。-一经创建，内存-memory-数组的大小就是固定的（但却是动态的，也就是说，它可以根据运行时的参数创建）。" class="headerlink" title="length数组有 length 属性表示当前数组的长度。 一经创建，内存 memory 数组的大小就是固定的（但却是动态的，也就是说，它可以根据运行时的参数创建）。"></a>length数组有 <code>length</code> 属性表示当前数组的长度。 一经创建，内存 memory 数组的大小就是固定的（但却是动态的，也就是说，它可以根据运行时的参数创建）。</h5><p><strong>通过 <code>arr.length</code> 获取数组的长度</strong></p><p><strong>不能通过设置 <code>arr.length</code> 来调整动态数组的长度。</strong></p><h3 id="7-1-3-数组的方法"><a href="#7-1-3-数组的方法" class="headerlink" title="7.1.3 数组的方法"></a>7.1.3 数组的方法</h3><ul><li><p>push : 只有动态数组可以使用，动态的 storage 数组以及bytes类型可以用，string类型不可以</p><ul><li><code>push()</code>: 它用来添加新的零初始化元素到数组末尾，并返回元素引用.因此可以这样：<code>x.push().t = 2</code> 或 <code>x.push() = b</code>.</li><li><code>push(x)</code>: 用来在数组末尾添加一个给定的元素，这个函数没有返回值．</li></ul></li><li><p><code>pop:</code> 删除最后一个长度</p><ul><li>它用来从数组末尾删除元素。 同样的会在移除的元素上隐含调用 delete 。</li></ul></li><li><p><code>delete</code>: 删除对应的索引；删除并不会改变长度，索引位置的值会改为默认值。</p></li><li><p><code>x[start:end]</code>: 数组切片，仅可使用于 <code>calldata</code> 数组.</p></li></ul><h2 id="7-2-bytes"><a href="#7-2-bytes" class="headerlink" title="7.2.bytes"></a>7.2.bytes</h2><p><code>string</code> 和 <code>bytes</code> 类型的变量是特殊的数组。 <code>bytes</code> 可以通过索引或者<code>.length</code>来访问数据。string 与 bytes 相同，但不允许用<code>.length</code>或索引来访问数据。</p><ul><li>对任意长度的原始字节数据使用 <code>bytes</code>，对任意长度字符串（UTF-8）数据使用 <code>string</code> 。</li><li>如果使用一个长度限制的字节数组，应该使用一个 <code>bytes1</code> 到 <code>bytes32</code> 的具体类型，因为它们便宜得多。</li><li><code>bytesN[]</code> 和 <code>bytes</code> 可以转换: bytes1 是值类型，比如 <code>0x61</code>; <code>bytes</code>是可变字节数组,如果 bytes1 想要借用 bytes 的方法，就需要转换成 bytes;</li></ul><h3 id="7-2-1-创建"><a href="#7-2-1-创建" class="headerlink" title="7.2.1 创建"></a>7.2.1 创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    bytes public welcome = bytes(&quot;1.Welcome&quot;);</span><br><span class="line">    bytes public temp1 = new bytes(2); // 可变字节数组创建方式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-2-bytes-和-bytes32-区别"><a href="#7-2-2-bytes-和-bytes32-区别" class="headerlink" title="7.2.2 bytes 和 bytes32[] 区别"></a>7.2.2 bytes 和 bytes32[] 区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// bytes / bytes32 / bytes32[] 区别</span><br><span class="line">// bytes:可变字节数组 ： 引用类型</span><br><span class="line">// bytes32: 固定长度的字节数组 ： 值类型</span><br><span class="line">// bytes32[]: 由“固定长度的字节数组” 组成的 数组类型</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    bytes public welcome1 = bytes(&quot;1.Welcome&quot;);</span><br><span class="line">    bytes32 public welcome2 = &quot;a&quot;;</span><br><span class="line">    bytes32[] public welcome3 = [bytes32(&quot;a&quot;)];</span><br><span class="line"></span><br><span class="line">    bytes32[] public abcArray = [bytes1(&quot;a&quot;), bytes1(&quot;b&quot;), bytes1(&quot;c&quot;)];</span><br><span class="line"></span><br><span class="line">    // 0x616263</span><br><span class="line">    bytes public abcBytes = bytes(&quot;abc&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>abcBytes</code> 的值是: <code>0x616263</code>;</p><p><code>abcArray</code> 的值是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    0x6100000000000000000000000000000000000000000000000000000000000000,</span><br><span class="line">    0x6200000000000000000000000000000000000000000000000000000000000000,</span><br><span class="line">    0x6300000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>bytes</code> 有点类似于 <code>bytes1[]</code>的紧打包，我们可以把上面例子中 bytes32 改为 bytes1 类型进行对比。</p><p>我们更多时候应该使用 <code>bytes</code> 而不是 <code>bytes32[]</code>这种数组类型 ，因为 Gas 费用更低;</p><ul><li><code>bytes32[]</code> 会在元素之间添加 31 个填充字节。</li><li><code>bytes</code> 由于紧密包装，这没有填充字节。</li></ul><h3 id="7-2-3-属性"><a href="#7-2-3-属性" class="headerlink" title="7.2.3  属性"></a>7.2.3  属性</h3><ul><li><p>获取 bytes 长度</p><ul><li>bytesVar.length:以字节长度表示字符串的长度</li></ul></li><li><p>获取指定索引的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes1 temp1 = bytes(welcome)[_index]; // 返回固定长度的 bytes1</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-2-4-方法"><a href="#7-2-4-方法" class="headerlink" title="7.2.4 方法"></a>7.2.4 方法</h3><h4 id="bytes-concat-拼接"><a href="#bytes-concat-拼接" class="headerlink" title="bytes.concat 拼接"></a>bytes.concat 拼接</h4><ul><li><code>bytes.concat(...) returns (bytes memory)</code></li><li><code>bytes.concat( )</code>返回空数组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    bytes public concatBytes = bytes.concat();</span><br><span class="line">    bytes public welcome = bytes(&quot;a&quot;);</span><br><span class="line">    bytes public concatBytes = bytes.concat(welcome, bytes(&quot;b&quot;), bytes1(&quot;c&quot;),&quot;a&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="push-方法"><a href="#push-方法" class="headerlink" title="push 方法"></a>push 方法</h4><p>注意： push 是单个字节，是 <code>bytes1</code>的固定长度,而不是 <code>bytes</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    bytes public welcome1 = bytes(&quot;Welcome&quot;);</span><br><span class="line">    bytes public welcome2 = new bytes(10);</span><br><span class="line"></span><br><span class="line">    function testPush() public &#123;</span><br><span class="line">        welcome1.push(bytes(&quot;A&quot;)[0]);</span><br><span class="line">        welcome2.push(bytes1(&quot;B&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pop-方法"><a href="#pop-方法" class="headerlink" title="pop 方法"></a>pop 方法</h4><p>删除数组的最后一个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    bytes public welcome1 = bytes(&quot;Welcome&quot;);</span><br><span class="line">    bytes public welcome2 = new bytes(10);</span><br><span class="line"></span><br><span class="line">    function testPop() public &#123;</span><br><span class="line">        welcome1.pop();</span><br><span class="line">        welcome2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delete-清空字节数组"><a href="#delete-清空字节数组" class="headerlink" title="delete 清空字节数组"></a>delete 清空字节数组</h4><p>使用 <code>delete</code> 全局关键字;</p><ul><li><code>delete bytesName</code></li><li><code>delete bytesName[index]</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    bytes public welcome1 = bytes(&quot;Welcome&quot;);</span><br><span class="line"></span><br><span class="line">    function deleteAll() public &#123;</span><br><span class="line">        delete welcome1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deleteIndex(uint256 index_) public &#123;</span><br><span class="line">        delete welcome1[index_];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="x-start-end-数组切片"><a href="#x-start-end-数组切片" class="headerlink" title="x[start:end]:数组切片"></a><code>x[start:end]</code>:数组切片</h4><p>注意：数组切片只能用在 calldata 类型上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Proxy &#123;</span><br><span class="line">    bytes public welcome1 = bytes(&quot;Welcome&quot;);</span><br><span class="line">    bytes4 public temp1 = bytes4(welcome1); // 0x57656c63</span><br><span class="line"></span><br><span class="line">    // 把 welcome1 的值传入参数</span><br><span class="line">    function forward(bytes calldata payload)</span><br><span class="line">        external pure</span><br><span class="line">        returns(bytes memory temp2,bytes4 temp3)</span><br><span class="line">    &#123;</span><br><span class="line">        // 切片方法只能用在 calldata 上。</span><br><span class="line">        temp2 = payload[:4];</span><br><span class="line">        temp3 = bytes4(payload[:4]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-5-字符串-到-bytes-的转换"><a href="#7-2-5-字符串-到-bytes-的转换" class="headerlink" title="7.2.5 字符串 到 bytes 的转换"></a>7.2.5 字符串 到 bytes 的转换</h3><p>转换方法: 可以使用 <code>bytes()</code> 构造函数将字符串转换为 <code>bytes</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function trans(string memory _str) external pure returns (bytes memory) &#123;</span><br><span class="line">        return bytes(_str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-6-bytes-到-字符串-的转换"><a href="#7-2-6-bytes-到-字符串-的转换" class="headerlink" title="7.2.6 bytes 到 字符串 的转换"></a>7.2.6 bytes 到 字符串 的转换</h3><p>转换方法: 可以使用 <code>string()</code> 构造函数将 <code>bytes</code> 转换为字符串。</p><p>注意: 字节数组分为动态大小和固定大小的。如果是固定大小字节数组，需要先转为动态大小字节数组。</p><ul><li><code>动态大小字节数组</code> —&gt; <code>string</code></li><li><code>固定大小字节数组</code> —&gt; <code>动态大小字节数组</code> —&gt; <code>string</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    string public data1;</span><br><span class="line">    string public data2;</span><br><span class="line"></span><br><span class="line">    // `动态大小字节数组` —&gt; `string`</span><br><span class="line">    function trans1() external &#123;</span><br><span class="line">        bytes memory bstr = new bytes(2);</span><br><span class="line">        bstr[0] = &quot;a&quot;;</span><br><span class="line">        bstr[1] = &quot;b&quot;;</span><br><span class="line">        data1 = string(bstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // `固定大小字节数组` —&gt; `动态大小字节数组` —&gt; `string`</span><br><span class="line">    function trans2() external &#123;</span><br><span class="line">        // 固定大小字节数组</span><br><span class="line">        bytes2 ab = 0x6162;</span><br><span class="line"></span><br><span class="line">        // `固定大小字节数组` —&gt; `动态大小字节数组`</span><br><span class="line">        bytes memory temp = new bytes(ab.length); // 可变字节数组创建方式</span><br><span class="line">        for (uint256 i = 0; i &lt; ab.length; i++) &#123;</span><br><span class="line">            temp[i] = ab[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // `动态大小字节数组` —&gt; `string`</span><br><span class="line">        data2 = string(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3-string"><a href="#7-3-string" class="headerlink" title="7.3 string"></a>7.3 string</h2><p>Solidity 中，字符串值使用双引号(<code>&quot;&quot;</code>)或单引号(<code>&#39;&#39;</code>)包括，字符串类型用 string 表示。<code>string</code> 和 <code>bytes</code> 类型的变量是特殊的数组，是引用类型。</p><h3 id="7-3-1-格式"><a href="#7-3-1-格式" class="headerlink" title="7.3.1 格式"></a>7.3.1 格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract For &#123;</span><br><span class="line">    string public a = &quot;a&quot; &quot;b&quot; &quot;c&quot;;</span><br><span class="line">    string public b = &quot;abc&quot;;</span><br><span class="line">    string public c = &#x27;x&#x27; &#x27;y&#x27; &#x27;z&#x27;;</span><br><span class="line">    string public d = &#x27;xyz&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-2-属性"><a href="#7-3-2-属性" class="headerlink" title="7.3.2 属性"></a>7.3.2 属性</h3><p>string 并没有获取其字符串长度的 length 属性; 也没提供获取某个索引字节码的索引属性。</p><p>我们可以通过把 string 转换成 <code>bytes</code>，借助<code>bytes</code> 的属性。</p><p>例子: 下面是使用 <code>getLength()</code> 获取长度，使用<code>modi()</code>修改字符串，使用 <code>getIndexValue()</code> 获取字符串的指定索引的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    string public welcome = &quot;1.Welcome&quot;;</span><br><span class="line"></span><br><span class="line">    function getLength() public view returns (uint256 welcomeLength) &#123;</span><br><span class="line">        welcomeLength = bytes(welcome).length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getIndexValue(uint256 _index) public view returns (string memory) &#123;</span><br><span class="line">        bytes1 temp1 = bytes(welcome)[_index]; // 返回固定长度的 bytes1</span><br><span class="line">        bytes memory temp2 = new bytes(1); // 可变字节数组创建方式</span><br><span class="line">        temp2[0] = temp1;</span><br><span class="line">        return string(temp2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function modi() public &#123;</span><br><span class="line">        bytes(welcome)[0] = bytes1(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-3-方法"><a href="#7-3-3-方法" class="headerlink" title="7.3.3 方法"></a>7.3.3 方法</h3><p>Solidity string 本身并没有操作函数，需要借助全局的函数</p><ul><li>字符串拼接<ul><li><code>string.concat()</code></li><li>如果不使用参数调用 string.concat 将返回空数组。</li></ul></li><li>将 bytes 转换到字符串<ul><li><code>string()</code></li></ul></li><li>将 字符串 转换到 bytes<ul><li><code>bytes()</code></li></ul></li><li>比较两个字符串<ul><li><code>keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))</code></li><li><code>keccak256(bytes(s1)) == keccak256(bytes(s2))</code>:更省 gas</li></ul></li></ul><p><strong>string.concat</strong>:可以使用 <code>string.concat</code> 连接任意数量的 string 字符串。 该函数返回一个 <code>string memory</code> ，包含所有参数的内容，无填充方式拼接在一起。 如果你想使用不能隐式转换为 string 的其他类型作为参数，你需要先把它们转换为 string。</p><p>输入字符串，输出拼接后的字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    string public welcome = &quot;Welcome&quot;;</span><br><span class="line"></span><br><span class="line">    // 写一个 welcome username 的小方法</span><br><span class="line">    // Welcome Anbang!</span><br><span class="line">    function test(string memory name_)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns(string memory concatString)&#123;</span><br><span class="line">            bytes memory bs = bytes(&quot;!&quot;);</span><br><span class="line">            // welcome + name_ + bs</span><br><span class="line">            // 内部是使用字符串，如果是bytes，需要转换为 string 类型</span><br><span class="line">            concatString = string.concat(</span><br><span class="line">                welcome,</span><br><span class="line">                name_,</span><br><span class="line">                string(bs)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你不使用参数调用 <code>string.concat</code> 或 <code>bytes.concat</code> 将返回空数组。</p><h2 id="7-4-mapping-映射"><a href="#7-4-mapping-映射" class="headerlink" title="7.4 mapping 映射"></a>7.4 mapping 映射</h2><p>mapping 可以看作一个哈希表，会执行虚拟化初始化，使所有可能的值都是该类型的默认值。其实 mapping 并不是一个哈希表，没有 key 集合，也没有 value 集合，所以 mapping 没办法遍历&#x2F;迭代。</p><p>数组中找某一个值需要循环遍历，这是很消耗 Gas 的，而使用 mapping 就可以很好的解决这个问题。映射可以很方便的获取某个值。映射并没有做迭代的方法。</p><h3 id="7-4-1本节重点"><a href="#7-4-1本节重点" class="headerlink" title="7.4.1本节重点"></a>7.4.1本节重点</h3><p>声明映射类型的语法：<code>mapping(_KeyType =&gt; _ValueType)</code></p><p><code>_KeyType</code>：可以是任何内置类型，或者 bytes 和 字符串,键是唯一的，其赋值方式为：<code>map[a]=test</code>; 意思是键为 a,值为 test；</p><p><code>_ValueType</code>： 可以是任何类型，用户自定义类型也可以。</p><p>mapping 支持嵌套,映射的数据位置(data location)只能是 <code>storage</code>，通常用于状态变量,mapping不能用于public</p><p>函数的参数或返回结果</p><ul><li>映射只能是 storage 的数据位置，因此只允许作为状态变量 或 作为函数内的 storage 引用 或 作为库函数的参数。它们不能用<strong>合约公有函数的参数或返回值</strong>。</li><li>这些限制同样适用于包含映射的数组和结构体。</li></ul><p><strong>问答题：为什么映射不能像哈希表一样遍历？</strong></p><p>映射与哈希表不同的地方：<strong>在映射中,并不存储 key，而是存储它的 <code>keccak256</code> 哈希值，从而便于查询实际的值</strong>。正因为如此，映射是没有长度的，也没有 <code>key 的集合</code>或 <code>value 的集合</code>的概念。映射只能是存储的数据位置，因此只允许作为状态变量或作为函数内的存储引用 或 作为库函数的参数。</p><h3 id="7-4-2-创建格式"><a href="#7-4-2-创建格式" class="headerlink" title="7.4.2 创建格式"></a>7.4.2 创建格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Mapping &#123;</span><br><span class="line">    // 普通</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line">    // 嵌套</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; bool)) public friends;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-3-如何获取-设置-删除"><a href="#7-4-3-如何获取-设置-删除" class="headerlink" title="7.4.3 如何获取-设置-删除"></a>7.4.3 如何获取-设置-删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Mapping &#123;</span><br><span class="line">    // 普通</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    // 嵌套</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; bool)) public friends;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        balances[msg.sender] = 100;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function blanceGet() external view returns (uint256) &#123;</span><br><span class="line">        // 获取</span><br><span class="line">        return balances[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function blanceSet(uint256 amount) external &#123;</span><br><span class="line">        // 设置</span><br><span class="line">        balances[msg.sender] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function blanceDelete() external &#123;</span><br><span class="line">        // 删除</span><br><span class="line">        delete balances[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function friendGet() external view returns (bool) &#123;</span><br><span class="line">        // 获取</span><br><span class="line">        return friends[msg.sender][address(0)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function friendSet() external &#123;</span><br><span class="line">        // 设置</span><br><span class="line">        friends[msg.sender][address(0)] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function friendDelete() external &#123;</span><br><span class="line">        // 删除</span><br><span class="line">        delete friends[msg.sender][address(0)];</span><br><span class="line">        // delete friends[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-4-作为局部变量的使用"><a href="#7-4-4-作为局部变量的使用" class="headerlink" title="7.4.4 作为局部变量的使用"></a>7.4.4 作为局部变量的使用</h3><p><code>mapping</code> 类型可以用做局部变量，但只能引用状态变量，而且存储位置为 storage。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 作为局部变量的使用</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // 普通 mapping</span><br><span class="line">    mapping(address =&gt; uint256) public balances; // 普通mapping</span><br><span class="line"></span><br><span class="line">    // storage: 改变内部 ref，会影响 balances 的值</span><br><span class="line">    // 不能声明为 memory</span><br><span class="line">    function updataBalance() public returns(uint256)&#123;</span><br><span class="line">        // mapping(address=&gt;uint256) memory ref = balances; // ❌</span><br><span class="line">        mapping(address=&gt;uint256) storage ref = balances;</span><br><span class="line">        ref[msg.sender] += 3;</span><br><span class="line">        return ref[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-5-在-ERC20-token-中的用法"><a href="#7-4-5-在-ERC20-token-中的用法" class="headerlink" title="7.4.5 在 ERC20 token 中的用法"></a>7.4.5 在 ERC20 token 中的用法</h3><p>下面的例子是ERC20 token的简单版本 <code>._allowances</code> 是一个嵌套 mapping 的例子 <code>._allowances</code> 用来记录其他的账号，可以允许从其账号使用多少数量的币．</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// mapping 在 ERC20 token 中的用法</span><br><span class="line">contract MappingExample &#123;</span><br><span class="line">    // 余额</span><br><span class="line">    mapping(address =&gt; uint256) private _balances;</span><br><span class="line">    // 授权:</span><br><span class="line">    // 授权人 - 代理人 - 授权金额</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line">    event Approval(</span><br><span class="line">        address indexed owner,</span><br><span class="line">        address indexed spender,</span><br><span class="line">        uint256 value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 获取：授权金额</span><br><span class="line">    function allowance(address owner, address spender)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        return _allowances[owner][spender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查：授权金额大于等于需要操作的金额</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address sender,</span><br><span class="line">        address recipient,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) public returns (bool) &#123;</span><br><span class="line">        require(</span><br><span class="line">            _allowances[sender][msg.sender] &gt;= amount,</span><br><span class="line">            &quot;ERC20: Allowance not high enough.&quot;</span><br><span class="line">        );</span><br><span class="line">        _allowances[sender][msg.sender] -= amount; // 设置额度</span><br><span class="line">        _transfer(sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置：</span><br><span class="line">    function approve(address spender, uint256 amount) public returns (bool) &#123;</span><br><span class="line">        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">        _allowances[msg.sender][spender] = amount;</span><br><span class="line">        emit Approval(msg.sender, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _transfer(</span><br><span class="line">        address sender,</span><br><span class="line">        address recipient,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) internal &#123;</span><br><span class="line">        require(sender != address(0), &quot;ERC20: transfer from the zero address&quot;);</span><br><span class="line">        require(recipient != address(0), &quot;ERC20: transfer to the zero address&quot;);</span><br><span class="line">        require(_balances[sender] &gt;= amount, &quot;ERC20: Not enough funds.&quot;);</span><br><span class="line"></span><br><span class="line">        _balances[sender] -= amount;</span><br><span class="line">        _balances[recipient] += amount;</span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-6-可迭代映射"><a href="#7-4-6-可迭代映射" class="headerlink" title="7.4.6 可迭代映射"></a>7.4.6 可迭代映射</h3><p>遍历所有 Mapping 内的数据，（Mapping 配合 array ）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line">    // 用于检查:地址是否已经存在于 balancesKey</span><br><span class="line">    mapping(address =&gt; bool) public balancesInserted;</span><br><span class="line">    address[] public balancesKey; // 所有地址</span><br><span class="line"></span><br><span class="line">    // 设置</span><br><span class="line">    function set(address ads_,uint256 amount_) external&#123;</span><br><span class="line">        balances[ads_] = amount_;</span><br><span class="line">        // 1.检查</span><br><span class="line">        if(!balancesInserted[ads_])&#123;</span><br><span class="line">            // 2.修改检查条件</span><br><span class="line">            balancesInserted[ads_] = true;</span><br><span class="line">            // 3.正在的操作</span><br><span class="line">            balancesKey.push(ads_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取</span><br><span class="line">    function get(uint256 index_) external view returns(uint256)&#123;</span><br><span class="line">        require(index_&lt;balancesKey.length,&quot;index_ error&quot;);</span><br><span class="line">        return balances[balancesKey[index_]];</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取所有</span><br><span class="line">    function totalAddress() external view returns(uint256)&#123;</span><br><span class="line">        return balancesKey.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取第一个值</span><br><span class="line">    function first() external view returns(uint256)&#123;</span><br><span class="line">        return balances[balancesKey[0]];</span><br><span class="line">    &#125;</span><br><span class="line">    // 最后一个值</span><br><span class="line">    function latest() external view returns(uint256)&#123;</span><br><span class="line">        return balances[balancesKey[balancesKey.length-1]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>更完善的实现: <a href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol">https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol</a></li><li>更新的实现: <a href="https://learnblockchain.cn/docs/solidity/types.html#iterable-mappings">https://learnblockchain.cn/docs/solidity/types.html#iterable-mappings</a></li></ul><h2 id="7-5-struct-结构体"><a href="#7-5-struct-结构体" class="headerlink" title="7.5 struct 结构体"></a>7.5 struct 结构体</h2><h3 id="7-5-1-创建语法"><a href="#7-5-1-创建语法" class="headerlink" title="7.5.1 创建语法"></a>7.5.1 创建语法</h3><p>要定义结构体，使用 <code>struct</code> 关键字。<code>struct</code> 关键字定义了一个新的数据类型，包含多个成员。结构体是可以将多个变量进行编组的自定义类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    struct Book &#123;</span><br><span class="line">        string title;</span><br><span class="line">        string author;</span><br><span class="line">        uint256 book_id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-2-三种创建方法"><a href="#7-5-2-三种创建方法" class="headerlink" title="7.5.2 三种创建方法"></a>7.5.2 三种创建方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 第 1 种生成</span><br><span class="line">Book memory solidity1 = Book(unicode&quot;Solidity 高级程序设计&quot;, &quot;Anbang&quot;, ++bookId);</span><br><span class="line"></span><br><span class="line">// 第 2 种生成</span><br><span class="line">Book memory solidity2 = Book(&#123;</span><br><span class="line">    title: unicode&quot;Solidity 高级程序设计&quot;,</span><br><span class="line">    author: &quot;Anbang&quot;,</span><br><span class="line">    book_id: ++bookId,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 第 3 种生成</span><br><span class="line">Book memory temp;</span><br><span class="line">temp.title = unicode&quot;Solidity 高级程序设计&quot;;</span><br><span class="line">temp.author = &quot;Anbang&quot;;</span><br><span class="line">temp.book_id = ++bookId;</span><br></pre></td></tr></table></figure><h3 id="7-5-3-读取"><a href="#7-5-3-读取" class="headerlink" title="7.5.3 读取"></a>7.5.3 读取</h3><p>函数内仅读取结构体，使用 memory 和 storage 区别:</p><ol><li>函数内读取并返回,如果使用 memory 变量接收:<ol><li>从状态变量拷贝到内存中，然后内存中的变量拷贝到返回值。两次拷贝，消耗 gas 多</li><li><code>Book memory _book = book;</code></li></ol></li><li>函数内读取并返回，如果使用 storage 变量接收:<ol><li>直接从状态变量读取，状态变量拷贝到返回值。1 次拷贝，消耗 gas 小</li></ol></li><li>总结: 读取时候推荐使用 <code>storage</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 读取</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    struct Book &#123;</span><br><span class="line">        string title;</span><br><span class="line">        string author;</span><br><span class="line">        uint256 book_id;</span><br><span class="line">    &#125;</span><br><span class="line">    Book public book = Book(&quot;Solidity&quot;, &quot;Anbang&quot;, 1);</span><br><span class="line"></span><br><span class="line">    // memory  30029 gas</span><br><span class="line">    // 函数内读取并返回：使用 memory 变量接收</span><br><span class="line">    //  两次拷贝，所以消耗的 gas 多</span><br><span class="line">    function get1() external view</span><br><span class="line">        returns(</span><br><span class="line">            string memory,</span><br><span class="line">            string memory,</span><br><span class="line">            uint256</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">         // 从状态变量拷贝到内存中</span><br><span class="line">        Book memory _book = book;</span><br><span class="line">        // 内存中的变量拷贝到返回值；2次拷贝</span><br><span class="line">        return (_book.title,_book.author,_book.book_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // storage 29983 gas</span><br><span class="line">    // 函数内读取并返回：使用 storage 变量接收</span><br><span class="line">    function get2() external view</span><br><span class="line">        returns(</span><br><span class="line">            string memory,</span><br><span class="line">            string memory,</span><br><span class="line">            uint256</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        // 从状态变量读取，没有拷贝的行为</span><br><span class="line">        Book storage _book = book;</span><br><span class="line"></span><br><span class="line">        // 状态变量拷贝到返回值。1次拷贝</span><br><span class="line">        return (_book.title,_book.author,_book.book_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-4-修改"><a href="#7-5-4-修改" class="headerlink" title="7.5.4 修改"></a>7.5.4 修改</h3><p>函数内读取时，标记 <code>memory</code> &#x2F; <code>storage</code>,会产生完全不同的结果；</p><p>特别注意：**如果结构体内包含 <code>mapping</code> 类型，则必须使用 <code>storage</code>，不可以使用 memeory.**，否则报错</p><p>函数内获取并修改结构体：</p><ul><li>因为要修改状态变量，所以使用 storage</li><li>函数内直接修改变量; 在修改一个属性时比较省 Gas 费用</li><li>函数内先获取存储到 storage 再修改:修改多个属性的时候比较省 Gas 费用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Structs &#123;</span><br><span class="line">    struct Book &#123;</span><br><span class="line">        string title;</span><br><span class="line">        string author;</span><br><span class="line">        uint256 book_id;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 private bookId;</span><br><span class="line">    Book public book1; // Book类型</span><br><span class="line">    Book public book2; // Book类型</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; Book) public students; // mapping 类型</span><br><span class="line"></span><br><span class="line">    // 设置 book1</span><br><span class="line">    function setBook1() external &#123;</span><br><span class="line">        Book memory temp;</span><br><span class="line">        temp.title = unicode&quot;Solidity 高级程序设计&quot;;</span><br><span class="line">        temp.author = &quot;Yaoqi&quot;;</span><br><span class="line">        temp.book_id = ++bookId;</span><br><span class="line">        book1 = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置 book2</span><br><span class="line">    // ✅ 最优方案，推荐:直接修改</span><br><span class="line">    function setBook2() external &#123;</span><br><span class="line">        book2.title = unicode&quot;Solidity 高级程序设计&quot;;</span><br><span class="line">        book2.author = &quot;Yaoqi&quot;;</span><br><span class="line">        book2.book_id = ++bookId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ✅ 最优方案，推荐:直接修改</span><br><span class="line">    function set1Student() external &#123;</span><br><span class="line">        Book storage temp = students[msg.sender];</span><br><span class="line">        temp.title = unicode&quot;Solidity 高级程序设计&quot;;</span><br><span class="line">        temp.author = &quot;Anbang&quot;;</span><br><span class="line">        temp.book_id = ++bookId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function set2Student() external &#123;</span><br><span class="line">        Book memory temp;</span><br><span class="line">        temp.title = unicode&quot;Solidity 高级程序设计&quot;;</span><br><span class="line">        temp.author = &quot;Anbang&quot;;</span><br><span class="line">        temp.book_id = ++bookId;</span><br><span class="line">        students[msg.sender] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-5-删除"><a href="#7-5-5-删除" class="headerlink" title="7.5.5 删除"></a>7.5.5 删除</h3><p>删除结构体的变量，仅仅是重置数据，并不是完全的删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    struct Book &#123;</span><br><span class="line">        string title;</span><br><span class="line">        string author;</span><br><span class="line">        uint256 book_id;</span><br><span class="line">    &#125;</span><br><span class="line">    Book public book = Book(&quot;Solidity&quot;, &quot;Anbang&quot;, 1);</span><br><span class="line"></span><br><span class="line">    function del() external</span><br><span class="line">    &#123;</span><br><span class="line">        delete book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>Solidity 允许类型之间进行隐式转换和显式转换。</p><p><strong>前文回顾</strong>: <code>bytes1</code> 对应 <code>uint8</code>，对应两位连续的十六进制数字 <code>0xXX</code>。</p><h2 id="8-1-隐式转换"><a href="#8-1-隐式转换" class="headerlink" title="8.1 隐式转换"></a>8.1 隐式转换</h2><h3 id="8-1-1-发生场景"><a href="#8-1-1-发生场景" class="headerlink" title="8.1.1 发生场景"></a>8.1.1 发生场景</h3><p>在<strong>赋值</strong>, <strong>函数参数传递</strong>以及应用运算符时，会发生隐式转换。</p><h3 id="8-1-2-转换的标准"><a href="#8-1-2-转换的标准" class="headerlink" title="8.1.2  转换的标准"></a>8.1.2  转换的标准</h3><ol><li>值类型</li><li>源类型必须是目标类型的子集。</li></ol><p>例如，<code>uint8</code> 可以转换为 <code>uint16</code>&#x2F;<code>uint24</code>..&#x2F;<code>uint256</code>，因为<code>uint8</code>是<code>uint16</code>这些类型的子集。</p><p>但是 <code>int8</code> 不可以转换为 <code>uint256</code>，因为 <code>int8</code> 可以包含 <code>uint256</code> 中不允许的负值，比如 <code>-1</code>。</p><h3 id="8-1-3-相交集合的类型，不能隐式转换。"><a href="#8-1-3-相交集合的类型，不能隐式转换。" class="headerlink" title="8.1.3  相交集合的类型，不能隐式转换。"></a>8.1.3  相交集合的类型，不能隐式转换。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    int8 public a1 = 3;</span><br><span class="line"></span><br><span class="line">    // Type int8 is not implicitly convertible to expected type uint16.</span><br><span class="line">    // uint16 public a2 = a1;</span><br><span class="line"></span><br><span class="line">    uint8 public b1 = 3;</span><br><span class="line">    uint16 public b2 = b1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-1-4-把整数字面量赋值给整型时，不能超出范围而发生截断，否则会报错。"><a href="#8-1-4-把整数字面量赋值给整型时，不能超出范围而发生截断，否则会报错。" class="headerlink" title="8.1.4 把整数字面量赋值给整型时，不能超出范围而发生截断，否则会报错。"></a>8.1.4 把整数字面量赋值给整型时，不能超出范围而发生截断，否则会报错。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo1 &#123;</span><br><span class="line">    uint8 public a = 12; // no error</span><br><span class="line">    uint32 public b = 1234; // no error</span><br><span class="line">    uint16 public c = 0x01;</span><br><span class="line"></span><br><span class="line">    // Type int_const 123456 is not implicitly convertible</span><br><span class="line">    // to expected type uint8. Literal is too large to fit in uint8.</span><br><span class="line">    // uint8 d = 123456;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-1-4-函数参数传递"><a href="#8-1-4-函数参数传递" class="headerlink" title="8.1.4 函数参数传递"></a>8.1.4 函数参数传递</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 函数的传参</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint256 public a;</span><br><span class="line"></span><br><span class="line">    function test1(uint256 u_) public &#123;</span><br><span class="line">        a = u_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test2() external &#123;</span><br><span class="line">        uint8 temp = 3;</span><br><span class="line">        test1(temp); //</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 函数的传参</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint256 public a;</span><br><span class="line"></span><br><span class="line">    function test1(uint256[3] memory u_) public &#123;</span><br><span class="line">        a = u_[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 禁止的：</span><br><span class="line">    function test2() external &#123;</span><br><span class="line">        // function call. Invalid implicit conversion from uint8[3]</span><br><span class="line">        // memory to uint256[3] memory requested.</span><br><span class="line">        // test1([1,2,3]);</span><br><span class="line">        test1([uint256(1),uint256(2),uint256(3)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-1-5-运算符应用"><a href="#8-1-5-运算符应用" class="headerlink" title="8.1.5 运算符应用"></a>8.1.5 运算符应用</h3><p>则编译器将尝试将<strong>其中一个操作数</strong>隐式转换为<strong>另一个操作数的类型</strong>（赋值也是如此）。 这意味着操作始终以操作数之一的类型执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// 运算符</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    uint8 public  x = 1;</span><br><span class="line">    uint16 public  y = 2;</span><br><span class="line"></span><br><span class="line">    // uint8 + uint16 =&gt; uint16 + uint16 = uint16</span><br><span class="line">    // uint16 =&gt; uint32</span><br><span class="line">    uint32 public  z = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，加法的操作数 x 和 y 没有相同的类型，uint8 可以被隐式转换为 uint16，相反却不可以。 因此在执行加法之前，将 uint8 转换为 uint16 的类型，结果类型是 uint16。因为它被赋值给 uint32 类型的变量，又进行了另一个类似逻辑的隐式转换.</p><h2 id="8-2-显式转换"><a href="#8-2-显式转换" class="headerlink" title="8.2 显式转换"></a>8.2 显式转换</h2><p>可以使用类型关键字，显式地将数据类型转换为另一种类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // uint8 =&gt; uint16</span><br><span class="line">    uint8 public a1 = 3;</span><br><span class="line">    uint16 public a2 = uint16(a1);</span><br><span class="line"></span><br><span class="line">    int8 public b1 = 3;</span><br><span class="line">    //Explicit type conversion not allowed from &quot;int8&quot; to &quot;uint256&quot;.</span><br><span class="line">    // uint256 b2 = uint256(b1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-1-int-uint-整型转换"><a href="#8-2-1-int-uint-整型转换" class="headerlink" title="8.2.1 int&#x2F;uint 整型转换"></a>8.2.1 int&#x2F;uint 整型转换</h3><p>整型加大数据位置是从左侧增加，减小数据位置也是从左侧移除；（<strong>整型是右对齐</strong>）</p><ul><li>整型转换成更大的类型，从左侧添加填充位。</li><li>整型转换成更小的类型，会丢失左侧数据。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // 整型转换成更大的类型，从左侧添加填充位。</span><br><span class="line">    // uint16 =&gt; uint32</span><br><span class="line">    uint16 public a1 = 22136;       // 等于 0x5678</span><br><span class="line">    uint32 public a2 = uint32(a1); // a2 = 22136</span><br><span class="line"></span><br><span class="line">    // uint16 =&gt; uint8</span><br><span class="line">    uint8 public a3 = uint8(a1); // a4 = 0x78</span><br><span class="line">    uint8 public a4 = 0x78;</span><br><span class="line"></span><br><span class="line">    // 整型转换成更小的类型，会丢失左侧数据。</span><br><span class="line">    // uint32 =&gt; uint16</span><br><span class="line">    uint32 public b1 = 0x12345678; // 0x12345678</span><br><span class="line">    uint16 public b2 = uint16(b1); // 0x5678 | b2 = 22136</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>整数显式转换为更大的类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint16 a = 0x1234;</span><br><span class="line">uint32 b = uint32(a); // b 为 0x00001234 now</span><br></pre></td></tr></table></figure><p><strong>整数显式转换成更小的类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint32 a = 0x12345678;</span><br><span class="line">uint16 b = uint16(a); // 此时 b 的值是 0x5678</span><br></pre></td></tr></table></figure><h3 id="8-2-1-bytes-字节类型转换"><a href="#8-2-1-bytes-字节类型转换" class="headerlink" title="8.2.1 bytes 字节类型转换"></a>8.2.1 bytes 字节类型转换</h3><p>字节加大数据位置是从右侧增加，减小数据位置也是从右侧移除；（<strong>字节是左对齐</strong>）</p><ul><li>字节转换为更大的类型时，从右侧添加填充位。</li><li>字节转换到更小的类型时，丢失右侧数据。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // 字节转换为更大的类型时，从右侧添加填充位。</span><br><span class="line">    // bytes2 =&gt;bytes4</span><br><span class="line">    bytes2 public a1 = 0x5678;</span><br><span class="line">    bytes4 public a2 = bytes4(a1); // a2 = 0x56780000</span><br><span class="line"></span><br><span class="line">    // 字节转换到更小的类型时，丢失右侧数据。</span><br><span class="line">    // bytes4 =&gt; bytes2</span><br><span class="line">    bytes4 public b1 = 0x12345678;</span><br><span class="line">    bytes2 public b2 = bytes2(b1); // b2 = 0x1234</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>bytes 显式转换成更小的类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bytes2 a = 0x1234;</span><br><span class="line">bytes1 b = bytes1(a); // b 为 0x12</span><br></pre></td></tr></table></figure><p><strong>bytes 显式转换成更大的类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bytes2 a = 0x1234;</span><br><span class="line">bytes4 b = bytes4(a); // b 为 0x12340000</span><br></pre></td></tr></table></figure><h3 id="8-2-3-bytes-与-uint-转换"><a href="#8-2-3-bytes-与-uint-转换" class="headerlink" title="8.2.3 bytes 与 uint 转换"></a>8.2.3 bytes 与 uint 转换</h3><p>只有当字节类型和整数类型大小相同时，才可以进行转换。</p><p>因为整数和定长字节数组在截断（或填充）时行为是不同的，如果要在不同的大小的整数和定长字节数组之间进行转换，<strong>必须使用一个中间类型来明确进行所需截断和填充的规则</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bytes2 a = 0x1234;</span><br><span class="line">uint32 b = uint16(a);           // b 为 0x00001234</span><br><span class="line">uint32 c = uint32(bytes4(a));   // c 为 0x12340000</span><br><span class="line"></span><br><span class="line">uint8  d = uint8(uint16(a));    // d 为 0x34</span><br><span class="line">uint8  e = uint8(bytes1(a));    // e 为 0x12</span><br></pre></td></tr></table></figure><p><strong>1.bytes 转换成 uint</strong>: <strong>先转类型，再转大小</strong></p><ul><li>推荐先把 bytes 显示转换成数字类型后，再转换成更大或更小的数字</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">// - `uint8`  等于两位连续的十六进制数字 `0xXX`</span><br><span class="line">// - `bytes1` 等于两位连续的十六进制数字 `0xXX`</span><br><span class="line">// - `bytes1` 等于 `uint8`</span><br><span class="line">contract Demo1 &#123;</span><br><span class="line">    // bytes =&gt; uint</span><br><span class="line">    bytes2 public a1 = 0x5678; // : 十进制数字 = 22136</span><br><span class="line">    bytes4 public a2 = bytes4(a1); // a2 = 0x56780000 : 十进制数字 = 1450704896</span><br><span class="line">    bytes1 public a3 = bytes1(a1); // a3 = 0x56 : 十进制数字 = 86</span><br><span class="line"></span><br><span class="line">    // -- 增大</span><br><span class="line">    // bytes 显示转换成数字后，显示转换更大的数字 (这里也可以隐式完成)</span><br><span class="line">    uint32 public a4 = uint32(uint16(a1)); // ✅ a4 = 0x00005678 : 十进制 = 22136</span><br><span class="line">    // bytes 显示转换成更大数字对应的的bytes，然后bytes显示转换成匹配的数字</span><br><span class="line">    uint32 public a5 = uint32(bytes4(a1)); // ❌ a5 = 0x56780000 : 十进制 = 1450704896</span><br><span class="line"></span><br><span class="line">    // -- 减小</span><br><span class="line">    // bytes 显示转换成数字后，显示转换成更小的数字</span><br><span class="line">    uint8 public a6 = uint8(uint16(a1)); // ✅ a6 = 0x78 : 十进制 = 120</span><br><span class="line">    // bytes 显示转换成更小数字对应的的bytes，然后bytes显示转换成匹配的数字</span><br><span class="line">    uint8 public a7 = uint8(bytes1(a1)); // ❌ a7 = 0x56 : 十进制 = 86</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.uint 转换成 bytes</strong>: <strong>先转大小，再转类型</strong></p><ul><li>推荐先把 uint 显示转换成更大 bytes 对应的 uint，然后 uint 再显示转换成匹配的 bytes</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo2 &#123;</span><br><span class="line">    // uint =&gt; bytes</span><br><span class="line">    uint16 public b1 = 0x5678; // 0x5678 : 十进制 = 22136</span><br><span class="line">    uint32 public b2 = uint32(b1); // b2 = 0x00005678 : 十进制 = 22136</span><br><span class="line">    uint8 public b3 = uint8(b1); // b3 = 0x78 : 十进制 = 120</span><br><span class="line">    // -- 增大</span><br><span class="line">    // uint 显示转换成bytes类型后，再显示转换成更大或更小的bytes</span><br><span class="line">    bytes4 public b4 = bytes4(bytes2(b1)); // ❌ b4 = 0x56780000</span><br><span class="line">    // uint 显示转换成更大bytes对应的uint，然后uint再显示转换成匹配的bytes</span><br><span class="line">    bytes4 public b5 = bytes4(uint32(b1)); //  ✅ b5 = 0x00005678</span><br><span class="line"></span><br><span class="line">    // -- 减小</span><br><span class="line">    // uint 显示转换成bytes类型后，再显示转换成更大或更小的bytes</span><br><span class="line">    bytes1 public b6 = bytes1(bytes2(b1)); // ❌ b4 = 0x56</span><br><span class="line">    // uint 显示转换成更大bytes对应的uint，然后uint再显示转换成匹配的bytes</span><br><span class="line">    bytes1 public b7 = bytes1(uint8(b1)); // ✅ b4 = 0x78</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-4-bytes-和-bytesN-之间转换"><a href="#8-2-4-bytes-和-bytesN-之间转换" class="headerlink" title="8.2.4 bytes 和 bytesN 之间转换"></a>8.2.4 bytes 和 bytesN 之间转换</h3><p><code>bytes</code> 数组和 <code>bytes calldata</code> 切片可以显示转换为固定长度的 bytes 类型(<code>bytes1...bytes32</code>).</p><ul><li>如果数组比固定长度的 bytes 类型长，则在末尾处会发生截断。</li><li>如果数组比目标类型短，它将在末尾用零填充。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    // 0x6162636465666768</span><br><span class="line">    bytes public bts = &quot;abcdefgh&quot;;</span><br><span class="line">    bytes3 public b1 = bytes3(bts);</span><br><span class="line">    bytes8 public b2 = bytes8(bts);</span><br><span class="line">    bytes16 public b3 = bytes16(bts);</span><br><span class="line">    bytes32 public b4 = bytes32(bts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>补充</strong>：使用切片也可以把数据从 bytes 转为 bytesN。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    // 0x6162636465666768</span><br><span class="line">    bytes public bts = &quot;abcdefgh&quot;;</span><br><span class="line"></span><br><span class="line">    function f(bytes calldata bts_)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes3,bytes16)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        bytes3 b1 = bytes3(bts_);</span><br><span class="line">        bytes16 b2 = bytes16(bts_[:8]);</span><br><span class="line">        return (b1, b2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-5-bytes-与-address-转换"><a href="#8-2-5-bytes-与-address-转换" class="headerlink" title="8.2.5 bytes 与 address 转换"></a>8.2.5 bytes 与 address 转换</h3><p>address 的格式是 <code>0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac</code>，是一个 <strong>bytes20</strong> 的数据。</p><p>地址是取 <code>bytes32</code> 数据中的后 20 位。如果想删除前面的 12 位数据，可以使用 solidity assembly (内联汇编) 来截取，也可以借助 <code>uint</code> 转换成更小的类型，会丢失左侧数据的特性来完成。</p><p>代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // 获取即将部署的地址</span><br><span class="line">    function getAddress(bytes memory bytecode, uint256 _salt)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (address)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes32 hash = keccak256(</span><br><span class="line">            abi.encodePacked(</span><br><span class="line">                bytes1(0xff), // 固定字符串</span><br><span class="line">                address(this), // 当前工厂合约地址</span><br><span class="line">                _salt, // salt</span><br><span class="line">                keccak256(bytecode) //部署合约的 bytecode</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        // bytes 转换成 uint: 先转类型，再转大小</span><br><span class="line">        //      bytes32 =&gt; uint256 =&gt; uint160</span><br><span class="line">        // uint160 转 address</span><br><span class="line">        //      uint160 =&gt; address</span><br><span class="line">        return address(uint160(uint256(hash)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前文介绍过编码的方式: <code>keccak256(abi.encodePacked())</code>，返回的是 <code>bytes32</code> 类型。</p><p>这个小例子是<strong>合约部署合约</strong>那章节中 create2 代码的一部分，相关的更多演示请查看 create2 创建。</p><h2 id="8-3-数字转换成字符串"><a href="#8-3-数字转换成字符串" class="headerlink" title="8.3 数字转换成字符串"></a>8.3 数字转换成字符串</h2><h3 id="8-3-1-直接借助-bytes-和-string（未完成）"><a href="#8-3-1-直接借助-bytes-和-string（未完成）" class="headerlink" title="8.3.1 直接借助 bytes 和 string（未完成）"></a>8.3.1 直接借助 bytes 和 string（未完成）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    // `固定大小字节数组` —&gt; `动态大小字节数组` —&gt; `string`</span><br><span class="line">    function test(uint8 num_) public pure returns (bytes1 ab,string memory data) &#123;</span><br><span class="line">        // 固定大小字节数组</span><br><span class="line">        ab = bytes1(num_);</span><br><span class="line"></span><br><span class="line">        // `固定大小字节数组` —&gt; `动态大小字节数组`</span><br><span class="line">        bytes memory temp = new bytes(ab.length); // 可变字节数组创建方式</span><br><span class="line">        for (uint8 i = 0; i &lt; ab.length; i++) &#123;</span><br><span class="line">            temp[i] = ab[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // `动态大小字节数组` —&gt; `string`</span><br><span class="line">        data = string(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-2-借助单个数字转换（推荐）"><a href="#8-3-2-借助单个数字转换（推荐）" class="headerlink" title="8.3.2 借助单个数字转换（推荐）"></a>8.3.2 借助单个数字转换（推荐）</h3><p>这种方法是借助将 0-9 的数字进行转换，然后超过十位的数字，通过 <code>%</code> 来得到，并且拼接在一起。<br>推荐方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    function uintToString(uint256 _uint)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (string memory str)</span><br><span class="line">    &#123;</span><br><span class="line">        if (_uint == 0) return &quot;0&quot;;</span><br><span class="line">        while (_uint != 0) &#123;</span><br><span class="line">            //取模</span><br><span class="line">            uint256 remainder = _uint % 10;</span><br><span class="line">            //每取一位就移动一位，个位、十位、百位、千位……</span><br><span class="line">            _uint = _uint / 10;</span><br><span class="line">            //将字符拼接，注意字符位置</span><br><span class="line">            str =  string.concat(toStr(remainder), str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function toStr(uint256 num_) internal pure returns (string memory) &#123;</span><br><span class="line">        require(num_ &lt; 10,&quot;error&quot;);</span><br><span class="line">        bytes memory alphabet = &quot;0123456789&quot;;</span><br><span class="line">        bytes memory str = new bytes(1);</span><br><span class="line">        str[0] = alphabet[num_];</span><br><span class="line">        return string(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-初识</title>
      <link href="/2022/06/09/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/01-%E5%88%9D%E8%AF%86/"/>
      <url>/2022/06/09/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity0.8/01-%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p>Solidity 是在兼容 EVM 的区块链上开发智能合约的语言，我们不需要关心所在区块链底层逻辑，只要是兼容 EVM 的公链，我们都可以使用 Solidity 进行智能合约的编码。简单了解以下的区块链概念：</p><h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1><p>你可能听过区块链的双花攻击，女巫攻击等作恶方式。如果你没有听过也没有关系，因为它们对于智能合约开发来说并不重要，我们编写的 Solidity 代码能运行在以太坊网络，也可以运行在 BSC， Matic，Eos EVM 网络等，就像前文说的那样，无论他们采用什么底层逻辑，只要它们支持 EVM 就足够了，底层逻辑不用关心。</p><p>我们需要关心的是，<strong>区块可能被回滚，交易可能被作废</strong>，所以会出现你发起的交易被回滚甚至从区块链中抹除掉的可能。区块链不能保证当前的交易一定包含在下一个区块中。如果你开发的合约有顺序关系，要注意这个特性。合约内的逻辑，不能将某一个块作为依赖。</p><h1 id="合约代码中的三种注释"><a href="#合约代码中的三种注释" class="headerlink" title="合约代码中的三种注释"></a>合约代码中的三种注释</h1><p>我们看到第一行的代码是 <code>// SPDX-License-Identifier: MIT</code> 这里面的 <code>//</code> 符号，是注释符。用来标记和记录代码开发相关的事情，注释的内容是不会被程序运行，Solidity 支持单行注释和块注释，注释是为了更好的解释代码。<strong>请不要相信好的代码不需要注释这种鬼言论</strong>。代码中加入注释可以更好的团队协作，让自己更好的进行代码开发，以及让阅读者更快捷的理解代码逻辑。在实际工作中经常会出现自己写的代码一年半载之后再看，复杂些的逻辑可能需要浪费很多时间在代</p><h2 id="2-1-单行注释"><a href="#2-1-单行注释" class="headerlink" title="2.1 单行注释"></a>2.1 单行注释</h2><p>格式: <code>// 注释内容</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">// 这是单行注释</span><br></pre></td></tr></table></figure><p>如上，<code>//</code> 后面的内容都会被编译器忽略，为了可读性，一般会在<code>//</code>后面加一个空格。</p><h2 id="2-2-块注释"><a href="#2-2-块注释" class="headerlink" title="2.2 块注释"></a>2.2 块注释</h2><p>格式如下，在 <code>/*</code> 与 <code>*/</code> 之间的内容，都被编译器忽略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">这是块注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>为了可读性，一般块注释的行首都加 <code>*</code> 和空格，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 这是块注释</span><br><span class="line">* 这是块注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="2-3-NatSpec-描述注释"><a href="#2-3-NatSpec-描述注释" class="headerlink" title="2.3 NatSpec 描述注释"></a>2.3 NatSpec 描述注释</h2><p>单行使用 <code>///</code> 开始，多行使用 <code>/**</code> 开头以 <code>*/</code> 结尾。NatSpec 描述注释的作用非常重要，它是为函数、返回变量等提供丰富的文档。在编写合约的时候，强烈推荐使用 <code>NatSpec</code> 为所有的开放接口（只要是在 <code>ABI</code> 里呈现的内容）进行完整的注释。</p><h4 id="简单演示"><a href="#简单演示" class="headerlink" title="简单演示"></a>简单演示</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">/// @title  一个简单的数据存储演示</span><br><span class="line">/// @author Anbang</span><br><span class="line">/// @notice 您智能将此合约用于最基本的演示</span><br><span class="line">/// @dev    提供了存储方法/获取方法</span><br><span class="line">/// @custom  自定义的描述/这个是实验的测试合约</span><br><span class="line">contract  TinyStorage &#123;</span><br><span class="line">    // data</span><br><span class="line">    uint256 storedData;</span><br><span class="line"></span><br><span class="line">    /// @notice 储存 x</span><br><span class="line">    /// @param _x: storedData 将要修改的值</span><br><span class="line">    /// @dev   将数字存储在状态变量 storedData 中</span><br><span class="line">    function set(uint256 _x) public&#123;</span><br><span class="line">        storedData = _x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// @notice 返回存储的值</span><br><span class="line">    /// @return 储存值</span><br><span class="line">    /// @dev   检索状态变量 storedData 的值</span><br><span class="line">    function get() public view returns(uint256)&#123;</span><br><span class="line">        return storedData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice 第二种写法</span><br><span class="line">     * @param _x: XXXXX</span><br><span class="line">     * @dev   XXXXX</span><br><span class="line">     * @return XXXXX</span><br><span class="line">     * @inheritdoc :</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面所有标签都是可选的。下表解释了每个 NatSpec 标记的用途以及可以使用在哪些位置。我们可以选择合适的标记进行记录</p><table><thead><tr><th>标签</th><th>说明</th><th>语境</th></tr></thead><tbody><tr><td><code>@title</code></td><td>描述 contract&#x2F;interface 的标题</td><td>contract, interface, library</td></tr><tr><td><code>@author</code></td><td>作者姓名</td><td>contract, interface, library</td></tr><tr><td><code>@notice</code></td><td>向最终用户解释这是做什么的</td><td>contract, interface, library, function, 公共状态变量 event</td></tr><tr><td><code>@dev</code></td><td>向开发人员解释任何额外的细节</td><td>contract, interface, library, function, 状态变量, event</td></tr><tr><td><code>@param</code></td><td>记录参数（后面必须跟参数名称）</td><td>function, event, 自定义错误</td></tr><tr><td><code>@return</code></td><td>函数的返回变量</td><td>function, 公共状态变量</td></tr><tr><td><code>@inheritdoc</code></td><td>从基本函数中复制所有缺失的标签（必须后跟合约名称）</td><td>function, 公共状态变量</td></tr><tr><td><code>@custom:...</code></td><td>自定义标签，语义由应用程序定义</td><td>所有位置均可以</td></tr></tbody></table><h4 id="文档输出"><a href="#文档输出" class="headerlink" title="文档输出"></a>文档输出</h4><p>使用 <code>NatSpec</code> 描述注释的另一个好处是，当被编译器解析时，上面示例中的代码将生成两个不同的 JSON 文件。</p><ul><li>User Documentation：供最终用户在执行功能时作为通知使用的</li><li>Developer Documentation：供开发人员使用的。</li></ul><p>如果将上述合约另存为，<code>a.sol</code> 则您可以使用以下命令生成文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solc --userdoc --devdoc a.sol</span><br></pre></td></tr></table></figure><h4 id="继承说明"><a href="#继承说明" class="headerlink" title="继承说明"></a>继承说明</h4><p>TODO: 在后面合约继承的时候再演示使用。</p><p>如果函数是继承别的合约，没有 NatSpec 的函数将自动继承其基本函数的文档。但是下面三种情况是例外的：</p><ul><li>当参数名称不同时。<ul><li>这时候是函数的重载，函数签名已经发生了改变。</li></ul></li><li>当有多个基本功能时。<ul><li>这时候因为发生了冲突，supper 中有多个父级</li></ul></li><li>当有一个明确的 <code>@inheritdoc</code> 标签指定应该使用哪个合约来继承时。</li></ul><p>更多 NatSpec 请参考: <a href="https://github.com/aragon/radspec">https://github.com/aragon/radspec</a></p><h1 id="合约结构介绍"><a href="#合约结构介绍" class="headerlink" title="合约结构介绍"></a>合约结构介绍</h1><h2 id="3-1-SPDX-版权声明https-spdx-org-licenses"><a href="#3-1-SPDX-版权声明https-spdx-org-licenses" class="headerlink" title="3.1 SPDX 版权声明https://spdx.org/licenses/"></a>3.1 SPDX 版权声明<a href="https://spdx.org/licenses/">https://spdx.org/licenses/</a></h2><p> <code>// SPDX-License-Identifier: MIT</code> 就是合约的版权声明。其中 <strong>SPDX-License-Identifier</strong>(SPDX 许可标示) 是标注当前的智能合约采用什么样的对外开放标准，该标准规定了别人是否拥有商业开发，学习使用等权利。代码中使用的 <code>MIT</code> 规定了其他人随便用该代码，但出问题不负责。SPDX 许可标示的注释在文件的任何位置都可以被编译器识别到的，按照规范建议把它放在文件的顶部第一行。</p><p>如果一个项目开源了智能合约的源代码，可以更好地建立社区信任。但是由于提供源代码就不可避免的涉及到版权或者法律问题。所以 solidity 鼓励开源，但是开源并不等于放弃版权。如果你不想指定任何许可证，或者代码就是不想开源，Solidity 推荐使用 <code>UNLICENSED</code> ;<code>UNLICENSED</code> 不存在于 SPDX 许可证列表中,与 UNLICENSE （授予所有人所有权利）不同，它比 <code>UNLICENSE</code> 多一个 <code>D</code> 字母。</p><p>需要注意: 源代码这里，编译器不会验证 SPDX 许可标示是否符合规范，比如我可以写为 <code>// SPDX-License-Identifier: ANBANG</code> ，并不会影响代码的运行。但是这里的标示会被打包在 <code>bytecode metadata</code> 里。</p><h2 id="3-2-pragma-solidity-版本限制"><a href="#3-2-pragma-solidity-版本限制" class="headerlink" title="3.2 pragma solidity 版本限制"></a>3.2 pragma solidity 版本限制</h2><p> <code>pragma solidity ^0.8.17;</code> 指令，它是告诉编译器，我当前的合约代码采用的是 Solidity 0.8.17 这个版本为基础编写的，解析部署时需要在匹配的版本下进行，在区块链浏览器上进行合约验证时，也需要选择匹配的版本。</p><p>而 <code>^0.8.17</code> 中的 <code>^</code> 表示小版本兼容，大版本不兼容，相当于 <code>pragma solidity &gt;= 0.8.17 &lt; 0.9.0;</code>。他既不允许低于<code>0.8.17</code>的编译器编译，也不允许大于等于 <code>0.9.0</code> 版本的编译器进行编译。之所以这么写，不写死 <code>pragma solidity 0.8.17;</code> 是为了可以享受到编译器的补丁版，比如以后出来了 <code>0.8.40</code> 版本，那么当前合约是可以运行在未来的 <code>0.8.40</code> 这个新版本的编译器。但是如果是大版本升级到了 <code>0.9.0</code>，那么编译器不会用新版的<code>0.9.x</code>解析，会使用 0.8 的最后一个稳定版本来进行解析编译。这里如果不加 <code>^</code>,直接写<code>pragma solidity 0.8.17;</code>,就是告诉编译器，当前合约只选择在 <code>0.8.17</code> 版本来编译和部署；这样做的缺点就是享受不到以后出的补丁版的编译器。</p><p>如果你打算跨大版本的合约，可以使用<code>&gt;</code> &#x2F;<code>&gt;=</code>&#x2F;<code>&lt;</code>&#x2F;<code>&lt;=</code>来操作，比如 <code>pragma solidity &gt;=0.7.0 &lt;0.9.0;</code>。</p><blockquote><p>注意：<code>pragma</code> 指令只对当前的源文件起作用，如果把文件 <code>B</code> 导入到文件 <code>A</code>，文件 B 的 pragma 将不会自动应用于文件 A。</p></blockquote><h1 id="import-导入声明"><a href="#import-导入声明" class="headerlink" title="import 导入声明"></a>import 导入声明</h1><p>功能：从其他文件内倒入需要的变量或者函数。</p><p>既可以导入<strong>本地文件</strong>，也可以导入 <strong>url</strong>(网络上的 ipfs，http 或者 git 文件)</p><ol><li><p>导入所有的全局标志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;filename&quot;;</span><br></pre></td></tr></table></figure><p>到当前全局范围</p><ol><li>导入本地文件:<code>import &quot;./ERC20.sol&quot;;</code>，其中<code>./</code>表示当前目录，查找路径参考</li><li>导入网络文件:<code>import &quot;https://github.com/aaa/.../tools.sol&quot;;</code></li><li>导入本地 NPM 库:<ol><li><code>$ npm install @openzeppelin/contracts</code></li><li><code>import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;;</code></li></ol></li></ol></li><li><p>导入所有的全局标志，并创建新的全局符号</p><ol><li>方式一: <code>import * as symbolName from &quot;filename&quot;;</code></li><li>方式二: <code>import &quot;filename&quot; as symbolName;</code></li></ol></li><li><p>按需导入，按需修改名称</p><ol><li><code>import &#123;symbol1 as aliasName, symbol2&#125; from &quot;filename&quot;;</code></li></ol></li></ol><p>不推荐导入变量标示名到当前全局范围的方式，因为不可控，容易污染当前的命名空间。如果全局导入，推荐使用 <code>import &quot;filename&quot; as symbolName;</code></p><p>注：一份源文件可以包含多个版本声明、多<strong>个导入声明</strong>和多个合约声明。</p><h1 id="fallback"><a href="#fallback" class="headerlink" title="fallback"></a>fallback</h1><p>fallback 函数是调用合约没有的方法时候执行，同时也可以设置为允许接收网络主币。</p><ul><li><p>语法</p><ul><li>不带参数: <code>fallback () external [payable]</code></li><li>带参数: <code>fallback (bytes calldata input) external [payable] returns (bytes memory output)</code></li><li>没有<code>function</code>关键字。必须是<code>external</code>可见性，</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// function fallback() external payable &#123;&#125;</span><br><span class="line">// 正确写法不带 function，直接写 fallback，fallback 如果使用 function 修饰，则有警告</span><br><span class="line">// This function is named &quot;fallback&quot; but is not the fallback function of the contract.</span><br><span class="line">// If you intend this to be a fallback function, use  &quot;fallback(...) &#123; ... &#125;&quot; without</span><br><span class="line">// the &quot;function&quot; keyword to define it.</span><br></pre></td></tr></table></figure></li></ul><p><strong>回退函数在两种情况被调用</strong>：</p><ul><li>向合约转账；<ul><li>如果使用 call 转账，会执行 fallback。</li><li>如果使用合约内已有的 <code>deposit</code> 转账，不会执行 fallback</li></ul></li><li>执行合约不存在的方法<ul><li>就会执行 fallback 函数。（执行合约不存在的方法时执行）</li></ul></li></ul><h1 id="receive-以太函数"><a href="#receive-以太函数" class="headerlink" title="receive 以太函数"></a>receive 以太函数</h1><p>receive 只负责接收主币,一个合约最多有一个 <code>receive</code> 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">receive() external payable &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>没有 <code>function</code> 关键字</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// function receive() external payable &#123;&#125;</span><br><span class="line">// receive 如果使用 function 修饰，则有如下警告</span><br><span class="line">// This function is named &quot;receive&quot; but is not the receive function of</span><br><span class="line">// the contract. If you intend this to be a receive function,</span><br><span class="line">// use &quot;receive(...) &#123; ... &#125;&quot; without the &quot;function&quot; keyword to define it.</span><br></pre></td></tr></table></figure><ul><li><p>receive 函数类型必须是 <code>payable</code> 的，并且里面的语句只有在通过外部地址往合约里转账的时候执行。</p></li><li><p>它可以是 <code>virtual</code> 的，可以被重载也可以有 修改器(modifier) 。</p></li><li><p>如果没有定义 <code>接收函数 receive</code>，就会执行 <code>fallback</code> 函数。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    event Log(string funName, address from, uint256 value, bytes data);</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        // receive 被调用的时候不存在 msg.data，所以不使用这个，直接用空字符串</span><br><span class="line">        emit Log(&quot;receive&quot;, msg.sender, msg.value, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() external view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子通过 calldata 执行转账，无参数时候会触发 receive 函数。但是如果有参数，比如<code>0x00</code>,则会报错 <em>‘Fallback’ function is not defined</em></p><p>在对合约没有任何附加数据调用（通常是对合约转账）是会执行 <code>receive</code>函数．例如　通过 <code>.send()</code> or <code>.transfer()</code>。</p><p>声明为 payable 之后，其所消耗的 gas 最大量就会被限定在 2300。除了基础的日志输出之外，进行其他操作的余地很小。下面的操作消耗会操作 2300 gas :</p><p>扩展阅读 ⚠️: 一个没有 receive 函数的合约，可以作为 <em>coinbase 交易</em> （又名<em>矿工区块回报</em> ）的接收者或者作为 <code>selfdestruct</code> 的目标来接收以太币。一个合约不能对这种以太币转移做出反应，因此也不能拒绝它们。这是 EVM 在设计时就决定好的，而且 Solidity 无法绕过这个问题。这也意味着 <code>address(this).balance</code> 可以高于合约中实现的一些手工记帐的总和（例如在 receive 函数中更新的累加器记帐）。</p><h1 id="receive-和-fallback-共存的调用"><a href="#receive-和-fallback-共存的调用" class="headerlink" title="receive 和 fallback 共存的调用"></a>receive 和 fallback 共存的调用</h1><p>注意：这里 fallback 需要是 <code>payable</code> 类型的。如下图:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    调用时发送了ETH</span><br><span class="line">            |</span><br><span class="line">判断 msg.data 是否为空</span><br><span class="line">          /     \</span><br><span class="line">        是       否</span><br><span class="line">是否存在 receive   fallbak()</span><br><span class="line">      /   \</span><br><span class="line">    存在   不存在</span><br><span class="line">    /        \</span><br><span class="line">receive()   fallbak()</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p><strong>总结</strong>: 只有 <code>msg.data</code> 为空，并且存在 <code>receive</code> 的时候，才会运行 <code>receive</code>。</p><p>如果不存在 <code>receive</code> 以太函数，<code>payable</code> 的 <code>fallback</code> 函数也可以在纯以太转账的时候执行。但是推荐总是定义一个 receive 函数，而不是定义一个 payable 的 fallback 函数。</p><h1 id="selfdestruct-合约自毁"><a href="#selfdestruct-合约自毁" class="headerlink" title="selfdestruct:合约自毁"></a>selfdestruct:合约自毁</h1><p>合约代码从区块链上移除的唯一方式是合约在合约地址上的执行自毁操作 <code>selfdestruct</code> 。<code>selfdestruct</code> 作用是 <strong>销毁合约</strong>，并<strong>把余额发送到指定地址类型 Address</strong>。</p><p>做了两件事：</p><ul><li>销毁合约:它使合约变为无效，删除该地址地字节码。</li><li>它把合约的所有资金强制发送到目标地址。<ul><li>如果接受的地址是合约，即使里面没有 <code>fallback</code> 和 <code>receive</code> 也会发送过去</li></ul></li><li>除非必要，不建议销毁合约。<ul><li>如果有人发送以太币到移除的合约，这些以太币可能将永远丢失</li><li>如果要禁用合约，可以通过修改某个内部状态让所有函数无法执行，这样也可以达到目的。</li></ul></li><li>即便一个合约的代码中没有显式地调用 <code>selfdestruct</code>，它仍然有可能通过 <code>delegatecall</code> 或 <code>callcode</code> 执行自毁操作。</li></ul><p>⚠️：即使一个合约被 <code>selfdestruct</code> 删除，它仍然是区块链历史的一部分，区块链的链条中不可能无缘无故消失一个块，这样他们就没办法做校验了。 因此，使用 <code>selfdestruct</code> 与从硬盘上删除数据是不同的。</p><p>请注意 <code>selfdestruct</code> 具有从 EVM 继承的一些特性：</p><ul><li>接收合约的 <code>receive</code> 函数 不会执行。</li><li>合约仅在交易结束时才真正被销毁，并且 <code>revert</code> 可能会“撤消”销毁。此外，当前合约内的所有函数都可以被直接调用，包括当前函数。</li></ul><h2 id="8-1自我毁灭"><a href="#8-1自我毁灭" class="headerlink" title="8.1自我毁灭"></a>8.1自我毁灭</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Kill &#123;</span><br><span class="line">    uint256 public aaa = 123;</span><br><span class="line"></span><br><span class="line">    function kill() external&#123;</span><br><span class="line">        selfdestruct(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-2通过合约调用毁灭"><a href="#8-2通过合约调用毁灭" class="headerlink" title="8.2通过合约调用毁灭"></a>8.2通过合约调用毁灭</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Kill &#123;</span><br><span class="line">    uint256 public aaa = 123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function kill() external &#123;</span><br><span class="line">        selfdestruct(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Helper &#123;</span><br><span class="line">    // 没有 `fallback` 和 `receive`，正常没办法接受ETH主币</span><br><span class="line">    function getBalance() external view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // kill 后，此时 Helper 余额就会强制收到ETH主币</span><br><span class="line">    function kill(Kill _kill) external &#123;</span><br><span class="line">        _kill.kill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h1><ul><li><p><strong>栈</strong>：合约的所有计算都在一个被称为栈（stack）的区域执行，栈最大有 1024 个元素，每一个元素长度是 256 bit；所以调用深度被限制为 1024 ，对复杂的操作，推荐使用循环而不是递归。</p></li><li><p><code>string message = &quot;Hello World!&quot;;</code> 这种没有明确标注可视范围的情况下，<code>message</code> 的可视范围是什么? 是 <code>internal</code> 还是 <code>private</code>?</p><ul><li>private</li></ul></li><li><p>合约进行<code>selfdestruct</code>后，还可以调用状态变量和函数么？</p><ul><li>可以调用，但是返回默认值。如果想调用，也可以在存档节点里指定未删除的高度进行调用。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Solidity0.8.17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity0.8.17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>控制Gas成本</title>
      <link href="/2022/06/06/%E5%8C%BA%E5%9D%97%E9%93%BE/Gas%E4%BC%98%E5%8C%96/%E6%8E%A7%E5%88%B6Gas%E6%88%90%E6%9C%AC/"/>
      <url>/2022/06/06/%E5%8C%BA%E5%9D%97%E9%93%BE/Gas%E4%BC%98%E5%8C%96/%E6%8E%A7%E5%88%B6Gas%E6%88%90%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="优化合约"><a href="#优化合约" class="headerlink" title="优化合约"></a>优化合约</h1><p>Solidity 编译器内置了一些优化器来改进合约的执行效率和生成更高效的字节码：</p><p>使用<code>--optimize</code>选项来启用优化器,使用<code>--optimize-runs</code>选项来指定优化器运行的次数</p><p><strong>solc –optimize (–optimize-runs 200) MyContract.sol</strong> </p><p>truffle、hardhat、Remix中都有配置这个选项</p><h1 id="与永久性存储交互"><a href="#与永久性存储交互" class="headerlink" title="与永久性存储交互"></a>与永久性存储交互</h1><blockquote><p>以太坊上有三种数据存储位置： 内存（memory）、（永久性）存储（storage）以及调用数据calldata</p></blockquote><p>查看<a href="https://ethereum.github.io/yellowpaper/paper.pdf"><em>以太坊黄皮书</em></a> 附录G 全面了解EVM操作码成本。</p><p>永久性存储操作码(<code>SSTORE</code>)非常昂贵。首次写插槽时，每个32个字节的当前成本是为20,000 Gas(在10 Gwei gas价格下为5美分，每ETH为250美元)，而后续每次修改则为5,000 Gas。尽管从理论上讲复杂度成本是<code>恒定的</code>，但它却是算术或内存运算成本的一千倍以上，而算术或内存运算的成本通常不到10 Gas。目前整个区块(截至2020年10月)的Gas限制为〜12,000,000 Gas实，开发人员应设计其智能合约以最大程度地减少所需的存储插槽数量。</p>]]></content>
      
      
      <categories>
          
          <category> Gas优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Gas优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>节省Gas的合约</title>
      <link href="/2022/06/06/%E5%8C%BA%E5%9D%97%E9%93%BE/Gas%E4%BC%98%E5%8C%96/%E8%8A%82%E7%9C%81Gas%E7%9A%84%E5%90%88%E7%BA%A6/"/>
      <url>/2022/06/06/%E5%8C%BA%E5%9D%97%E9%93%BE/Gas%E4%BC%98%E5%8C%96/%E8%8A%82%E7%9C%81Gas%E7%9A%84%E5%90%88%E7%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="使用短路模式排序Solidity操作"><a href="#使用短路模式排序Solidity操作" class="headerlink" title="使用短路模式排序Solidity操作"></a>使用短路模式排序Solidity操作</h1><p>短路（short-circuiting）是一种使用或&#x2F;与逻辑来排序不同成本操作的solidity合约 开发模式，它<strong>将低gas成本的操作放在前面</strong>，高gas成本的操作放在后面，这样如果前面的低成本操作可行，就可以跳过（短路）后面的高成本以太坊虚拟机操作了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f(x) 是低gas成本的操作</span></span><br><span class="line"><span class="comment">// g(y) 是高gas成本的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按如下排序不同gas成本的操作</span></span><br><span class="line"><span class="built_in">f</span>(x) || <span class="built_in">g</span>(y)</span><br><span class="line"><span class="built_in">f</span>(x) &amp;&amp; <span class="built_in">g</span>(y)</span><br></pre></td></tr></table></figure><h1 id="删减不必要的Solidity库"><a href="#删减不必要的Solidity库" class="headerlink" title="删减不必要的Solidity库"></a>删减不必要的Solidity库</h1><p>在开发Solidity智能合约时，我们引入的库<strong>通常只需要用到其中的部分功能</strong>，这意味着其中可能会包含大量对于你的智能合约而言其实是冗余的solidity代码。如果可以在你自己的合约里安全有效地实现所依赖的库功能，那么就能够达到优化solidity合约的gas利用的目的。</p><p>例如，在下面的solidity代码中，我们的以太坊合约只是用到了SafeMath库的<code>add</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;./SafeMath.sol&#x27; as SafeMath;</span><br><span class="line"></span><br><span class="line">contract SafeAddition &#123;</span><br><span class="line"> function safeAdd(uint a, uint b) public pure returns(uint) &#123;</span><br><span class="line"> return SafeMath.add(a, b);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过参考SafeMath的这部分代码的实现，可以把对这个solidity库的依赖剔除掉：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract SafeAddition &#123;</span><br><span class="line"> function safeAdd(uint a, uint b) public pure returns(uint) &#123;</span><br><span class="line"> uint c = a + b;</span><br><span class="line"> require(c &gt;= a, &quot;Addition overflow&quot;);</span><br><span class="line"> return c;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="精确声明Solidity合约函数的可见性"><a href="#精确声明Solidity合约函数的可见性" class="headerlink" title="精确声明Solidity合约函数的可见性"></a>精确声明Solidity合约函数的可见性</h1><p>在Solidity合约开发中，显式声明函数的可见性不仅可以提高智能合约的安全性， 同时也有利于优化合约执行的gas成本。例如，通过显式地标记函数为外部函数（External），可以强制将函数参数的存储位置设置为<code>calldata</code>，这会节约每次函数执行时所需的以太坊gas成本。</p><blockquote><p>External 可见性比 public 消耗gas 少</p></blockquote><h1 id="使用适合的数据类型"><a href="#使用适合的数据类型" class="headerlink" title="使用适合的数据类型"></a>使用适合的数据类型</h1><p>在Solidity中，有些数据类型要比另外一些数据类型的gas成本高。有必要 了解可用数据类型的gas利用情况，以便根据你的需求选择效率最高的那种。 下面是关于solidity数据类型gas消耗情况的一些规则：</p><ul><li>在任何可以使用<code>uint</code>类型的情况下，不要使用<code>string</code>类型</li><li>存储uint256要比存储uint8的gas成本低，为什么？点击这里查看<a href="https://ethereum.stackexchange.com/questions/3067/why-does-uint8-cost-more-gas-than-uint256">原文</a></li><li>当可以使用<code>bytes</code>类型时，不要在solidity合约种使用<code>byte[]</code>类型</li><li>如果<code>bytes</code>的长度有可以预计的上限，那么尽可能改用bytes1~bytes32这些具有固定长度的solidity类型</li><li>bytes32所需的gas成本要低于string类型</li></ul><h1 id="避免Solidity智能合约中的死代码"><a href="#避免Solidity智能合约中的死代码" class="headerlink" title="避免Solidity智能合约中的死代码"></a>避免Solidity智能合约中的死代码</h1><p>死代码（Dead code）是指那些永远也不会执行的Solidity代码，例如那些执行条件永远也不可能满足的代码，就像下面的两个自相矛盾的条件判断里的Solidity代码块，消耗了以太坊gas资源但没有任何作用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function deadCode(uint x) public pure &#123;</span><br><span class="line"> if(x &lt; 1) &#123;</span><br><span class="line">    if(x &gt; 2) &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="避免使用不必要的条件判断"><a href="#避免使用不必要的条件判断" class="headerlink" title="避免使用不必要的条件判断"></a>避免使用不必要的条件判断</h1><p>有些条件断言的结果不需要Solidity代码的执行就可以知道结果，那么这样的条件判断就可以精简掉。例如下面的Solidity合约代码中的两级判断条件，内层的判断是在浪费宝贵的以太坊gas资源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function opaquePredicate(uint x) public pure &#123;</span><br><span class="line"> if(x &lt; 1) &#123;</span><br><span class="line">    if(x &lt; 0 ) &#123;  // uint 不可能小于0</span><br><span class="line">    return x;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="避免在循环中执行gas成本高的操作"><a href="#避免在循环中执行gas成本高的操作" class="headerlink" title="避免在循环中执行gas成本高的操作"></a>避免在循环中执行gas成本高的操作</h1><p>由于<code>SLOAD</code>和<code>SSTORE</code>操作码的成本高昂，因此管理storage变量的gas成本 要远远高于内存变量，所以要避免在循环中操作storage变量。例如下面的 solidity 代码中，<code>num</code>变量是一个storage变量，那么未知循环次数的若干次操作，很可能会造成solidity开发者意料之外的以太坊gas消耗黑洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint num = 0;</span><br><span class="line"></span><br><span class="line">function expensiveLoop(uint x) public &#123;</span><br><span class="line">  for(uint i = 0; i &lt; x; i++) &#123;</span><br><span class="line">    num += 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决上述以太坊合约代码问题的方法，是创建一个solidity临时变量 来代替上述全局变量参与循环，然后在循环结束后重新将临时变量的值赋给全局状态变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint num = 0;</span><br><span class="line"></span><br><span class="line">function lessExpensiveLoop(uint x) public &#123;</span><br><span class="line">  uint temp = num;</span><br><span class="line">  for(uint i = 0; i &lt; x; i++) &#123;</span><br><span class="line">    temp += 1;</span><br><span class="line">  &#125;</span><br><span class="line">  num = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="避免使用常量结果的循环"><a href="#避免使用常量结果的循环" class="headerlink" title="避免使用常量结果的循环"></a>避免使用常量结果的循环</h1><p>如果一个循环计算的结果是无需编译执行Solidity代码就可以预测的，那么 就不要使用循环，这可以可观地节省gas。例如下面的以太坊合约代码就可以 直接设置num变量的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function constantOutcome() public pure returns(uint) &#123;</span><br><span class="line">  uint num = 0;</span><br><span class="line">  for(uint i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">    num += 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="合并循环"><a href="#合并循环" class="headerlink" title="合并循环"></a>合并循环</h1><p>有时候在Solidity智能合约中，你会发现两个循环的判断条件一致，那么在这种情况下就没有理由不合并它们。例如下面的以太坊合约代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function loopFusion(uint x, uint y) public pure returns(uint) &#123;</span><br><span class="line">  for(uint i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">    x += 1;</span><br><span class="line">  &#125;</span><br><span class="line">  for(uint i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">    y += 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="避免循环中的重复计算"><a href="#避免循环中的重复计算" class="headerlink" title="避免循环中的重复计算"></a>避免循环中的重复计算</h1><p>如果循环中的某个Solidity表达式在每次迭代都产生同样的结果，那么就可以将其 移出循环先行计算，从而节省掉循环中额外的gas成本。如果表达式中使用的变量是storage变量， 这就更重要了。例如下面的智能合约代码中表达式<code>a*b</code>的值，并不需要每次迭代重新计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint a = 4;</span><br><span class="line">uint b = 5;</span><br><span class="line">function repeatedComputations(uint x) public returns(uint) &#123;</span><br><span class="line">  uint sum = 0;</span><br><span class="line">  for(uint i = 0; i &lt;= x; i++) &#123;</span><br><span class="line">    sum = sum + a * b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="去除循环中的比较运算"><a href="#去除循环中的比较运算" class="headerlink" title="去除循环中的比较运算"></a>去除循环中的比较运算</h1><p>如果在循环的每个迭代中执行比较运算，但每次的比较结果都相同，则应将其从循环中删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function unilateralOutcome(uint x) public returns(uint) &#123;</span><br><span class="line">  uint sum = 0;</span><br><span class="line">  for(uint i = 0; i &lt;= 100; i++) &#123;</span><br><span class="line">    if(x &gt; 1) &#123;</span><br><span class="line">      sum += 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="不要存储不必要的数据"><a href="#不要存储不必要的数据" class="headerlink" title="不要存储不必要的数据"></a>不要存储不必要的数据</h1><p>这听起来似乎很明显，但是非常值得一提。编写智能合约时，你应该只存储交易验证所需的内容。与合约逻辑无关的交易记录或详细说明之类的数据可能不需要保存在合约存储中。</p><h1 id="将多个小变量打包到单个字中"><a href="#将多个小变量打包到单个字中" class="headerlink" title="将多个小变量打包到单个字中"></a>将多个小变量打包到单个字中</h1><blockquote><p>译者注：标题中的”字”, 也称为字长，表示每个指令操作的数据长度。</p></blockquote><p>EVM在32字节字长存储模型下运行。可以将小于32个字节的多个变量打包到一个存储槽中，以最大程度地减少<code>SSTORE</code>操作码的数量。尽管Solidity <a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html">自动尝试将小的基本类型打包到同一插槽中</a>，但是糟糕的结构体成员排序可能会阻止编译器执行此操作。考虑下面的<code>Good</code>和<code>Bad</code>结构体。</p><p><img src="/noteimg/%E5%8C%BA%E5%9D%97%E9%93%BE/Gas%E4%BC%98%E5%8C%96/img/MGf38d9w.png" alt="Image for post"></p><p>第一个<code>doBad()</code>函数调用执行消耗约60,000 Gas，而<code>doGood()</code>仅消耗约40,000 Gas。注意是一个字长存储的差异(20,000 Gas)，因为<code>Good</code>结构将两个uint128打包为一个字。</p><h1 id="在合约的字节码中存储值"><a href="#在合约的字节码中存储值" class="headerlink" title="在合约的字节码中存储值"></a>在合约的字节码中存储值</h1><p>一种相对便宜的存储和读取信息的方法是，将信息部署在区块链上时，直接将其包含在智能合约的字节码中。不利之处是此值以后不能更改。但是，用于加载和存储数据的 gas 消耗将大大减少。有两种可能的实现方法：</p><ol><li>将变量声明为 <em>constant</em> 常量 (声明为 <a href="https://learnblockchain.cn/article/1059">immutable</a> 同样也可以降低 gas)</li><li>在你要使用的任何地方对其进行硬编码。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint256 public v1;</span><br><span class="line">uint256 public constant v2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params"></span>) returns (uint256 result) &#123;</span><br><span class="line">    <span class="keyword">return</span> v1 * v2 * <span class="number">10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量<em>v1</em> 是合约状态的一部分，而<em>v2</em>和<em>1000</em>是合约字节码的一部分。</p><h1 id="带有-数字的变量，读取时候花费-gas-更少"><a href="#带有-数字的变量，读取时候花费-gas-更少" class="headerlink" title="带有_数字的变量，读取时候花费 gas 更少"></a>带有<code>_</code>数字的变量，读取时候花费 gas 更少</h1>]]></content>
      
      
      <categories>
          
          <category> Gas优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Gas优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>驼峰命名</title>
      <link href="/2022/05/31/%E5%85%B6%E4%BB%96/%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D/"/>
      <url>/2022/05/31/%E5%85%B6%E4%BB%96/%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="驼峰命名法"><a href="#驼峰命名法" class="headerlink" title="驼峰命名法"></a>驼峰命名法</h1><p>在我们程序员编写代码的时候，如果大家的命名没有一个规范的话，当一个人去阅读另一个人的代码的时候，就会感到很乏力，难以理解。在大家互相在一起团结合作，共同完成任务的时候，需要定义一些规范的类名、方法名、变量名，为了让所有人都能理解，就需要大家去共同遵守一个符合要求的命名规范，合理应用命名规范能方便成员之间的协作，截止到目前为止，应用最广泛的应该就是驼峰命名法了。</p><h1 id="什么是驼峰命名法呢？"><a href="#什么是驼峰命名法呢？" class="headerlink" title="什么是驼峰命名法呢？"></a>什么是驼峰命名法呢？</h1><p>驼峰命名法是指多个单词组合在一起来标识一个特定的含义时，对每一个单词的首字母进行大小写要求，其中分为小驼峰法与大驼峰法：</p><ol><li><p>小驼峰法（一般用于变量名和方法名）</p><p>第一个单词首字母小写，其他单词首字母大写，如：getUserById、checkName等</p></li><li><p>大驼峰法（一般用于接口名和类名）</p><p>全部单词首字母大写，如：UserController、UserService等</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域问题</title>
      <link href="/2022/05/26/%E5%85%B6%E4%BB%96/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/26/%E5%85%B6%E4%BB%96/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h1><h2 id="为什么会出现跨域问题？"><a href="#为什么会出现跨域问题？" class="headerlink" title="为什么会出现跨域问题？"></a>为什么会出现跨域问题？</h2><p>因为浏览器有一个安全机制叫<a href="https://www.baidu.com/link?url=fD0KCfZLPdbJ5rM4wGnZXL08OxmS1XneXBoKh0bLzmVQU1YN9MWidxxsvvkm2wiaTcBxoY7xkJz25mSKZulp2OsGM3uMFiSfjD576Qj_GFqYRrfhEkIIEXt12fLwuV9b&wd=&eqid=89db0ba0002617250000000662df525d">同源策略</a>。同源就是指协议、域名、端口都一样，如果任意一项不一致就是不同源。简单点说就是，你的网页URL和你调用的接口URL不是一个地方的，浏览器觉得有安全风险，不想让你使用这个接口的数据。</p><h2 id="举例说明跨域的几种情况："><a href="#举例说明跨域的几种情况：" class="headerlink" title="举例说明跨域的几种情况："></a>举例说明跨域的几种情况：</h2><p>如果你当前的页面URL是 <a href="http://www.yaoqi.com/index.html%EF%BC%8C%E9%82%A3%E4%B9%88%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80%E5%A6%82%E4%B8%8B%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5">http://www.yaoqi.com/index.html，那么接口地址如下几种情况</a></p><ol><li><p><a href="https://www.yaoqi.com/xxx">https://www.yaoqi.com/xxx</a> （不同源，因为协议不同）</p></li><li><p><a href="http://www.yaoqi.com:8080/xxx">http://www.yaoqi.com:8080/xxx</a> （不同源，因为端口不同）</p></li><li><p><a href="http://www.notyaoqi.com/xxx">http://www.notyaoqi.com/xxx</a> （不同源，因为域名不同）</p></li><li><p><a href="http://aaa.yaoqi.com/xxx">http://aaa.yaoqi.com/xxx</a> （不同源，因为域名不同）</p></li><li><p><a href="http://www.yaoqi.com/xxx">http://www.yaoqi.com/xxx</a> （同源，协议、域名、端口均相同）</p></li></ol><h2 id="简单解决方法"><a href="#简单解决方法" class="headerlink" title="简单解决方法"></a>简单解决方法</h2><p>在网关中定义“CorsConfiguration”类，该类用来做过滤，允许所有的请求跨域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 添加过滤器</span></span><br><span class="line">    <span class="keyword">public</span> CorsWebFilter <span class="title function_">corsWebFilter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 基于url跨域，选择reactive包下的</span></span><br><span class="line">        UrlBasedCorsConfigurationSource source=<span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        <span class="comment">// 跨域配置信息</span></span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        <span class="comment">// 允许跨域的头</span></span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 允许跨域的请求方式</span></span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 允许跨域的请求来源</span></span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 是否允许携带cookie跨域</span></span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 任意url都要进行跨域配置</span></span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>,corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsWebFilter</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令</title>
      <link href="/2022/05/20/%E5%85%B6%E4%BB%96/Git%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/05/20/%E5%85%B6%E4%BB%96/Git%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h1><table><thead><tr><th align="left"><strong>命令名称</strong></th><th>作用</th></tr></thead><tbody><tr><td align="left">git config –global user.name 用户名</td><td>设置用户签名</td></tr><tr><td align="left">git config –global user.email 邮箱</td><td>设置用户签名</td></tr><tr><td align="left">git init</td><td>初始化本地库</td></tr><tr><td align="left">git status</td><td>查看本地库状态</td></tr><tr><td align="left">git add 文件名</td><td>添加到暂存区</td></tr><tr><td align="left">git commit -m “日志信息” 文件名</td><td>提交到本地库</td></tr><tr><td align="left">git reflog</td><td>查看历史记录</td></tr><tr><td align="left">git reset –hard 版本号</td><td>版本穿梭</td></tr></tbody></table><h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><table><thead><tr><th><strong>命令名称</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>git branch 分支名</td><td>创建分支</td></tr><tr><td>git branch -v</td><td>查看分支</td></tr><tr><td>git checkout 分支名</td><td>切换分支</td></tr><tr><td>git merge 分支名</td><td>把指定的分支合并到当前分支上</td></tr></tbody></table><h1 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h1><table><thead><tr><th>命令名称(别名&#x3D;远程地址)</th><th>作用</th></tr></thead><tbody><tr><td>git remote -v</td><td>查看当前所有远程地址别名</td></tr><tr><td>git remote add 别名 远程地址</td><td>起别名</td></tr><tr><td>git push 别名 分支</td><td>推送本地分支的内容到远程仓库</td></tr><tr><td>git  clone 别名</td><td>将远程仓库的内容克隆到本地</td></tr><tr><td>git pull 别名 远程分支名</td><td>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-SpringMvc</title>
      <link href="/2022/05/20/Java%E7%AC%94%E8%AE%B0/SpringMvc/2-SpringMvc/"/>
      <url>/2022/05/20/Java%E7%AC%94%E8%AE%B0/SpringMvc/2-SpringMvc/</url>
      
        <content type="html"><![CDATA[<h2 id="RequestMapping注解-将请求和控制器关联起来"><a href="#RequestMapping注解-将请求和控制器关联起来" class="headerlink" title="@RequestMapping注解:将请求和控制器关联起来"></a>@RequestMapping注解:将请求和控制器关联起来</h2><p>标识一个类时：设置请求的初始信息</p><p>标识一个方法时：设置请求的具体信息</p><p>这个注解里面还有很多属性：</p><ul><li>value:设置多个请求映射的地址</li><li>method：设置能通过的请求方式（springmvc提供了扩展注解：@GetMapping、@PostMapping、@PutMapping、@DeleteMapping）</li><li>params：设置能通过的请求必须携带的请求参数</li><li>headers：设置能通过的请求必须携带的请求头参数</li></ul><h3 id="请求过来了那当然就是如何获取参数了？"><a href="#请求过来了那当然就是如何获取参数了？" class="headerlink" title="请求过来了那当然就是如何获取参数了？"></a>请求过来了那当然就是如何获取参数了？</h3><ol><li><p>通过ServletAPI获取：将HttpServletRequest作为控制器的形参，会封装放弃那请求的请求参数</p></li><li><p>通过控制器方法获取：当控制器的形参名和请求参数名相同时，DispatcherServlet会将请求参数自动赋值给形参</p></li><li><p>@RequestParam：将请求参数与控制器形参创建映射关系，标注在形参前面，获取请求参数名与形参名相同的，有三个属性（value：指定形参赋值的参数名、required：设置请求参数是否必须、defaultValue：默认值为参数名）</p></li><li><p>@RequestHeader：将请求头信息与控制器形参创建映射关系，用法与@RequestParam</p></li><li><p>@CookieValue：将Cookie数据与控制器形参创建映射关系，用法与@RequestParam</p></li><li><p>通过POJO获取：控制器形参设置一个实体类类型，当请求参数中的参数与该实体类中的属性一一对应，则会给其赋值</p></li></ol><h3 id="域对象的数据共享"><a href="#域对象的数据共享" class="headerlink" title="域对象的数据共享"></a>域对象的数据共享</h3><ol><li>使用ServletAPI向request域对象共享数据:控制器设置形参”HttpServletRequest request“，调用方法request.setAttribute(“AB”, “data”);</li><li>使用ModelAndView向request域对象共享数据：创建一个新的ModelAndView()对象，调用方法：mod.addObject(“AB”, “data”); 设置视图，实现页面跳转 ：mod.setViewName(“success”); 返回ModelAndView()对象：return mav; </li><li>使用Model向request域对象共享数据:控制器设置形参”Model model“，调用方法model.addAttribute(“AB”, “data”);</li><li>使用map向request域对象共享数据::控制器设置形参”Map&lt;String, Object&gt; map“,调用方法map.put(“AB”, “data”);</li><li>使用ModelMap向request域对象共享数据:控制器设置形参”ModelMap modelMap“，调用方法modelMap.addAttribute(“AB”, “data”);</li><li>向session域共享数据:控制器设置形参”HttpSession session”，调用方法session.setAttribute(“AB”, “data”);</li><li>向application域共享数据:控制器设置形参”HttpSession session”，创建session.getServletContext(); 对象，调用方法application.setAttribute(“AB”, “data”);</li></ol><h3 id="SpringMvc视图的渲染"><a href="#SpringMvc视图的渲染" class="headerlink" title="SpringMvc视图的渲染"></a>SpringMvc视图的渲染</h3><ul><li><p>ThymeleafView：当控制器所请求的视图没有前缀的时候，会默认被配置文件中的视图解析器根据前缀和后缀拼接解析，然后转发</p></li><li><p>转发视图：当控制器的请求的视图含有前缀“forword:”时，不会经过视图解析器，而是将前缀去掉，转发到剩下的路径</p></li><li><p>重定向视图：当控制器的请求的视图含有前缀“redirect:”时，不会经过视图解析器，而是将前缀去掉，重定向到剩下的路径</p><p>（当控制器方法中只需要实现页面跳转，则可以设置view controller标签）</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">path：设置处理的请求地址 </span></span><br><span class="line"><span class="comment">view-name：设置请求地址所对应的视图名称 </span></span><br><span class="line"><span class="comment">--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/router&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;success&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="请求体的转换"><a href="#请求体的转换" class="headerlink" title="请求体的转换"></a>请求体的转换</h3><ol><li>@RequestBody:标注在控制器形参位置，请求体会赋值给形参</li><li>RequestEntity：是一种封装请求报文的类型，标注在形参位置，请求报文会赋值给形参，可以通过getHeaders()获取请求头信息，getBody()获取请求体信息等</li><li>@ResponseBody：标注在控制器方法，将该方法的返回体直接响应在浏览器上</li><li>ResponseEntity：用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文</li><li>@RestController：标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解</li></ol><h3 id="拦截器和异常处理器"><a href="#拦截器和异常处理器" class="headerlink" title="拦截器和异常处理器"></a>拦截器和异常处理器</h3><p>在配置文件中配置拦截器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.yaoqqi.interceptor.FirstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/testRequestEntity&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过 </span></span><br><span class="line"><span class="comment">    mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求 </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><p>拦截器有三个抽象方法：</p><ul><li>preHandle：控制器方法执行之前执行preHandle()，返回值boolean类型表示是否令其通过，返回true为通过并调用控制器方法；返回false表示拦截，即不调用控制器方法</li><li>postHandle：控制器方法执行之后执行postHandle()</li><li>afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()</li></ul><h3 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ControllerAdvice将当前类标识为异常处理的组件 </span></span><br><span class="line"><span class="meta">@ControllerAdvice</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionController</span> &#123; </span><br><span class="line">    <span class="comment">//@ExceptionHandler用于设置所标识方法处理的异常 </span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ArithmeticException.class)</span> </span><br><span class="line">    <span class="comment">//ex表示当前请求处理中出现的异常对象 </span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleArithmeticException</span><span class="params">(Exception ex, Model model)</span>&#123; </span><br><span class="line">        model.addAttribute(<span class="string">&quot;ex&quot;</span>, ex); </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringMvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> SpringMvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-概述</title>
      <link href="/2022/05/14/Java%E7%AC%94%E8%AE%B0/SpringMvc/1-%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/05/14/Java%E7%AC%94%E8%AE%B0/SpringMvc/1-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分</p><p>M：Model，模型层，指工程中的JavaBean，作用是处理数据</p><p>JavaBean分为两类：</p><ul><li>一类称为实体类Bean：专门存储业务数据的，如 Student、User 等</li><li>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问</li></ul><p>V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</p><p>C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器</p><h2 id="具体流程："><a href="#具体流程：" class="headerlink" title="具体流程："></a>具体流程：</h2><p><img src="/noteimg/Java%E7%AC%94%E8%AE%B0/SpringMvc/img/image-20220726100456664.png" alt="image-20220726100456664"></p><h2 id="快速入门："><a href="#快速入门：" class="headerlink" title="快速入门："></a>快速入门：</h2><p>1.引用依赖：spring-mvc、thymeleaf-spring5、javax.servlet-api</p><p>2.添加Web.xml配置文件关于SpringMvc的配置，位于WEB-INF下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 </span></span><br><span class="line"><span class="comment">但是/不能匹配.jsp请求路径的请求 </span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--配置springMVC的编码过滤器--&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">filter</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-</span> <span class="attr">class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span> </span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span> </span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span> </span><br><span class="line">           <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span> </span><br><span class="line">           <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">因为浏览器只能发送get和post请求，HiddenHttpMethodFilter能将POST请求转换为DELETE或PUT请求</span></span><br><span class="line"><span class="comment">条件：当前请求方式为：POST</span></span><br><span class="line"><span class="comment"> 必须携带请求参数_method</span></span><br><span class="line"><span class="comment">--&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">filter</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.创建请求控制器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/mvc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mvcController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.在WEB-INF文件夹下创建名为jsp的文件夹，用来存放jsp视图。创建一个hello.jsp，在body中添加“Hello World”。</p><p>5.创建SpringMvc的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd&quot;</span>&gt;</span>                    </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;test.SpringMVC&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 处理静态资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启Mvc注解驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>6.启动服务器，键入<a href="http://localhost:8080/%E9%A1%B9%E7%9B%AE%E5%90%8D/mvc/hello%E6%88%90%E5%8A%9F%E8%B7%B3%E8%BD%AC%E5%88%B0hello.jsp%E9%A1%B5%E9%9D%A2%E3%80%82">http://localhost:8080/项目名/mvc/hello成功跳转到hello.jsp页面。</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringMvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> SpringMvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YAML文件详解</title>
      <link href="/2022/05/09/Java%E7%AC%94%E8%AE%B0/SpringBoot/YAML%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/05/09/Java%E7%AC%94%E8%AE%B0/SpringBoot/YAML%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="YAML-简介"><a href="#YAML-简介" class="headerlink" title="YAML 简介"></a>YAML 简介</h1><p>YAML，即 ”YAML Ain’t a Markup Language“（YAML 不是一种标记语言）的递归缩写，YAML 意思其实是“ Yet Another Markup Language”（仍是一种标记语言）。该配置文件类型主要强调这种语言是主要侧重于匹配值数据，而不是以标记为中心， 以标记为中心的主要是XML语言。</p><p>YAML 可读性高，容易理解，用来表达数据序列化的格式。它的语法与其他高级语言很像，对于各种数据类型有属于自己较为简单的表达方式，它使用空白符缩进，层次分明，对于需要表达或者编辑的数据结构和各种配置文件等使用yaml文件非常方便。</p><p>YAML 配置文件后缀为**.yml**，例如application.yml、bootstrap.yml。</p><h1 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h1><ul><li>采用key :value格式，kv之间需要用空格间隔</li><li>‘#’表示注释</li><li>字符串值不使用引号，如果要加引号，” “会转义字符串中的特殊字符(例如<code>\n</code>)，‘ ’不会转义字符串中的特殊字符。</li><li>使用缩进来表示配置之间的层级关系</li><li>缩进的空格数没有具体要求，只需满足相同层级的元素左对齐</li><li>该文件对配置中的大小写很敏感</li></ul><h1 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h1><p>标量：不可再分的值，int、filoat、boolean、string、date、null</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">k:</span> <span class="string">v</span></span><br></pre></td></tr></table></figure><p>对象：键值对的集合，有map、hash、set、object </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#行内写法  </span></span><br><span class="line"><span class="attr">k:</span> &#123;<span class="string">k1:v1</span>,<span class="string">k2:v2</span>,<span class="string">k3:v3</span>&#125;</span><br><span class="line"><span class="comment">#分行写法</span></span><br><span class="line"><span class="attr">k:</span> </span><br><span class="line">  <span class="attr">k1:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">k2:</span> <span class="string">v2</span></span><br><span class="line">  <span class="attr">k3:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><p>数组：一组按次序排列的值，有array、list、queue</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#行内写法 </span></span><br><span class="line"><span class="attr">k:</span> [<span class="string">v1</span>,<span class="string">v2</span>,<span class="string">v3</span>]</span><br><span class="line"><span class="comment">#分行写法</span></span><br><span class="line"><span class="attr">k:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v2</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><p>配置类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> Boolean committee;</span><br><span class="line"><span class="keyword">private</span> Date birth;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> Teacher teacher;</span><br><span class="line"><span class="keyword">private</span> String[] subjects;</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; aside;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Double&gt; score;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;Teacher&gt;&gt; allteachers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yaml表示以上对象</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">student:</span></span><br><span class="line">  <span class="attr">userName:</span> <span class="string">zhangsan</span></span><br><span class="line">  <span class="attr">boss:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">birth:</span> <span class="number">2022</span><span class="string">/08/9</span> <span class="number">11</span><span class="string">:11:11</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">teacher:</span> </span><br><span class="line">    <span class="attr">name:</span> <span class="string">xiaohong</span></span><br><span class="line">    <span class="attr">weight:</span> <span class="number">35</span></span><br><span class="line">  <span class="attr">subjects:</span> [<span class="string">语文</span>,<span class="string">数学</span>,<span class="string">英语</span>]</span><br><span class="line">  <span class="attr">aside:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">lisi</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">wangwu</span></span><br><span class="line">  <span class="attr">score:</span></span><br><span class="line">    <span class="attr">english:</span> <span class="number">66</span></span><br><span class="line">    <span class="attr">math:</span> <span class="number">66.5</span></span><br><span class="line">    <span class="attr">chinese:</span> <span class="number">66</span></span><br><span class="line">  <span class="attr">allteachers:</span></span><br><span class="line">    <span class="attr">woman:</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">xioahuang</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">xiaoli</span>,<span class="attr">age:</span> <span class="number">47</span>&#125;</span><br><span class="line">    <span class="attr">male:</span> [&#123;<span class="attr">name:</span> <span class="string">xiaochen</span>,<span class="attr">age:</span> <span class="number">47</span>&#125;]</span><br></pre></td></tr></table></figure><h1 id="文本块-如果想引入多行的文本块，则使用-符号"><a href="#文本块-如果想引入多行的文本块，则使用-符号" class="headerlink" title="文本块(如果想引入多行的文本块，则使用**|**符号)"></a>文本块(如果想引入多行的文本块，则使用**|**符号)</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">|</span></span><br><span class="line"><span class="string">   Hello jack!!</span></span><br><span class="line"><span class="string">   I am good!</span></span><br><span class="line"><span class="string">   Thanks! </span></span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>用到<code>&amp;</code>锚点和<code>*</code>星号，<code>&amp;</code>用来建立锚点，<code>&lt;&lt;</code>表示合并到当前数据，<code>*</code>用来引用锚点</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zhangsan:</span> <span class="meta">&amp;zhangsan</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">张三</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="attr">committee:</span> </span><br><span class="line">  <span class="attr">position:</span> <span class="string">LifeMember</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*zhangsan</span></span><br></pre></td></tr></table></figure><p>上面最终相当于如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zhangsan:</span> <span class="meta">&amp;zhangsan</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">张三</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="attr">committee:</span> </span><br><span class="line">  <span class="attr">position:</span> <span class="string">LifeMember</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">张三</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br></pre></td></tr></table></figure><p>还有一种文件内引用，引用已经定义好的变量，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">host:</span> <span class="string">http://yaoqi.com</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">$&#123;host&#125;/person/add</span>  </span><br><span class="line"><span class="comment"># 最终值为 http://yaoqi.com/person/add  </span></span><br></pre></td></tr></table></figure><p>本次分享到此结束啦~~~~</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05-web开发</title>
      <link href="/2022/05/03/Java%E7%AC%94%E8%AE%B0/SpringBoot/05-web%E5%BC%80%E5%8F%91/"/>
      <url>/2022/05/03/Java%E7%AC%94%E8%AE%B0/SpringBoot/05-web%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h2><p>原理：当一个请求进来，先找Controller看能不能处理，不能处理又交给静态资源处理器，静态资源也找不到则响应404页面</p><p>要求静态资源放在 called &#x2F;static (or &#x2F;public or &#x2F;resources or &#x2F;META-INF&#x2F;resources 类路径下，这是默认配置，需要访问的时候路径为：当前项目根路径&#x2F;+静态资源名</p><p>若需要改变的静态资源路径，需在配置文件配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="comment">#这个会导致index.html不能默认访问</span></span><br><span class="line">    <span class="comment">#自定义Favicon：favicon.ico 放在静态资源目录下即可</span></span><br><span class="line">    <span class="comment">#此配置也会导致Favicon功能失效</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">static-locations:</span> [<span class="string">classpath:/yaoqi/</span>]</span><br></pre></td></tr></table></figure><h2 id="请求参数处理"><a href="#请求参数处理" class="headerlink" title="请求参数处理"></a>请求参数处理</h2><ul><li><p>@PathVariable：标注在形参前面,获取请求路径中的值</p></li><li><p>@RequestParam：将请求参数与控制器形参创建映射关系，标注在形参前面，获取请求参数名与形参名相同的</p></li><li><p>@RequestHeader：将请求头信息与控制器形参创建映射关系，用法与@RequestParam</p></li><li><p>@CookieValue：将Cookie数据与控制器形参创建映射关系，用法与@RequestParam</p></li><li><p>@RequestBody：标注在控制器形参位置，请求体会赋值给形</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-容器</title>
      <link href="/2022/04/29/Java%E7%AC%94%E8%AE%B0/SpringBoot/02-%E5%AE%B9%E5%99%A8/"/>
      <url>/2022/04/29/Java%E7%AC%94%E8%AE%B0/SpringBoot/02-%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>@Configuration：说明这个类是配置类，在类中的方法中添加@Bean注解(返回一个实例对象)，在spring5.2以后，该注解添加了一个属性proxyBeanMethods，默认是true，保证每个@Bean方法被调用多少次返回的组件都是单实例的，当为false时，说明每个@Bean方法被调用多少次返回的组件都是新创建的，一般情况下组件依赖(一个组件中含有另一个组件)必须使用true,其他是false比较合适</p><p>@Bean：给容器添加组件，组件的默认id就是方法名，可以通过@Bean(”名字”)自定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;yaoqi&quot;)</span><span class="comment">//更改组件名</span></span><br><span class="line">    <span class="keyword">public</span> yaoqiService <span class="title function_">yaoqiservice</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">yaoqiService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Component、@Controller、@Service、@Repository：同样也是添加组件的注解，主要用于区分组件的功能</p><p>@Conditional：条件装配，满足某些条件才会添加组件，是一个组合注解</p><p><img src="/noteimg/Java%E7%AC%94%E8%AE%B0/SpringBoot/img/image-20220731112419998.png" alt="image-20220731112419998"> </p><p>常见的要求：</p><ul><li><p>@ConditionalOnJava：系统的java版本是否符合要求</p></li><li><p>@ConditionalOnBean：容器中存在指定Bean；</p></li><li><p>@ConditionalOnMissingBean：容器中不存在指定Bean；</p></li><li><p>@ConditionalOnExpression：满足SpEL表达式指定</p></li><li><p>@ConditionalOnClass：系统中有指定的类</p></li><li><p>@ConditionalOnMissingClass：系统中没有指定的类</p></li><li><p>@ConditionalOnSingleCandidate：容器中只有一个指定的Bean，或者这个Bean是首选Bean</p></li><li><p>@ConditionalOnProperty：系统中指定的属性是否有指定的值</p></li><li><p>@ConditionalOnResource：类路径下是否存在指定资源文件</p></li><li><p>@ConditionalOnWebApplication：当前是web环境</p></li><li><p>@ConditionalOnNotWebApplication：当前不是web环境</p></li><li><p>@ConditionalOnJndi：JNDI存在指定项</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果容器中不存在名为yaoqi的组件,那么该配置类中的所有主件都不会被创建</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(name=&quot;yaoqi&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">    <span class="comment">//如果容器中有名为yao注解的主件,才会创建yaoqiService组件</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(name=&quot;yaoqi&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> yaoqiService <span class="title function_">yaoqiservice</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">yaoqiService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Import：该注解作用在配置类上,通过调用无参构造方法给容器中创建组件，默认名字就是全类名</p><p>@ImportResource：我们自己编写的Spring配置文件是不能自动引用的，@ImportResource标注在一个配置类上，就能加载Spring的配置文件，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:spring.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-自动配置</title>
      <link href="/2022/04/29/Java%E7%AC%94%E8%AE%B0/SpringBoot/03-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/04/29/Java%E7%AC%94%E8%AE%B0/SpringBoot/03-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="自动配置简介"><a href="#自动配置简介" class="headerlink" title="自动配置简介"></a>自动配置简介</h2><p>SpringBoot应用程序通过@SpringBootApplication注解来实现自动配置，虽然127个场景的所有自动配置启动的时候默认全部加载，但我们需要按需开启自动配置项，通过条件装配规则注解@Conditional来进行配置。</p><p>@SpringBootApplication是一个复合注解，@SpringBootConfiguration说明这是一个配置类，里面有一个@EnableAutoConfiguration注解表示开启自动配置功能，自动配置了常见的第三方工具，例如mybatis、redis、OAuth2、Rabbitmq等。</p><p>spring官网提供了所有的自动配置属性,可参考: <a href="https://docs.spring.io/spring-boot/docs/2.1.13.RELEASE/reference/htmlsingle/">https://docs.spring.io/spring-boot/docs/2.1.13.RELEASE/reference/htmlsingle/</a> <img src="/noteimg/Java%E7%AC%94%E8%AE%B0/SpringBoot/img/image-20220807110739904.png" alt="image-20220807110739904"></p><p>在@EnableAutoConfiguration注解中，@AutoConfigurationPackage指定了默认的包规则，@Import(AutoConfigurationImportSelector.class)，给容器中导入所有需要导入到容器的组件，并配置好这些组件。</p><p><img src="/noteimg/Java%E7%AC%94%E8%AE%B0/SpringBoot/img/image-20220807113006755.png" alt="image-20220807113006755"> </p><p>SpringBoot默认会在底层配好所有的组件。但是如果用户自己配置了以用户的优先。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-配置文件</title>
      <link href="/2022/04/29/Java%E7%AC%94%E8%AE%B0/SpringBoot/04-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2022/04/29/Java%E7%AC%94%E8%AE%B0/SpringBoot/04-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>类型：properties、yaml(yml)</p><p>启动顺序：bootstrap.properties –&gt; bootstrap.yml –&gt; application.properties –&gt; application.yml</p><p>Springboot项目启动时会按照如下顺序由高到低读取配置，高优先级的属性会覆盖低优先级的属性，属性文件之间存在互补配置的特性</p><p>例：如果在bootstrap.properties配置启动端口号:8080，bootstrap.yml文件中配置启动端口号:8081，此时启动时为8081端口号。先加载bootstrap.properties配置文件中的配置，会被后加载的配置文件中的配置会进行选择性的覆盖。</p><h2 id="在不同位置的优先级"><a href="#在不同位置的优先级" class="headerlink" title="在不同位置的优先级"></a>在不同位置的优先级</h2><p>主要区分的位置是项目的根目录下和Resources目录下的</p><p><img src="/noteimg/Java%E7%AC%94%E8%AE%B0/SpringBoot/img/image-20220809110700581.png" alt="image-20220809110700581"> </p><p>这种情况下是config里的配置文件优先级高</p><p><img src="/noteimg/Java%E7%AC%94%E8%AE%B0/SpringBoot/img/image-20220809114206796.png" alt="image-20220809114206796"> </p><p>这种情况下还是config里的配置文件优先级高,在项目根目录下的配置文件会直接覆盖Resources下的配置文件</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>project:…&#x2F;config&#x2F;配置文件（项目根目录下的config文件夹里的配置文件）</li><li>project:…&#x2F;配置文件（项目根目录下的配置文件）</li><li>classpath:…&#x2F;config&#x2F;配置文件（Resources文件夹下config文件夹里的配置文件）</li><li>classpath:…&#x2F;配置文件（Resources文件夹下的配置文件））</li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-基础篇</title>
      <link href="/2022/04/24/Java%E7%AC%94%E8%AE%B0/SpringBoot/01-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/2022/04/24/Java%E7%AC%94%E8%AE%B0/SpringBoot/01-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot-介绍"><a href="#Spring-Boot-介绍" class="headerlink" title="Spring Boot 介绍"></a>Spring Boot 介绍</h1><p>Spring Boot框架是简化新Spring应用的初始搭建以及开发过程，该框架采用自动化配置，自动配好Tomcat、自动配好SpringMvc、Web的常用功能，从而使开发人员简化了配置。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决。</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>（1）快速出创建生产级别的Spring应用</p><p>（2）内嵌Tomcat或Jetty等Servlet容器</p><p>（3）提供自动配置的“starter”项目对象模型（POMS）以简化Maven配置</p><p>（4）提供自动化配置Spring容器功能</p><p>（5）提供一系列的安全性、指标、健康检查和外部化配置等等的非功能特性</p><p>（6）完全抛弃了XML配置文件</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>1.创建maven工程</p><p>2.引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    依赖spring-boot-starter-* ： *表示的是某种场景，如spring-boot-starter-data-redis，spring-boot-starter-thymeleaf等，成功引入依赖，      这个场景的所有常规需要的依赖都会自动引入</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">plugins</span>&gt;</span> </span><br><span class="line">         <span class="comment">&lt;!--SpringBoot提供的打包编译等插件--&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span> </span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">build</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>3.创建主程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//springboot应用</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       SpringApplication.run(MainApplication.class,args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.创建控制器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handle01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello，yaoqi!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.创建properties配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#内置Tomcat的端口号</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br></pre></td></tr></table></figure><p>6.运行主程序代码，浏览器输入<a href="http://localhost:8080/hello%EF%BC%8C%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BAHello%EF%BC%8Cyaoqi!%EF%BC%9B">http://localhost:8080/hello，页面显示Hello，yaoqi!；</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-AOP</title>
      <link href="/2022/04/19/Java%E7%AC%94%E8%AE%B0/Spring/3-AOP/"/>
      <url>/2022/04/19/Java%E7%AC%94%E8%AE%B0/Spring/3-AOP/</url>
      
        <content type="html"><![CDATA[<h3 id="AOP-的作用及其优势"><a href="#AOP-的作用及其优势" class="headerlink" title="AOP 的作用及其优势"></a>AOP 的作用及其优势</h3><p>作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强</p><p>优势：减少重复代码，提高开发效率，并且便于维护</p><h3 id="AOP-的底层实现"><a href="#AOP-的底层实现" class="headerlink" title="AOP 的底层实现"></a>AOP 的底层实现</h3><p>实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。</p><h3 id="AOP-的动态代理技术"><a href="#AOP-的动态代理技术" class="headerlink" title="AOP 的动态代理技术"></a>AOP 的动态代理技术</h3><p>第一种 有接口情况，使用 JDK 动态代理（创建接口实现类代理对象，增强类的方法）</p><p>第二种 没有接口情况，使用 CGLIB 动态代理（创建子类的代理对象，增强类的方法）</p><p>（1）创建接口，定义方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）创建接口实现类，实现方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> a+b;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）使用 Proxy 类创建接口代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKProxy</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">//创建接口实现类代理对象</span></span><br><span class="line">     Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line">     <span class="type">UserDaoImpl</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">     <span class="type">UserDao</span> <span class="variable">dao</span> <span class="operator">=</span> (UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, <span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao)); </span><br><span class="line">     <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> dao.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">     System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建代理对象代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">     <span class="comment">//1 把创建的是谁的代理对象，把谁传递过来</span></span><br><span class="line">     <span class="comment">//有参数构造传递</span></span><br><span class="line">     <span class="keyword">private</span> Object obj;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.obj = obj;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//增强的逻辑</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;方法之前执行....&quot;</span>);</span><br><span class="line">     <span class="comment">//被增强的方法执行</span></span><br><span class="line">     <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(obj, args);</span><br><span class="line">     System.out.println(<span class="string">&quot;方法之后执行....&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AOP-的相关术语"><a href="#AOP-的相关术语" class="headerlink" title="AOP 的相关术语"></a>AOP 的相关术语</h3><p>常用的术语如下：<br>Target（目标对象):代理的目标对象<br>Proxy （代理):一个类被 AOP 织入增强后，就产生一个结果代理类<br>Joinpoint（连接点):所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点<br>Pointcut（切入点):所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义<br>Advice（通知&#x2F; 增强):所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知<br>Aspect（切面):是切入点和通知（引介）的结合<br>Weaving（织入):是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入</p><h3 id="AOP-操作（AspectJ-注解）"><a href="#AOP-操作（AspectJ-注解）" class="headerlink" title="AOP 操作（AspectJ 注解）"></a>AOP 操作（AspectJ 注解）</h3><p>1、创建类，在类里面定义方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;add starting...&quot;</span>);</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、创建增强类（编写增强逻辑）</p><p>（1）在增强类里面，创建方法，让不同方法代表不同通知类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;before starting...&quot;</span>);</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、进行通知的配置</p><p>（1）在 spring 配置文件中，开启注解扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.yaoqi.package&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>（2）使用注解创建 User 和 UserProxy 对象</p><p>（3）在增强类上面添加注解 @Aspect</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br></pre></td></tr></table></figure><p>（4）在 spring 配置文件中开启生成代理对象</p><!-- 开启 Aspect 生成代理对象--> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>4、配置不同类型的通知</p><p>（1）在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line"> <span class="comment">//前置通知</span></span><br><span class="line"> <span class="meta">@Before(value = &quot;execution(*com.yaoqi.package.User.add(..))&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;before.........&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//后置通知</span></span><br><span class="line"> <span class="meta">@AfterReturning(value = &quot;execution(*com.yaoqi.package.User.add(..))&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;afterReturning.........&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//最终通知</span></span><br><span class="line"> <span class="meta">@After(value = &quot;execution(*com.yaoqi.package.User.add(..))&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;after.........&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//异常通知</span></span><br><span class="line"> <span class="meta">@AfterThrowing(value = &quot;execution(*com.yaoqi.package.User.add(..))&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;afterThrowing.........&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//环绕通知</span></span><br><span class="line"> <span class="meta">@Around(value = &quot;execution(*com.yaoqi.package.User.add(..))&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;环绕之前.........&quot;</span>);</span><br><span class="line">     <span class="comment">//被增强的方法执行</span></span><br><span class="line">     proceedingJoinPoint.proceed();</span><br><span class="line">     System.out.println(<span class="string">&quot;环绕之后.........&quot;</span>);</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、相同的切入点抽取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相同切入点抽取</span></span><br><span class="line"><span class="meta">@Pointcut(value = &quot;execution(*com.yaoqi.package.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commondemo</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前置通知</span></span><br><span class="line"><span class="meta">@Before(value = &quot;commondemo()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;before.........&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、有多个增强类多同一个方法进行增强，设置增强类优先级</p><p>（1）在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxy</span></span><br></pre></td></tr></table></figure><p>7、完全使用注解开发 </p><p>（1）创建配置类，不需要创建 xml 配置文件 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.yaoqi&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigAop</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AOP-操作（AspectJ-配置文件）"><a href="#AOP-操作（AspectJ-配置文件）" class="headerlink" title="AOP 操作（AspectJ 配置文件）"></a>AOP 操作（AspectJ 配置文件）</h4><p>1、创建两个类，增强类和被增强类，创建方法</p><p>2、在 spring 配置文件中创建两个类对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yaoqi.Book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookProxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yaoqi.BookProxy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>3、在 spring 配置文件中配置切入点</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置 aop 增强--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--切入点--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(*com.yaoqi..Book.buy(..))&quot;</span>/&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;bookProxy&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--增强作用在具体的方法上--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;p&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-IOC</title>
      <link href="/2022/04/13/Java%E7%AC%94%E8%AE%B0/Spring/2-IOC/"/>
      <url>/2022/04/13/Java%E7%AC%94%E8%AE%B0/Spring/2-IOC/</url>
      
        <content type="html"><![CDATA[<h4 id="IOC操作Bean管理"><a href="#IOC操作Bean管理" class="headerlink" title="IOC操作Bean管理"></a>IOC操作Bean管理</h4><h5 id="1、基于-xml方式创建对象"><a href="#1、基于-xml方式创建对象" class="headerlink" title="1、基于 xml方式创建对象"></a>1、基于 xml方式创建对象</h5><p>（1）在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建</p><p>（2）在 bean 标签有很多属性，介绍常用的属性</p><p>​id 属性：唯一标识</p><p>​class 属性：类全路径（包类路径）</p><p>（3）创建对象时候，默认也是执行无参数构造方法完成对象创建</p><h5 id="2、基于-xml方式注入属性"><a href="#2、基于-xml方式注入属性" class="headerlink" title="2、基于 xml方式注入属性"></a>2、基于 xml方式注入属性</h5><p>​    DI：依赖注入，就是注入属性</p><h5 id="3、第一种注入方式：使用-set-方法进行注入"><a href="#3、第一种注入方式：使用-set-方法进行注入" class="headerlink" title="3、第一种注入方式：使用 set 方法进行注入"></a>3、第一种注入方式：使用 set 方法进行注入</h5><p>（1）创建类，定义属性和对应的 set 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"> <span class="comment">//创建属性</span></span><br><span class="line"> <span class="keyword">private</span> String Name;</span><br><span class="line"> <span class="keyword">private</span> String Age;</span><br><span class="line"> <span class="comment">//创建属性对应的 set 方法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String Name)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.Name = Name;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(String Age)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.Age = Age;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）在 spring 配置文件配置对象创建，配置属性注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;User&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yaoqi.bean.User&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--使用 property 完成属性注入</span></span><br><span class="line"><span class="comment">     name：类里面属性名称</span></span><br><span class="line"><span class="comment">     value：向属性注入的值</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure><h5 id="4、第二种注入方式：使用有参数构造进行注入"><a href="#4、第二种注入方式：使用有参数构造进行注入" class="headerlink" title="4、第二种注入方式：使用有参数构造进行注入"></a>4、第二种注入方式：使用有参数构造进行注入</h5><p>（1）创建类，定义属性，创建属性对应有参数构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/使用有参数构造注入/使用有参数构造注入/</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"> <span class="comment">//属性</span></span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="keyword">private</span> String age;</span><br><span class="line"> <span class="comment">//有参数构造</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name,String age)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;</span><br><span class="line"> <span class="built_in">this</span>.age = age;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）在 spring 配置文件中进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--3 有参数构造注入属性--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;User&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yaoqi.bean.User&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure><h4 id="注入其他类型属性"><a href="#注入其他类型属性" class="headerlink" title="注入其他类型属性:"></a>注入其他类型属性:</h4><p>1、字面量</p><p>（1）null 值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;属性名&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>（2）属性值包含特殊符号</p><ul><li><p>把&lt;&gt;进行转义 &lt; &gt;</p></li><li><p>把带特殊符号内容写到 CDATA</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;属性名&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置值为&lt;&lt;深圳&gt;&gt;--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[&lt;&lt;深圳&gt;&gt;]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>2、注入属性-外部 bean</p><p>（1）创建两个类 service 类和 dao 类 </p><p>（2）在 service 调用 dao 里面的方法</p><p>（3）在 spring 配置文件中进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"> <span class="comment">//创建 UserDao 类型属性，生成 set 方法</span></span><br><span class="line"> <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;service add...............&quot;</span>);</span><br><span class="line">     userDao.update();</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yaoqi.service.UserService&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yaoqi.dao.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>3、注入属性-内部 bean</p><p>（1）一对多关系：部门和员工</p><p>（2）在实体类之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//部门类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dept</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> String dname;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDname</span><span class="params">(String dname)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.dname = dname;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> String ename;</span><br><span class="line">     <span class="keyword">private</span> String gender;</span><br><span class="line">     <span class="keyword">private</span> Dept dept;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDept</span><span class="params">(Dept dept)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.dept = dept;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEname</span><span class="params">(String ename)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.ename = ename;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.gender = gender; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）在 spring 配置文件中进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yaoqi.bean.Emp&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--设置两个普通属性--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--设置对象类型属性--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yaoqi.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;销售部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>4、注入属性-级联赋值 </p><p>（1）第一种写法 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yaoqi.bean.Emp&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--设置两个普通属性--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--级联赋值--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yaoqi.bean.Dept&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;销售部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>（2）第二种写法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yaoqi.bean.Emp&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--设置两个普通属性--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--级联赋值--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;销售部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure><h4 id="注入集合属性"><a href="#注入集合属性" class="headerlink" title="注入集合属性:"></a>注入集合属性:</h4><p>1、注入数组类型属性</p><p>2、注入 List 集合类型属性</p><p>3、注入 Map 集合类型属性</p><p>（1）创建类，定义数组、list、map、set 类型属性，生成对应 set 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line"> <span class="comment">//1 数组类型属性</span></span><br><span class="line"> <span class="keyword">private</span> String[] courses;</span><br><span class="line"> <span class="comment">//2 list 集合类型属性</span></span><br><span class="line"> <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"> <span class="comment">//3 map 集合类型属性</span></span><br><span class="line"> <span class="keyword">private</span> Map&lt;String,String&gt; maps;</span><br><span class="line"> <span class="comment">//4 set 集合类型属性</span></span><br><span class="line"> <span class="keyword">private</span> Set&lt;String&gt; sets;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSets</span><span class="params">(Set&lt;String&gt; sets)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.sets = sets;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCourses</span><span class="params">(String[] courses)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.courses = courses;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setList</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.list = list;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaps</span><span class="params">(Map&lt;String, String&gt; maps)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.maps = maps;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）在 spring 配置文件进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yaoqi.bean.Stu&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--数组类型属性注入--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courses&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>A<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>B<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--list 类型属性注入--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">list</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>A<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>B<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--map 类型属性注入--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;A&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;B&quot;</span> <span class="attr">value</span>=<span class="string">&quot;b&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--set 类型属性注入--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sets&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>A<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>B<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>4、在集合里面设置对象类型值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建多个class对象--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;class1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yaoqi.bean.Class&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;语文&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;class2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yaoqi.bean.Class&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;数学&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注入 list 集合类型，值是对象--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;classList&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;class1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;class2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br></pre></td></tr></table></figure><h4 id="工厂Bean（FactoryBean）："><a href="#工厂Bean（FactoryBean）：" class="headerlink" title="工厂Bean（FactoryBean）："></a>工厂Bean（FactoryBean）：</h4><p>1、Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean） </p><p>2、普通 bean：在配置文件中定义 bean 类型就是返回类型</p><p>3、工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样</p><p>第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean</p><p>第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Class&gt; &#123;</span><br><span class="line"> <span class="comment">//定义返回 bean</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Course <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     <span class="type">Course</span> <span class="variable">course</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Course</span>();</span><br><span class="line">     course.setCname(<span class="string">&quot;英语&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> course;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yaoqi.factorybean.MyBean&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean3.xml&quot;</span>);</span><br><span class="line">     <span class="type">Course</span> <span class="variable">course</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;myBean&quot;</span>, Course.class);</span><br><span class="line">     System.out.println(course);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Bean作用域："><a href="#Bean作用域：" class="headerlink" title="Bean作用域："></a>Bean作用域：</h4><p>scope:指对象的作用范围，取值如下：</p><table><thead><tr><th>取值范围</th><th>说明</th></tr></thead><tbody><tr><td>singleton</td><td>默认值，单例的</td></tr><tr><td>prototype</td><td>多例的</td></tr><tr><td>request</td><td>WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 request 域中</td></tr><tr><td>session</td><td>WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 session 域中</td></tr><tr><td>global session</td><td>WEB 项目中，应用在 Portlet 环境，如果没有 Portlet 环境那么globalSession 相当于 session</td></tr></tbody></table><h4 id="Bean-生命周期："><a href="#Bean-生命周期：" class="headerlink" title="Bean 生命周期："></a>Bean 生命周期：</h4><ol><li><p>执行无参数构造创建Bean实例</p></li><li><p>调用set方法设置属性值</p><p>—初始之前执行的方法</p></li><li><p>执行初始化的方法</p><p>—初始之后执行的方法</p></li><li><p>获取创建Bean实例对象</p></li><li><p>执行销毁的方法</p></li></ol><p>（1）创建类，实现接口 BeanPostProcessor，创建后置处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPost</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;这是在初始化之前执行的方法&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> bean;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;这是在初始化之后执行的方法&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> bean;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置后置处理器--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPost&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yaoqi.bean.MyBeanPost&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="外部属性文件："><a href="#外部属性文件：" class="headerlink" title="外部属性文件："></a>外部属性文件：</h4><p>把外部 properties 属性文件引入到 spring 配置文件中引入 context 名称空间</p><p><img src="/noteimg/Java%E7%AC%94%E8%AE%B0/Spring/img/image-20220628173255831.png" alt="image-20220628173255831"> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>  </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/util </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/util/spring-util.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">&lt;!--context空间名称--&gt;                          </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure><p> 在 spring 配置文件使用标签引入外部属性文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置连接池--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h4><p>@Component 使用在类上用于实例化Bean<br>@Controller    使用在web层类上用于实例化Bean<br>@Service 使用在service层类上用于实例化Bean<br>@Repository  使用在dao层类上用于实例化Bean<br>@Autowired   使用在字段上用于根据类型依赖注入<br>@Qualifier      结合@Autowired一起使用用于根据名称进行依赖注入<br>@Resource     相当于@Autowired+@Qualifier，按照名称进行注入<br>@Value            注入普通属性<br>@Scope   标注Bean的作用范围</p><p>@Configuration用于指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解<br>@Bean使用在方法上，标注将该方法的返回值存储到 Spring 容器中<br>@PropertySource用于加载.properties 文件中的配置<br>@Import用于导入其他配置类</p><p>使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法，或者使用@ComponentScan注解，用于指定 Spring 在初始化容器时要扫描的包。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注解的组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.yaoqi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-概述</title>
      <link href="/2022/04/07/Java%E7%AC%94%E8%AE%B0/Spring/1-%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/04/07/Java%E7%AC%94%E8%AE%B0/Spring/1-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h1><p>Spring 是轻量级的开源的 JavaEE 框架，Spring为简化企业级开发而生，使用Spring开发可以将Bean对象，Dao组件对象，Service组件对象等交给Spring容器来管理，这样使得很多复杂的代码在Spring中开发却变得非常的优雅和简洁，有效的降低代码的耦合度，极大的方便项目的后期维护、升级和扩展。</p><p>Spring 有两个核心部分：IOC 和 Aop</p><p>（1）<strong>IOC</strong>：控制反转，指的是将对象的创建权交给Spring去创建，使用Spring之前，对象的创建都是由我们自己在代码中new创建。而使用Spring之后。对象的创建都是由给了Spring框架。</p><p>（2）<strong>Aop</strong>：面向切面，不修改源代码进行功能增强。</p><h3 id="Spring快速入门"><a href="#Spring快速入门" class="headerlink" title="Spring快速入门"></a>Spring快速入门</h3><ol><li><p>导入Spring 坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>`</span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>`</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDao Startinng....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Spring核心配置文件 applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.terence.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建ApplicationContext对象，通过getBean方法获得Bean实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) applicationContext.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-MybatisPlus</title>
      <link href="/2022/04/01/Java%E7%AC%94%E8%AE%B0/Mybatis/2-MybatisPlus/"/>
      <url>/2022/04/01/Java%E7%AC%94%E8%AE%B0/Mybatis/2-MybatisPlus/</url>
      
        <content type="html"><![CDATA[<h1 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h1><h2 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h2><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>1.导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据库驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- mybatis-plus --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>版本号<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.操作对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.配置数据源</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.datasource.username=root</span> </span><br><span class="line"><span class="string">spring.datasource.password=root</span> </span><br><span class="line"><span class="string">spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8</span> </span><br><span class="line"><span class="string">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>4.mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在对应的Mapper上面继承基本的类BaseMapper </span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123; </span><br><span class="line">    <span class="comment">//CRUD操作都已经编写完成了 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.扫描包（主启动类上添加注解@MapperScan(“com.yaoqi.mapper”)）</p><p>6.测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">Tests</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="comment">// 参数是一个 Wrapper，条件构造器，这里我们先不用 null </span></span><br><span class="line">    <span class="comment">// 查询全部用户 </span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>); </span><br><span class="line">    users.forEach(System.out::println); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>1.主键生成设置：实体类字段上添加@TableId（type&#x3D;IdType.AUTO）</p><p>2.自动生成时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字段添加填充内容 </span></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span> </span><br><span class="line"><span class="keyword">private</span> Date createTime; </span><br><span class="line"></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span> </span><br><span class="line"><span class="keyword">private</span> Date updateTime; </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">tHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.设置乐观锁：</p><p>数据库增加Version字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version; </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.yaoqi.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OptimisticLockerInterceptor <span class="title function_">optimisticLockerInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockerInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.分页查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> </span><br><span class="line"><span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 参数一：当前页</span></span><br><span class="line">    <span class="comment">// 参数二：页面大小 </span></span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    List&lt;User&gt; users=userMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.逻辑删除（没有从数据库删除，通过一个变量来让数据失效）</p><p>在数据库新增一个deleted字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span> <span class="comment">//逻辑删除 </span></span><br><span class="line"><span class="keyword">private</span> Integer deleted; </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> </span><br><span class="line"><span class="keyword">public</span> ISqlInjector <span class="title function_">sqlInjector</span><span class="params">()</span> &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogicSqlInjector</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mybatis-plus.global-config.db-config.logic-delete-value=1</span> </span><br><span class="line"><span class="string">mybatis-plus.global-config.db-config.logic-not-delete-value=0</span></span><br></pre></td></tr></table></figure><p>执行的是更新操作不是删除操作！</p><h2 id="条件构造器（Wrapper）"><a href="#条件构造器（Wrapper）" class="headerlink" title="条件构造器（Wrapper）"></a><strong>条件构造器（Wrapper）</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;(); </span><br><span class="line">wrapper.查询方式(参数<span class="number">1</span>，参数<span class="number">2</span>); </span><br><span class="line">Mapper.selectCount(wrapper);</span><br></pre></td></tr></table></figure><p><img src="/noteimg/Java%E7%AC%94%E8%AE%B0/Mybatis/img/image-20220715104450923.png" alt="image-20220715104450923"> </p>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-Mybatis</title>
      <link href="/2022/03/29/Java%E7%AC%94%E8%AE%B0/Mybatis/1-Mybatis/"/>
      <url>/2022/03/29/Java%E7%AC%94%E8%AE%B0/Mybatis/1-Mybatis/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis（基于Java的持久层的框架）"><a href="#Mybatis（基于Java的持久层的框架）" class="headerlink" title="Mybatis（基于Java的持久层的框架）"></a>Mybatis（基于Java的持久层的框架）</h1><h2 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h2><ul><li>具有定制化SQL、存储过程、高级映射的持久层框架</li><li>避免几乎所有JDBC代码的手动设置参数及获取参数集</li><li>使用简单的XML或注解用于配置，可以将接口和Java的POJO映射成数据库的记录</li><li>半自动的ORM框架（框架格式：用元数据【XML格式】描述对象与关系映射的细节）</li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>1.引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- Mybatis核心 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- MySQL驱动 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.创建配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--引入properties文件，此时就可以$&#123;属性名&#125;的方式访问属性值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!--将表中字段的下划线自动转换为驼峰--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!--设置别名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.yao.mybatis.bean&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;abc&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置连接数据库的环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environm</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/MyBatis&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/Mapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.创建mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mapper</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">addUser</span><span class="params">()</span>;</span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;</span><br><span class="line">    User <span class="title function_">mohuSelect</span><span class="params">(<span class="meta">@Param(&quot;String&quot;)</span> String field)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.创建Mybatis映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span> <span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.yaoqi.mybatis.mapper.Mapper&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;sql语句开头单词 id=&quot;对应接口方法名&quot;&gt; </span></span><br><span class="line"><span class="comment">        sql语句</span></span><br><span class="line"><span class="comment">    &lt;/sql语句开头单词&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span>&gt;</span> </span><br><span class="line">        insert into user values (1, &#x27;张三&#x27;, 23, &#x27;女&#x27;) </span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span> </span><br><span class="line">        select * from user where id = #&#123;id&#125; </span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--模糊查询--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;mohuSelect&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span> </span><br><span class="line">        select * from user where username like &quot;%&quot;#&#123;field&#125;&quot;%&quot; </span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>功能测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取MyBatis的核心配置文件 </span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;config.xml&quot;</span>); </span><br><span class="line"><span class="comment">//创建SqlSessionFactoryBuilder对象 </span></span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>(); </span><br><span class="line"><span class="comment">//通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象 </span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is); </span><br><span class="line"><span class="comment">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务 </span></span><br><span class="line"><span class="comment">//SqlSession sqlSession = sqlSessionFactory.openSession(); </span></span><br><span class="line"><span class="comment">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交 </span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>); </span><br><span class="line"><span class="comment">//通过代理模式创建UserMapper接口的代理实现类对象 </span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(Mapper.class); </span><br><span class="line"><span class="comment">//调用Mapper接口中的方法，就可根据Mapper的全类名匹配元素文件，通过调用的方法名匹配 映射文件中的SQL标签，并执行标签中的SQL语句 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Mapper.insertUser(); </span><br><span class="line"><span class="comment">//sqlSession.commit();</span></span><br><span class="line">System.out.println(<span class="string">&quot;结果：&quot;</span>+result); </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动生成代码</title>
      <link href="/2022/03/23/Java%E7%AC%94%E8%AE%B0/Java%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81/"/>
      <url>/2022/03/23/Java%E7%AC%94%E8%AE%B0/Java%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据库驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mybatis-plus --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 代码自动生成器依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.hhhh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.DataSourceConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.GlobalConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.PackageConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.StrategyConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.po.TableFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.DateType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">outo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">scanner</span><span class="params">(String tip)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">help</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        help.append(<span class="string">&quot;请输入&quot;</span> + tip + <span class="string">&quot;：&quot;</span>);</span><br><span class="line">        System.out.println(help.toString());</span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ipt</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(ipt)) &#123;</span><br><span class="line">                <span class="keyword">return</span> ipt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusException</span>(<span class="string">&quot;请输入正确的&quot;</span> + tip + <span class="string">&quot;！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 代码生成器</span></span><br><span class="line">        <span class="type">AutoGenerator</span> <span class="variable">mpg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全局配置</span></span><br><span class="line">        <span class="type">GlobalConfig</span> <span class="variable">gc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">projectPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        gc.setOutputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>);<span class="comment">//设置代码生成路径</span></span><br><span class="line">        gc.setFileOverride(<span class="literal">true</span>);<span class="comment">//是否覆盖以前文件</span></span><br><span class="line">        gc.setOpen(<span class="literal">false</span>);<span class="comment">//是否打开生成目录</span></span><br><span class="line">        gc.setAuthor(<span class="string">&quot;yaoqi&quot;</span>);<span class="comment">//设置项目作者名称</span></span><br><span class="line">        gc.setIdType(IdType.AUTO);<span class="comment">//设置主键策略</span></span><br><span class="line">        gc.setBaseResultMap(<span class="literal">true</span>);<span class="comment">//生成基本ResultMap</span></span><br><span class="line">        gc.setBaseColumnList(<span class="literal">true</span>);<span class="comment">//生成基本ColumnList</span></span><br><span class="line">        gc.setServiceName(<span class="string">&quot;%sService&quot;</span>);<span class="comment">//去掉服务默认前缀</span></span><br><span class="line">        gc.setDateType(DateType.ONLY_DATE);<span class="comment">//设置时间类型</span></span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据源配置</span></span><br><span class="line">        <span class="type">DataSourceConfig</span> <span class="variable">dsc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>();</span><br><span class="line">        dsc.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3307/bitdf?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&quot;</span>);</span><br><span class="line">        dsc.setDriverName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dsc.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dsc.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        mpg.setDataSource(dsc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包配置</span></span><br><span class="line">        <span class="type">PackageConfig</span> <span class="variable">pc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>();</span><br><span class="line">        pc.setParent(<span class="string">&quot;com.yixin&quot;</span>);</span><br><span class="line">        pc.setMapper(<span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">        pc.setXml(<span class="string">&quot;mapper.xml&quot;</span>);</span><br><span class="line">        pc.setEntity(<span class="string">&quot;pojo&quot;</span>);</span><br><span class="line">        pc.setService(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">        pc.setServiceImpl(<span class="string">&quot;service.impl&quot;</span>);</span><br><span class="line">        pc.setController(<span class="string">&quot;controller&quot;</span>);</span><br><span class="line">        mpg.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 策略配置</span></span><br><span class="line">        <span class="type">StrategyConfig</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyConfig</span>();</span><br><span class="line">        sc.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        sc.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        sc.setEntityLombokModel(<span class="literal">true</span>);<span class="comment">//自动lombok</span></span><br><span class="line">        sc.setRestControllerStyle(<span class="literal">true</span>);</span><br><span class="line">        sc.setControllerMappingHyphenStyle(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        sc.setLogicDeleteFieldName(<span class="string">&quot;deleted&quot;</span>);<span class="comment">//设置逻辑删除</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置自动填充配置</span></span><br><span class="line">        <span class="type">TableFill</span> <span class="variable">gmt_create</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TableFill</span>(<span class="string">&quot;create_time&quot;</span>, FieldFill.INSERT);</span><br><span class="line">        <span class="type">TableFill</span> <span class="variable">gmt_modified</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TableFill</span>(<span class="string">&quot;update_time&quot;</span>, FieldFill.INSERT_UPDATE);</span><br><span class="line">        ArrayList&lt;TableFill&gt; tableFills=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        tableFills.add(gmt_create);</span><br><span class="line">        tableFills.add(gmt_modified);</span><br><span class="line">        sc.setTableFillList(tableFills);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//乐观锁</span></span><br><span class="line">        sc.setVersionFieldName(<span class="string">&quot;version&quot;</span>);</span><br><span class="line">        sc.setRestControllerStyle(<span class="literal">true</span>);<span class="comment">//驼峰命名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  sc.setTablePrefix(&quot;tbl_&quot;); 设置表名前缀</span></span><br><span class="line">        sc.setInclude(scanner(<span class="string">&quot;表名，多个英文逗号分割&quot;</span>).split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">        mpg.setStrategy(sc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成代码</span></span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java其他知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> Java其他知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树形分类数据</title>
      <link href="/2022/03/17/Java%E7%AC%94%E8%AE%B0/Java%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%A0%91%E5%BD%A2%E5%88%86%E7%B1%BB%E6%95%B0%E6%8D%AE/"/>
      <url>/2022/03/17/Java%E7%AC%94%E8%AE%B0/Java%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%A0%91%E5%BD%A2%E5%88%86%E7%B1%BB%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="树形分类数据"><a href="#树形分类数据" class="headerlink" title="树形分类数据"></a>树形分类数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class CategoryEntity implements Serializable &#123;</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 分类id</span><br><span class="line"> */</span><br><span class="line">@TableId</span><br><span class="line">private Long catId;</span><br><span class="line">/**</span><br><span class="line"> * 分类名称</span><br><span class="line"> */</span><br><span class="line">private String name;</span><br><span class="line">/**</span><br><span class="line"> * 父分类id</span><br><span class="line"> */</span><br><span class="line">private Long parentCid;</span><br><span class="line">/**</span><br><span class="line"> * 层级</span><br><span class="line"> */</span><br><span class="line">private Integer catLevel;</span><br><span class="line">/**</span><br><span class="line"> * 是否显示[0-不显示，1显示]</span><br><span class="line"> */</span><br><span class="line">@TableLogic(value = &quot;1&quot;,delval = &quot;0&quot;)</span><br><span class="line">private Integer showStatus;</span><br><span class="line">/**</span><br><span class="line"> * 排序</span><br><span class="line"> */</span><br><span class="line">private Integer sort;</span><br><span class="line">/**</span><br><span class="line"> * 图标地址</span><br><span class="line"> */</span><br><span class="line">private String icon;</span><br><span class="line">/**</span><br><span class="line"> * 计量单位</span><br><span class="line"> */</span><br><span class="line">private String productUnit;</span><br><span class="line">/**</span><br><span class="line"> * 商品数量</span><br><span class="line"> */</span><br><span class="line">private Integer productCount;</span><br><span class="line"></span><br><span class="line">@TableField(exist = false)</span><br><span class="line">private List&lt;CategoryEntity&gt; children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;CategoryEntity&gt; <span class="title function_">listwithtree</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;CategoryEntity&gt; entities = baseMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    List&lt;CategoryEntity&gt; levelmenus = entities.stream().filter(categoryEntity -&gt;</span><br><span class="line">            categoryEntity.getParentCid() == <span class="number">0</span></span><br><span class="line">    ).map((menu) -&gt; &#123;</span><br><span class="line">        menu.setChildren(getChildrens(menu, entities));</span><br><span class="line">        <span class="keyword">return</span> menu;</span><br><span class="line">    &#125;).sorted((menu1, menu2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> (menu1.getSort() == <span class="literal">null</span> ? <span class="number">0</span> : menu1.getSort()) - (menu2.getSort() == <span class="literal">null</span> ? <span class="number">0</span> : menu2.getSort());</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> levelmenus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;CategoryEntity&gt; <span class="title function_">getChildrens</span><span class="params">(CategoryEntity root, List&lt;CategoryEntity&gt; all)</span> &#123;</span><br><span class="line">    List&lt;CategoryEntity&gt; children = all.stream().filter(categoryEntity -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> categoryEntity.getParentCid() == root.getCatId();</span><br><span class="line">    &#125;).map(categoryEntity -&gt; &#123;</span><br><span class="line">        categoryEntity.setChildren(getChildrens(categoryEntity, all));</span><br><span class="line">        <span class="keyword">return</span> categoryEntity;</span><br><span class="line">    &#125;).sorted((menu1, menu2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> (menu1.getSort() == <span class="literal">null</span> ? <span class="number">0</span> : menu1.getSort()) - (menu2.getSort() == <span class="literal">null</span> ? <span class="number">0</span> : menu2.getSort());</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java其他知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> Java其他知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步编排</title>
      <link href="/2022/03/16/Java%E7%AC%94%E8%AE%B0/Java%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92/"/>
      <url>/2022/03/16/Java%E7%AC%94%E8%AE%B0/Java%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<h2 id="异步编排"><a href="#异步编排" class="headerlink" title="异步编排"></a>异步编排</h2><p><strong>简介</strong>：重要的数据先调用获取，例如：假如商品详情每个页面查询，需要的如下的标准时间完成，那么用户需要10s才能完成。这里我们需采用异步查询，比如接口A查询商品信息，而接口B需要查询商品sku,接口C需要查询商品供应商等信息，如接口C必须依赖接口A或接口B的返回值。那么我们就需要使用CompletableFuture接口来实现。</p><h4 id="初始化线程的四种方法："><a href="#初始化线程的四种方法：" class="headerlink" title="初始化线程的四种方法："></a><strong>初始化线程的四种方法：</strong></h4><ol><li>继承Thread</li><li>实现Runnable接口</li><li>实现Callable接口 + FutureTask （可以拿到返回结果，可以处理异常）</li><li>线程池</li></ol><p>方式1、方式2：主进程无法获取线程的运算结果。不适合当前场景。</p><p>方式3：主进程可以获取线程的运算结果，并设置给VO，但是不利于控制服务器中的线程资源。可以导致服务器资源耗尽。</p><p>方式4：通过线程池性能稳定，也可以获取执行结果，并捕获异常。但是，在业务复杂情况下，一个异步调用可能会依赖于另一个异步调用的执行结果。</p><h4 id="创建异步对象："><a href="#创建异步对象：" class="headerlink" title="创建异步对象："></a><strong>创建异步对象</strong>：</h4><p>CompletableFuture 提供了四个静态方法来创建一个异步操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span><br></pre></td></tr></table></figure><p>没有指定Executor的方法会使用ForkJoinPool.commonPool() 作为它的线程池执行异步代码。如果指定线程池，则使用指定的线程池运行。以下所有的方法都类同。</p><ul><li>runAsync方法不支持返回值。</li><li>supplyAsync可以支持返回值。</li></ul><h4 id="计算完成时回调方法"><a href="#计算完成时回调方法" class="headerlink" title="计算完成时回调方法:"></a><strong>计算完成时回调方法</strong>:</h4><p>当CompletableFuture的计算结果完成，或者抛出异常的时候，可以执行特定的Action。主要是下面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> Throwable&gt; action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">exceptionally</span><span class="params">(Function&lt;Throwable,? extends T&gt; fn)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> Throwable&gt; action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> Throwable&gt; action, Executor executor)</span>;</span><br></pre></td></tr></table></figure><ul><li>whenComplete可以处理正常和异常的计算结果，exceptionally处理异常情况。</li><li>BiConsumer&lt;? super T,? super Throwable&gt;可以定义处理业务</li><li>whenComplete 和 whenCompleteAsync 的区别：<br>whenComplete：是执行当前任务的线程执行继续执行 whenComplete 的任务。<br>whenCompleteAsync：是执行把 whenCompleteAsync 这个任务继续提交给线程池来进行执行。</li></ul><p>方法不以Async结尾，意味着Action使用相同的线程执行，而Async可能会使用其他线程执行（如果是使用相同的线程池，也可能会被同一个线程选中执行）</p><h4 id="handle-方法"><a href="#handle-方法" class="headerlink" title="handle 方法:"></a><strong>handle 方法</strong>:</h4><p>handle 是执行任务完成时对结果的处理。<br>handle 是在任务完成后再执行，还可以处理异常的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">handle</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn,Executor executor)</span>;</span><br></pre></td></tr></table></figure><h4 id="线程串行化方法"><a href="#线程串行化方法" class="headerlink" title="线程串行化方法:"></a><strong>线程串行化方法</strong>:</h4><p>thenApply 方法：当一个线程依赖另一个线程时，获取上一个任务返回的结果，并返回当前任务的返回值。</p><p>thenAccept方法：消费处理结果。接收任务的处理结果，并消费处理，无返回结果。</p><p>thenRun方法：只要上面的任务执行完成，就开始执行thenRun，只是处理完任务后，执行 thenRun的后续操作</p><p>带有Async默认是异步执行的。这里所谓的异步指的是不在当前线程内执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn, Executor executor)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">thenAccept</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action,Executor executor)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">thenRun</span><span class="params">(Runnable action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action,Executor executor)</span>;</span><br></pre></td></tr></table></figure><p>Function&lt;? super T,? extends U&gt;<br>T：上一个任务返回结果的类型<br>U：当前任务的返回值类型</p><h4 id="两任务组合"><a href="#两任务组合" class="headerlink" title="两任务组合"></a>两任务组合</h4><ul><li><strong>都要完成</strong></li></ul><p>两个任务必须都完成，触发该任务。</p><p>thenCombine：组合两个future，获取两个future的返回结果，并返回当前任务的返回值</p><p>thenAcceptBoth：组合两个future，获取两个future任务的返回结果，然后处理任务，没有返回值。</p><p>runAfterBoth：组合两个future，不需要获取future的结果，只需两个future处理完任务后，处理该任务。  </p><ul><li><strong>一个完成</strong></li></ul><p>当两个任务中，任意一个future任务完成的时候，执行任务。</p><p>applyToEither：两个任务有一个执行完成，获取它的返回值，处理任务并有新的返回值。</p><p>acceptEither：两个任务有一个执行完成，获取它的返回值，处理任务，没有新的返回值。</p><p>runAfterEither：两个任务有一个执行完成，不需要获取future的结果，处理任务，也没有返回值。</p><h4 id="多任务组合"><a href="#多任务组合" class="headerlink" title="多任务组合"></a>多任务组合</h4><ul><li>allOf：等待所有任务完成</li><li>anyOf：只要有一个任务完成</li></ul><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><p>配置线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">threadPoolExecutor</span><span class="params">(ThreadPoolConfigProperties threadPoolConfigProperties)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(threadPoolConfigProperties.getCoreSize(),</span><br><span class="line">                threadPoolConfigProperties.getMaxSize(),</span><br><span class="line">                threadPoolConfigProperties.getKeepAliveTime() , TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">10000</span>), Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;yaoqi.thread&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfigProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer keepAliveTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gulimall:</span></span><br><span class="line">  <span class="attr">thread:</span></span><br><span class="line">    <span class="attr">core-size:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">max-size:</span> <span class="number">200</span></span><br><span class="line">    <span class="attr">keep-alive-time:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>业务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ThreadPoolExecutor executor;</span><br><span class="line"><span class="comment">//有返回值</span></span><br><span class="line">CompletableFuture&lt;Vo&gt; infoFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//1、sku基本信息的获取</span></span><br><span class="line">            <span class="keyword">return</span> Vo;</span><br><span class="line">        &#125;, executor);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; saleAttrFuture = infoFuture.thenAcceptAsync((res) -&gt; &#123;</span><br><span class="line">            <span class="comment">//3、获取spu的销售属性组合-&gt; 依赖1 获取spuId</span></span><br><span class="line">        &#125;, executor);</span><br><span class="line"></span><br><span class="line"><span class="comment">//无返回值</span></span><br><span class="line">CompletableFuture&lt;Void&gt; imageFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//2、sku的图片信息</span></span><br><span class="line">        &#125;, executor);</span><br><span class="line"></span><br><span class="line"><span class="comment">//w所有任务</span></span><br><span class="line">CompletableFuture.allOf(imageFuture,saleAttrFuture).get();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java其他知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> Java其他知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot文件上传下载</title>
      <link href="/2022/03/12/Java%E7%AC%94%E8%AE%B0/Java%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/SpringBoot%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
      <url>/2022/03/12/Java%E7%AC%94%E8%AE%B0/Java%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/SpringBoot%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot文件上传下载"><a href="#SpringBoot文件上传下载" class="headerlink" title="SpringBoot文件上传下载"></a>SpringBoot文件上传下载</h1><h2 id="后台代码"><a href="#后台代码" class="headerlink" title="后台代码"></a>后台代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/file&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;上传及下载文件的路径&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件上传</span></span><br><span class="line">    <span class="meta">@PostMapping</span> (<span class="string">&quot;/upload&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;文件内容为空&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">            <span class="comment">//若需要修改上传的文件名，则获取后缀名，再拼接到新的filename前缀名称</span></span><br><span class="line">            <span class="comment">//获取后缀名</span></span><br><span class="line">            <span class="comment">//String suffixName = filename.substring(filename.lastIndexOf(&quot;.&quot;));</span></span><br><span class="line">            <span class="comment">//设置文件路径</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath+filename);</span><br><span class="line">            <span class="comment">//检测是否存在目录,若不存在则新建</span></span><br><span class="line">            <span class="keyword">if</span> (!dest.getParentFile().exists()) &#123;</span><br><span class="line">                dest.getParentFile().mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//文件写入</span></span><br><span class="line">            file.transferTo(dest);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;上传成功&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;上传失败&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件下载</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/download/&#123;fileName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">download</span><span class="params">(HttpServletResponse response,<span class="meta">@PathVariable(&quot;fileName&quot;)</span> String fileName)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath+fileName);</span><br><span class="line">        <span class="keyword">if</span> (file.exists())&#123;</span><br><span class="line">            <span class="comment">// 设置下载的文件名</span></span><br><span class="line">            response.addHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;fileName=&quot;</span> + fileName);</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">BufferedInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">            <span class="type">BufferedOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(response.getOutputStream());</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bis.read(buffer);</span><br><span class="line">            <span class="keyword">while</span> (i != -<span class="number">1</span>) &#123;</span><br><span class="line">                bout.write(buffer, <span class="number">0</span>, i);</span><br><span class="line">                i = bin.read(buffer);</span><br><span class="line">                <span class="comment">//释放资源</span></span><br><span class="line">                <span class="keyword">if</span> (bin != <span class="literal">null</span>) &#123;</span><br><span class="line">                    bin.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bout != <span class="literal">null</span>) &#123;</span><br><span class="line">                    bout.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;下载成功&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;下载失败&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>springboot文件上传与下载<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>文件上传<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--enctype=&quot;multipart/form-data&quot;:指定传输类型为二进制类型，一般上传文件时使用，上传方法也必须是“POST”--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    请选择文件： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;download/文件名&quot;</span>&gt;</span>下载文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：springboot对上传的文件大小有默认大小不能1MB，超过1MB会出现这个错误：org.springframework.web.multipart.MultipartException。</p><p>解决方法：配置第一行是设置单个文件的大小，第二行是设置单次请求的文件的总大小，配置方法根据SpringBoot版本不同而不同。</p><p>1.Spring Boot 1.3 或之前的版本，配置:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">multipart.maxFileSize</span> <span class="string">=</span> <span class="string">100Mb</span></span><br><span class="line"><span class="string">multipart.maxRequestSize</span> <span class="string">=</span> <span class="string">200Mb</span></span><br></pre></td></tr></table></figure><p>2.Spring Boot 1.4 版本后配置:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.http.multipart.maxFileSize</span> <span class="string">=</span> <span class="string">100Mb</span></span><br><span class="line"><span class="string">spring.http.multipart.maxRequestSize</span> <span class="string">=</span> <span class="string">200Mb</span></span><br></pre></td></tr></table></figure><p>3.Spring Boot 2.0 之后的版本配置修改为: </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单位由Mb改为MB了</span></span><br><span class="line"><span class="string">spring.servlet.multipart.max-file-size</span> <span class="string">=</span> <span class="string">100MB</span></span><br><span class="line"><span class="string">spring.servlet.multipart.max-request-size</span> <span class="string">=</span> <span class="string">200MB</span></span><br></pre></td></tr></table></figure><p>如果想要不限制文件上传的大小，那么就把两个值都设置为-1</p>]]></content>
      
      
      <categories>
          
          <category> Java其他知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> Java其他知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea导入git分支项目</title>
      <link href="/2022/03/07/Java%E7%AC%94%E8%AE%B0/Java%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/Idea%E5%AF%BC%E5%85%A5git%E5%88%86%E6%94%AF%E9%A1%B9%E7%9B%AE/"/>
      <url>/2022/03/07/Java%E7%AC%94%E8%AE%B0/Java%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/Idea%E5%AF%BC%E5%85%A5git%E5%88%86%E6%94%AF%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Idea导入git分支项目"><a href="#Idea导入git分支项目" class="headerlink" title="Idea导入git分支项目"></a>Idea导入git分支项目</h1><p>因为直接通过git的clone命令默认是直接导入远程仓库的master主支的代码，无法导入分支代码</p><h2 id="如何导入分支代码？"><a href="#如何导入分支代码？" class="headerlink" title="如何导入分支代码？"></a>如何导入分支代码？</h2><p>首先创建个空文件夹，打开文件夹右击出现git命令行，执行以下代码：</p><p><img src="/noteimg/Java%E7%AC%94%E8%AE%B0/Java%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/img/image-20220727110600522.png" alt="image-20220727110600522"> </p><p>打开idea，在idea里打开刚才新建的项目文件夹（File-&gt;open）</p><p>右键刚才打开的项目，从远程获取代码库</p><p><img src="/noteimg/Java%E7%AC%94%E8%AE%B0/Java%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/img/image-20220727110923223.png" alt="image-20220727110923223"> </p><p>选择所需要的分支代码并从远程获取代码并合并本地的版本</p><p><img src="/noteimg/Java%E7%AC%94%E8%AE%B0/Java%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/img/image-20220727111037749.png" alt="image-20220727111037749"> </p><p><img src="/noteimg/Java%E7%AC%94%E8%AE%B0/Java%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/img/image-20220727111202072.png" alt="image-20220727111202072"> </p><p>等待Idea加载代码，完成！</p><p><img src="/noteimg/Java%E7%AC%94%E8%AE%B0/Java%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/img/image-20220727111659418.png" alt="image-20220727111659418"> </p><p>若需要新项目联合maven，只需右键文件夹，选择Add Frameworks Support—&gt;Maven</p><p><img src="/noteimg/Java%E7%AC%94%E8%AE%B0/Java%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/img/image-20220727112412339.png" alt="image-20220727112412339"> </p><p><img src="/noteimg/Java%E7%AC%94%E8%AE%B0/Java%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/img/image-20220727112304055.png" alt="image-20220727112304055"> </p>]]></content>
      
      
      <categories>
          
          <category> Java其他知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> Java其他知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.并发编程</title>
      <link href="/2022/03/07/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/5.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/03/07/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/5.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="协程-goroutine"><a href="#协程-goroutine" class="headerlink" title="协程 goroutine"></a>协程 goroutine</h2><h4 id="goroutine-只是由官方实现的超级”线程池”。"><a href="#goroutine-只是由官方实现的超级”线程池”。" class="headerlink" title="goroutine 只是由官方实现的超级”线程池”。"></a>goroutine 只是由官方实现的超级”线程池”。</h4><p>每个实力<code>4~5KB</code>的栈内存占用和由于实现机制而大幅减少的创建和销毁开销是go高并发的根本原因。</p><p>并发不是并行：并发主要由切换时间片来实现”同时”运行，并行则是直接利用多核实现多线程的运行，go可以设置使用核数，以发挥多核计算机的能力。</p><h4 id="goroutine-奉行通过通信来共享内存，而不是共享内存来通信。"><a href="#goroutine-奉行通过通信来共享内存，而不是共享内存来通信。" class="headerlink" title="goroutine 奉行通过通信来共享内存，而不是共享内存来通信。"></a>goroutine 奉行通过通信来共享内存，而不是共享内存来通信。</h4><h2 id="runtime包"><a href="#runtime包" class="headerlink" title="runtime包"></a>runtime包</h2><h3 id="runtime-Gosched"><a href="#runtime-Gosched" class="headerlink" title="runtime.Gosched()"></a>runtime.Gosched()</h3><p>使当前go程放弃处理器，以让其它go程运行。它不会挂起当前go程，因此当前go程未来会恢复执行</p><h3 id="runtime-Goexit"><a href="#runtime-Goexit" class="headerlink" title="runtime.Goexit()"></a>runtime.Goexit()</h3><p>退出当前协程</p><h3 id="runtime-GOMAXPROCS"><a href="#runtime-GOMAXPROCS" class="headerlink" title="runtime.GOMAXPROCS"></a>runtime.GOMAXPROCS</h3><p>Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>channel是一种类型，一种引用类型：var 变量 chan 元素类型</p><p>创建channel的格式如下：make(chan 元素类型, [缓冲大小])</p><p>channel的缓冲大小是可选的。</p><p>举几个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">ch6 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">int</span>)</span><br></pre></td></tr></table></figure><h3 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h3><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p><p>发送和接收都使用&lt;-符号。</p><p>现在我们先使用以下语句定义一个通道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>发送：将一个值发送到通道中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 把10发送到ch中</span></span><br></pre></td></tr></table></figure><p>接收：从一个通道中接收值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;- ch <span class="comment">// 从ch中接收值并赋值给变量x</span></span><br><span class="line">&lt;-ch       <span class="comment">// 从ch中接收值，忽略结果</span></span><br></pre></td></tr></table></figure><p>关闭：我们通过调用内置的close函数来关闭通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p><p>关闭后的通道有以下特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.对一个关闭的通道再发送值就会导致panic。</span><br><span class="line">2.对一个关闭的通道进行接收会一直获取值直到通道为空。</span><br><span class="line">3.对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</span><br><span class="line">4.关闭一个已经关闭的通道会导致panic。</span><br></pre></td></tr></table></figure><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>select的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句。如果多个channel同时ready，则随机选择一个执行</p><h2 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h2><h4 id="GMP-模型"><a href="#GMP-模型" class="headerlink" title="GMP 模型"></a>GMP 模型</h4><p>在 Go 中，线程是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上。</p><p><img src="https://www.topgoer.com/static/7.1/gmp/12.jpg" alt="img"></p><ul><li>全局队列（Global Queue）：存放等待运行的 G。</li><li>P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。</li><li>P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。</li><li>M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</li></ul><p>Goroutine 调度器和 OS 调度器是通过 M 结合起来的，每个 M 都代表了 1 个内核线程，OS 调度器负责把内核线程分配到 CPU 的核上执行。</p><blockquote><p>有关 P 和 M 的个数问题</p></blockquote><p>1、P 的数量：</p><ul><li>由启动时环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS() 决定。这意味着在程序执行的任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行。</li></ul><p>2、M 的数量:</p><ul><li>go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000. 但是内核很难支持这么多的线程数，所以这个限制可以忽略。</li><li>runtime&#x2F;debug 中的 SetMaxThreads 函数，设置 M 的最大数量</li><li>一个 M 阻塞了，会创建新的 M。</li></ul><p>M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。</p><blockquote><p>P 和 M 何时会被创建</p></blockquote><p>1、P 何时创建：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。</p><p>2、M 何时创建：没有足够的 M 来关联 P 并运行其中的可运行的 G。比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M。</p><h2 id="go-func-调度流程"><a href="#go-func-调度流程" class="headerlink" title="go func () 调度流程"></a>go func () 调度流程</h2><p><img src="https://www.topgoer.com/static/7.1/gmp/13.jpg" alt="img"></p><p>从上图我们可以分析出几个结论：</p><p> 1、我们通过 go func () 来创建一个 goroutine；</p><p> 2、有两个存储 G 的队列，一个是局部调度器 P 的本地队列、一个是全局 G 队列。新创建的 G 会先保存在 P 的本地队列中，如果 P 的本地队列已经满了就会保存在全局的队列中；</p><p> 3、G 只能运行在 M 中，一个 M 必须持有一个 P，M 与 P 是 1：1 的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会想其他的 MP 组合偷取一个可执行的 G 来执行；</p><p> 4、一个 M 调度 G 执行的过程是一个循环机制；</p><p> 5、当 M 执行某一个 G 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除 (detach)，然后再创建一个新的操作系统的线程 (如果有空闲的线程可用就复用空闲线程) 来服务于这个 P；</p><p> 6、当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中。</p>]]></content>
      
      
      <categories>
          
          <category> Go笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> Go笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.常用标准库</title>
      <link href="/2022/03/07/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/6.%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/"/>
      <url>/2022/03/07/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/6.%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h2><h3 id="向外输出"><a href="#向外输出" class="headerlink" title="向外输出"></a>向外输出</h3><h4 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h4><p>Print系列函数会将内容输出到系统的标准输出，区别在于Print函数直接输出内容，Printf函数支持格式化输出字符串，Println函数会在输出内容的结尾添加一个换行符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><h4 id="Fprint"><a href="#Fprint" class="headerlink" title="Fprint"></a>Fprint</h4><p>Fprint系列函数会将内容输出到一个io.Writer接口类型的变量w中，我们通常用这个函数往文件中写入内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprint</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintln</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向标准输出写入内容</span></span><br><span class="line">fmt.Fprintln(os.Stdout, <span class="string">&quot;向标准输出写入内容&quot;</span>)</span><br><span class="line">fileObj, err := os.OpenFile(<span class="string">&quot;./xx.txt&quot;</span>, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;打开文件出错，err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">name := <span class="string">&quot;枯藤&quot;</span></span><br><span class="line"><span class="comment">// 向打开的文件句柄中写入内容</span></span><br><span class="line">fmt.Fprintf(fileObj, <span class="string">&quot;往文件中写如信息：%s&quot;</span>, name)</span><br></pre></td></tr></table></figure><p>注意，只要满足io.Writer接口的类型都支持写入。</p><h4 id="Sprint"><a href="#Sprint" class="headerlink" title="Sprint"></a>Sprint</h4><p>Sprint系列函数会把传入的数据生成并返回一个字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprint</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure><h4 id="Errorf"><a href="#Errorf" class="headerlink" title="Errorf"></a>Errorf</h4><p>Errorf函数根据format参数生成格式化字符串并返回一个包含该字符串的错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure><p>通常使用这种方式来自定义错误类型，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := fmt.Errorf(<span class="string">&quot;这是一个错误&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="通用占位符"><a href="#通用占位符" class="headerlink" title="通用占位符"></a>通用占位符</h4><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%v</td><td>值的默认格式表示</td></tr><tr><td>%+v</td><td>类似%v，但输出结构体时会添加字段名</td></tr><tr><td>%#v</td><td>值的Go语法表示</td></tr><tr><td>%T</td><td>打印值的类型</td></tr><tr><td>%%</td><td>百分号</td></tr></tbody></table><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="number">100</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">o := <span class="keyword">struct</span>&#123; name <span class="type">string</span> &#125;&#123;<span class="string">&quot;枯藤&quot;</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, o)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, o)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, o)</span><br><span class="line">fmt.Printf(<span class="string">&quot;100%%\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">false</span><br><span class="line">&#123;枯藤&#125;</span><br><span class="line">struct &#123; name string &#125;&#123;name:&quot;枯藤&quot;&#125;</span><br><span class="line">struct &#123; name string &#125;</span><br><span class="line">100%</span><br></pre></td></tr></table></figure><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%t</td><td>true或false</td></tr></tbody></table><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%b</td><td>表示为二进制</td></tr><tr><td>%c</td><td>该值对应的unicode码值</td></tr><tr><td>%d</td><td>表示为十进制</td></tr><tr><td>%o</td><td>表示为八进制</td></tr><tr><td>%x</td><td>表示为十六进制，使用a-f</td></tr><tr><td>%X</td><td>表示为十六进制，使用A-F</td></tr><tr><td>%U</td><td>表示为Unicode格式：U+1234，等价于”U+%04X”</td></tr><tr><td>%q</td><td>该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示</td></tr></tbody></table><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="number">65</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%c\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%o\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%X\n&quot;</span>, n)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1000001</span><br><span class="line">A</span><br><span class="line">65</span><br><span class="line">101</span><br><span class="line">41</span><br><span class="line">41</span><br></pre></td></tr></table></figure><h4 id="浮点数与复数"><a href="#浮点数与复数" class="headerlink" title="浮点数与复数"></a>浮点数与复数</h4><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%b</td><td>无小数部分、二进制指数的科学计数法，如-123456p-78</td></tr><tr><td>%e</td><td>科学计数法，如-1234.456e+78</td></tr><tr><td>%E</td><td>科学计数法，如-1234.456E+78</td></tr><tr><td>%f</td><td>有小数部分但无指数部分，如123.456</td></tr><tr><td>%F</td><td>等价于%f</td></tr><tr><td>%g</td><td>根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）</td></tr><tr><td>%G</td><td>根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）</td></tr></tbody></table><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f := <span class="number">12.34</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%e\n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%E\n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%g\n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%G\n&quot;</span>, f)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">6946802425218990p-49</span><br><span class="line">1.234000e+01</span><br><span class="line">1.234000E+01</span><br><span class="line">12.340000</span><br><span class="line">12.34</span><br><span class="line">12.34</span><br></pre></td></tr></table></figure><h4 id="字符串和-byte"><a href="#字符串和-byte" class="headerlink" title="字符串和[]byte"></a>字符串和[]byte</h4><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%s</td><td>直接输出字符串或者[]byte</td></tr><tr><td>%q</td><td>该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示</td></tr><tr><td>%x</td><td>每个字节用两字符十六进制数表示（使用a-f )</td></tr><tr><td>%X</td><td>每个字节用两字符十六进制数表示（使用A-F）</td></tr></tbody></table><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;枯藤&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%X\n&quot;</span>, s)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">枯藤</span><br><span class="line">&quot;枯藤&quot;</span><br><span class="line">e69eafe897a4</span><br><span class="line">E69EAFE897A4</span><br></pre></td></tr></table></figure><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%p</td><td>表示为十六进制，并加上前导的0x</td></tr></tbody></table><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">18</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#p\n&quot;</span>, &amp;a)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xc000054058</span><br><span class="line">c000054058</span><br></pre></td></tr></table></figure><h4 id="宽度标识符"><a href="#宽度标识符" class="headerlink" title="宽度标识符"></a>宽度标识符</h4><p>宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为0。举例如下</p><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%f</td><td>默认宽度，默认精度</td></tr><tr><td>%9f</td><td>宽度9，默认精度</td></tr><tr><td>%.2f</td><td>默认宽度，精度2</td></tr><tr><td>%9.2f</td><td>宽度9，精度2</td></tr><tr><td>%9.f</td><td>宽度9，精度0</td></tr></tbody></table><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="number">88.88</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%9f\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%9.2f\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%9.f\n&quot;</span>, n)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">88.880000</span><br><span class="line">88.880000</span><br><span class="line">88.88</span><br><span class="line">    88.88</span><br><span class="line">       89</span><br></pre></td></tr></table></figure><h4 id="其他falg"><a href="#其他falg" class="headerlink" title="其他falg"></a>其他falg</h4><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>’+’</td><td>总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）；</td></tr><tr><td>’ ‘</td><td>对数值，正数前加空格而负数前加负号；对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格</td></tr><tr><td>’-’</td><td>在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）；</td></tr><tr><td>’#’</td><td>八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）对%q（%#q），对%U（%#U）会输出空格和单引号括起来的go字面值；</td></tr><tr><td>‘0’</td><td>使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面；</td></tr></tbody></table><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;枯藤&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%5s\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%-5s\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%5.7s\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%-5.7s\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%5.2s\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%05s\n&quot;</span>, s)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">枯藤</span><br><span class="line">   枯藤</span><br><span class="line">枯藤</span><br><span class="line">   枯藤</span><br><span class="line">枯藤</span><br><span class="line">   枯藤</span><br><span class="line">000枯藤</span><br></pre></td></tr></table></figure><h3 id="获取输入"><a href="#获取输入" class="headerlink" title="获取输入"></a>获取输入</h3><p>Go语言fmt包下有fmt.Scan、fmt.Scanf、fmt.Scanln三个函数，可以在程序运行过程中从标准输入获取用户的输入。</p><h4 id="fmt-Scan"><a href="#fmt-Scan" class="headerlink" title="fmt.Scan"></a>fmt.Scan</h4><p>函数定签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scan</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><ul><li>Scan从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。</li><li>本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因。</li></ul><p>具体代码示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        name    <span class="type">string</span></span><br><span class="line">        age     <span class="type">int</span></span><br><span class="line">        married <span class="type">bool</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Scan(&amp;name, &amp;age, &amp;married)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;扫描结果 name:%s age:%d married:%t \n&quot;</span>, name, age, married)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译后在终端执行，在终端依次输入枯藤、18和false使用空格分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./scan_demo </span><br><span class="line">枯藤 18 false</span><br><span class="line">扫描结果 name:枯藤 age:18 married:false</span><br></pre></td></tr></table></figure><p>fmt.Scan从标准输入中扫描用户输入的数据，将以空白符分隔的数据分别存入指定的参数。</p><h4 id="fmt-Scanf"><a href="#fmt-Scanf" class="headerlink" title="fmt.Scanf"></a>fmt.Scanf</h4><p>函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scanf</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><ul><li>Scanf从标准输入扫描文本，根据format参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。</li><li>本函数返回成功扫描的数据个数和遇到的任何错误。</li></ul><p>代码示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        name    <span class="type">string</span></span><br><span class="line">        age     <span class="type">int</span></span><br><span class="line">        married <span class="type">bool</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Scanf(<span class="string">&quot;1:%s 2:%d 3:%t&quot;</span>, &amp;name, &amp;age, &amp;married)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;扫描结果 name:%s age:%d married:%t \n&quot;</span>, name, age, married)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译后在终端执行，在终端按照指定的格式依次输入枯藤、18和false。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./scan_demo </span><br><span class="line">1:枯藤 2:18 3:false</span><br><span class="line">扫描结果 name:枯藤 age:18 married:false</span><br></pre></td></tr></table></figure><p>fmt.Scanf不同于fmt.Scan简单的以空格作为输入数据的分隔符，fmt.Scanf为输入数据指定了具体的输入内容格式，只有按照格式输入数据才会被扫描并存入对应变量。</p><p>例如，我们还是按照上个示例中以空格分隔的方式输入，fmt.Scanf就不能正确扫描到输入的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./scan_demo </span><br><span class="line">枯藤 18 false</span><br><span class="line">扫描结果 name: age:0 married:false</span><br></pre></td></tr></table></figure><h4 id="fmt-Scanln"><a href="#fmt-Scanln" class="headerlink" title="fmt.Scanln"></a>fmt.Scanln</h4><p>函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scanln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><ul><li>Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。</li><li>本函数返回成功扫描的数据个数和遇到的任何错误。</li></ul><p>具体代码示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        name    <span class="type">string</span></span><br><span class="line">        age     <span class="type">int</span></span><br><span class="line">        married <span class="type">bool</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Scanln(&amp;name, &amp;age, &amp;married)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;扫描结果 name:%s age:%d married:%t \n&quot;</span>, name, age, married)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译后在终端执行，在终端依次输入枯藤、18和false使用空格分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./scan_demo </span><br><span class="line">枯藤 18 false</span><br><span class="line">扫描结果 name:枯藤 age:18 married:false</span><br></pre></td></tr></table></figure><p>fmt.Scanln遇到回车就结束扫描了，这个比较常用。</p><h4 id="bufio-NewReader"><a href="#bufio-NewReader" class="headerlink" title="bufio.NewReader"></a>bufio.NewReader</h4><p>有时候我们想完整获取输入的内容，而输入的内容可能包含空格，这种情况下可以使用bufio包来实现。示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bufioDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    reader := bufio.NewReader(os.Stdin) <span class="comment">// 从标准输入生成读对象</span></span><br><span class="line">    fmt.Print(<span class="string">&quot;请输入内容：&quot;</span>)</span><br><span class="line">    text, _ := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 读到换行</span></span><br><span class="line">    text = strings.TrimSpace(text)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Fscan系列"><a href="#Fscan系列" class="headerlink" title="Fscan系列"></a>Fscan系列</h4><p>这几个函数功能分别类似于fmt.Scan、fmt.Scanf、fmt.Scanln三个函数，只不过它们不是从标准输入中读取数据而是从io.Reader中读取数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscan</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanln</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanf</span><span class="params">(r io.Reader, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><h4 id="Sscan系列"><a href="#Sscan系列" class="headerlink" title="Sscan系列"></a>Sscan系列</h4><p>这几个函数功能分别类似于fmt.Scan、fmt.Scanf、fmt.Scanln三个函数，只不过它们不是从标准输入中读取数据而是从指定字符串中读取数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscan</span><span class="params">(str <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanln</span><span class="params">(str <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanf</span><span class="params">(str <span class="type">string</span>, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><h2 id="Strconv"><a href="#Strconv" class="headerlink" title="Strconv"></a>Strconv</h2><p>strconv包实现了基本数据类型与其字符串表示的转换，主要有以下常用函数： Atoi()、Itia()、parse系列、format系列、append系列</p><h3 id="Atoi"><a href="#Atoi" class="headerlink" title="Atoi()"></a>Atoi()</h3><p>Atoi()函数用于将字符串类型的整数转换为int类型，函数签名如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atoi</span><span class="params">(s <span class="type">string</span>)</span></span> (i <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><h3 id="Itoa"><a href="#Itoa" class="headerlink" title="Itoa()"></a>Itoa()</h3><p>Itoa()函数用于将int类型数据转换为对应的字符串表示，具体的函数签名如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Itoa</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure><h3 id="Parse系列函数"><a href="#Parse系列函数" class="headerlink" title="Parse系列函数"></a>Parse系列函数</h3><p>Parse类函数用于转换字符串为给定类型的值：ParseBool()、ParseFloat()、ParseInt()、ParseUint()</p><h3 id="Format系列函数"><a href="#Format系列函数" class="headerlink" title="Format系列函数"></a>Format系列函数</h3><p>Format系列函数实现了将给定类型数据格式化为string类型数据的功能。</p><h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。</p><p>对服务器传入的请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传递上下文，或者可以使用WithCancel、WithDeadline、WithTimeout或WithValue创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。</p><p>context.Context是一个接口，该接口定义了四个需要实现的方法。具体签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>Deadline方法需要返回当前Context被取消的时间，也就是完成工作的截止时间（deadline）；</li><li>Done方法需要返回一个Channel，这个Channel会在当前工作完成或者上下文被取消之后关闭，多次调用Done方法会返回同一个Channel；</li><li>Err方法会返回当前Context结束的原因，它只会在Done返回的Channel被关闭时才会返回非空的值；<ul><li>如果当前Context被取消就会返回Canceled错误；</li><li>如果当前Context超时就会返回DeadlineExceeded错误；</li></ul></li><li>Value方法会从Context中返回键对应的值，对于同一个上下文来说，多次调用Value 并传入相同的Key会返回相同的结果，该方法仅用于传递跨API和进程间跟请求域的数据；</li></ul><h3 id="Background-和TODO"><a href="#Background-和TODO" class="headerlink" title="Background()和TODO()"></a>Background()和TODO()</h3><p>Go内置两个函数：Background()和TODO()，这两个函数分别返回一个实现了Context接口的background和todo。我们代码中最开始都是以这两个内置的上下文对象作为最顶层的partent context，衍生出更多的子上下文对象。</p><p>Background()主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context。</p><p>TODO()，它目前还不知道具体的使用场景，如果我们不知道该使用什么Context的时候，可以使用这个。</p><p>background和todo本质上都是emptyCtx结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context。</p><h3 id="With系列函数"><a href="#With系列函数" class="headerlink" title="With系列函数"></a>With系列函数</h3><p>此外，context包中还定义了四个With系列函数。</p><h4 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h4><p>WithCancel的函数签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</span><br></pre></td></tr></table></figure><p>WithCancel返回带有新Done通道的父节点的副本。当调用返回的cancel函数或当关闭父上下文的Done通道时，将关闭返回上下文的Done通道，无论先发生什么情况。</p><p>取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(ctx context.Context)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">        dst := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">        n := <span class="number">1</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">                    <span class="keyword">return</span> <span class="comment">// return结束该goroutine，防止泄露</span></span><br><span class="line">                <span class="keyword">case</span> dst &lt;- n:</span><br><span class="line">                    n++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">return</span> dst</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">defer</span> cancel() <span class="comment">// 当我们取完需要的整数后调用cancel</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) &#123;</span><br><span class="line">        fmt.Println(n)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例代码中，gen函数在单独的goroutine中生成整数并将它们发送到返回的通道。 gen的调用者在使用生成的整数之后需要取消上下文，以免gen启动的内部goroutine发生泄漏。</p><h4 id="WithDeadline"><a href="#WithDeadline" class="headerlink" title="WithDeadline"></a>WithDeadline</h4><p>WithDeadline的函数签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</span><br></pre></td></tr></table></figure><p>返回父上下文的副本，并将deadline调整为不迟于d。如果父上下文的deadline已经早于d，则WithDeadline(parent, d)在语义上等同于父上下文。当截止日过期时，当调用返回的cancel函数时，或者当父上下文的Done通道关闭时，返回上下文的Done通道将被关闭，以最先发生的情况为准。</p><p>取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := time.Now().Add(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">    ctx, cancel := context.WithDeadline(context.Background(), d)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尽管ctx会过期，但在任何情况下调用它的cancel函数都是很好的实践。</span></span><br><span class="line">    <span class="comment">// 如果不这样做，可能会使上下文及其父类存活的时间超过必要的时间。</span></span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;overslept&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(ctx.Err())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，定义了一个50毫秒之后过期的deadline，然后我们调用context.WithDeadline(context.Background(), d)得到一个上下文（ctx）和一个取消函数（cancel），然后使用一个select让主程序陷入等待：等待1秒后打印overslept退出或者等待ctx过期后退出。 因为ctx50秒后就过期，所以ctx.Done()会先接收到值，上面的代码会打印ctx.Err()取消原因。</p><h4 id="WithTimeout"><a href="#WithTimeout" class="headerlink" title="WithTimeout"></a>WithTimeout</h4><p>WithTimeout的函数签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</span><br></pre></td></tr></table></figure><p>WithTimeout返回WithDeadline(parent, time.Now().Add(timeout))。</p><p>取消此上下文将释放与其相关的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel，通常用于数据库或者网络连接的超时控制。具体示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// context.WithTimeout</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">LOOP:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;db connecting ...&quot;</span>)</span><br><span class="line">        time.Sleep(time.Millisecond * <span class="number">10</span>) <span class="comment">// 假设正常连接数据库耗时10毫秒</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 50毫秒后自动调用</span></span><br><span class="line">            <span class="keyword">break</span> LOOP</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;worker done!&quot;</span>)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置一个50毫秒的超时</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*<span class="number">50</span>)</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> worker(ctx)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">    cancel() <span class="comment">// 通知子goroutine结束</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;over&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h4><p>WithValue函数能够将请求作用域的数据与 Context 对象建立关系。声明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func WithValue(parent Context, key, val interface&#123;&#125;) Context</span><br></pre></td></tr></table></figure><p>WithValue返回父节点的副本，其中与key关联的值为val。</p><p>仅对API和进程间传递请求域的数据使用上下文值，而不是使用它来传递可选参数给函数。</p><p>所提供的键必须是可比较的，并且不应该是string类型或任何其他内置类型，以避免使用上下文在包之间发生冲突。WithValue的用户应该为键定义自己的类型。为了避免在分配给interface{}时进行分配，上下文键通常具有具体类型struct{}。或者，导出的上下文关键变量的静态类型应该是指针或接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// context.WithValue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TraceCode <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    key := TraceCode(<span class="string">&quot;TRACE_CODE&quot;</span>)</span><br><span class="line">    traceCode, ok := ctx.Value(key).(<span class="type">string</span>) <span class="comment">// 在子goroutine中获取trace code</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;invalid trace code&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">LOOP:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;worker, trace code:%s\n&quot;</span>, traceCode)</span><br><span class="line">        time.Sleep(time.Millisecond * <span class="number">10</span>) <span class="comment">// 假设正常连接数据库耗时10毫秒</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 50毫秒后自动调用</span></span><br><span class="line">            <span class="keyword">break</span> LOOP</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;worker done!&quot;</span>)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置一个50毫秒的超时</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*<span class="number">50</span>)</span><br><span class="line">    <span class="comment">// 在系统的入口中设置trace code传递给后续启动的goroutine实现日志数据聚合</span></span><br><span class="line">    ctx = context.WithValue(ctx, TraceCode(<span class="string">&quot;TRACE_CODE&quot;</span>), <span class="string">&quot;12512312234&quot;</span>)</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> worker(ctx)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">    cancel() <span class="comment">// 通知子goroutine结束</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;over&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Context的注意事项"><a href="#使用Context的注意事项" class="headerlink" title="使用Context的注意事项"></a>使用Context的注意事项</h4><ul><li>推荐以参数的方式显示传递Context</li><li>以Context作为参数的函数方法，应该把Context作为第一个参数。</li><li>给一个函数方法传递Context的时候，不要传递nil，如果不知道传递什么，就使用context.TODO()</li><li>Context的Value相关方法应该传递请求域的必要数据，不应该用于传递可选参数</li><li>Context是线程安全的，可以放心的在多个goroutine中传递</li></ul><h4 id="客户端超时取消示例"><a href="#客户端超时取消示例" class="headerlink" title="客户端超时取消示例"></a>客户端超时取消示例</h4><p>调用服务端API时如何在客户端实现超时控制？</p><h3 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context_timeout/server/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server端，随机出现慢响应</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    number := rand.Intn(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">0</span> &#123;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">10</span>) <span class="comment">// 耗时10秒的慢响应</span></span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;slow response&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Fprint(w, <span class="string">&quot;quick response&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, indexHandler)</span><br><span class="line">    err := http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context_timeout/client/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> respData <span class="keyword">struct</span> &#123;</span><br><span class="line">    resp *http.Response</span><br><span class="line">    err  <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doCall</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    transport := http.Transport&#123;</span><br><span class="line">       <span class="comment">// 请求频繁可定义全局的client对象并启用长链接</span></span><br><span class="line">       <span class="comment">// 请求不频繁使用短链接</span></span><br><span class="line">       DisableKeepAlives: <span class="literal">true</span>,     &#125;</span><br><span class="line">    client := http.Client&#123;</span><br><span class="line">        Transport: &amp;transport,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    respChan := <span class="built_in">make</span>(<span class="keyword">chan</span> *respData, <span class="number">1</span>)</span><br><span class="line">    req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://127.0.0.1:8000/&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;new requestg failed, err:%v\n&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    req = req.WithContext(ctx) <span class="comment">// 使用带超时的ctx创建一个新的client request</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">defer</span> wg.Wait()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        resp, err := client.Do(req)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;client.do resp:%v, err:%v\n&quot;</span>, resp, err)</span><br><span class="line">        rd := &amp;respData&#123;</span><br><span class="line">            resp: resp,</span><br><span class="line">            err:  err,</span><br><span class="line">        &#125;</span><br><span class="line">        respChan &lt;- rd</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        <span class="comment">//transport.CancelRequest(req)</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;call api timeout&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> result := &lt;-respChan:</span><br><span class="line">        fmt.Println(<span class="string">&quot;call server api success&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> result.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;call server api failed, err:%v\n&quot;</span>, result.err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> result.resp.Body.Close()</span><br><span class="line">        data, _ := ioutil.ReadAll(result.resp.Body)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;resp:%v\n&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个100毫秒的超时</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">defer</span> cancel() <span class="comment">// 调用cancel释放子goroutine资源</span></span><br><span class="line">    doCall(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><ul><li><p>json使用go语言内置的encoding&#x2F;json 标准库</p></li><li><p>编码json使用json.Marshal()函数可以对一组数据进行JSON格式的编码</p></li><li><p>解码json使用json.Unmarshal()函数可以对一组数据进行JSON格式的解码</p></li></ul><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><ul><li>是可扩展标记语言，包含声明、根标签、子元素和属性</li><li>应用场景：配置文件以及webService</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    &lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">    &lt;servers version=<span class="string">&quot;1&quot;</span>&gt;</span><br><span class="line">        &lt;server&gt;</span><br><span class="line">            &lt;serverName&gt;Shanghai_VPN&lt;/serverName&gt;</span><br><span class="line">            &lt;serverIP&gt;<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>&lt;/serverIP&gt;</span><br><span class="line">        &lt;/server&gt;</span><br><span class="line">        &lt;server&gt;</span><br><span class="line">            &lt;serverName&gt;Beijing_VPN&lt;/serverName&gt;</span><br><span class="line">            &lt;serverIP&gt;<span class="number">127.0</span><span class="number">.0</span><span class="number">.2</span>&lt;/serverIP&gt;</span><br><span class="line">        &lt;/server&gt;</span><br><span class="line">    &lt;/servers&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;encoding/xml&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽取单个server对象</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">   ServerName <span class="type">string</span> <span class="string">`xml:&quot;serverName&quot;`</span></span><br><span class="line">   ServerIP   <span class="type">string</span> <span class="string">`xml:&quot;serverIP&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Servers <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name    xml.Name <span class="string">`xml:&quot;servers&quot;`</span></span><br><span class="line">   Version <span class="type">int</span>   <span class="string">`xml:&quot;version&quot;`</span></span><br><span class="line">   Servers []Server <span class="string">`xml:&quot;server&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   data, err := ioutil.ReadFile(<span class="string">&quot;D:/my.xml&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> servers Servers</span><br><span class="line">   err = xml.Unmarshal(data, &amp;servers)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;xml: %#v\n&quot;</span>, servers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> Go笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> Go笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.方法</title>
      <link href="/2022/03/01/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/3.%E6%96%B9%E6%B3%95/"/>
      <url>/2022/03/01/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/3.%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := User&#123;<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line">    u.Test()</span><br><span class="line"></span><br><span class="line">    mValue := u.Test</span><br><span class="line">    mValue() <span class="comment">// 隐式传递 receiver</span></span><br><span class="line"></span><br><span class="line">    mExpression := (*User).Test</span><br><span class="line">    mExpression(&amp;u) <span class="comment">// 显式传递 receiver</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">0xc42000a060</span>, &amp;&#123;<span class="number">1</span> Tom&#125;</span><br><span class="line"><span class="number">0xc42000a060</span>, &amp;&#123;<span class="number">1</span> Tom&#125;</span><br><span class="line"><span class="number">0xc42000a060</span>, &amp;&#123;<span class="number">1</span> Tom&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">    path       <span class="type">string</span></span><br><span class="line">    op         <span class="type">string</span></span><br><span class="line">    createTime <span class="type">string</span></span><br><span class="line">    message    <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PathError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;path=%s \nop=%s \ncreateTime=%s \nmessage=%s&quot;</span>, p.path,</span><br><span class="line">        p.op, p.createTime, p.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(filename <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">    file, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;PathError&#123;</span><br><span class="line">            path:       filename,</span><br><span class="line">            op:         <span class="string">&quot;read&quot;</span>,</span><br><span class="line">            message:    err.Error(),</span><br><span class="line">            createTime: fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, time.Now()),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := Open(<span class="string">&quot;/Users/5lmh/Desktop/go/src/test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">switch</span> v := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> *PathError:</span><br><span class="line">        fmt.Println(<span class="string">&quot;get path error,&quot;</span>, v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">get path <span class="type">error</span>, path=/Users/pprof/Desktop/<span class="keyword">go</span>/src/test.txt </span><br><span class="line">op=read </span><br><span class="line">createTime=<span class="number">2018</span><span class="number">-04</span><span class="number">-05</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">17.331915</span> +<span class="number">0800</span> CST m=+<span class="number">0.000441790</span> </span><br><span class="line">message=open /Users/pprof/Desktop/<span class="keyword">go</span>/src/test.txt: no such file or directory</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> Go笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.接口、网络编程</title>
      <link href="/2022/03/01/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/4.%E6%8E%A5%E5%8F%A3%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/03/01/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/4.%E6%8E%A5%E5%8F%A3%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型</p><p>一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个需要实现的方法列表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">    move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *dog)</span></span> move() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;狗会动&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x Mover</span><br><span class="line">    <span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">    x = wangcai         <span class="comment">// x不可以接收dog类型(如果为d dog则可以接受)</span></span><br><span class="line">    <span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">    x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><ul><li>Socket又称“套接字”，应用程序通常通过“套接字”向网络发出请求或者应答网络请求</li><li>常用的Socket类型有两种：流式Socket和数据报式Socket，流式是一种面向连接的Socket，针对于面向连接的TCP服务应用，数据报式Socket是一种无连接的Socket，针对于无连接的UDP服务应用</li></ul><h2 id="TCP-传输层"><a href="#TCP-传输层" class="headerlink" title="TCP(传输层)"></a>TCP(传输层)</h2><p>是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transport layer）通信协议，因为是面向连接的协议，数据像水流一样传输，会存在黏包问题。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>不需要建立连接就能直接进行数据发送和接收，属于不可靠的、没有时序的通信，但是UDP协议的实时性比较好，通常用于视频直播相关领域。UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><h2 id="TCP粘包"><a href="#TCP粘包" class="headerlink" title="TCP粘包"></a>TCP粘包</h2><h3 id="为什么会出现粘包"><a href="#为什么会出现粘包" class="headerlink" title="为什么会出现粘包"></a>为什么会出现粘包</h3><p>主要原因就是tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。</p><p>“粘包”可发生在发送端也可发生在接收端：</p><p>​    1.由Nagle算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。<br>​    2.接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>出现”粘包”的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。</p><p>封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了(过滤非法包时封包会加入”包尾”内容)。包头部分的长度是固定的，并且它存储了包体的长度，根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。</p><p>我们可以自己定义一个协议，比如数据包的前4个字节为包头，里面存储的是发送的数据的长度。</p><h2 id="WebSocket编程"><a href="#WebSocket编程" class="headerlink" title="WebSocket编程"></a>WebSocket编程</h2><ul><li>WebSocket是一种在单个TCP连接上进行全双工通信的协议</li><li>WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据</li><li>在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输</li><li>需要安装第三方包：<ul><li>cmd中：go get -u -v github.com&#x2F;gorilla&#x2F;websocket</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> Go笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.函数</title>
      <link href="/2022/02/26/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/2.%E5%87%BD%E6%95%B0/"/>
      <url>/2022/02/26/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/2.%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>无需声明原型。</li><li>支持不定 变参。</li><li>支持多返回值。</li><li>支持命名返回参数。 </li><li>支持匿名函数和闭包。</li><li>函数也是一种类型，一个函数可以赋值给变量。</li><li>不支持 嵌套 (nested) 一个包不能有两个名字一样的函数。</li><li>不支持 重载 (overload) </li><li>不支持 默认参数 (default parameter)。</li></ul><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(fn <span class="keyword">func</span>()</span></span> <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义函数类型。</span></span><br><span class="line"><span class="keyword">type</span> FormatFunc <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>, x, y <span class="type">int</span>)</span></span> <span class="type">string</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">format</span><span class="params">(fn FormatFunc, s <span class="type">string</span>, x, y <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(s, x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := test(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">100</span> &#125;) <span class="comment">// 直接将匿名函数当参数。</span></span><br><span class="line"></span><br><span class="line">    s2 := format(<span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>, x, y <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(s, x, y)</span><br><span class="line">    &#125;, <span class="string">&quot;%d, %d&quot;</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(s1, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>在默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数</p><p>注意1：无论是值传递，还是引用传递，传递给函数的都是变量的副本，不过，值传递是值的拷贝。引用传递是地址的拷贝，一般来说，地址拷贝更为高效。而值拷贝取决于拷贝的对象大小，对象越大，则性能越低。</p><p>注意2：map、slice、chan、指针、interface默认以引用的方式传递。</p><p>在参数赋值时可以不用用一个一个的赋值，可以直接传递一个数组或者切片，特别注意的是在参数后加上“…”即可</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">&quot;Hello, World!&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><p>匿名函数可赋值给变量，做为结构字段，或者在 channel 里传送。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>Go语言是支持闭包的，这里只是简单地讲一下在Go语言中闭包是如何实现的。 下面我来将之前的JavaScript的闭包例子用Go来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    b := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := a()</span><br><span class="line">    c()</span><br><span class="line">    c()</span><br><span class="line">    c()</span><br><span class="line"></span><br><span class="line">    a() <span class="comment">//不会输出i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>闭包复制的是原对象指针，这就很容易解释延迟引用现象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">100</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;x (%p) = %d\n&quot;</span>, &amp;x, x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x (%p) = %d\n&quot;</span>, &amp;x, x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := test()</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x (0xc42007c008) = 100</span><br><span class="line">x (0xc42007c008) = 100</span><br></pre></td></tr></table></figure><p>在汇编层 ，test 实际返回的是 FuncVal 对象，其中包含了匿名函数地址、闭包对象指针。当调 匿名函数时，只需以某个寄存器传递该对象即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FuncVal &#123; func_address, closure_var_pointer ... &#125;</span><br></pre></td></tr></table></figure><p>外部引用函数参数局部变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部引用函数参数局部变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(base <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        base += i</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tmp1 := add(<span class="number">10</span>)</span><br><span class="line">    fmt.Println(tmp1(<span class="number">1</span>), tmp1(<span class="number">2</span>))</span><br><span class="line">    <span class="comment">// 此时tmp1和tmp2不是一个实体了</span></span><br><span class="line">    tmp2 := add(<span class="number">100</span>)</span><br><span class="line">    fmt.Println(tmp2(<span class="number">1</span>), tmp2(<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回2个闭包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回2个函数类型的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test01</span><span class="params">(base <span class="type">int</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 定义2个函数，并返回</span></span><br><span class="line">    <span class="comment">// 相加</span></span><br><span class="line">    add := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        base += i</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相减</span></span><br><span class="line">    sub := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        base -= i</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> add, sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f1, f2 := test01(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">// base一直是没有消</span></span><br><span class="line">    fmt.Println(f1(<span class="number">1</span>), f2(<span class="number">2</span>))</span><br><span class="line">    <span class="comment">// 此时base是9</span></span><br><span class="line">    fmt.Println(f1(<span class="number">3</span>), f2(<span class="number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="延迟调用（defer）"><a href="#延迟调用（defer）" class="headerlink" title="延迟调用（defer）"></a>延迟调用（defer）</h2><p>defer 是先进后出</p>]]></content>
      
      
      <categories>
          
          <category> Go笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> Go笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.基础</title>
      <link href="/2022/02/25/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/1.%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/02/25/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/1.%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>go env用于打印Go语言的环境信息。</p><p>go run命令可以编译并运行命令源码文件。</p><p>go get可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。</p><p>go build命令用于编译我们指定的源码文件或代码包以及它们的依赖包。</p><p>go install用于编译并安装指定的代码包及它们的依赖包。</p><p>go clean命令会删除掉执行其它命令时产生的一些文件和目录。</p><p>go doc命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。</p><p>go test命令用于对Go语言编写的程序进行测试。</p><p>go list命令的作用是列出指定的代码包的信息。</p><p>go fix会把指定代码包的所有Go语言源码文件中的旧版本代码修正为新版本的代码。</p><p>go vet是一个用于检查Go语言源码中静态错误的简单工具。</p><p>go tool pprof命令来交互式的访问概要文件的内容。</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td></tr><tr><td>ll</td><td>逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td></tr><tr><td>!</td><td>逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td></tr><tr><td>&amp;</td><td>参与运算的两数各对应的二进位相与。（两位均为1才为1）</td></tr><tr><td>l</td><td>参与运算的两数各对应的二进位相或。（两位有一个为1就为1）</td></tr><tr><td>^</td><td>参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。（两位不一样则为1）</td></tr><tr><td>&lt;&lt;</td><td>左移n位就是乘以2的n次方。“a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td></tr><tr><td>&gt;&gt;</td><td>右移n位就是除以2的n次方。“a&gt;&gt;b”是把a的各二进位全部右移b位。</td></tr><tr><td>&lt;&lt;&#x3D;</td><td>左移后赋值</td></tr><tr><td>&gt;&gt;&#x3D;</td><td>右移后赋值</td></tr><tr><td>&amp;&#x3D;</td><td>按位与后赋值</td></tr><tr><td>l&#x3D;</td><td>按位或后赋值</td></tr><tr><td>^&#x3D;</td><td>按位异或后赋值</td></tr></tbody></table><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>import _ 包路径：只是引用该包，仅仅是为了调用init()函数，所以无法通过包名来调用包中的其他函数</p><p>忽略这个变量</p><h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line"><span class="keyword">var</span> name, sex = <span class="string">&quot;pprof.cn&quot;</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数内部 (:= 不能声明在函数外)</span></span><br><span class="line">n := <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span> <span class="comment">//常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//iota</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">    n2 = <span class="number">100</span>  <span class="comment">//100</span></span><br><span class="line">    _</span><br><span class="line">    n4        <span class="comment">//3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _  = <span class="literal">iota</span></span><br><span class="line">    KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h3><table><thead><tr><th>方法</th><th>介绍</th></tr></thead><tbody><tr><td>len(str)</td><td>求长度</td></tr><tr><td>+或fmt.Sprintf</td><td>拼接字符串</td></tr><tr><td>strings.Split</td><td>分割</td></tr><tr><td>strings.Contains</td><td>判断是否包含</td></tr><tr><td>strings.HasPrefix,strings.HasSuffix</td><td>前缀&#x2F;后缀判断</td></tr><tr><td>strings.Index(),strings.LastIndex()</td><td>子串出现的位置</td></tr><tr><td>strings.Join(a[]string, sep string)</td><td>join操作</td></tr></tbody></table><h3 id="rune"><a href="#rune" class="headerlink" title="rune"></a>rune</h3><p>uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。</p><p>rune类型，代表一个 UTF-8字符。</p><p><code>rune</code>类型实际是一个<code>int32</code>。 Go 使用了特殊的 <code>rune</code> 类型来处理 <code>Unicode</code>，让基于 <code>Unicode</code>的文本处理更为方便，也可以使用 <code>byte</code> 型进行默认字符串处理，性能和扩展性都有照顾</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局：</span></span><br><span class="line"><span class="keyword">var</span> arr0 [<span class="number">5</span>]<span class="type">int</span> = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr2 = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="keyword">var</span> str = [<span class="number">5</span>]<span class="type">string</span>&#123;<span class="number">3</span>: <span class="string">&quot;hello world&quot;</span>, <span class="number">4</span>: <span class="string">&quot;tom&quot;</span>&#125;</span><br><span class="line"><span class="comment">//局部：</span></span><br><span class="line">a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;           <span class="comment">// 未初始化元素值为 0。</span></span><br><span class="line">b := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;   <span class="comment">// 通过初始化值确定数组长度。</span></span><br><span class="line">c := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">2</span>: <span class="number">100</span>, <span class="number">4</span>: <span class="number">200</span>&#125; <span class="comment">// 使用索引号初始化元素。</span></span><br><span class="line">d := [...]<span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">uint8</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    &#123;<span class="string">&quot;user1&quot;</span>, <span class="number">10</span>&#125;, <span class="comment">// 可省略元素类型。</span></span><br><span class="line">    &#123;<span class="string">&quot;user2&quot;</span>, <span class="number">20</span>&#125;, <span class="comment">// 别忘了最后一行的逗号。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多维数组</span></span><br><span class="line"><span class="comment">//全局</span></span><br><span class="line"><span class="keyword">var</span> arr0 [<span class="number">5</span>][<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> arr1 [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span> = [...][<span class="number">3</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;</span><br><span class="line"><span class="comment">//局部：</span></span><br><span class="line">a := [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line">b := [...][<span class="number">2</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">3</span>&#125;&#125; <span class="comment">// 第 2 纬度不能用 &quot;...&quot;。</span></span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//1.声明切片</span></span><br><span class="line">   <span class="keyword">var</span> s1 []<span class="type">int</span></span><br><span class="line">   <span class="keyword">if</span> s1 == <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;是空&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;不是空&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 2.:=</span></span><br><span class="line">   s2 := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">   <span class="comment">// 3.make()</span></span><br><span class="line">   <span class="keyword">var</span> s3 []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">   fmt.Println(s1, s2, s3)</span><br><span class="line">   <span class="comment">// 4.初始化赋值</span></span><br><span class="line">   <span class="keyword">var</span> s4 []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">   fmt.Println(s4)</span><br><span class="line">   s5 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">   fmt.Println(s5)</span><br><span class="line">   <span class="comment">// 5.从数组切片</span></span><br><span class="line">   arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">   <span class="keyword">var</span> s6 []<span class="type">int</span></span><br><span class="line">   <span class="comment">// 前包后不包</span></span><br><span class="line">   s6 = arr[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">   fmt.Println(s6)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>select 语句类似于 switch 语句，每个case必须是一个通信操作，要么是发送要么是接收。 select 随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。</p>]]></content>
      
      
      <categories>
          
          <category> Go笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> Go笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04函数</title>
      <link href="/2022/02/24/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/04%E5%87%BD%E6%95%B0/"/>
      <url>/2022/02/24/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/04%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h1><p>实参通过值的方式传递，因此函数的形参是实参的<strong>值拷贝</strong>。<strong>形参进行修改不会影响实参</strong>。但是，<strong>如果实参包括引用类型</strong>，如指针，slice(切片)、map、function、channel等类型，<strong>实参可能会由于函数的间接引用被修改</strong>。</p><p>拥有2个int型参数和1个int型返回值的函数（__符号：强调某个参数未被使用）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span>   &#123;<span class="keyword">return</span> x + y&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>)   &#123; z = x - y; <span class="keyword">return</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">first</span><span class="params">(x <span class="type">int</span>, _ <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>      &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WaitForServer</span><span class="params">(url <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timeout = <span class="number">1</span> * time.Minute</span><br><span class="line">    deadline := time.Now().Add(timeout)</span><br><span class="line">    <span class="keyword">for</span> tries := <span class="number">0</span>; time.Now().Before(deadline); tries++ &#123;</span><br><span class="line">        _, err := http.Head(url)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// success</span></span><br><span class="line">        &#125;</span><br><span class="line">        log.Printf(<span class="string">&quot;server not responding (%s);retrying…&quot;</span>, err)</span><br><span class="line">        time.Sleep(time.Second &lt;&lt; <span class="type">uint</span>(tries)) <span class="comment">// exponential back-off</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;server %s failed to respond after %s&quot;</span>, url, timeout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := WaitForServer(url); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fprintf(os.Stderr, <span class="string">&quot;Site is down: %v\n&quot;</span>, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    log.Fatalf(<span class="string">&quot;Site is down: %v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。</p><p><strong>log</strong>中的所有函数，都默认会在错误信息之前<strong>输出时间信息</strong>。</p><h1 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h1><p>在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> n * n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">negative</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> -n &#125;</span><br><span class="line"></span><br><span class="line">f := square</span><br><span class="line">fmt.Println(f(<span class="number">3</span>)) <span class="comment">// &quot;9&quot;</span></span><br><span class="line"></span><br><span class="line">f = negative</span><br><span class="line">fmt.Println(f(<span class="number">3</span>))     <span class="comment">// &quot;-3&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, f) <span class="comment">// &quot;func(int) int&quot;</span></span><br></pre></td></tr></table></figure><p>函数类型的零值是nil。调用值为nil的函数值会引起panic错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">f(<span class="number">3</span>) <span class="comment">// 此处f的值为nil, 会引起panic错误</span></span><br></pre></td></tr></table></figure><p>函数值之间是不可比较的，也不能用函数值作为map的key。</p><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>func关键字后没有函数名。函数值字面量是一种表达式，它的值被称为匿名函数，函数字面量允许我们在使用函数时，再定义它。</p><p>通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squares</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        x++</span><br><span class="line">        <span class="keyword">return</span> x * x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := squares()</span><br><span class="line">    fmt.Println(f()) <span class="comment">// &quot;1&quot;</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// &quot;4&quot;</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// &quot;9&quot;</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// &quot;16&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包，等待循环结束后，再执行函数值。&#x3D;&#x3D;</p><h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号<code>...</code>，这表示该函数会接收任意数量的该类型参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(vals...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> vals &#123;</span><br><span class="line">        total += val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sum函数返回任意个int型参数的和。在函数体中,vals被看作是类型为[] int的切片。sum可以接收任意数量的int型参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(sum())           <span class="comment">// &quot;0&quot;</span></span><br><span class="line">fmt.Println(sum(<span class="number">3</span>))          <span class="comment">// &quot;3&quot;</span></span><br><span class="line">fmt.Println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)) <span class="comment">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure><h1 id="Deffered函数"><a href="#Deffered函数" class="headerlink" title="Deffered函数"></a>Deffered函数</h1><p>你只需要在调用普通函数或方法前加上关键字<strong>defer</strong>，当执行到该条语句时，函数和参数表达式得到计算，但直到包含该defer语句的<strong>函数执行完毕</strong>时，<strong>defer后的函数才会被执行</strong>，可以在一个函数中执行<strong>多条defer语句</strong>，它们的<strong>执行顺序与声明顺序相反</strong>。</p><h1 id="Panic异常"><a href="#Panic异常" class="headerlink" title="Panic异常"></a>Panic异常</h1><p>虽然Go的panic机制类似于其他语言的异常，但panic的适用场景有一些不同。由于panic会引起程序的崩溃，因此panic一般用于严重错误，如程序内部的逻辑不一致。勤奋的程序员认为任何崩溃都表明代码中存在漏洞，所以对于大部分漏洞，我们应该使用Go提供的错误机制，而不是panic，尽量避免程序的崩溃。在健壮的程序中，任何可以预料到的错误，如不正确的输入、错误的配置或是失败的I&#x2F;O操作都应该被优雅的处理，最好的处理方式，就是使用Go的错误机制。</p><h1 id="Recover捕获异常"><a href="#Recover捕获异常" class="headerlink" title="Recover捕获异常"></a>Recover捕获异常</h1><p>如果在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。在未发生panic时调用recover，recover会返回nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(input <span class="type">string</span>)</span></span> (s *Syntax, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">            err = fmt.Errorf(<span class="string">&quot;internal error: %v&quot;</span>, p)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// ...parser...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> Go笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03复合数据类型</title>
      <link href="/2022/02/19/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/03%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/02/19/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/03%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><strong>数组的长度需要在编译阶段确定。</strong></p><p>因为数组的长度是固定的，因此在Go语言中很少直接使用数组。和数组对应的类型是Slice（切片），它是可以增长和收缩动态序列，slice功能也更灵活，但是要理解slice工作原理的话需要先理解数组,数组的每个元素都被初始化为元素类型对应的零值.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span> </span><br><span class="line"><span class="keyword">var</span> q [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">q := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  <span class="comment">//“...”省略号，则表示数组的长度是根据初始化值的个数来计算。</span></span><br><span class="line"><span class="keyword">type</span> Currency <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    USD Currency = <span class="literal">iota</span> <span class="comment">// 美元</span></span><br><span class="line">    EUR <span class="comment">// 欧元</span></span><br><span class="line">    GBP <span class="comment">// 英镑</span></span><br><span class="line">    RMB <span class="comment">// 人民币</span></span><br><span class="line">)</span><br><span class="line">symbol := [...]<span class="type">string</span>&#123;USD: <span class="string">&quot;$&quot;</span>, EUR: <span class="string">&quot;€&quot;</span>, GBP: <span class="string">&quot;￡&quot;</span>, RMB: <span class="string">&quot;￥&quot;</span>&#125;</span><br><span class="line">fmt.Println(RMB, symbol[RMB]) <span class="comment">// &quot;3 ￥&quot;</span></span><br></pre></td></tr></table></figure><h1 id="Slice切片"><a href="#Slice切片" class="headerlink" title="Slice切片"></a>Slice切片</h1><p>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。</p><p>append函数用于向slice追加元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> runes []<span class="type">rune</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">&quot;Hello, 世界&quot;</span> &#123;</span><br><span class="line">runes = <span class="built_in">append</span>(runes, r)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, runes) <span class="comment">// &quot;[&#x27;H&#x27; &#x27;e&#x27; &#x27;l&#x27; &#x27;l&#x27; &#x27;o&#x27; &#x27;,&#x27; &#x27; &#x27; &#x27;世&#x27; &#x27;界&#x27;]&quot;</span></span><br></pre></td></tr></table></figure><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>哈希表是一种巧妙并且实用的数据结构。它是一个无序的key&#x2F;value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) <span class="comment">// mapping from strings to ints</span></span><br><span class="line">ages := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">   <span class="string">&quot;alice&quot;</span>: <span class="number">31</span>,</span><br><span class="line">   <span class="string">&quot;charlie&quot;</span>: <span class="number">34</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map中的元素通过key对应的下标语法访问：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ages[<span class="string">&quot;alice&quot;</span>] = <span class="number">32</span></span><br><span class="line">fmt.Println(ages[<span class="string">&quot;alice&quot;</span>]) <span class="comment">// &quot;32&quot;</span></span><br></pre></td></tr></table></figure><p>使用内置的delete函数可以删除元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(ages, <span class="string">&quot;alice&quot;</span>) <span class="comment">// remove element ages[&quot;alice&quot;]</span></span><br></pre></td></tr></table></figure><p><strong>不能对map的元素进行取址操作</strong></p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">   ID        <span class="type">int</span></span><br><span class="line">   Name      <span class="type">string</span></span><br><span class="line">   Address   <span class="type">string</span></span><br><span class="line">   DoB       time.Time</span><br><span class="line">   Position  <span class="type">string</span></span><br><span class="line">   Salary    <span class="type">int</span></span><br><span class="line">   ManagerID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dilbert Employee</span><br></pre></td></tr></table></figure><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">   Title <span class="type">string</span></span><br><span class="line">   Year <span class="type">int</span> <span class="string">`json:&quot;released&quot;`</span></span><br><span class="line">   Color <span class="type">bool</span> <span class="string">`json:&quot;color,omitempty&quot;`</span></span><br><span class="line">   Actors []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> movies = []Movie&#123;</span><br><span class="line">   &#123;Title: <span class="string">&quot;Casablanca&quot;</span>, Year: <span class="number">1942</span>, Color: <span class="literal">false</span>,</span><br><span class="line">      Actors: []<span class="type">string</span>&#123;<span class="string">&quot;Humphrey Bogart&quot;</span>, <span class="string">&quot;Ingrid Bergman&quot;</span>&#125;&#125;,</span><br><span class="line">   &#123;Title: <span class="string">&quot;Cool Hand Luke&quot;</span>, Year: <span class="number">1967</span>, Color: <span class="literal">true</span>,</span><br><span class="line">      Actors: []<span class="type">string</span>&#123;<span class="string">&quot;Paul Newman&quot;</span>&#125;&#125;,</span><br><span class="line">   &#123;Title: <span class="string">&quot;Bullitt&quot;</span>, Year: <span class="number">1968</span>, Color: <span class="literal">true</span>,</span><br><span class="line">      Actors: []<span class="type">string</span>&#123;<span class="string">&quot;Steve McQueen&quot;</span>, <span class="string">&quot;Jacqueline Bisset&quot;</span>&#125;&#125;,</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">data, err := json.Marshal(movies)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalf(<span class="string">&quot;JSON marshaling failed: %s&quot;</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, data)</span><br><span class="line"></span><br><span class="line">[&#123;<span class="string">&quot;Title&quot;</span>:<span class="string">&quot;Casablanca&quot;</span>,<span class="string">&quot;released&quot;</span>:<span class="number">1942</span>,<span class="string">&quot;Actors&quot;</span>:[<span class="string">&quot;Humphrey Bogart&quot;</span>,<span class="string">&quot;Ingr</span></span><br><span class="line"><span class="string">id Bergman&quot;</span>]&#125;,&#123;<span class="string">&quot;Title&quot;</span>:<span class="string">&quot;Cool Hand Luke&quot;</span>,<span class="string">&quot;released&quot;</span>:<span class="number">1967</span>,<span class="string">&quot;color&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;Ac</span></span><br><span class="line"><span class="string">tors&quot;</span>:[<span class="string">&quot;Paul Newman&quot;</span>]&#125;,&#123;<span class="string">&quot;Title&quot;</span>:<span class="string">&quot;Bullitt&quot;</span>,<span class="string">&quot;released&quot;</span>:<span class="number">1968</span>,<span class="string">&quot;color&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;</span></span><br><span class="line"><span class="string">Actors&quot;</span>:[<span class="string">&quot;Steve McQueen&quot;</span>,<span class="string">&quot;Jacqueline Bisset&quot;</span>]&#125;]</span><br><span class="line">                                                 </span><br><span class="line"><span class="comment">//json.MarshalIndent函数将产生整齐缩进的输出</span></span><br><span class="line">                                                </span><br><span class="line">data, err := json.MarshalIndent(movies, <span class="string">&quot;&quot;</span>, <span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;JSON marshaling failed: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, data)                                                 </span><br><span class="line">                                                 </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="string">&quot;Title&quot;</span>: <span class="string">&quot;Casablanca&quot;</span>,</span><br><span class="line">    <span class="string">&quot;released&quot;</span>: <span class="number">1942</span>,</span><br><span class="line">    <span class="string">&quot;Actors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;Humphrey Bogart&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Ingrid Bergman&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="string">&quot;Title&quot;</span>: <span class="string">&quot;Cool Hand Luke&quot;</span>,</span><br><span class="line">    <span class="string">&quot;released&quot;</span>: <span class="number">1967</span>,</span><br><span class="line">    <span class="string">&quot;color&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;Actors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;Paul Newman&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="string">&quot;Title&quot;</span>: <span class="string">&quot;Bullitt&quot;</span>,</span><br><span class="line">    <span class="string">&quot;released&quot;</span>: <span class="number">1968</span>,</span><br><span class="line">    <span class="string">&quot;color&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;Actors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;Steve McQueen&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Jacqueline Bisset&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]                                                 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> Go笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02基础数据类型</title>
      <link href="/2022/02/19/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/02%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/02/19/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/02%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h1><p>有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是uint8、uint16、uint32和uint64四种无符号整数类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> u <span class="type">uint8</span> = <span class="number">255</span></span><br><span class="line">fmt.Println(u, u+<span class="number">1</span>, u*u) <span class="comment">// &quot;255 0 1&quot;</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int8</span> = <span class="number">127</span></span><br><span class="line">fmt.Println(i, i+<span class="number">1</span>, i*i) <span class="comment">// &quot;127 -128 1&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> apples <span class="type">int32</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> oranges <span class="type">int16</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> compote <span class="type">int</span> = apples + oranges <span class="comment">// compile error</span></span><br><span class="line"><span class="keyword">var</span> compote = <span class="type">int</span>(apples) + <span class="type">int</span>(oranges)</span><br></pre></td></tr></table></figure><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="type">float32</span> = <span class="number">16777216</span></span><br></pre></td></tr></table></figure><p>小数点前面或后面的数字都可能被省略（例如.707或1.）。很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分：</p><p>用Printf函数的%g参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用%e（带指数）或%f的形式打印可能更合适。所有的这三个打印形式都可以指定打印的宽度和控制打印精度。</p><h1 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h1><p>Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">complex128</span> = <span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1+2i</span></span><br><span class="line"><span class="keyword">var</span> y <span class="type">complex128</span> = <span class="built_in">complex</span>(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 3+4i</span></span><br><span class="line">fmt.Println(x*y) <span class="comment">// &quot;(-5+10i)&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">real</span>(x*y)) <span class="comment">// &quot;-5&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">imag</span>(x*y)) </span><br></pre></td></tr></table></figure><h1 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h1><p>布尔值可以和&amp;&amp;（AND）和||（OR）操作符结合，&amp;&amp; 的优先级比 || 高</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>一个字符串是一个不可改变的字节序列。</p><p>子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串。生成的新字符串将包含j-i个字节。</p><p>字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变，当然我们也可以给一个字符串变量分配一个新字符串值。可以像下面这样将一个字符串追加到另一个字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;left foot&quot;</span></span><br><span class="line">t := s</span><br><span class="line">s += <span class="string">&quot;, right foot&quot;</span></span><br></pre></td></tr></table></figure><p>在一个双引号包含的字符串面值中，可以用以反斜杠 \ 开头的转义序列插入任意的数据。下</p><p>面的换行、回车和制表符等是常见的ASCII控制代码的转义方式：</p><ul><li>\a 响铃</li><li>\b 退格</li><li>\f 换页</li><li>\n 换行</li><li>\r 回车</li><li>\t 制表符</li><li>\v 垂直制表符</li><li>&#39; 单引号 (只用在 ‘&#39;‘ 形式的rune符号面值中)</li><li>&quot; 双引号 (只用在 “…” 形式的字符串面值中)</li><li>\ 反斜杠</li></ul><p>字符串包含12个字节，以UTF8形式编码，但是只对应8个Unicode字符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;unicode/utf8&quot;</span></span><br><span class="line">s := <span class="string">&quot;Hello,世界&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// &quot;12&quot;</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(s)) <span class="comment">// &quot;8&quot;</span></span><br></pre></td></tr></table></figure><p>标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包。strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。</p><p>bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效，稍后我们将展示。</p><p>strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。</p><p>unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是ToUpper和ToLower，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。</p><h5 id="转换：除了字符串、字符、字节之间的转换，字符串和数值之间的转换也比较常见。由strconv包提供这类转换功能。"><a href="#转换：除了字符串、字符、字节之间的转换，字符串和数值之间的转换也比较常见。由strconv包提供这类转换功能。" class="headerlink" title="转换：除了字符串、字符、字节之间的转换，字符串和数值之间的转换也比较常见。由strconv包提供这类转换功能。"></a>转换：除了字符串、字符、字节之间的转换，字符串和数值之间的转换也比较常见。由strconv包提供这类转换功能。</h5><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>常量的值不可修改，这样可以防止在运行期被意外或恶意的修改。例如，常量比变量更适合用于表达像π之类的数学常数，因为它们的值不会发生变化，和变量声明一样，可以批量声明多个常量；这比较适合声明一组相关的常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.14159</span> <span class="comment">// approximately; math.Pi is a better approximation</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    e = <span class="number">2.71828182845904523536028747135266249775724709369995957496696763</span></span><br><span class="line">    pi = <span class="number">3.14159265358979323846264338327950288419716939937510582097494459</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b</span><br><span class="line">    c = <span class="number">2</span></span><br><span class="line">    d</span><br><span class="line">)</span><br><span class="line">fmt.Println(a, b, c, d) <span class="comment">// &quot;1 1 2 2&quot;</span></span><br></pre></td></tr></table></figure><p><strong>iota 常量生成器:在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。</strong></p><p>下面是来自time包的例子，它首先定义了一个Weekday命名类型，然后为一周的每天定义了一个常量，从周日0开始。在其它编程语言中，这种类型一般被称为枚举类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weekday <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday Weekday = <span class="literal">iota</span></span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">Saturday</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>周日将对应0，周一为1，如此等等。</p>]]></content>
      
      
      <categories>
          
          <category> Go笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> Go笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01程序结构</title>
      <link href="/2022/02/14/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/01%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
      <url>/2022/02/14/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/01%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><p>关键字不能用于自定义名字，只能在特定语法结构中使用。</p><p>break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var</p><p>此外，还有大约30多个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。</p><p>内建常量: true false iota nil</p><p>内建类型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune  string error</p><p>内建函数: make len cap new append copy close delete complex real imag panic recover</p><p>这些内部预先定义的名字并不是关键字，你可以在定义中重新使用它们。在一些特殊的场景</p><p>中重新定义它们也是有意义的，但是也要注意避免过度而引起语义混乱。</p><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>var 变量名字 类型 &#x3D; 表达式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> i, j, k <span class="type">int</span> <span class="comment">// int, int, int</span></span><br><span class="line"><span class="keyword">var</span> b, f, s = <span class="literal">true</span>, <span class="number">2.3</span>, <span class="string">&quot;four&quot;</span> <span class="comment">// bool, float64, string</span></span><br></pre></td></tr></table></figure><p>名字</p><p><strong>:&#x3D; 表达式”形式声明变量，变量的类型根据表达式来自动推导。</strong></p><h4 id="new函数：表达式new-T-将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为-T"><a href="#new函数：表达式new-T-将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为-T" class="headerlink" title="new函数：表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为 *T"></a>new函数：表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为 *T</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="type">int</span>) <span class="comment">// p, *int 类型, 指向匿名的 int 变量</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// &quot;0&quot;</span></span><br><span class="line">*p = <span class="number">2</span> <span class="comment">// 设置 int 匿名变量的值为 2</span></span><br><span class="line">fmt.Println(*p) <span class="comment">//</span></span><br></pre></td></tr></table></figure><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>type 类型名字 底层类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Celsius <span class="type">float64</span> <span class="comment">// 摄氏温度</span></span><br><span class="line"><span class="keyword">type</span> Fahrenheit <span class="type">float64</span> <span class="comment">// 华氏温度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">AbsoluteZeroC Celsius = <span class="number">-273.15</span> <span class="comment">// 绝对零度</span></span><br><span class="line">FreezingC Celsius = <span class="number">0</span> <span class="comment">// 结冰点温度</span></span><br><span class="line">BoilingC Celsius = <span class="number">100</span> <span class="comment">// 沸水温度</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="包和文件"><a href="#包和文件" class="headerlink" title="包和文件"></a>包和文件</h1><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/img/image-20221121211730320.png" alt="image-20221121211730320"></p><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E7%AC%94%E8%AE%B0/img/image-20221121212110139.png" alt="image-20221121212110139"></p>]]></content>
      
      
      <categories>
          
          <category> Go笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> Go笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式与go-redis设计</title>
      <link href="/2022/02/13/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E4%B8%8Ego-redis%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/02/13/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E4%B8%8Ego-redis%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="命令模式与go-redis-command设计"><a href="#命令模式与go-redis-command设计" class="headerlink" title="命令模式与go-redis command设计"></a><a href="https://www.cnblogs.com/wangxinwen/p/14311991.html">命令模式与go-redis command设计</a></h1><p>目录</p><ul><li><a href="https://www.cnblogs.com/wangxinwen/p/14311991.html#%E4%B8%80%E4%BB%80%E4%B9%88%E6%98%AF%E5%91%BD%E4%BB%A4command%E6%A8%A1%E5%BC%8F">一、什么是命令（Command）模式</a></li><li><a href="https://www.cnblogs.com/wangxinwen/p/14311991.html#%E4%BA%8Cgo-redis-command%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81">二、go-redis command相关代码</a></li><li><a href="https://www.cnblogs.com/wangxinwen/p/14311991.html#%E4%B8%89%E6%80%BB%E7%BB%93">三、总结</a></li></ul><h4 id="一、什么是命令（Command）模式"><a href="#一、什么是命令（Command）模式" class="headerlink" title="一、什么是命令（Command）模式#"></a>一、什么是命令（Command）模式<a href="https://www.cnblogs.com/wangxinwen/p/14311991.html#%E4%B8%80%E4%BB%80%E4%B9%88%E6%98%AF%E5%91%BD%E4%BB%A4command%E6%A8%A1%E5%BC%8F">#</a></h4><p>命令模式是行为型设计模式的一种，其目的是将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化。与另一种将每种命令与调用命令的对象结合形成一个专有类的方式相比，命令模式的优点有将调用操作的对象与知道如何实现该操作的对象解耦，增加新的命令不需要修改现有的类。<br>命令模式的结构如下：<br><a href="https://img2020.cnblogs.com/blog/1447810/202101/1447810-20210122095641252-470394572.png"><img src="https://img2020.cnblogs.com/blog/1447810/202101/1447810-20210122095641252-470394572.png" alt="command"></a><br>参与者有：<br>1.Invoker请求者<br>要求该命令执行这个请求，即命令的调用者<br>2.Command接口<br>3.ConcreteCommand具体接口<br>4.Receiver接收者<br>命令的相关操作的实际实施者<br>5.Client<br>协作过程：<br>1.Client创建一个ConcreteCommand对象并指定它的Receiver对象<br>2.某Invoker对象存储该ConcreteCommand对象<br>3.该Invoker通过调用Command对象的Excute操作来提交一个请求。若该命令是可撤消的，ConcreteCommand就在执行Excute操作之前存储当前状态以用于取消该命令<br>4.ConcreteCommand对象对调用它的Receiver的一些操作以执行该请求</p><h4 id="二、go-redis-command相关代码"><a href="#二、go-redis-command相关代码" class="headerlink" title="二、go-redis command相关代码#"></a>二、go-redis command相关代码<a href="https://www.cnblogs.com/wangxinwen/p/14311991.html#%E4%BA%8Cgo-redis-command%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81">#</a></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// commands.go</span><br><span class="line"></span><br><span class="line">// <span class="type">Invoker</span>请求者接口</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Cmdable</span> interface &#123;</span></span><br><span class="line"><span class="class">      <span class="type">Pipeline</span>() <span class="type">Pipeliner</span></span></span><br><span class="line"><span class="class">      <span class="type">Pipelined</span>(<span class="title">ctx</span> <span class="title">context</span>.<span class="type">Context</span>, <span class="title">fn</span> <span class="title">func</span>(<span class="type">Pipeliner</span>) <span class="title">error</span>) ([]<span class="type">Cmder</span>, <span class="title">error</span>)</span></span><br><span class="line"><span class="class">      <span class="type">TxPipelined</span>(<span class="title">ctx</span> <span class="title">context</span>.<span class="type">Context</span>, <span class="title">fn</span> <span class="title">func</span>(<span class="type">Pipeliner</span>) <span class="title">error</span>) ([]<span class="type">Cmder</span>, <span class="title">error</span>)</span></span><br><span class="line"><span class="class">      <span class="type">TxPipeline</span>() <span class="type">Pipeliner</span></span></span><br><span class="line"><span class="class">      <span class="type">Command</span>(<span class="title">ctx</span> <span class="title">context</span>.<span class="type">Context</span>) *<span class="type">CommandsInfoCmd</span></span></span><br><span class="line"><span class="class">      <span class="type">ClientGetName</span>(<span class="title">ctx</span> <span class="title">context</span>.<span class="type">Context</span>) *<span class="type">StringCmd</span></span></span><br><span class="line"><span class="class">      // ...</span></span><br><span class="line"><span class="class">      // 和所有<span class="type">Redis</span>命令的相关方法</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"></span><br><span class="line">// cmdable实现了<span class="type">Cmdable</span>接口</span><br><span class="line"><span class="class"><span class="keyword">type</span> cmdable func(<span class="title">ctx</span> <span class="title">context</span>.<span class="type">Context</span>, <span class="title">cmd</span> <span class="type">Cmder</span>) error  </span></span><br><span class="line"><span class="title">func</span> (c cmdable) <span class="type">Echo</span>(ctx context.<span class="type">Context</span>, message interface&#123;&#125;) *<span class="type">StringCmd</span> &#123;</span><br><span class="line">cmd := <span class="type">NewStringCmd</span>(ctx, <span class="string">&quot;echo&quot;</span>, message)</span><br><span class="line">_ = c(ctx, cmd)</span><br><span class="line">return cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里值得一提的是cmdable是一个函数类型，func(ctx context.Context, cmd Cmder) error<br>并且每个cmdable方法里都会有_ &#x3D; c(ctx, cmd)，也就是如何去调用cmd在这里还没有明确写出<br>再回头看redis.go，会发现这样一段代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">      *baseClient</span><br><span class="line">      cmdable</span><br><span class="line">      hooks</span><br><span class="line">      ctx context.Context</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(opt *Options)</span></span> *Client &#123;</span><br><span class="line">      opt.init()</span><br><span class="line"></span><br><span class="line">      c := Client&#123;</span><br><span class="line">            baseClient: newBaseClient(opt, newConnPool(opt)),</span><br><span class="line">            ctx:        context.Background(),</span><br><span class="line">      &#125;</span><br><span class="line">      c.cmdable = c.Process <span class="comment">//划线</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &amp;c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c.cmdable &#x3D; c.Process这行指定了请求如何调用Command的<br>在ctrl+左键追踪几层后，会在redis.go里找到调用的具体过程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis.go </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *baseClient)</span></span> process(ctx context.Context, cmd Cmder) <span class="type">error</span> &#123;</span><br><span class="line">      ......</span><br><span class="line">      err := cn.WithWriter(ctx, c.opt.WriteTimeout, <span class="function"><span class="keyword">func</span><span class="params">(wr *proto.Writer)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">            eturn writeCmd(wr, cmd)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      err = cn.WithReader(ctx, c.cmdTimeout(cmd), cmd.readReply)</span><br><span class="line">      ......</span><br></pre></td></tr></table></figure><p>然后再去找Command，这边就比较清晰了，都在command.go中</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// command.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Command接口</span></span><br><span class="line">type Cmder interface &#123;</span><br><span class="line">      <span class="built_in">Name</span>() string</span><br><span class="line">      <span class="built_in">FullName</span>() string</span><br><span class="line">      <span class="built_in">Args</span>() <span class="selector-attr">[]</span>interface&#123;&#125;</span><br><span class="line">      <span class="built_in">String</span>() string</span><br><span class="line">      <span class="built_in">stringArg</span>(int) string</span><br><span class="line">      <span class="built_in">firstKeyPos</span>() int8</span><br><span class="line">      <span class="built_in">setFirstKeyPos</span>(int8)</span><br><span class="line"></span><br><span class="line">      <span class="built_in">readTimeout</span>() *<span class="selector-tag">time</span><span class="selector-class">.Duration</span></span><br><span class="line">      <span class="built_in">readReply</span>(rd *proto.Reader) error</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">SetErr</span>(error)</span><br><span class="line">      <span class="built_in">Err</span>() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有许多Cmder的具体实现，其中一个实现的部分代码如下</span></span><br><span class="line">type XPendingExtCmd struct &#123;</span><br><span class="line">      baseCmd</span><br><span class="line">      val <span class="selector-attr">[]</span>XPendingExt</span><br><span class="line">&#125;</span><br><span class="line">func (cmd *XPendingExtCmd) <span class="built_in">Val</span>() <span class="selector-attr">[]</span>XPendingExt &#123;</span><br><span class="line">      return cmd<span class="selector-class">.val</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里没有看到Receiver，是因为每个Cmder实现都自己实现了所有功能，根本不需要额外的接收者对象。</p><h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结#"></a>三、总结<a href="https://www.cnblogs.com/wangxinwen/p/14311991.html#%E4%B8%89%E6%80%BB%E7%BB%93">#</a></h4><p>有时必须向某对象提交请求，但并不知道关于被请求的操作或请求的接受者的任何信息。这个时候可以用到命令模式，通过将请求本身变成一个对象来使工具箱对象可向未指定的应用对象提出请求。</p>]]></content>
      
      
      <categories>
          
          <category> Go其他知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> Go其他知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-redis和redisgo</title>
      <link href="/2022/02/08/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/go-redis%E5%92%8Credisgo/"/>
      <url>/2022/02/08/Go%E7%9F%A5%E8%AF%86%E7%82%B9/Go%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/go-redis%E5%92%8Credisgo/</url>
      
        <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/go-redis/redis">go-redis</a>和<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/gomodule/redigo">redigo</a>底层是通过调用的万能 Do 方法实现, 但是</p><p><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/gomodule/redigo">redigo</a>:</p><ul><li>由于输入是万能类型所以必须记住每个命令的参数和返回值情况, 使用起来非常的不友好，</li><li>参数类型是万能类型导致在编译阶段无法检查参数类型,</li><li>每个命令都需要花时间记录使用方法，参数个数等，使用成本高；</li></ul><p><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/go-redis/redis">go-redis</a>:</p><ul><li>细化了每个redis每个命令的功能, 我们只需记住命令，具体的用法直接查看接口的申请就可以了，使用成本低；</li><li>其次它对数据类型按照redis底层的类型进行统一，编译时就可以帮助检查参数类型</li><li>并且它的响应统一采用 Result 的接口返回，确保了返回参数类型的正确性，对用户更加友好；</li></ul><h1 id="Redigo库"><a href="#Redigo库" class="headerlink" title="Redigo库"></a>Redigo库</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/gomodule/redigo">redigo</a> 是<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://redis.io/">Redis</a><a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>的<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://golang.org/">Go</a>客户端, 操作Redis基本和commands一样. Redigo命令基本都是通过Do方法来实现的.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Do</span>(ctx context.<span class="property">Context</span>, cmd string, args ...interface&#123;&#125;) (interface&#123;&#125;, error)</span><br></pre></td></tr></table></figure><p>复制</p><p>虽然调用<code>Do</code>函数万能参数可以实现所有的功能，但是使用起来非常的不友好，参数类型是万能类型，所以在编译阶段无法检查参数类型, 其次每个命令都需要花时间记录使用方法，参数个数等，使用成本高；</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>演示基本的<strong>连接池建立, ping, string操作, hash操作, list操作, expire</strong>等操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/gomodule/redigo/redis&quot;</span></span><br><span class="line">)</span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="comment">// 新建一个连接池</span></span><br><span class="line">   <span class="keyword">var</span> pool *redis.<span class="property">Pool</span></span><br><span class="line">   pool = &amp;amp;redis.<span class="property">Pool</span>&#123;</span><br><span class="line">      <span class="title class_">MaxIdle</span>:     <span class="number">10</span>,  <span class="comment">//最初的连接数量</span></span><br><span class="line">      <span class="title class_">MaxActive</span>:   <span class="number">0</span>,   <span class="comment">//连接池最大连接数量,（0表示自动定义），按需分配</span></span><br><span class="line">      <span class="title class_">IdleTimeout</span>: <span class="number">300</span>, <span class="comment">//连接关闭时间 300秒 （300秒不使用自动关闭）</span></span><br><span class="line">      <span class="title class_">Dial</span>: <span class="title function_">func</span>() (redis.<span class="property">Conn</span>, error) &#123; <span class="comment">//要连接的redis数据库</span></span><br><span class="line">         <span class="keyword">return</span> redis.<span class="title class_">Dial</span>(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:6379&quot;</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;</span><br><span class="line">   conn := pool.<span class="title class_">Get</span>() <span class="comment">//从连接池，取一个链接</span></span><br><span class="line">   defer conn.<span class="title class_">Close</span>()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 0. ping正常返回pong， 异常res is nil, err not nil</span></span><br><span class="line">   res, err := conn.<span class="title class_">Do</span>(<span class="string">&quot;ping&quot;</span>)</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;ping res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;ping err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// string操作</span></span><br><span class="line">   <span class="comment">// set</span></span><br><span class="line">   res, err = conn.<span class="title class_">Do</span>(<span class="string">&quot;set&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;测试001&quot;</span>)</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;set res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;set err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// get</span></span><br><span class="line">   res, err = redis.<span class="title class_">String</span>(conn.<span class="title class_">Do</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;name&quot;</span>))</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;get res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;get err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// MSet   MGet</span></span><br><span class="line">   res, err = conn.<span class="title class_">Do</span>(<span class="string">&quot;MSet&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;测试001&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;MSet res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;MSet err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   r, err := redis.<span class="title class_">Strings</span>(conn.<span class="title class_">Do</span>(<span class="string">&quot;MGet&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>))</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;MGet res=%v\n&quot;</span>, r)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;MGet err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// expire</span></span><br><span class="line">   res, err = conn.<span class="title class_">Do</span>(<span class="string">&quot;expire&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="number">5</span>)</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;expire res=%v\n&quot;</span>, r)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;expire err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// list操作</span></span><br><span class="line">   <span class="comment">// lpush lpop</span></span><br><span class="line">   res, err = conn.<span class="title class_">Do</span>(<span class="string">&quot;lpush&quot;</span>, <span class="string">&quot;hobby&quot;</span>, <span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;足球&quot;</span>, <span class="string">&quot;乒乓球&quot;</span>)</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;lpush res=%v\n&quot;</span>, r)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;lpush err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// lpop</span></span><br><span class="line">   rs, er := conn.<span class="title class_">Do</span>(<span class="string">&quot;lpop&quot;</span>, <span class="string">&quot;hobby&quot;</span>)</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;lpop res=%v\n&quot;</span>, rs)</span><br><span class="line">   <span class="keyword">if</span> er != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;lpop err=%v\n&quot;</span>, er.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// hash 操作</span></span><br><span class="line">   <span class="comment">// hset</span></span><br><span class="line">   res, err = conn.<span class="title class_">Do</span>(<span class="string">&quot;HSet&quot;</span>, <span class="string">&quot;userinfo&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;lqz&quot;</span>)</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;HSet res=%v\n&quot;</span>, r)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;HSet err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// hget</span></span><br><span class="line">   r4, er4 := conn.<span class="title class_">Do</span>(<span class="string">&quot;HGet&quot;</span>, <span class="string">&quot;userinfo&quot;</span>, <span class="string">&quot;name&quot;</span>)</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;HGet res=%v\n&quot;</span>, r4)</span><br><span class="line">   <span class="keyword">if</span> er4 != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;HGet err=%v\n&quot;</span>, er4.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="go-redis组件介绍和使用"><a href="#go-redis组件介绍和使用" class="headerlink" title="go-redis组件介绍和使用"></a>go-redis组件介绍和使用</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/go-redis/redis">go-redis</a>提供了三种对应服务端的客户端模式，集群，哨兵，和单机模式，三种模式在连接池这一块都是公用的, 同时还提供了灵活的Hook机制, 其底层实际也是调用的万能 Do 方法.</p><p><img src="https://ask.qcloudimg.com/developer-images/article/7380026/ooeifbs9by.png" alt="img"></p><p>但go-redis细化了每个redis每个命令的功能, 我们只需记住命令，具体的用法直接查看接口的申请就可以了，使用成本低；其次它对数据类型按照redis底层的类型进行统一，编译时就可以帮助检查参数类型, 并且它的响应统一采用 Result 的接口返回，确保了返回参数类型的正确性，对用户更加友好；</p><h2 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h2><p>演示基本的<strong>连接池建立, ping, string操作, hash操作, list操作, expire</strong>等操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> rdb = redis2.<span class="title class_">NewClient</span>(</span><br><span class="line">      &amp;amp;redis2.<span class="property">Options</span>&#123;</span><br><span class="line">         <span class="title class_">Addr</span>:     <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">         <span class="title class_">Password</span>: <span class="string">&quot;&quot;</span>, <span class="attr">DB</span>: <span class="number">1</span>,</span><br><span class="line">         <span class="title class_">MinIdleConns</span>: <span class="number">1</span>,</span><br><span class="line">         <span class="title class_">PoolSize</span>:     <span class="number">1000</span>,</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">   ctx := context.<span class="title class_">Background</span>()</span><br><span class="line">   res, err = rdb.<span class="title class_">Ping</span>(ctx).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;ping res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;ping err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// string操作</span></span><br><span class="line">   <span class="comment">// set</span></span><br><span class="line">   res, err = rdb.<span class="title class_">Set</span>(ctx, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;测试001&quot;</span>, <span class="number">0</span>).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;set res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;set err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// get</span></span><br><span class="line">   res, err = rdb.<span class="title class_">Get</span>(ctx, <span class="string">&quot;name&quot;</span>).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;get res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;get err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// MSet   MGet</span></span><br><span class="line">   res, err = rdb.<span class="title class_">MSet</span>(ctx, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;测试001&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;18&quot;</span>).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;MSet res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;MSet err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> ret []interface&#123;&#125;</span><br><span class="line">   ret, err = rdb.<span class="title class_">MGet</span>(ctx, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;MGet res=%v\n&quot;</span>, ret)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;MGet err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// expire</span></span><br><span class="line">   res, err = rdb.<span class="title class_">Expire</span>(ctx, <span class="string">&quot;name&quot;</span>, time.<span class="property">Second</span>).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;expire res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;expire err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// list操作</span></span><br><span class="line">   <span class="comment">// lpush lpop</span></span><br><span class="line">   res, err = rdb.<span class="title class_">LPush</span>(ctx, <span class="string">&quot;hobby&quot;</span>, <span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;足球&quot;</span>, <span class="string">&quot;乒乓球&quot;</span>).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;lpush res=%v\n&quot;</span>, res)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;lpush err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// lpop</span></span><br><span class="line">   rs, err = rdb.<span class="title class_">LPop</span>(ctx, <span class="string">&quot;hobby&quot;</span>).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;lpop res=%v\n&quot;</span>, rs)</span><br><span class="line">   <span class="keyword">if</span> er != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;lpop err=%v\n&quot;</span>, er.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// hash 操作</span></span><br><span class="line">   <span class="comment">// hset</span></span><br><span class="line">   res, err = rdb.<span class="title class_">HSet</span>(ctx, <span class="string">&quot;userinfo&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;lqz&quot;</span>).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;HSet res=%v\n&quot;</span>, r)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;HSet err=%v\n&quot;</span>, err.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// hget</span></span><br><span class="line">   r4, er4 = rdb.<span class="title class_">HGet</span>(ctx, <span class="string">&quot;userinfo&quot;</span>, <span class="string">&quot;name&quot;</span>).<span class="title class_">Result</span>()</span><br><span class="line">   fmt.<span class="title class_">Printf</span>(<span class="string">&quot;HGet res=%v\n&quot;</span>, r4)</span><br><span class="line">   <span class="keyword">if</span> er4 != nil &#123;</span><br><span class="line">      fmt.<span class="title class_">Printf</span>(<span class="string">&quot;HGet err=%v\n&quot;</span>, er4.<span class="title class_">Error</span>())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go其他知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> Go其他知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-基础教程</title>
      <link href="/2022/02/03/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GRPC/2-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
      <url>/2022/02/03/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GRPC/2-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="定义服务"><a href="#定义服务" class="headerlink" title="定义服务"></a>定义服务</h1><p>要定义服务，您可以<code>service</code>在 .proto 文件中指定一个名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service RouteGuide &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rpc</code>然后，您在服务定义中定义方法，指定它们的请求和响应类型。gRPC允许您定义四种服务方法，所有这些方法都在<code>RouteGuide</code>服务中使用：</p><ul><li><p>一个<em>简单的 RPC</em>，客户端使用存根向服务器发送请求并等待响应返回，就像正常的函数调用一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Obtains the feature at a given position.</span><br><span class="line">rpc GetFeature(Point) returns (Feature) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务器<em>端流式 RPC</em>，客户端向服务器发送请求并获取流以读回一系列消息。客户端从返回的流中读取，直到没有更多消息为止。<em>正如您在我们的示例中看到的，您可以通过将关键字放在响应</em><code>stream</code>类型 之前来指定服务器端流方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Obtains the Features available within the given Rectangle.  Results are</span><br><span class="line">// streamed rather than returned at once (e.g. in a response message with a</span><br><span class="line">// repeated field), as the rectangle may cover a large area and contain a</span><br><span class="line">// huge number of features.</span><br><span class="line">rpc ListFeatures(Rectangle) returns (stream Feature) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户<em>端流式 RPC</em>，客户端写入一系列消息并将它们发送到服务器，同样使用提供的流。一旦客户端完成消息写入，它就会等待服务器读取所有消息并返回响应。<em>您可以通过将关键字放在请求</em><code>stream</code>类型之前来指定客户端流方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Accepts a stream of Points on a route being traversed, returning a</span><br><span class="line">// RouteSummary when traversal is completed.</span><br><span class="line">rpc RecordRoute(stream Point) returns (RouteSummary) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>双向<em>流式 RPC</em>，双方使用读写流发送一系列消息。这两个流独立运行，因此客户端和服务器可以按照它们喜欢的任何顺序读取和写入：例如，服务器可以在写入响应之前等待接收所有客户端消息，或者可以交替读取消息然后写入消息，或其他一些读和写的组合。每个流中消息的顺序都会被保留。<code>stream</code> 您可以通过在请求和响应之前放置关键字来指定这种类型的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Accepts a stream of RouteNotes sent while a route is being traversed,</span><br><span class="line">// while receiving other RouteNotes (e.g. from other users).</span><br><span class="line">rpc RouteChat(stream RouteNote) returns (stream RouteNote) &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>我们的 .proto 文件还包含服务方法中使用的所有请求和响应类型的协议缓冲区消息类型定义 - 例如，以下是消息<code>Point</code>类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Points are represented as latitude-longitude pairs in the E7 representation</span><br><span class="line">// (degrees multiplied by 10**7 and rounded to the nearest integer).</span><br><span class="line">// Latitudes should be in the range +/- 90 degrees and longitude should be in</span><br><span class="line">// the range +/- 180 degrees (inclusive).</span><br><span class="line">message Point &#123;</span><br><span class="line">  int32 latitude = 1;</span><br><span class="line">  int32 longitude = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GRPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GRPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-快速开始</title>
      <link href="/2022/02/01/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GRPC/1-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/"/>
      <url>/2022/02/01/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GRPC/1-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h1><h3 id="gRPC简介"><a href="#gRPC简介" class="headerlink" title="gRPC简介"></a>gRPC简介</h3><ul><li>gRPC由google开发，是一款语言中立、平台中立、开源的远程过程调用系统</li><li>gRPC客户端和服务端可以在多种环境中运行和交互，例如用java写一个服务端，可以用go语言写客户端调用</li></ul><h3 id="gRPC与Protobuf介绍"><a href="#gRPC与Protobuf介绍" class="headerlink" title="gRPC与Protobuf介绍"></a>gRPC与Protobuf介绍</h3><ul><li>微服务架构中，由于每个服务对应的代码库是独立运行的，无法直接调用，彼此间的通信就是个大问题</li><li>gRPC可以实现微服务，将大的项目拆分为多个小且独立的业务模块，也就是服务，各服务间使用高效的protobuf协议进行RPC调用，gRPC默认使用protocol buffers，这是google开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如JSON）</li><li>可以用proto files创建gRPC服务，用message类型来定义方法参数和返回类型</li></ul><h3 id="安装gRPC和Protobuf"><a href="#安装gRPC和Protobuf" class="headerlink" title="安装gRPC和Protobuf"></a>安装gRPC和Protobuf</h3><ul><li>go get github.com&#x2F;golang&#x2F;protobuf&#x2F;proto</li><li>go get google.golang.org&#x2F;grpc（无法使用，用如下命令代替）<ul><li>git clone <a href="https://github.com/grpc/grpc-go.git">https://github.com/grpc/grpc-go.git</a> $GOPATH&#x2F;src&#x2F;google.golang.org&#x2F;grpc</li><li>git clone <a href="https://github.com/golang/net.git">https://github.com/golang/net.git</a> $GOPATH&#x2F;src&#x2F;golang.org&#x2F;x&#x2F;net</li><li>git clone <a href="https://github.com/golang/text.git">https://github.com/golang/text.git</a> $GOPATH&#x2F;src&#x2F;golang.org&#x2F;x&#x2F;text</li><li>go get -u github.com&#x2F;golang&#x2F;protobuf&#x2F;{proto,protoc-gen-go}</li><li>git clone <a href="https://github.com/google/go-genproto.git">https://github.com/google/go-genproto.git</a> $GOPATH&#x2F;src&#x2F;google.golang.org&#x2F;genproto</li><li>cd $GOPATH&#x2F;src&#x2F;</li><li>go install google.golang.org&#x2F;grpc</li></ul></li><li>go get github.com&#x2F;golang&#x2F;protobuf&#x2F;protoc-gen-go</li><li>上面安装好后，会在GOPATH&#x2F;bin下生成protoc-gen-go.exe</li><li>但还需要一个protoc.exe，windows平台编译受限，很难自己手动编译，直接去网站下载一个，地址：<a href="https://github.com/protocolbuffers/protobuf/releases/tag/v3.9.0">https://github.com/protocolbuffers/protobuf/releases/tag/v3.9.0</a> ，同样放在GOPATH&#x2F;bin下</li></ul>]]></content>
      
      
      <categories>
          
          <category> GRPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GRPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题</title>
      <link href="/2022/01/31/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/01/31/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="init函数和main函数的异同"><a href="#init函数和main函数的异同" class="headerlink" title="init函数和main函数的异同"></a>init函数和main函数的异同</h1><p><strong>init函数不能被其他函数调用，而是在main函数执行之前，自动被调用</strong></p><p>​    相同点：<br>​        两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。<br>​    不同点：<br>​        init可以应用于任意包中，且可以重复定义多个。<br>​        main函数只能用于main包中，且只能定义一个。</p><h1 id="new与make的区别"><a href="#new与make的区别" class="headerlink" title="new与make的区别"></a>new与make的区别</h1><p>​    1.二者都是用来做内存分配的。<br>​    2.<strong>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</strong><br>​    3.而<strong>new用于类型的内存分配，并且内存对应的值为类型默认值，返回的是指向类型的指针</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a *<span class="type">int</span></span><br><span class="line">    a = <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">    *a = <span class="number">10</span></span><br><span class="line">    fmt.Println(*a)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">    b = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    b[<span class="string">&quot;测试&quot;</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>匿名函数是指<strong>不需要定义函数名的一种函数</strong>实现方式，匿名函数的优越性在于可以<strong>直接使用函数内的变量，不必申明</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> getSqrt := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Sqrt(a)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(getSqrt(<span class="number">4</span>))</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>Golang匿名函数可赋值给变量，做为结构字段，或者在 channel 里传送。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fn := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">&quot;Hello, World!&quot;</span>) &#125;</span><br><span class="line">    fn()</span><br><span class="line"></span><br><span class="line">    fns := [](<span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x + <span class="number">1</span> &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x + <span class="number">2</span> &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(fns[<span class="number">0</span>](<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    d := <span class="keyword">struct</span> &#123;</span><br><span class="line">        fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        fn: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span> &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(d.fn())</span><br><span class="line"></span><br><span class="line">    fc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    fc &lt;- <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span> &#125;</span><br><span class="line">    <span class="built_in">println</span>((&lt;-fc)())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>Go语言中的闭包（Closure）是一种<strong>引用了自由变量的函数</strong>，<strong>自由变量是指在函数中使用的变量</strong>，但<strong>既不是函数参数也不是函数本地变量</strong>。闭包允许在一个函数内部包含一个自由变量的引用，这样就可以让这个自由变量的值在函数调用之间得以保留。</p><p>当<strong>函数返回时，函数所引用的自由变量可以被继续访问，不被释放</strong>。这是因为<strong>在编译时，编译器将函数与其自由变量打包为一个封闭函数对象</strong>，<strong>该对象包含函数的代码以及其访问的自由变量的引用</strong>。<strong>当函数对象被返回或直接使用时，自由变量的引用会被保留，因此可以继续访问闭包引用的自由变量</strong>。</p><h1 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h1><p>defer语句本质上是<strong>将语句推迟到函数返回之前</strong>执行，在函数退出时，defer推迟执行的语句会被按照<strong>后进先出</strong>的顺序执行，<strong>不管函数是否出错都会执行</strong>。因此，在使用defer时，<strong>需要考虑变量的作用域和生命周期，确保变量可以正确地传递到defer语句中</strong>。</p><p>defer<strong>后面的语句在执行的时候，函数调用的参数会被保存起来，但是不执行。也就是复制了一份。</strong>但是并没有说struct这里的this指针如何处理，通过这个例子可以看出go语言并没有把这个明确写出来的this指针当作参数来看待。</p><h4 id="用途：关闭文件句柄、锁资源释放、数据库连接释放"><a href="#用途：关闭文件句柄、锁资源释放、数据库连接释放" class="headerlink" title="用途：关闭文件句柄、锁资源释放、数据库连接释放"></a>用途：关闭文件句柄、锁资源释放、数据库连接释放</h4><h4 id="陷阱："><a href="#陷阱：" class="headerlink" title="陷阱："></a>陷阱：</h4><p>defer 与 return：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> (i <span class="type">int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure><p>defer nil 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> run <span class="function"><span class="keyword">func</span><span class="params">()</span></span> = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">defer</span> run()</span><br><span class="line"><span class="comment">//  defer 函数会被执行且会因为值为 nil 而产生 panic 异常。然而值得注意的是，run() 的声明是没有问题，因为在test函数运行完成后它才会被调用</span></span><br></pre></td></tr></table></figure><p>在错误的位置使用 defer：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">res, err := http.Get(<span class="string">&quot;http://www.google.com&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line"><span class="comment">// 因为在这里我们并没有检查我们的请求是否成功执行，当它失败的时候，我们访问了 Body 中的空变量 res ，因此会抛出异常</span></span><br><span class="line"><span class="comment">// 解决：</span></span><br><span class="line"><span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>Golang 没有结构化异常，使用 panic 抛出错误，recover 捕获错误</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>1.利用recover处理panic指令，<strong>defer 必须放在 panic 之前定义</strong>，另外 recover <strong>只有在 defer 调用的函数中才有效</strong>。否则当panic时，  recover无法捕获到panic，无法防止panic扩散。<br>2.recover 处理异常后，逻辑并不会恢复到 panic 那个点去，函数跑到 defer 之后的那个点。<br>3.多个 defer 会形成 defer 栈，后定义的 defer 语句会被最先调用。</p><blockquote><p>延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后一个错误可被捕获。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="built_in">recover</span>())</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;defer panic&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line"><span class="comment">// 输出defer panic</span></span><br></pre></td></tr></table></figure><h1 id="保护代码段"><a href="#保护代码段" class="headerlink" title="保护代码段"></a>保护代码段</h1><p>将代码块重构成匿名函数，如此可确保后续代码被执 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> z <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">                z = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="comment">// 出错</span></span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">        z = x / y</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;()</span><br><span class="line"><span class="comment">// 继续执行</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;x / y = %d\n&quot;</span>, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Go实现类似-try-catch-的异常处理"><a href="#Go实现类似-try-catch-的异常处理" class="headerlink" title="Go实现类似 try catch 的异常处理"></a>Go实现类似 try catch 的异常处理</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Try</span><span class="params">(fun <span class="keyword">func</span>()</span></span>, handler <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            handler(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fun()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Try(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">func</span><span class="params">(err <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="普通函数与方法的区别"><a href="#普通函数与方法的区别" class="headerlink" title="普通函数与方法的区别"></a>普通函数与方法的区别</h1><p>1.对于普通函数，<strong>接收者为值类型时，不能将指针类型的数据直接传递，反之亦然。</strong></p><p>2.对于方法（如struct的方法），<strong>接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以</strong>。</p><h1 id="Golang方法集-："><a href="#Golang方法集-：" class="headerlink" title="Golang方法集 ："></a>Golang方法集 ：</h1><p>每个类型都有与之关联的方法集，这会影响到接口实现规则</p><p>​    • 类型 T 方法集包含全部 receiver T 方法。<br>​    • 类型 *T 方法集包含全部 receiver T + *T 方法。<br>​    • 如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。<br>​    • 如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T + *T 方法。<br>​    • 不管嵌入 T 或 <em>T，</em>S 方法集总是包含 T + *T 方法。</p><h1 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h1><p>为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型</p><h1 id="进程线程协程"><a href="#进程线程协程" class="headerlink" title="进程线程协程"></a>进程线程协程</h1><p>进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。<br>线程是进程的一个执行实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。<br>一个进程可以创建和撤销多个线程;同一个进程中的多个线程之间可以并发执行。</p><p>协程：协程是一种用户态的轻量级线程，由程序自身控制调度，不需要操作系统的支持，协程之间可以通过协程间通信机制进行通信，协程的执行效率高，可以减少线程切换的开销。<br>线程：一个线程上可以跑多个协程，协程是轻量级的线程。</p><h1 id="GPM"><a href="#GPM" class="headerlink" title="GPM"></a>GPM</h1><p>是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p><ul><li>1.G很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li><li>2.P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li><li>3.M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</li></ul><p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p><p>P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p><p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用&#x2F;调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的，  不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池，  不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。  另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上，  再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p><h1 id="runtime包"><a href="#runtime包" class="headerlink" title="runtime包"></a>runtime包</h1><p>runtime.Gosched():让出CPU时间片，重新等待安排任务</p><p>runtime.Goexit():退出当前协程</p><p>runtime.GOMAXPROCS(n):需要使用多少个OS线程来同时执行Go代码</p><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/image-20230409150132645.png" alt="image-20230409150132645"></p>]]></content>
      
      
      <categories>
          
          <category> GO基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GO基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随便写写</title>
      <link href="/2022/01/26/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/"/>
      <url>/2022/01/26/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h2 id="init函数和main函数的异同"><a href="#init函数和main函数的异同" class="headerlink" title="init函数和main函数的异同"></a>init函数和main函数的异同</h2><p>​    相同点：<br>​        两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。<br>​    不同点：<br>​        init可以应用于任意包中，且可以重复定义多个。<br>​        main函数只能用于main包中，且只能定义一个。</p><h2 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h2><p>使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值</p><p><code>var a *int</code>只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值</p><p>make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型</p><p><code>var b map[string]int</code>只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值</p><p>区别：二者都是用来做内存分配的；make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</p>]]></content>
      
      
      <categories>
          
          <category> GO基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GO基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go面试题</title>
      <link href="/2022/01/20/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/01/20/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a><strong>基础部分</strong></h2><h3 id="golang-中-make-和-new-的区别？（基本必问）"><a href="#golang-中-make-和-new-的区别？（基本必问）" class="headerlink" title="golang 中 make 和 new 的区别？（基本必问）"></a><strong>golang 中 make 和 new 的区别？（基本必问）</strong></h3><p><strong>共同点：</strong>给变量分配内存</p><p><strong>不同点：</strong></p><p>1）作用变量类型不同，new给string,int和数组分配内存，make给切片，map，channel分配内存；</p><p>2）返回类型不一样，new返回指向变量的指针，make返回变量本身；</p><p>3）new 分配的空间被清零。make 分配空间后，会进行初始化；</p><p>\4) 字节的面试官还说了另外一个区别，就是分配的位置，在堆上还是在栈上？这块我比较模糊，大家可以自己探究下，我搜索出来的答案是golang会弱化分配的位置的概念，因为编译的时候会自动内存逃逸处理，懂的大佬帮忙补充下：make、new内存分配是在堆上还是在栈上？</p><h3 id="数组和切片的区别-（基本必问）"><a href="#数组和切片的区别-（基本必问）" class="headerlink" title="数组和切片的区别 （基本必问）"></a><strong>数组和切片的区别 （基本必问）</strong></h3><p><strong>相同点：</strong></p><p>1)只能存储一组相同类型的数据结构</p><p>2)都是通过下标来访问，并且有容量长度，长度通过 len 获取，容量通过 cap 获取</p><p><strong>区别：</strong></p><p>1）数组是定长，访问和复制不能超过数组定义的长度，否则就会下标越界，切片长度和容量可以自动扩容</p><p>2）数组是值类型，切片是引用类型，每个切片都引用了一个底层数组，切片本身不能存储任何数据，都是这底层数组存储数据，所以修改切片的时候修改的是底层数组中的数据。切片一旦扩容，指向一个新的底层数组，内存地址也就随之改变</p><p><strong>简洁的回答：</strong></p><p>1）定义方式不一样 2）初始化方式不一样，数组需要指定大小，大小不改变 3）在函数传递中，数组切片都是值传递。</p><p><strong>数组的定义</strong></p><p>var a1 [3]int</p><p>var a2 […]int{1,2,3}</p><p><strong>切片的定义</strong></p><p>var a1 []int</p><p>var a2 :&#x3D;make([]int,3,5)</p><p><strong>数组的初始化</strong></p><p>a1 :&#x3D; […]int{1,2,3}</p><p>a2 :&#x3D; [5]int{1,2,3}</p><p><strong>切片的初始化</strong></p><p>b:&#x3D; make([]int,3,5)</p><h3 id="for-range-的时候它的地址会发生变化么？"><a href="#for-range-的时候它的地址会发生变化么？" class="headerlink" title="for range 的时候它的地址会发生变化么？"></a><strong>for range 的时候它的地址会发生变化么？</strong></h3><p>答：在 for a,b :&#x3D; range c 遍历中， a 和 b 在内存中只会存在一份，即之后每次循环时遍历到的数据都是以值覆盖的方式赋给 a 和 b，a，b 的内存地址始终不变。由于有这个特性，for 循环里面如果开协程，不要直接把 a 或者 b 的地址传给协程。解决办法：在每次循环时，创建一个临时变量。</p><h3 id="go-defer，多个-defer-的顺序，defer-在什么时机会修改返回值？"><a href="#go-defer，多个-defer-的顺序，defer-在什么时机会修改返回值？" class="headerlink" title="go defer，多个 defer 的顺序，defer 在什么时机会修改返回值？"></a><strong>go defer，多个 defer 的顺序，defer 在什么时机会修改返回值？</strong></h3><p>作用：defer延迟函数，释放资源，收尾工作；如释放锁，关闭文件，关闭链接；捕获panic;</p><p>避坑指南：defer函数紧跟在资源打开后面，否则defer可能得不到执行，导致内存泄露。</p><p>多个 defer 调用顺序是 LIFO（后入先出），defer后的操作可以理解为压入栈中</p><p>defer，return，return value（函数返回值） 执行顺序：首先return，其次return value，最后defer。defer可以修改函数最终返回值，修改时机：<strong>有名返回值或者函数返回指针</strong> 参考：</p><p><strong>有名返回值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> (i <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">i++</span><br><span class="line">fmt.Println(<span class="string">&quot;defer2:&quot;</span>, i)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">i++</span><br><span class="line">fmt.Println(<span class="string">&quot;defer1:&quot;</span>, i)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> i <span class="comment">//或者直接写成return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;return:&quot;</span>, b())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p><p><strong>函数返回指针</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func c() *int &#123;</span><br><span class="line">var i int</span><br><span class="line">defer func() &#123;</span><br><span class="line">i++</span><br><span class="line">fmt.Println(&quot;defer2:&quot;, i)</span><br><span class="line">&#125;()</span><br><span class="line">defer func() &#123;</span><br><span class="line">i++</span><br><span class="line">fmt.Println(&quot;defer1:&quot;, i)</span><br><span class="line">&#125;()</span><br><span class="line">return &amp;i</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;return:&quot;, *(c()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uint-类型溢出问题"><a href="#uint-类型溢出问题" class="headerlink" title="uint 类型溢出问题"></a><strong>uint 类型溢出问题</strong></h3><p>超过最大存储值如uint8最大是255</p><p>var a uint8 &#x3D;255</p><p>var b uint8 &#x3D;1</p><p>a+b &#x3D; 0总之类型溢出会出现难以意料的事</p><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-5bf5e213ce315a16d0b7e65ef41cc685_720w.webp" alt="img"></p><h3 id="能介绍下-rune-类型吗？"><a href="#能介绍下-rune-类型吗？" class="headerlink" title="能介绍下 rune 类型吗？"></a><strong>能介绍下 rune 类型吗？</strong></h3><p>相当int32</p><p>golang中的字符串底层实现是通过byte数组的，中文字符在unicode下占2个字节，在utf-8编码下占3个字节，而golang默认编码正好是utf-8</p><p>byte 等同于int8，常用来处理ascii字符</p><p>rune 等同于int32,常用来处理unicode或utf-8字符</p><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-15a9656d176cfcc16d4116bbc9d2a24d_720w.webp" alt="img"></p><h3 id="调用函数传入结构体时，应该传值还是指针？-（Golang-都是传值）"><a href="#调用函数传入结构体时，应该传值还是指针？-（Golang-都是传值）" class="headerlink" title="调用函数传入结构体时，应该传值还是指针？ （Golang 都是传值）"></a><strong>调用函数传入结构体时，应该传值还是指针？ （Golang 都是传值）</strong></h3><p>Go 的函数参数传递都是值传递。所谓值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。参数传递还有引用传递，所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数</p><p>因为 Go 里面的 map，slice，chan 是引用类型。变量区分值类型和引用类型。所谓值类型：变量和变量的值存在同一个位置。所谓引用类型：变量和变量的值是不同的位置，变量的值存储的是对值的引用。但并不是 map，slice，chan 的所有的变量在函数内都能被修改，不同数据类型的底层存储结构和实现可能不太一样，情况也就不一样。</p><h3 id="讲讲-Go-的-slice-底层数据结构和一些特性？"><a href="#讲讲-Go-的-slice-底层数据结构和一些特性？" class="headerlink" title="讲讲 Go 的 slice 底层数据结构和一些特性？"></a><strong>讲讲 Go 的 slice 底层数据结构和一些特性？</strong></h3><p>答：Go 的 slice 底层数据结构是由一个 array 指针指向底层数组，len 表示切片长度，cap 表示切片容量。slice 的主要实现是扩容。对于 append 向 slice 添加元素时，假如 slice 容量够用，则追加新元素进去，slice.len++，返回原来的 slice。当原容量不够，则 slice 先扩容，扩容之后 slice 得到新的 slice，将元素追加进新的 slice，slice.len++，返回新的 slice。对于切片的扩容规则：当切片比较小时（容量小于 1024），则采用较大的扩容倍速进行扩容（新的扩容会是原来的 2 倍），避免频繁扩容，从而减少内存分配的次数和数据拷贝的代价。当切片较大的时（原来的 slice 的容量大于或者等于 1024），采用较小的扩容倍速（新的扩容将扩大大于或者等于原来 1.25 倍），主要避免空间浪费，网上其实很多总结的是 1.25 倍，那是在不考虑内存对齐的情况下，实际上还要考虑内存对齐，扩容是大于或者等于 1.25 倍。</p><p>（关于刚才问的 slice 为什么传到函数内可能被修改，如果 slice 在函数内没有出现扩容，函数外和函数内 slice 变量指向是同一个数组，则函数内复制的 slice 变量值出现更改，函数外这个 slice 变量值也会被修改。如果 slice 在函数内出现扩容，则函数内变量的值会新生成一个数组（也就是新的 slice，而函数外的 slice 指向的还是原来的 slice，则函数内的修改不会影响函数外的 slice。）</p><h3 id="讲讲-Go-的-select-底层数据结构和一些特性？（难点，没有项目经常可能说不清，面试一般会问你项目中怎么使用select）"><a href="#讲讲-Go-的-select-底层数据结构和一些特性？（难点，没有项目经常可能说不清，面试一般会问你项目中怎么使用select）" class="headerlink" title="讲讲 Go 的 select 底层数据结构和一些特性？（难点，没有项目经常可能说不清，面试一般会问你项目中怎么使用select）"></a><strong>讲讲 Go 的 select 底层数据结构和一些特性？（难点，没有项目经常可能说不清，面试一般会问你项目中怎么使用select）</strong></h3><p>答：go 的 select 为 golang 提供了多路 IO 复用机制，和其他 IO 复用一样，用于检测是否有读写事件是否 ready。linux 的系统 IO 模型有 select，poll，epoll，go 的 select 和 linux 系统 select 非常相似。</p><p>select 结构组成主要是由 case 语句和执行的函数组成 select 实现的多路复用是：每个线程或者进程都先到注册和接受的 channel（装置）注册，然后阻塞，然后只有一个线程在运输，当注册的线程和进程准备好数据后，装置会根据注册的信息得到相应的数据。</p><p><strong>select 的特性</strong></p><p>1）select 操作至少要有一个 case 语句，出现读写 nil 的 channel 该分支会忽略，在 nil 的 channel 上操作则会报错。</p><p>2）select 仅支持管道，而且是单协程操作。</p><p>3）每个 case 语句仅能处理一个管道，要么读要么写。</p><p>4）多个 case 语句的执行顺序是随机的。</p><p>5）存在 default 语句，select 将不会阻塞，但是存在 default 会影响性能。</p><h3 id="讲讲-Go-的-defer-底层数据结构和一些特性？"><a href="#讲讲-Go-的-defer-底层数据结构和一些特性？" class="headerlink" title="讲讲 Go 的 defer 底层数据结构和一些特性？"></a><strong>讲讲 Go 的 defer 底层数据结构和一些特性？</strong></h3><p>答：每个 defer 语句都对应一个_defer 实例，多个实例使用指针连接起来形成一个单连表，保存在 gotoutine 数据结构中，每次插入_defer 实例，均插入到链表的头部，函数结束再一次从头部取出，从而形成后进先出的效果。</p><p><strong>defer 的规则总结</strong>：</p><p>延迟函数的参数是 defer 语句出现的时候就已经确定了的。</p><p>延迟函数执行按照后进先出的顺序执行，即先出现的 defer 最后执行。</p><p>延迟函数可能操作主函数的返回值。</p><p>申请资源后立即使用 defer 关闭资源是个好习惯。</p><h3 id="单引号，双引号，反引号的区别？"><a href="#单引号，双引号，反引号的区别？" class="headerlink" title="单引号，双引号，反引号的区别？"></a><strong>单引号，双引号，反引号的区别？</strong></h3><p>单引号，表示byte类型或rune类型，对应 uint8和int32类型，默认是 rune 类型。byte用来强调数据是raw data，而不是数字；而rune用来表示Unicode的code point。</p><p>双引号，才是字符串，实际上是字符数组。可以用索引号访问某字节，也可以用len()函数来获取字符串所占的字节长度。</p><p>反引号，表示字符串字面量，但不支持任何转义序列。字面量 raw literal string 的意思是，你定义时写的啥样，它就啥样，你有换行，它就换行。你写转义字符，它也就展示转义字符。</p><h2 id="map相关"><a href="#map相关" class="headerlink" title="map相关"></a><strong>map相关</strong></h2><h3 id="map-使用注意的点，是否并发安全？"><a href="#map-使用注意的点，是否并发安全？" class="headerlink" title="map 使用注意的点，是否并发安全？"></a>map 使用注意的点，是否并发安全？</h3><p>map的类型是map[key]，key类型的ke必须是可比较的，通常情况，会选择内建的基本类型，比如整数、字符串做key的类型。如果要使用struct作为key，要保证struct对象在逻辑上是不可变的。在Go语言中，map[key]函数返回结果可以是一个值，也可以是两个值。map是无序的，如果我们想要保证遍历map时元素有序，可以使用辅助的数据结构，例如orderedmap。</p><p><strong>第一，</strong>一定要先初始化，否则panic</p><p><strong>第二，</strong>map类型是容易发生并发访问问题的。不注意就容易发生程序运行时并发读写导致的panic。 Go语言内建的map对象不是线程安全的，并发读写的时候运行时会有检查，遇到并发问题就会导致panic。</p><h3 id="map-循环是有序的还是无序的？"><a href="#map-循环是有序的还是无序的？" class="headerlink" title="map 循环是有序的还是无序的？"></a>map 循环是有序的还是无序的？</h3><p>无序的, map 因扩张⽽重新哈希时，各键值项存储位置都可能会发生改变，顺序自然也没法保证了，所以官方避免大家依赖顺序，直接打乱处理。就是 for range map 在开始处理循环逻辑的时候，就做了随机播种</p><h3 id="map-中删除一个-key，它的内存会释放么？（常问）"><a href="#map-中删除一个-key，它的内存会释放么？（常问）" class="headerlink" title="map 中删除一个 key，它的内存会释放么？（常问）"></a>map 中删除一个 key，它的内存会释放么？（常问）</h3><p>如果删除的元素是值类型，如int，float，bool，string以及数组和struct，map的内存不会自动释放</p><p>如果删除的元素是引用类型，如指针，slice，map，chan等，map的内存会自动释放，但释放的内存是子元素应用类型的内存占用</p><p>将map设置为nil后，内存被回收。</p><p><strong>这个问题还需要大家去搜索下答案，我记得有不一样的说法，谨慎采用本题答案。</strong></p><h3 id="怎么处理对-map-进行并发访问？有没有其他方案？-区别是什么？"><a href="#怎么处理对-map-进行并发访问？有没有其他方案？-区别是什么？" class="headerlink" title="怎么处理对 map 进行并发访问？有没有其他方案？ 区别是什么？"></a>怎么处理对 map 进行并发访问？有没有其他方案？ 区别是什么？</h3><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-1107961e741b834eb5fc071ff68da831_720w.webp" alt="img"></p><p><strong>方式一、使用内置sync.Map，详细参考</strong></p><p><a href="https://link.zhihu.com/?target=https://mbd.baidu.com/ma/s/7Hwd9yMc">https://mbd.baidu.com/ma/s/7Hwd9yMcmbd.baidu.com/ma/s/7Hwd9yMc</a></p><p><strong>方式二、使用读写锁实现并发安全map</strong></p><p><a href="https://link.zhihu.com/?target=https://mbd.baidu.com/ma/s/qO7b0VQU">https://mbd.baidu.com/ma/s/qO7b0VQUmbd.baidu.com/ma/s/qO7b0VQU</a></p><h3 id="nil-map-和空-map-有何不同？"><a href="#nil-map-和空-map-有何不同？" class="headerlink" title="nil map 和空 map 有何不同？"></a>nil map 和空 map 有何不同？</h3><p>1）可以对未初始化的map进行取值，但取出来的东西是空：</p><p>var m1 map[string]string</p><p>fmt.Println(m1[“1”])</p><p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p><p>2）不能对未初始化的map进行赋值，这样将会抛出一个异常：</p><p>var m1 map[string]string</p><p>m1[“1”] &#x3D; “1”</p><p>panic: assignment to entry in nil map</p><p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p><p>\3) 通过fmt打印map时，空map和nil map结果是一样的，都为map[]。所以，这个时候别断定map是空还是nil，而应该通过map &#x3D;&#x3D; nil来判断。</p><p><strong>nil map 未初始化，空map是长度为空</strong></p><h3 id="map-的数据结构是什么？是怎么实现扩容？"><a href="#map-的数据结构是什么？是怎么实现扩容？" class="headerlink" title="map 的数据结构是什么？是怎么实现扩容？"></a>map 的数据结构是什么？是怎么实现扩容？</h3><p>答：golang 中 map 是一个 kv 对集合。底层使用 hash table，用链表来解决冲突 ，出现冲突时，不是每一个 key 都申请一个结构通过链表串起来，而是以 bmap 为最小粒度挂载，一个 bmap 可以放 8 个 kv。在哈希函数的选择上，会在程序启动时，检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。每个 map 的底层结构是 hmap，是有若干个结构为 bmap 的 bucket 组成的数组。每个 bucket 底层都采用链表结构。</p><p><strong>hmap 的结构如下：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type hmap struct &#123;</span><br><span class="line">    count     int                  // 元素个数</span><br><span class="line">    flags     uint8</span><br><span class="line">    B         uint8                // 扩容常量相关字段B是buckets数组的长度的对数 2^B</span><br><span class="line">    noverflow uint16               // 溢出的bucket个数</span><br><span class="line">    hash0     uint32               // hash seed</span><br><span class="line">    buckets    unsafe.Pointer      // buckets 数组指针</span><br><span class="line">    oldbuckets unsafe.Pointer      // 结构扩容的时候用于赋值的buckets数组</span><br><span class="line">    nevacuate  uintptr             // 搬迁进度</span><br><span class="line">    extra *mapextra                // 用于扩容的指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>map 的容量大小</strong></p><p>底层调用 makemap 函数，计算得到合适的 B，map 容量最多可容纳 6.52^B 个元素，6.5 为装载因子阈值常量。装载因子的计算公式是：装载因子&#x3D;填入表中的元素个数&#x2F;散列表的长度，装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。底层调用 makemap 函数，计算得到合适的 B，map 容量最多可容纳 6.52^B 个元素，6.5 为装载因子阈值常量。装载因子的计算公式是：装载因子&#x3D;填入表中的元素个数&#x2F;散列表的长度，装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p><p><strong>触发 map 扩容的条件</strong></p><p>1）装载因子超过阈值，源码里定义的阈值是 6.5。</p><p>2）overflow 的 bucket 数量过多 map 的 bucket 定位和 key 的定位高八位用于定位 bucket，低八位用于定位 key，快速试错后再进行完整对比</p><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-f99ed061ef6ea995743cda6d332861e3_720w.webp" alt="img"></p><h3 id="slices能作为map类型的key吗？"><a href="#slices能作为map类型的key吗？" class="headerlink" title="slices能作为map类型的key吗？"></a>slices能作为map类型的key吗？</h3><p>当时被问的一脸懵逼，其实是这个问题的变种：golang 哪些类型可以作为map key？</p><p>答案是：<strong>在golang规范中，可比较的类型都可以作为map key；</strong>这个问题又延伸到在：golang规范中，哪些数据类型可以比较？</p><p><strong>不能作为map key 的类型包括：</strong></p><ul><li>slices</li><li>maps</li><li>functions</li></ul><h2 id="context相关"><a href="#context相关" class="headerlink" title="context相关**"></a>context相关**</h2><h3 id="context-结构是什么样的？context-使用场景和用途？"><a href="#context-结构是什么样的？context-使用场景和用途？" class="headerlink" title="context 结构是什么样的？context 使用场景和用途？"></a><strong>context 结构是什么样的？context 使用场景和用途？</strong></h3><p><strong>（难，也常常问你项目中怎么用，光靠记答案很难让面试官满意，反正有各种结合实际的问题）</strong></p><p><strong>参考链接：</strong></p><p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/juanmaofeifei/p/14439957.html">go context详解 - 卷毛狒狒 - 博客园www.cnblogs.com/juanmaofeifei/p/14439957.html</a></p><p>答：Go 的 Context 的数据结构包含 Deadline，Done，Err，Value，Deadline 方法返回一个 time.Time，表示当前 Context 应该结束的时间，ok 则表示有结束时间，Done 方法当 Context 被取消或者超时时候返回的一个 close 的 channel，告诉给 context 相关的函数要停止当前工作然后返回了，Err 表示 context 被取消的原因，Value 方法表示 context 实现共享数据存储的地方，是协程安全的。context 在业务中是经常被使用的，</p><p><strong>其主要的应用 ：</strong></p><p>1：上下文控制，2：多个 goroutine 之间的数据交互等，3：超时控制：到某个时间点超时，过多久超时。</p><h2 id="channel相关"><a href="#channel相关" class="headerlink" title="channel相关"></a><strong>channel相关</strong></h2><h3 id="channel-是否线程安全？锁用在什么地方？"><a href="#channel-是否线程安全？锁用在什么地方？" class="headerlink" title="channel 是否线程安全？锁用在什么地方？"></a><strong>channel 是否线程安全？锁用在什么地方？</strong></h3><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-e287f5861392d5de73d8956974acdbbd_720w.webp" alt="img"></p><p>就着图片里面的答案看看吧。</p><h3 id="go-channel-的底层实现原理-（数据结构）"><a href="#go-channel-的底层实现原理-（数据结构）" class="headerlink" title="go channel 的底层实现原理 （数据结构）"></a><strong>go channel 的底层实现原理 （数据结构）</strong></h3><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-9452c08ff058590cea1b40a39fd8c70f_720w.webp" alt="img"></p><p>底层结构需要描述出来，这个简单，buf，发送队列，接收队列，lock。</p><h3 id="nil、关闭的-channel、有数据的-channel，再进行读、写、关闭会怎么样？（各类变种题型，重要）"><a href="#nil、关闭的-channel、有数据的-channel，再进行读、写、关闭会怎么样？（各类变种题型，重要）" class="headerlink" title="nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？（各类变种题型，重要）"></a><strong>nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？（各类变种题型，重要）</strong></h3><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-8e12b7eb664280346ec96bcc4fe1db2c_720w.webp" alt="img"></p><p>还要去了解一下单向channel,如只读或者只写通道常见的异常问题，这块还需要大家自己总结总结，有懂得大佬也可以评论发送答案。</p><h3 id="向-channel-发送数据和从-channel-读数据的流程是什么样的？"><a href="#向-channel-发送数据和从-channel-读数据的流程是什么样的？" class="headerlink" title="向 channel 发送数据和从 channel 读数据的流程是什么样的？"></a><strong>向 channel 发送数据和从 channel 读数据的流程是什么样的？</strong></h3><p><strong>发送流程：</strong></p><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-d2a3f2aa5c85b94df49430c21a53a2d9_720w.webp" alt="img"></p><p><strong>接收流程：</strong></p><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/v2-69e0e2f1409a17ec2987e4b63e6210da_720w.webp" alt="img"></p><p>这个没啥好说的，底层原理，1、2、3描述出来，保证面试官满意。具体的文字描述下面一题有，channel的概念多且复杂，脑海中有个总分的概念，否则你说的再多，面试官也抓不住你说的重点，等于白说。问题5已经为大家总结好了。</p><h3 id="讲讲-Go-的-chan-底层数据结构和主要使用场景"><a href="#讲讲-Go-的-chan-底层数据结构和主要使用场景" class="headerlink" title="讲讲 Go 的 chan 底层数据结构和主要使用场景"></a><strong>讲讲 Go 的 chan 底层数据结构和主要使用场景</strong></h3><p>答：channel 的数据结构包含 qccount 当前队列中剩余元素个数，dataqsiz 环形队列长度，即可以存放的元素个数，buf 环形队列指针，elemsize 每个元素的大小，closed 标识关闭状态，elemtype 元素类型，sendx 队列下表，指示元素写入时存放到队列中的位置，recv 队列下表，指示元素从队列的该位置读出。recvq 等待读消息的 goroutine 队列，sendq 等待写消息的 goroutine 队列，lock 互斥锁，chan 不允许并发读写。</p><p><strong>无缓冲和有缓冲区别：</strong> 管道没有缓冲区，从管道读数据会阻塞，直到有协程向管道中写入数据。同样，向管道写入数据也会阻塞，直到有协程从管道读取数据。管道有缓冲区但缓冲区没有数据，从管道读取数据也会阻塞，直到协程写入数据，如果管道满了，写数据也会阻塞，直到协程从缓冲区读取数据。</p><p><strong>channel 的一些特点</strong> 1）、读写值 nil 管道会永久阻塞 2）、关闭的管道读数据仍然可以读数据 3）、往关闭的管道写数据会 panic 4）、关闭为 nil 的管道 panic 5）、关闭已经关闭的管道 panic</p><p><strong>向 channel 写数据的流程：</strong> 如果等待接收队列 recvq 不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从 recvq 取出 G,并把数据写入，最后把该 G 唤醒，结束发送过程； 如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程； 如果缓冲区中没有空余位置，将待发送数据写入 G，将当前 G 加入 sendq，进入睡眠，等待被读 goroutine 唤醒；</p><p><strong>向 channel 读数据的流程：</strong> 如果等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G，把 G 中数据读出，最后把 G 唤醒，结束读取过程； 如果等待发送队列 sendq 不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程； 如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；将当前 goroutine 加入 recvq，进入睡眠，等待被写 goroutine 唤醒；</p><p><strong>使用场景：</strong> 消息传递、消息过滤，信号广播，事件订阅与广播，请求、响应转发，任务分发，结果汇总，并发控制，限流，同步与异步</p><h2 id="GMP相关"><a href="#GMP相关" class="headerlink" title="GMP相关"></a><strong>GMP相关</strong></h2><h3 id="什么是-GMP？（必问）"><a href="#什么是-GMP？（必问）" class="headerlink" title="什么是 GMP？（必问）"></a>什么是 GMP？（必问）</h3><p>答：G 代表着 goroutine，P 代表着上下文处理器，M 代表 thread 线程，在 GPM 模型，有一个全局队列（Global Queue）：存放等待运行的 G，还有一个 P 的本地队列：也是存放等待运行的 G，但数量有限，不超过 256 个。GPM 的调度流程从 go func()开始创建一个 goroutine，新建的 goroutine 优先保存在 P 的本地队列中，如果 P 的本地队列已经满了，则会保存到全局队列中。M 会从 P 的队列中取一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会从其他的 MP 组合偷取一个可执行的 G 来执行，当 M 执行某一个 G 时候发生系统调用或者阻塞，M 阻塞，如果这个时候 G 在执行，runtime 会把这个线程 M 从 P 中摘除，然后创建一个新的操作系统线程来服务于这个 P，当 M 系统调用结束时，这个 G 会尝试获取一个空闲的 P 来执行，并放入到这个 P 的本地队列，如果这个线程 M 变成休眠状态，加入到空闲线程中，然后整个 G 就会被放入到全局队列中。</p><p>关于 G,P,M 的个数问题，G 的个数理论上是无限制的，但是受内存限制，P 的数量一般建议是逻辑 CPU 数量的 2 倍，M 的数据默认启动的时候是 10000，内核很难支持这么多线程数，所以整个限制客户忽略，M 一般不做设置，设置好 P，M 一般都是要大于 P。</p><h3 id="进程、线程、协程有什么区别？（必问）"><a href="#进程、线程、协程有什么区别？（必问）" class="headerlink" title="进程、线程、协程有什么区别？（必问）"></a>进程、线程、协程有什么区别？（必问）</h3><p>进程：是应用程序的启动实例，每个进程都有独立的内存空间，不同的进程通过进程间的通信方式来通信。</p><p>线程：从属于进程，每个进程至少包含一个线程，线程是 CPU 调度的基本单位，多个线程之间可以共享进程的资源并通过共享内存等线程间的通信方式来通信。</p><p>协程：为轻量级线程，与线程相比，协程不受操作系统的调度，协程的调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行</p><h3 id="抢占式调度是如何抢占的？"><a href="#抢占式调度是如何抢占的？" class="headerlink" title="抢占式调度是如何抢占的？"></a><strong>抢占式调度是如何抢占的？</strong></h3><p><strong>基于协作式抢占</strong></p><p><strong>基于信号量抢占</strong></p><p>就像操作系统要负责线程的调度一样，Go的runtime要负责goroutine的调度。现代操作系统调度线程都是抢占式的，我们不能依赖用户代码主动让出CPU，或者因为IO、锁等待而让出，这样会造成调度的不公平。基于经典的时间片算法，当线程的时间片用完之后，会被时钟中断给打断，调度器会将当前线程的执行上下文进行保存，然后恢复下一个线程的上下文，分配新的时间片令其开始执行。这种抢占对于线程本身是无感知的，系统底层支持，不需要开发人员特殊处理。</p><p>基于时间片的抢占式调度有个明显的优点，能够避免CPU资源持续被少数线程占用，从而使其他线程长时间处于饥饿状态。goroutine的调度器也用到了时间片算法，但是和操作系统的线程调度还是有些区别的，因为整个Go程序都是运行在用户态的，所以不能像操作系统那样利用时钟中断来打断运行中的goroutine。也得益于完全在用户态实现，goroutine的调度切换更加轻量。</p><p><strong>上面这两段文字只是对调度的一个概括，具体的协作式调度、信号量调度大家还需要去详细了解，这偏底层了，大厂或者中高级开发会问。（字节就问了）</strong></p><h3 id="M-和-P-的数量问题？"><a href="#M-和-P-的数量问题？" class="headerlink" title="M 和 P 的数量问题？"></a>M 和 P 的数量问题？</h3><p>p默认cpu内核数</p><p>M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来</p><p>【Go语言调度模型G、M、P的数量多少合适？】</p><p>详细参考这篇文章</p><p><a href="https://link.zhihu.com/?target=https://mbd.baidu.com/ma/s/ZMOKQATr">https://mbd.baidu.com/ma/s/ZMOKQATrmbd.baidu.com/ma/s/ZMOKQATr</a></p><p>GMP数量这一块，结论很好记，没用项目经验的话，问了项目中怎么用可能容易卡壳。</p><h2 id="锁相关"><a href="#锁相关" class="headerlink" title="锁相关"></a>锁相关</h2><h3 id="除了-mutex-以外还有那些方式安全读写共享变量？"><a href="#除了-mutex-以外还有那些方式安全读写共享变量？" class="headerlink" title="除了 mutex 以外还有那些方式安全读写共享变量？"></a>除了 mutex 以外还有那些方式安全读写共享变量？</h3><p>* 将共享变量的读写放到一个 goroutine 中，其它 goroutine 通过 channel 进行读写操作。</p><p>* 可以用个数为 1 的信号量（semaphore）实现互斥</p><p>* 通过 Mutex 锁实现</p><h3 id="Go-如何实现原子操作？"><a href="#Go-如何实现原子操作？" class="headerlink" title="Go 如何实现原子操作？"></a>Go 如何实现原子操作？</h3><p>答：原子操作就是不可中断的操作，外界是看不到原子操作的中间状态，要么看到原子操作已经完成，要么看到原子操作已经结束。在某个值的原子操作执行的过程中，CPU 绝对不会再去执行其他针对该值的操作，那么其他操作也是原子操作。</p><p>Go 语言的标准库代码包 sync&#x2F;atomic 提供了原子的读取（Load 为前缀的函数）或写入（Store 为前缀的函数）某个值（这里细节还要多去查查资料）。</p><p><strong>原子操作与互斥锁的区别</strong></p><p>1）、互斥锁是一种数据结构，用来让一个线程执行程序的关键部分，完成互斥的多个操作。</p><p>2）、原子操作是针对某个值的单个互斥操作。</p><h3 id="Mutex-是悲观锁还是乐观锁？悲观锁、乐观锁是什么？"><a href="#Mutex-是悲观锁还是乐观锁？悲观锁、乐观锁是什么？" class="headerlink" title="Mutex 是悲观锁还是乐观锁？悲观锁、乐观锁是什么？"></a>Mutex 是悲观锁还是乐观锁？悲观锁、乐观锁是什么？</h3><p><strong>悲观锁</strong></p><p>悲观锁：当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。</p><p><strong>乐观锁</strong></p><p>乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量</p><h3 id="Mutex-有几种模式？"><a href="#Mutex-有几种模式？" class="headerlink" title="Mutex 有几种模式？"></a>Mutex 有几种模式？</h3><p><strong>1）正常模式</strong></p><ol><li>当前的mutex只有一个goruntine来获取，那么没有竞争，直接返回。</li><li>新的goruntine进来，如果当前mutex已经被获取了，则该goruntine进入一个先入先出的waiter队列，在mutex被释放后，waiter按照先进先出的方式获取锁。该goruntine会处于自旋状态(不挂起，继续占有cpu)。</li><li>新的goruntine进来，mutex处于空闲状态，将参与竞争。新来的 goroutine 有先天的优势，它们正在 CPU 中运行，可能它们的数量还不少，所以，在高并发情况下，被唤醒的 waiter 可能比较悲剧地获取不到锁，这时，它会被插入到队列的前面。如果 waiter 获取不到锁的时间超过阈值 1 毫秒，那么，这个 Mutex 就进入到了饥饿模式。</li></ol><p><strong>2）饥饿模式</strong></p><p>在饥饿模式下，Mutex 的拥有者将直接把锁交给队列最前面的 waiter。新来的 goroutine 不会尝试获取锁，即使看起来锁没有被持有，它也不会去抢，也不会 spin（自旋），它会乖乖地加入到等待队列的尾部。 如果拥有 Mutex 的 waiter 发现下面两种情况的其中之一，它就会把这个 Mutex 转换成正常模式:</p><ol><li>此 waiter 已经是队列中的最后一个 waiter 了，没有其它的等待锁的 goroutine 了；</li><li>此 waiter 的等待时间小于 1 毫秒。</li></ol><h3 id="goroutine-的自旋占用资源如何解决"><a href="#goroutine-的自旋占用资源如何解决" class="headerlink" title="goroutine 的自旋占用资源如何解决"></a>goroutine 的自旋占用资源如何解决</h3><p>自旋锁是指当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断地判断是否能够被成功获取，直到获取到锁才会退出循环。</p><p><strong>自旋的条件如下：</strong></p><p>1）还没自旋超过 4 次,</p><p>2）多核处理器，</p><p>3）GOMAXPROCS &gt; 1，</p><p>4）p 上本地 goroutine 队列为空。</p><p>mutex 会让当前的 goroutine 去空转 CPU，在空转完后再次调用 CAS 方法去尝试性的占有锁资源，直到不满足自旋条件，则最终会加入到等待队列里。</p><h2 id="并发相关"><a href="#并发相关" class="headerlink" title="并发相关"></a><strong>并发相关</strong></h2><h3 id="怎么控制并发数？"><a href="#怎么控制并发数？" class="headerlink" title="怎么控制并发数？"></a>怎么控制并发数？</h3><p><strong>第一，有缓冲通道</strong></p><p>根据通道中没有数据时读取操作陷入阻塞和通道已满时继续写入操作陷入阻塞的特性，正好实现控制并发数量。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">count := 10 // 最大支持并发</span><br><span class="line">sum := 100 // 任务总数</span><br><span class="line">wg := sync.WaitGroup&#123;&#125; //控制主协程等待所有子协程执行完之后再退出。</span><br><span class="line"></span><br><span class="line">c := make(chan struct&#123;&#125;, count) // 控制任务并发的chan</span><br><span class="line">defer close(c)</span><br><span class="line"></span><br><span class="line">for i:=0; i&lt;sum;i++&#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">c &lt;- struct&#123;&#125;&#123;&#125; // 作用类似于waitgroup.Add(1)</span><br><span class="line">go func(j int) &#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">fmt.Println(j)</span><br><span class="line">&lt;- c // 执行完毕，释放资源</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二，三方库实现的协程池</strong></p><p>panjf2000&#x2F;ants（比较火）</p><p>Jeffail&#x2F;tunny</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line"></span><br><span class="line">&quot;github.com/Jeffail/tunny&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">pool := tunny.NewFunc(10, func(i interface&#123;&#125;) interface&#123;&#125; &#123;</span><br><span class="line">log.Println(i)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">return nil</span><br><span class="line">&#125;)</span><br><span class="line">defer pool.Close()</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; 500; i++ &#123;</span><br><span class="line">go pool.Process(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second * 4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个-goroutine-对同一个-map-写会-panic，异常是否可以用-defer-捕获？"><a href="#多个-goroutine-对同一个-map-写会-panic，异常是否可以用-defer-捕获？" class="headerlink" title="多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 捕获？"></a>多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 捕获？</h3><p>可以捕获异常，但是只能捕获一次，Go语言，可以使用多值返回来返回错误。不要用异常代替错误，更不要用来控制流程。在极个别的情况下，才使用Go中引入的Exception处理：defer, panic, recover Go中，对异常处理的原则是：多用error包，少用panic</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">defer func() &#123;</span><br><span class="line">if err := recover(); err != nil &#123;</span><br><span class="line">// 打印异常，关闭资源，退出此函数</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3 id="如何优雅的实现一个-goroutine-池"><a href="#如何优雅的实现一个-goroutine-池" class="headerlink" title="如何优雅的实现一个 goroutine 池"></a>如何优雅的实现一个 goroutine 池</h3><p>（百度、手写代码，本人面传音控股被问道：请求数大于消费能力怎么设计协程池）</p><p>这一块能啃下来，offer满天飞，这应该是保证高并发系统稳定性、高可用的核心部分之一。</p><p><strong>建议参考：</strong></p><p><strong>这篇文章的目录是：</strong></p><p>\1. 为什么需要协程池？</p><p>\2. 简单的协程池</p><p>\3. go-playground&#x2F;pool</p><p>\4. ants（推荐）</p><p><strong>所以直接研究ants底层吧，省的造轮子。</strong></p><h2 id="GC相关"><a href="#GC相关" class="headerlink" title="GC相关"></a><strong>GC相关</strong></h2><h3 id="go-gc-是怎么实现的？（必问）"><a href="#go-gc-是怎么实现的？（必问）" class="headerlink" title="go gc 是怎么实现的？（必问）"></a>go gc 是怎么实现的？（必问）</h3><p>答：</p><p><strong>细分常见的三个问题：1、GC机制随着golang版本变化如何变化的？2、三色标记法的流程？3、插入屏障、删除屏障，混合写屏障（具体的实现比较难描述，但你要知道屏障的作用：避免程序运行过程中，变量被误回收；减少STW的时间）4、虾皮还问了个开放性的题目：你觉得以后GC机制会怎么优化？</strong></p><p>Go 的 GC 回收有三次演进过程，Go V1.3 之前普通标记清除（mark and sweep）方法，整体过程需要启动 STW，效率极低。GoV1.5 三色标记法，堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要 STW)，效率普通。GoV1.8 三色标记法，混合写屏障机制：栈空间不启动（全部标记成黑色），堆空间启用写屏障，整个过程不要 STW，效率高。</p><p>Go1.3 之前的版本所谓标记清除是先启动 STW 暂停，然后执行标记，再执行数据回收，最后停止 STW。Go1.3 版本标记清除做了点优化，流程是：先启动 STW 暂停，然后执行标记，停止 STW，最后再执行数据回收。</p><p>Go1.5 三色标记主要是插入屏障和删除屏障，写入屏障的流程：程序开始，全部标记为白色，1）所有的对象放到白色集合，2）遍历一次根节点，得到灰色节点，3）遍历灰色节点，将可达的对象，从白色标记灰色，遍历之后的灰色标记成黑色，4）由于并发特性，此刻外界向在堆中的对象发生添加对象，以及在栈中的对象添加对象，在堆中的对象会触发插入屏障机制，栈中的对象不触发，5）由于堆中对象插入屏障，则会把堆中黑色对象添加的白色对象改成灰色，栈中的黑色对象添加的白色对象依然是白色，6）循环第 5 步，直到没有灰色节点，7）在准备回收白色前，重新遍历扫描一次栈空间，加上 STW 暂停保护栈，防止外界干扰（有新的白色会被添加成黑色）在 STW 中，将栈中的对象一次三色标记，直到没有灰色，8）停止 STW，清除白色。至于删除写屏障，则是遍历灰色节点的时候出现可达的节点被删除，这个时候触发删除写屏障，这个可达的被删除的节点也是灰色，等循环三色标记之后，直到没有灰色节点，然后清理白色，删除写屏障会造成一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮 GC 中被清理掉。</p><p>GoV1.8 混合写屏障规则是：</p><p>1）GC 开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需 STW)，2）GC 期间，任何在栈上创建的新对象，均为黑色。3）被删除的对象标记为灰色。4）被添加的对象标记为灰色。</p><h3 id="go-是-gc-算法是怎么实现的？-（得物，出现频率低）"><a href="#go-是-gc-算法是怎么实现的？-（得物，出现频率低）" class="headerlink" title="go 是 gc 算法是怎么实现的？ （得物，出现频率低）"></a>go 是 gc 算法是怎么实现的？ （得物，出现频率低）</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func GC() &#123;</span><br><span class="line">n := atomic.Load(&amp;amp;work.cycles)</span><br><span class="line">gcWaitOnMark(n)</span><br><span class="line"></span><br><span class="line">gcStart(gcTrigger&#123;kind: gcTriggerCycle, n: n + 1&#125;)</span><br><span class="line">gcWaitOnMark(n + 1)</span><br><span class="line"></span><br><span class="line">for atomic.Load(&amp;amp;work.cycles) == n+1 &amp;amp;&amp;amp; sweepone() != ^uintptr(0) &#123;</span><br><span class="line">sweep.nbgsweep++</span><br><span class="line">Gosched()</span><br><span class="line">&#125;</span><br><span class="line">for atomic.Load(&amp;amp;work.cycles) == n+1 &amp;amp;&amp;amp; atomic.Load(&amp;amp;mheap_.sweepers) != 0 &#123;</span><br><span class="line">Gosched()</span><br><span class="line">&#125;</span><br><span class="line">mp := acquirem()</span><br><span class="line">cycle := atomic.Load(&amp;amp;work.cycles)</span><br><span class="line">if cycle == n+1 || (gcphase == _GCmark &amp;amp;&amp;amp; cycle == n+2) &#123;</span><br><span class="line">mProf_PostSweep()</span><br><span class="line">&#125;</span><br><span class="line">releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层原理了，可能大厂，中高级才会问，参考：</p><h3 id="GC-中-stw-时机，各个阶段是如何解决的？-（百度）"><a href="#GC-中-stw-时机，各个阶段是如何解决的？-（百度）" class="headerlink" title="GC 中 stw 时机，各个阶段是如何解决的？ （百度）"></a>GC 中 stw 时机，各个阶段是如何解决的？ （百度）</h3><p><strong>底层原理，自行百度一下，我等渣渣简历都过不了BAT，字节，虾皮，特使拉以及一些国Q还能收到面试邀约</strong>。</p><p>1）在开始新的一轮 GC 周期前，需要调用 gcWaitOnMark 方法上一轮 GC 的标记结束（含扫描终止、标记、或标记终止等）。</p><p>2）开始新的一轮 GC 周期，调用 gcStart 方法触发 GC 行为，开始扫描标记阶段。</p><p>3）需要调用 gcWaitOnMark 方法等待，直到当前 GC 周期的扫描、标记、标记终止完成。</p><p>4）需要调用 sweepone 方法，扫描未扫除的堆跨度，并持续扫除，保证清理完成。在等待扫除完毕前的阻塞时间，会调用 Gosched 让出。</p><p>5）在本轮 GC 已经基本完成后，会调用 mProf_PostSweep 方法。以此记录最后一次标记终止时的堆配置文件快照。</p><p>6）结束，释放 M。</p><h3 id="GC-的触发时机？"><a href="#GC-的触发时机？" class="headerlink" title="GC 的触发时机？"></a>GC 的触发时机？</h3><p>初级必问，分为系统触发和主动触发。</p><p>1）gcTriggerHeap：当所分配的堆大小达到阈值（由控制器计算的触发堆的大小）时，将会触发。</p><p>2）gcTriggerTime：当距离上一个 GC 周期的时间超过一定时间时，将会触发。时间周期以runtime.forcegcperiod 变量为准，默认 2 分钟。</p><p>3）gcTriggerCycle：如果没有开启 GC，则启动 GC。</p><p>4）手动触发的 runtime.GC 方法。</p><h2 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a><strong>内存相关</strong></h2><h3 id="谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？"><a href="#谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？" class="headerlink" title="谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？"></a>谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？</h3><p>答：go 中的内存泄漏一般都是 goroutine 泄漏，就是 goroutine 没有被关闭，或者没有添加超时控制，让 goroutine 一只处于阻塞状态，不能被 GC。</p><p><strong>内存泄露有下面一些情况</strong></p><p>1）如果 goroutine 在执行时被阻塞而无法退出，就会导致 goroutine 的内存泄漏，一个 goroutine 的最低栈大小为 2KB，在高并发的场景下，对内存的消耗也是非常恐怖的。</p><p>2）互斥锁未释放或者造成死锁会造成内存泄漏</p><p>3）time.Ticker 是每隔指定的时间就会向通道内写数据。作为循环触发器，必须调用 stop 方法才会停止，从而被 GC 掉，否则会一直占用内存空间。</p><p>4）字符串的截取引发临时性的内存泄漏</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var str0 = &quot;12345678901234567890&quot;</span><br><span class="line">str1 := str0[:10]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5）切片截取引起子切片内存泄漏</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var s0 = []int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br><span class="line">s1 := s0[:3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6）函数数组传参引发内存泄漏【如果我们在函数传参的时候用到了数组传参，且这个数组够大（我们假设数组大小为 100 万，64 位机上消耗的内存约为 800w 字节，即 8MB 内存），或者该函数短时间内被调用 N 次，那么可想而知，会消耗大量内存，对性能产生极大的影响，如果短时间内分配大量内存，而又来不及 GC，那么就会产生临时性的内存泄漏，对于高并发场景相当可怕。】</p><p><strong>排查方式：</strong></p><p>一般通过 pprof 是 Go 的性能分析工具，在程序运行过程中，可以记录程序的运行信息，可以是 CPU 使用情况、内存使用情况、goroutine 运行情况等，当需要性能调优或者定位 Bug 时候，这些记录的信息是相当重要。</p><p><strong>当然你能说说具体的分析指标更加分咯，有的面试官就喜欢他问什么，你简洁的回答什么，不喜欢巴拉巴拉详细解释一通，比如虾P面试官，不过他考察的内容特别多，可能是为了节约时间。</strong></p><h3 id="知道-golang-的内存逃逸吗？什么情况下会发生内存逃逸？（必问）"><a href="#知道-golang-的内存逃逸吗？什么情况下会发生内存逃逸？（必问）" class="headerlink" title="知道 golang 的内存逃逸吗？什么情况下会发生内存逃逸？（必问）"></a>知道 golang 的内存逃逸吗？什么情况下会发生内存逃逸？（必问）</h3><p>答：1)本该分配到栈上的变量，跑到了堆上，这就导致了内存逃逸。2)栈是高地址到低地址，栈上的变量，函数结束后变量会跟着回收掉，不会有额外性能的开销。3)变量从栈逃逸到堆上，如果要回收掉，需要进行 gc，那么 gc 一定会带来额外的性能开销。编程语言不断优化 gc 算法，主要目的都是为了减少 gc 带来的额外性能开销，变量一旦逃逸会导致性能开销变大。</p><p><strong>内存逃逸的情况如下：</strong></p><p>1）方法内返回局部变量指针。</p><p>2）向 channel 发送指针数据。</p><p>3）在闭包中引用包外的值。</p><p>4）在 slice 或 map 中存储指针。</p><p>5）切片（扩容后）长度太大。</p><p>6）在 interface 类型上调用方法。</p><h3 id="请简述-Go-是如何分配内存的？"><a href="#请简述-Go-是如何分配内存的？" class="headerlink" title="请简述 Go 是如何分配内存的？"></a>请简述 Go 是如何分配内存的？</h3><p>mcache mcentral mheap mspan</p><p>Go 程序启动的时候申请一大块内存，并且划分 spans，bitmap，areana 区域；arena 区域按照页划分成一个个小块，span 管理一个或者多个页，mcentral 管理多个 span 供现场申请使用；mcache 作为线程私有资源，来源于 mcentral。</p><p><strong>这里描述的比较简单，你可以自己再去搜索下更简洁完整的答案。</strong></p><h3 id="Channel-分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？"><a href="#Channel-分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？" class="headerlink" title="Channel 分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？"></a>Channel 分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？</h3><p>Channel 被设计用来实现协程间通信的组件，其作用域和生命周期不可能仅限于某个函数内部，所以 golang 直接将其分配在堆上</p><p>准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。</p><p>知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。然而，如果编译器不能确保变量在函数 return 之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。</p><p>当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上,然而，还要对这些变量做逃逸分析，如果函数 return 之后，变量不再被引用，则将其分配到栈上。</p><h3 id="介绍一下大对象小对象，为什么小对象多了会造成-gc-压力？"><a href="#介绍一下大对象小对象，为什么小对象多了会造成-gc-压力？" class="headerlink" title="介绍一下大对象小对象，为什么小对象多了会造成 gc 压力？"></a>介绍一下大对象小对象，为什么小对象多了会造成 gc 压力？</h3><p>小于等于 32k 的对象就是小对象，其它都是大对象。一般小对象通过 mspan 分配内存；大对象则直接由 mheap 分配内存。通常小对象过多会导致 GC 三色法消耗过多的 CPU。优化思路是，减少对象分配。</p><p>小对象：如果申请小对象时，发现当前内存空间不存在空闲跨度时，将会需要调用 nextFree 方法获取新的可用的对象，可能会触发 GC 行为。</p><p>大对象：如果申请大于 32k 以上的大对象时，可能会触发 GC 行为。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="Go-多返回值怎么实现的？"><a href="#Go-多返回值怎么实现的？" class="headerlink" title="Go 多返回值怎么实现的？"></a>Go 多返回值怎么实现的？</h3><p>答：Go 传参和返回值是通过 FP+offset 实现，并且存储在调用函数的栈帧中。FP 栈底寄存器，指向一个函数栈的顶部;PC 程序计数器，指向下一条执行指令;SB 指向静态数据的基指针，全局符号;SP 栈顶寄存器。</p><h3 id="讲讲-Go-中主协程如何等待其余协程退出"><a href="#讲讲-Go-中主协程如何等待其余协程退出" class="headerlink" title="讲讲 Go 中主协程如何等待其余协程退出?"></a>讲讲 Go 中主协程如何等待其余协程退出?</h3><p>答：Go 的 sync.WaitGroup 是等待一组协程结束，sync.WaitGroup 只有 3 个方法，Add()是添加计数，Done()减去一个计数，Wait()阻塞直到所有的任务完成。Go 里面还能通过有缓冲的 channel 实现其阻塞等待一组协程结束，这个不能保证一组 goroutine 按照顺序执行，可以并发执行协程。Go 里面能通过无缓冲的 channel 实现其阻塞等待一组协程结束，这个能保证一组 goroutine 按照顺序执行，但是不能并发执行。</p><p><strong>啰嗦一句：</strong>循环智能二面，手写代码部分时，三个协程按交替顺序打印数字，最后题目做出来了，问我代码中Add()是什么意思，我回答的不是很清晰，这家公司就没有然后了。Add()表示协程计数，可以一次Add多个，如Add(3),可以多次Add(1);然后每个子协程必须调用done（）,这样才能保证所有子协程结束，主协程才能结束。</p><h3 id="Go-语言中不同的类型如何比较是否相等？"><a href="#Go-语言中不同的类型如何比较是否相等？" class="headerlink" title="Go 语言中不同的类型如何比较是否相等？"></a>Go 语言中不同的类型如何比较是否相等？</h3><p>答：像 string，int，float interface 等可以通过 reflect.DeepEqual 和等于号进行比较，像 slice，struct，map 则一般使用 reflect.DeepEqual 来检测是否相等。</p><h3 id="Go-中-init-函数的特征"><a href="#Go-中-init-函数的特征" class="headerlink" title="Go 中 init 函数的特征?"></a>Go 中 init 函数的特征?</h3><p>答：一个包下可以有多个 init 函数，每个文件也可以有多个 init 函数。多个 init 函数按照它们的文件名顺序逐个初始化。应用初始化时初始化工作的顺序是，从被导入的最深层包开始进行初始化，层层递出最后到 main 包。不管包被导入多少次，包内的 init 函数只会执行一次。应用初始化时初始化工作的顺序是，从被导入的最深层包开始进行初始化，层层递出最后到 main 包。但包级别变量的初始化先于包内 init 函数的执行。</p><h3 id="Go-中-uintptr-和-unsafe-Pointer-的区别？"><a href="#Go-中-uintptr-和-unsafe-Pointer-的区别？" class="headerlink" title="Go 中 uintptr 和 unsafe.Pointer 的区别？"></a>Go 中 uintptr 和 unsafe.Pointer 的区别？</h3><p>答：unsafe.Pointer 是通用指针类型，它不能参与计算，任何类型的指针都可以转化成 unsafe.Pointer，unsafe.Pointer 可以转化成任何类型的指针，uintptr 可以转换为 unsafe.Pointer，unsafe.Pointer 可以转换为 uintptr。uintptr 是指针运算的工具，但是它不能持有指针对象（意思就是它跟指针对象不能互相转换），unsafe.Pointer 是指针对象进行运算（也就是 uintptr）的桥梁。</p><h3 id="golang共享内存（互斥锁）方法实现发送多个get请求"><a href="#golang共享内存（互斥锁）方法实现发送多个get请求" class="headerlink" title="golang共享内存（互斥锁）方法实现发送多个get请求"></a>golang共享内存（互斥锁）方法实现发送多个get请求</h3><p>待补充</p><h3 id="从数组中取一个相同大小的slice有成本吗？"><a href="#从数组中取一个相同大小的slice有成本吗？" class="headerlink" title="从数组中取一个相同大小的slice有成本吗？"></a>从数组中取一个相同大小的slice有成本吗？</h3><p>或者这么问：从切片中取一个相同大小的数组有成本吗？</p><p>这是爱立信的二面题目，这个问题我至今还没搞懂，不知道从什么切入点去分析，欢迎指教。</p><p>PS：爱立信面试都要英文自我介绍，以及问答，如果英文回答不上来，会直接切换成中文。</p>]]></content>
      
      
      <categories>
          
          <category> GO基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GO基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言面经</title>
      <link href="/2022/01/14/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E8%AF%AD%E8%A8%80%E9%9D%A2%E7%BB%8F/"/>
      <url>/2022/01/14/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E8%AF%AD%E8%A8%80%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="进程、线程、协程的区别"><a href="#进程、线程、协程的区别" class="headerlink" title="进程、线程、协程的区别"></a>进程、线程、协程的区别</h1><p><strong>进程：</strong>就是二进制可执行文件在计算机内存中的运行实例，<strong>进程是操作系统最小的资源分配单位</strong>，拥有独立的内存空间和系统资源，为了方便管理，每个进程都有自己的描述符，我们称之为<strong>进程控制块</strong>，即PCB，进程分类：</p><ul><li><strong>用户进程：位于用户空间中，是程序执行的实例</strong></li><li><strong>内核进程：位于内核空间中，可以访问硬件</strong></li></ul><p>进程在创建后，在执行过程中，其状态一直在变化。分别是：<strong>初始态、就绪态、运行态、挂起态（阻塞）、终止态</strong></p><p><strong>线程：线程是操作系统最小的调度执行单位</strong>，线程不能独立于进程而存在，其生命周期不可能逾越其所属的进程生命周期，<strong>线程与进程一样拥有独立的PCB，但是没有独立的地址空间，即线程之间共享了地址空间，直接就能通信！！</strong>进程的<strong>大多数资源会被其内部的线程所共享。</strong></p><p><strong>协程：</strong>程与进程、线程相比并不是一个维度的概念，协程不是被操作系统内核所管理的，而是<strong>完全由程序所控制，也就是在用户态执行</strong>。由程序员显式地定义和控制，可以在执行过程中暂停和恢复。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。   </p><p>优点：</p><ul><li>占用小：<strong>协程更加轻量，创建成本更小，降低了内存消耗</strong>，协程一般只占据极小的内存（2~5KB），而线程是1MB左右。虽然线程和协程都是独有栈，但是线程栈是固定的，比如在Java中，基本是2M，假如一个栈只有一个打印方法，还要为此开辟一个2M的栈，就太浪费了。而<strong>Go的的协程具备动态收缩功能</strong>，初始化为2KB，最大可达1GB</li><li><strong>运行效率高：</strong>线程切换需要从用户态-&gt;内核态-&gt;用户态，而协程切换是在用户态上，即用户态-&gt;用户态-&gt;用户态，其切换过程由语言层面的调度器（coroutine）或者语言引擎（goroutine）实现。</li><li>减少了同步锁：协程最终还是运行在线程上，本质上还是单线程运行，没有临界区域的话自然不需要锁的机制。<strong>多协程自然没有竞争关系</strong>。但是，如果存在临界区域，依然需要使用锁，<strong>协程可以减少以往必须使用锁的场景</strong></li></ul><p>缺点：</p><ul><li>无法利用多核资源：协程运行在线程上，单线程应用无法很好的利用多核，只能以多进程方式启动。</li><li><strong>协程不能有阻塞操作</strong>：线程是抢占式，线程在遇见IO操作时候，线程从运行态→阻塞态，释放cpu使用权。这是由操作系统调度。<strong>协程是非抢占式，如果遇见IO操作时候，协程是主动释放执行权限的，如果无法主动释放，程序将阻塞，无法往下执行，随之而来是整个线程被阻塞。</strong></li><li>CPU密集型不是长处：假设这个线程中有一个协程是 CPU 密集型的他没有 IO 操作，也就是自己不会主动触发调度器调度的过程，那么就会出现其他协程得不到执行的情况，所以这种情况下需要程序员自己避免。</li></ul><h1 id="Golang协程间如何通信"><a href="#Golang协程间如何通信" class="headerlink" title="Golang协程间如何通信"></a>Golang协程间如何通信</h1><p>Go推荐使用通道（channel）的方式解决数据传递问题，在多个goroutine之间，channel负责传递数据，还能保证整个过程的并发安全性。  </p><h1 id="GMP模型-Go协程调度模型"><a href="#GMP模型-Go协程调度模型" class="headerlink" title="GMP模型(Go协程调度模型)"></a>GMP模型(Go协程调度模型)</h1><p>每个G的执行需要P和M的支持，M与P关联后才会形成一个有效的G运行环境，即 <code>工作线程+上下文环境</code>。  </p><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/image-20230530155013217.png" alt="image-20230530155013217"> </p><ul><li>G：goroutine，一个G代表一个Go协程</li><li>M：machine，一个M代表一个工作线程，runtime&#x2F;debug 中的 <strong>SetMaxThreads</strong> 函数，设置 M 的最大数量</li><li>P：processor，一个P代表执行一个Go代码段需要的上下文环境，由<strong>启动时环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS()</strong> 决定</li></ul><blockquote><p>M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。</p></blockquote><p><strong>go func () 调度流程</strong>：</p><p> 1、我们通过 go func () 来创建一个 goroutine；</p><p> 2、有两个存储 G 的队列，一个是局部调度器 P 的本地队列、一个是全局 G 队列。新创建的 G 会先保存在 P 的本地队列中，如果 P 的本地队列已经满了就会保存在全局的队列中；（所有的 M 都可以从全局队列中拉取 G 来执行）</p><p> 3、G 只能运行在 M 中，一个 M 必须持有一个 P，M 和 P 存在一一绑定的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，则  M 从全局队列中拉取；如果全局队列也为空，则从其他的 P 中拉取 G</p><p> 4、一个 M 调度 G 执行的过程是一个循环机制；</p><p> 5、当 M 执行某一个 G 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime  会把这个线程 M 从 P 中摘除 (detach)，然后再创建一个新的操作系统的线程 (如果有空闲的线程可用就复用空闲线程) 来服务于这个 P；</p><p> 6、当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中。</p><h1 id="Golang-Map底层"><a href="#Golang-Map底层" class="headerlink" title="Golang Map底层"></a>Golang Map底层</h1><p>Map的底层实现是由哈希表（Hash Table）实现的。</p><p>哈希表是一种基于哈希函数的数据结构，它将键映射到存储位置，从而实现快速的查找。在Go语言中，Map的底层结构是一个哈希表数组，每个元素称为桶（Bucket）。每个桶存储着一个或多个键值对。</p><p>下面是Map底层的几个关键点：</p><ol><li>哈希函数：Map使用哈希函数将键转换为一个索引，用于确定键值对在哈希表数组中的存储位置。哈希函数应该具有良好的散列性，以减少冲突的发生。</li><li>桶（Bucket）：Map底层的哈希表数组由多个桶组成，每个桶存储着一个或多个键值对。当多个键映射到同一个索引位置时，它们会被存储在同一个桶中，形成一个链表或其他数据结构。</li><li>冲突解决：由于哈希函数的有限性，可能会发生不同的键映射到相同的索引位置，这就是哈希冲突。Map使用链表或其他冲突解决方法来处理冲突，确保所有键值对都能正确存储和访问。</li><li>动态调整大小：Map具有自动扩容和收缩的能力，以适应键值对的增加或减少。当Map中的键值对数量达到一定阈值时，Map会自动进行扩容，重新分配更大的哈希表数组。反之，如果键值对数量减少到一定程度，Map会自动进行收缩，释放不必要的内存。</li></ol><p>总结来说，Go语言中的Map底层使用哈希表实现，通过哈希函数将键映射到存储位置，解决键值对的查找、插入和删除操作。哈希冲突通过链表等冲突解决方法来处理。同时，Map具有动态调整大小的能力，以适应键值对的变化。这种底层实现使得Map在大多数情况下能够提供高效的性能和常数时间复杂度的操作。</p><h1 id="如何实现Map的有序查找"><a href="#如何实现Map的有序查找" class="headerlink" title="如何实现Map的有序查找"></a>如何实现Map的有序查找</h1><p>一种常见的方法是使用有序的数据结构，如切片（Slice）或平衡二叉树（Balanced Binary Tree）来维护键值对的有序性。</p><p>使用切片（Slice）：可以将Map的键值对复制到一个切片中，并按照键的顺序排序切片。然后，可以使用二分查找算法在有序的切片中进行查找操作</p><p>使用平衡二叉树（如红黑树）：将Map的键作为树节点的关键字，值作为节点的值，构建一颗平衡二叉树。可以使用平衡二叉树的查找操作来实现有序查找。</p><h1 id="sync包-sync包提供了基本的同步基元"><a href="#sync包-sync包提供了基本的同步基元" class="headerlink" title="sync包(sync包提供了基本的同步基元)"></a>sync包(sync包提供了基本的同步基元)</h1><h4 id="互斥锁-sync-Mutex"><a href="#互斥锁-sync-Mutex" class="headerlink" title="互斥锁 sync.Mutex"></a>互斥锁 sync.Mutex</h4><p><strong>互斥锁</strong>是传统并发程序进行共享资源访问控制的主要方法。Go中由结构体<code>sync.Mutex</code>表示互斥锁，<strong>保证同时只有一个 goroutine 可以访问共享资源</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock()</span><br></pre></td></tr></table></figure><h4 id="读写锁-sync-RWMutex"><a href="#读写锁-sync-RWMutex" class="headerlink" title="读写锁 sync.RWMutex"></a>读写锁 sync.RWMutex</h4><p>在开发场景中，经常遇到多处并发读取，一次并发写入的情况，Go为了方便这些操作，<strong>在互斥锁基础上，提供了读写锁操作</strong>。  读写锁即针对读写操作的互斥锁，简单来说，就是将数据设定为 写模式（只写）或者读模式（只读）。使用读写锁可以分别针对读操作和写操作进行锁定和解锁操作。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rwm sync.RWMutex</span><br><span class="line"><span class="comment">// 设定为写模式：与互斥锁使用方式一致，一路只写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span></span> Lock()<span class="comment">// 锁定写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span></span> Unlock()<span class="comment">// 解锁写</span></span><br><span class="line"><span class="comment">// 设定为读模式：对读执行加锁解锁，即多路只读</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span></span> RLock()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span></span> RUnlock()</span><br><span class="line"><span class="comment">//返回值Locker是实现了接口`sync.Lokcer`的值，该接口同样被 `*sync.Mutex`和`*sync.RWMutex`实现，包含方法：`Lock`和`Unlock`。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLocker() Locker</span><br></pre></td></tr></table></figure><h4 id="等待组-sync-WaitGroup"><a href="#等待组-sync-WaitGroup" class="headerlink" title="等待组 sync.WaitGroup"></a>等待组 sync.WaitGroup</h4><p><code>sync.WaitGroup</code>类型的值也是并发安全的，该类型结构体中<strong>内部拥有一个计数器</strong>，计数器的值可以通过方法调用实现计数器的增加和减少 。  </p><p>当我们<strong>添加了 N 个并发任务进行工作时，就将等待组的计数器值增加 N。每个任务完成时，这个值减1</strong>。 同时，在另外一个 goroutine 中等待这个等待组的计数器值为 0 时， 表示所有任务己经完成。  </p><p>等待组常用方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Add方法向内部计数加上delta，delta可以是负数；如果内部计数器变为0，切记不能减少为负数，会引发崩溃</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Add(delta <span class="type">int</span>)</span><br><span class="line"><span class="comment">//Done方法减少WaitGroup计数器的值，应在线程的最后执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Done()</span><br><span class="line"><span class="comment">//Wait方法阻塞直到WaitGroup计数器减为0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait()</span><br></pre></td></tr></table></figure><h4 id="条件变量-sync-Cond"><a href="#条件变量-sync-Cond" class="headerlink" title="条件变量 sync.Cond"></a>条件变量 sync.Cond</h4><p>条件变量通常与锁配合使用： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l locker)</span></span> *Cond        <span class="comment">// 条件变量必须传入一个锁，二者需要配合使用</span></span><br></pre></td></tr></table></figure><p><code>*sync.Cond</code>类型有三个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Broadcast唤醒所有等待c的线程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast()</span><br><span class="line"><span class="comment">//Signal唤醒等待c的一个线程（如果存在）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal()</span><br><span class="line"><span class="comment">//该方法会阻塞等待条件变量满足条件。也会对锁进行解锁，一旦收到通知则唤醒，并立即锁定该锁</span></span><br><span class="line"><span class="comment">//Wait自行解锁c.L并阻塞当前线程，在之后线程恢复执行时，Wait方法会在返回前锁定c.L。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait()</span><br></pre></td></tr></table></figure><h4 id="Once-只执行一次"><a href="#Once-只执行一次" class="headerlink" title="Once 只执行一次"></a>Once 只执行一次</h4><p><code>sync.Once</code>，负责只执行一次，也即全局唯一操作。  使用方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;&#125;)           <span class="comment">// Do方法的有效调用次数永远是1</span></span><br></pre></td></tr></table></figure><p><code>sync.Once</code>的典型应用场景是只执行一次的任务，如果这样的任务不适合在init函数中执行，该结构体类就会派上用场。  </p><p>sync.Once内部使用了“卫述语句、双重检查锁定、共享标记的原子操作”来实现<code>Once</code>功能。</p><h4 id="对象池-sync-Pool"><a href="#对象池-sync-Pool" class="headerlink" title="对象池 sync.Pool"></a>对象池 sync.Pool</h4><p><code>sync.Pool</code>可以作为临时值的容器，该容器具备自动伸缩、高效特性，同时也是并发安全的，其方法有：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Get() <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Put(x <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li>如果池子从未Put过，其New字段也没有被赋值一个非nil值，那么Get方法返回结果一定是nil。  </li><li>Get获取的值不一定存在于池中，如果Get到的值存在于池中，则该值Get后会被删除</li></ul><h4 id="原子操作-sync-atomic"><a href="#原子操作-sync-atomic" class="headerlink" title="原子操作 sync&#x2F;atomic"></a>原子操作 sync&#x2F;atomic</h4><p>这些函数可以对一些数据类型进行原子操作这些函数提供的原子操作有5种：增、减、比较并交换、载入、存储、交换。  </p><h5 id="原子运算：增-减"><a href="#原子运算：增-减" class="headerlink" title="原子运算：增&#x2F;减"></a>原子运算：增&#x2F;减</h5><p>增加函数的函数名前缀都是Add开头</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子性的把一个int32类型变量 i32 增大3 ，下列函数返回值必定是已经被修改的值</span></span><br><span class="line">newi32 := atomic.AddInt32(&amp;i32, <span class="number">3</span>)      <span class="comment">// 传入指针类型因为该函数需要获得数据的内存位置，以施加特殊的CPU指令</span></span><br></pre></td></tr></table></figure><p>常见的增&#x2F;减原子操作函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt32</span><span class="params">(addr *<span class="type">int32</span>, delta <span class="type">int32</span>)</span></span> (<span class="built_in">new</span> <span class="type">int32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt64</span><span class="params">(addr *<span class="type">int64</span>, delta <span class="type">int64</span>)</span></span> (<span class="built_in">new</span> <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint32</span><span class="params">(addr *<span class="type">uint32</span>, delta <span class="type">uint32</span>)</span></span> (<span class="built_in">new</span> <span class="type">uint32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint64</span><span class="params">(addr *<span class="type">uint64</span>, delta <span class="type">uint64</span>)</span></span> (<span class="built_in">new</span> <span class="type">uint64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, delta <span class="type">uintptr</span>)</span></span> (<span class="built_in">new</span> <span class="type">uintptr</span>)</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>如果需要执行减少操作，可以这样书写 atomic.AddInt32(&amp;i32, -3)</li><li>对uint32执行增加NN（代表负整数，增加NN也可以理解为减少-NN）：atomic.AddUint32(&amp;ui32, ^uint32(-NN-1)) </li><li>不存在atomic.AddPointer的函数，因为unsafe.Poniter类型的值无法被增减</li></ul><h5 id="原子运算：比较与替换"><a href="#原子运算：比较与替换" class="headerlink" title="原子运算：比较与替换"></a>原子运算：比较与替换</h5><p>比较并替换即“Compare And Swap”，简称CAS。该类原子操作名称都以<code>CompareAndSwap</code>为前缀。   </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数一：被操作数 参数二和参数三代表被操作数的旧值和新值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt32</span><span class="params">(addr *<span class="type">int32</span>, old, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt64</span><span class="params">(addr *<span class="type">int64</span>, old, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint32</span><span class="params">(addr *<span class="type">uint32</span>, old, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint64</span><span class="params">(addr *<span class="type">uint64</span>, old, <span class="built_in">new</span> <span class="type">uint64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, old, <span class="built_in">new</span> <span class="type">uintptr</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapPointer</span><span class="params">(addr *unsafe.Pointer, old, <span class="built_in">new</span> unsafe.Pointer)</span></span> (swapped <span class="type">bool</span>)</span><br></pre></td></tr></table></figure><p>CAS的一些特点：</p><ul><li>CAS与锁相比，明显不同是它总是假设操作值未被改变，一旦确认这个假设为真，立即进行替换。所以锁的做法趋于悲观，CAS的做法趋于乐观。  </li><li>CAS的优势：可以在不创建互斥量和不形成临界区的情况下，完成并发安全的值替换操作，可以大大减少性能损耗。  </li><li>CAS的劣势：在被操作之被频繁变更的情况下，CAS操作容易失败，有时候需要for循环判断返回结构的bool来进行多次尝试 </li><li>CAS操作不会阻塞协程，但是仍可能使流程执行暂时停滞（这种停滞极短）</li></ul><p>应用场景：并发安全的更新一些类型的值，可以优先选择CAS操作。  </p><h5 id="原子读取：载入"><a href="#原子读取：载入" class="headerlink" title="原子读取：载入"></a>原子读取：载入</h5><p>为了原子的读取数值，Go提供了一系列载入函数，名称以<code>Load</code>为前缀。   </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt32</span><span class="params">(addr *<span class="type">int32</span>)</span></span> (val <span class="type">int32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt64</span><span class="params">(addr *<span class="type">int64</span>)</span></span> (val <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint32</span><span class="params">(addr *<span class="type">uint32</span>)</span></span> (val <span class="type">uint32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint64</span><span class="params">(addr *<span class="type">uint64</span>)</span></span> (val <span class="type">uint64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUintptr</span><span class="params">(addr *<span class="type">uintptr</span>)</span></span> (val <span class="type">uintptr</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadPointer</span><span class="params">(addr *unsafe.Pointer)</span></span> (val unsafe.Pointer)</span><br></pre></td></tr></table></figure><p>CAS与载入的配合示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value 增加 num</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addValue</span><span class="params">(value,num <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        v := atomic.LoadInt32(&amp;value)</span><br><span class="line">        <span class="keyword">if</span> atomic.ComapreAndSwapInt32(&amp;value, v, (v + num)) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="原子写入：存储"><a href="#原子写入：存储" class="headerlink" title="原子写入：存储"></a>原子写入：存储</h5><p>在原子存储时，任何CPU都不会进行针对同一个值的读写操作，此时不会出现并发时候，别人读取到了修改了一半的值。</p><p>Go的<code>sync/atomic</code>包提供的存储函数都是以<code>Store</code>为前缀。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt32</span><span class="params">(addr *<span class="type">int32</span>, val <span class="type">int32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt64</span><span class="params">(addr *<span class="type">int64</span>, val <span class="type">int64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint32</span><span class="params">(addr *<span class="type">uint32</span>, val <span class="type">uint32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint64</span><span class="params">(addr *<span class="type">uint64</span>, val <span class="type">uint64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, val <span class="type">uintptr</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StorePointer</span><span class="params">(addr *unsafe.Pointer, val unsafe.Pointer)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数一为被操作数据的指针 参数二是要存储的新值</span></span><br><span class="line">atomic.StoreInt32(i *int3, v <span class="type">int32</span>)     </span><br></pre></td></tr></table></figure><p>Go原子存储的特点：存储操作总会成功，因为不关心被操作值的旧值是什么，这与CAS有明显区别。  </p><h5 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h5><p>交换与CAS操作相似，但是交换不关心被操作数据的旧值，而是直接设置新值，不过会返回被操作值的旧值。交换操作比CAS操作的约束更少，且比载入操作功能更强。 在Go中，交换操作都以<code>Swap</code>为前缀，示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt32</span><span class="params">(addr *<span class="type">int32</span>, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> (old <span class="type">int32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt64</span><span class="params">(addr *<span class="type">int64</span>, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (old <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUint32</span><span class="params">(addr *<span class="type">uint32</span>, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> (old <span class="type">uint32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUint64</span><span class="params">(addr *<span class="type">uint64</span>, <span class="built_in">new</span> <span class="type">uint64</span>)</span></span> (old <span class="type">uint64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, <span class="built_in">new</span> <span class="type">uintptr</span>)</span></span> (old <span class="type">uintptr</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapPointer</span><span class="params">(addr *unsafe.Pointer, <span class="built_in">new</span> unsafe.Pointer)</span></span> (old unsafe.Pointer)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数一是被操作值指针  参数二是新值  返回值为旧值</span></span><br><span class="line">atomic.SwapInt32(i *<span class="type">int32</span>, v <span class="type">int32</span>)         </span><br></pre></td></tr></table></figure><h1 id="怎么实现Map的并发安全-sync-Map，底层实际上用了一个Map缓存"><a href="#怎么实现Map的并发安全-sync-Map，底层实际上用了一个Map缓存" class="headerlink" title="怎么实现Map的并发安全(sync.Map，底层实际上用了一个Map缓存)"></a>怎么实现Map的并发安全(sync.Map，底层实际上用了一个Map缓存)</h1><p><code>sync.Map</code>类型提供了一种并发安全的键值对映射，它可以在多个goroutine之间安全地读取和写入数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个并发安全的Map</span></span><br><span class="line"><span class="keyword">var</span> m sync.Map</span><br><span class="line"><span class="comment">// 添加键值对</span></span><br><span class="line">m.Store(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>)</span><br><span class="line">m.Store(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>)</span><br><span class="line"><span class="comment">// 从Map中获取值</span></span><br><span class="line">value1, ok1 := m.Load(<span class="string">&quot;key1&quot;</span>)</span><br><span class="line">value2, ok2 := m.Load(<span class="string">&quot;key2&quot;</span>)</span><br><span class="line"><span class="comment">// 删除键值对</span></span><br><span class="line">m.Delete(<span class="string">&quot;key2&quot;</span>)</span><br><span class="line"><span class="comment">// 遍历Map</span></span><br><span class="line">m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Key:&quot;</span>, key, <span class="string">&quot;Value:&quot;</span>, value)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>sync.Map</code>内部被<strong>分成了多个分片（shard）</strong>，每个分片都包含了一个独立的映射，<strong>以及一个互斥锁用于保护该分片的读写操作</strong>。默认情况下，分<strong>片的数量是32，可以通过调整<code>runtime.GOMAXPROCS()</code>来改变分片的数量。</strong>当<strong>需要读取或写入映射时，<code>sync.Map</code>会根据键的哈希值选择一个特定的分片</strong>。对于读操作，只需要获取对应分片的互斥锁，并直接进行读取操作，不会对其他分片产生影响。<strong>对于写操作，需要先获取对应分片的互斥锁，然后执行写入操作，并最后释放互斥锁。</strong>这样就实现了对分片的并发访问控制，从而保证了并发安全性。</p><p>此外，<code>sync.Map</code>还使用了一种特殊的技术，即<strong>当读操作遇到正在进行的写操作时，读操作会等待写操作完成，并重新加载最新的数据。</strong>这种技术可以避免读操作读取到过期的数据，并确保读取的数据是最新的。</p><p>需要注意的是，<strong>由于<code>sync.Map</code>采用了分片锁的机制，因此在高并发的情况下，对于频繁的写操作可能会导致锁的争用，进而影响性能</strong>。因此，如果需要高性能的并发映射，可以<strong>考虑使用其他第三方的并发安全映射库</strong>，如<code>concurrent-map</code>、<code>go-cache</code>等，它们可能会采用更高效的底层实现方式。</p><h1 id="defer函数的使用场景（延迟Close、recover-panic）"><a href="#defer函数的使用场景（延迟Close、recover-panic）" class="headerlink" title="defer函数的使用场景（延迟Close、recover panic）"></a>defer函数的使用场景（延迟Close、recover panic）</h1><ol><li><strong>解锁互斥锁</strong>：在使用互斥锁进行临界区保护时，为了避免忘记解锁而导致死锁，可以<strong>使用defer函数来确保在函数执行完毕后解锁互斥锁</strong>。</li><li>延迟<strong>执行资源清理</strong>：在函数执行过程中，如果需要进行一些<strong>资源清理操作</strong>，可以使用defer函数来延迟执行清理操作，确保无论函数执行的逻辑分支如何，都能够进行资源清理.(文件、数据库连接、网络连接)</li><li><strong>恢复错误</strong>：在处理可能发生错误的代码段时，可以<strong>使用defer函数来捕获和处理错误</strong>，<strong>避免错误传播到调用栈的更高层。</strong></li><li><strong>确保函数调用顺序：</strong>当在函数中有多个函数调用的顺序很重要时，可以使用<strong>defer函数来确保它们按照正确的顺序执行</strong>。</li></ol><h1 id="Map可以用数组作为Key吗（数组可以，切片不可以）"><a href="#Map可以用数组作为Key吗（数组可以，切片不可以）" class="headerlink" title="Map可以用数组作为Key吗（数组可以，切片不可以）"></a>Map可以用数组作为Key吗（数组可以，切片不可以）</h1><p>Go 语言中只要是可比较的类型都可以作为 key。除开 <strong>slice，map，functions</strong> 这几种类型，其他类型都是 OK 的。具体包括：布尔值、数字、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组。</p><h1 id="Channel的阻塞和非阻塞（顺带问了select用法）"><a href="#Channel的阻塞和非阻塞（顺带问了select用法）" class="headerlink" title="Channel的阻塞和非阻塞（顺带问了select用法）"></a>Channel的阻塞和非阻塞（顺带问了select用法）</h1><ol><li>阻塞通道：<strong>默认情况下，通道是阻塞</strong>的。<strong>当发送方尝试将数据发送到通道时，如果通道已满（接收方没有准备好接收），发送方将被阻塞，直到有空间可用。类似地，当接收方尝试从通道中接收数据时，如果通道为空（发送方没有准备好发送），接收方将被阻塞，直到有数据可用</strong>。这种阻塞行为使得通道成为一种有效的同步机制。</li><li>非阻塞通道： 非阻塞通道的特点是在数据传输期间不会发生暂停，发送方和接收方可以继续执行其他操作。在 Go 中，<strong>可以使用<code>select</code>语句结合<code>default</code>分支来实现非阻塞的通道操作</strong>。<code>select</code>语句用于同时监视多个通道的状态，并执行相应的操作。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// 创建一个整数类型的通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送方（非阻塞）</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ch &lt;- <span class="number">42</span>: <span class="comment">// 尝试发送数据到通道</span></span><br><span class="line">    <span class="comment">// 发送成功时执行的代码</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 通道已满时执行的代码或其他操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收方（非阻塞）</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch: <span class="comment">// 尝试从通道接收数据</span></span><br><span class="line">    <span class="comment">// 接收到数据时执行的代码</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 通道为空时执行的代码或其他操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="实现一个接口C在指定时间内最大次数并发调用接口A与接口B"><a href="#实现一个接口C在指定时间内最大次数并发调用接口A与接口B" class="headerlink" title="实现一个接口C在指定时间内最大次数并发调用接口A与接口B"></a>实现一个接口C在指定时间内最大次数并发调用接口A与接口B</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">duration := <span class="number">5</span> * time.Second  <span class="comment">// 指定时间段</span></span><br><span class="line">startTime := time.Now()</span><br><span class="line"><span class="comment">// 循环调用接口A和接口B，直到达到指定时间或最大调用次数</span></span><br><span class="line"><span class="keyword">for</span> time.Since(startTime) &lt; duration&#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 并发调用接口A和接口B</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">a := InterfaceA&#123;&#125;</span><br><span class="line">b := InterfaceB&#123;&#125;</span><br><span class="line">a.CallA()</span><br><span class="line">b.CallB()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待所有调用完成</span></span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><h1 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h1><p>在<code>Ethereum.StartMining()</code>函数中，出现了<code>if c, ok := s.engine.(*clique.Clique); ok</code> 的写法。这中写法是 Golang 中的语法糖，称为<strong>类型断言</strong>。具体的语法是 <code>value, ok := element.(T)</code>，它的含义是如果 <code>element</code> 是 <code>T</code> 类型的话，那么ok等于<code>True</code>, <code>value</code> 等于 <code>element</code> 的值。在 <code>if c, ok := s.engine.(*clique.Clique); ok</code> 语句中，就是在判断 <code>s.engine</code> 的是否为 <code>*clique.Clique</code> 类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cli *clique.Clique</span><br><span class="line"><span class="keyword">if</span> c, ok := s.engine.(*clique.Clique); ok &#123;</span><br><span class="line"> cli = c</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> cl, ok := s.engine.(*beacon.Beacon); ok &#123;</span><br><span class="line"> <span class="keyword">if</span> c, ok := cl.InnerEngine().(*clique.Clique); ok &#123;</span><br><span class="line">  cli = c</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GO基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GO基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-垃圾回收器</title>
      <link href="/2022/01/13/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>/2022/01/13/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h1><p><strong>我们在程序中定义一个变量，会在内存中开辟相应内存空间进行存储，当不需要此变量后，需要手动销毁此对象，并释放内存。而这种对不再使用的内存资源进行自动回收的功能即为垃圾回收（Garbage Collection，缩写为GC），是一种自动内存管理机制</strong></p><h1 id="如何识别垃圾"><a href="#如何识别垃圾" class="headerlink" title="如何识别垃圾"></a>如何识别垃圾</h1><h2 id="引用计数算法-reference-counting"><a href="#引用计数算法-reference-counting" class="headerlink" title="引用计数算法(reference counting)"></a>引用计数算法(reference counting)</h2><p>引<strong>用计数通过在对象上增加自己被引用的次数，被其他对象引用时加1，引用自己的对象被回收时减1，引用数为0的对象即为可以被回收的对象，</strong>这种算法在内存比较紧张和实时性比较高的系统中使用比较广泛，如php，Python等。</p><img src="/noteimg/Go知识点/GO基础知识/img/3a41e75733c54c75b053ac26b3b526e8tplv-k3u1fbpfcp-zoom-in-crop-mark4536000-168662237133012.awebp" alt="img" style="zoom:80%;" /> <p>优点：方式简单，回收速度快。</p><p>缺点：</p><ol><li>需要额外的空间存放计数。</li><li>无法处理循环引用(如a.b&#x3D;b; b.a&#x3D;a)。</li><li>频繁更新引用计数降低了性能。</li></ol><h2 id="追踪式回收算法-Tracing"><a href="#追踪式回收算法-Tracing" class="headerlink" title="追踪式回收算法(Tracing)"></a>追踪式回收算法(Tracing)</h2><p>追踪式算法(可达性分析)的核心思想是<strong>判断一个对象是否可达，如果这个对象一旦不可达就可以立刻被GC回收了</strong>，那么我们怎么判断一个对象是否可达呢？第一步从<strong>根节点开始找出所有的全局变量和当前函数栈里的变量，标记为可达</strong>。第二步，<strong>从已经标记的数据开始，进一步标记它们可访问的变量，</strong>以此类推，专业术语叫传递闭包。当追踪结束时，没有被打上标记的对象就被判定是不可触达。</p><p><img src="/noteimg/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img/d42f9e9925ae473eb52ed795f8da5e35tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p><p>优点：</p><ol><li>解决了循环引用的问题</li><li>占用的空间少了</li></ol><p>和引用计数法相比，有以下缺点：</p><ol><li>无法立刻识别出垃圾对象，需要依赖GC线程</li><li>算法在标记时必须暂停整个程序，即STW(stop the world)，否则其他线程有可能会修改对象的状态从而回收不该回收的对象</li></ol><h2 id="STW-是什么意思？"><a href="#STW-是什么意思？" class="headerlink" title="STW 是什么意思？"></a>STW 是什么意思？</h2><p><code>STW</code> 可以是 <code>Stop the World</code> 的缩写，也可以是 <code>Start the World</code> 的缩写。通常意义上指指代从 <code>Stop the World</code> 这一动作发生时到 <code>Start the World</code> 这一动作发生时这一段时间间隔，即万物静止。STW 在垃圾回收过程中为了保证实现的正确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图的一段过程。</p><p>在这个过程中整个用户代码被停止或者放缓执行， <code>STW</code> 越长，对用户代码造成的影响（例如延迟）就越大，早期 Go 对垃圾回收器的实现中 <code>STW</code> 长达几百毫秒，对时间敏感的实时通信等应用程序会造成巨大的影响。</p><h1 id="如何清理垃圾"><a href="#如何清理垃圾" class="headerlink" title="如何清理垃圾"></a>如何清理垃圾</h1><h2 id="标记清除算法-Mark-Sweep"><a href="#标记清除算法-Mark-Sweep" class="headerlink" title="标记清除算法(Mark Sweep)"></a>标记清除算法(Mark Sweep)</h2><p>标记清除算法是最常见的垃圾收集算法，标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记(Mark)和清除(Sweep)两个阶段：</p><ol><li>标记阶段：<strong>暂停应用程序的执行，从根对象触发查找并标记堆中所有存活的对象；</strong></li><li>清除阶段：<strong>遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表，恢复应用程序的执行；</strong></li></ol><img src="/noteimg/Go知识点/GO基础知识/img/26a3f4946dfe438893654a9dad0d0a53tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img" style="zoom: 50%;" /> <p>优点：实现简单。</p><p>缺点：</p><ol><li><strong>执行期间需要把整个程序完全暂停，不能异步的进行垃圾回收。</strong></li><li>容易产生大量不连续的内存碎片，碎片太多可能会导致后续没有足够的连续内存分配给较大的对象，从而提前触发新的一次垃圾收集动作。</li></ol><h2 id="标记复制算法"><a href="#标记复制算法" class="headerlink" title="标记复制算法"></a>标记复制算法</h2><p>它把内存空间划分为两个相等的区域，每次只使用其中一个区域。在垃圾收集时，遍历当前使用的区域，<strong>把存活对象复制到另一个区域中，最后将当前使用的区域的可回收对象进行回收。</strong></p><p>实现：</p><p>首先这个算法会把对分成两块，一块是From、一块是To</p><p>对象只会在From上生成，发生GC之后会找到所有的存活对象，然后将其复制到To区，然后整体回收From区。</p><img src="/noteimg/Go知识点/GO基础知识/img/432b58a1a30f4d91a5d810fcfddf9478tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img" style="zoom: 67%;" /> <p>优点：</p><ol><li>不用进行大量垃圾对象的扫描：标记复制算法需要从<code>GC-root</code>对象出发，将可达的对象复制到另外一块内存后直接清理当前这块内存即可。</li><li>解决了内存碎片问题，防止分配大空间对象是提前gc的问题。</li></ol><p>缺点：</p><ol><li>复制成本问题：在可达对象占用内存高的时候，复制成本会很高。</li><li>内存利用率低：相当于可利用的内存仅有一半。</li></ol><h2 id="标记压缩算法"><a href="#标记压缩算法" class="headerlink" title="标记压缩算法"></a>标记压缩算法</h2><p>在标记可回收的对象后<strong>将所有存活的对象压缩到内存的一端</strong>，使他们紧凑地排列在一起，对边界以外的内存进行回收，回收后，已用和未用的内存都各自一边。</p><img src="/noteimg/Go知识点/GO基础知识/img/9fc05db886244859a02fa3ac92d1e57atplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img" style="zoom:67%;" /> <p>优点：</p><ol><li>避免了内存碎片化的问题。</li><li>适合老年代算法，老年代对象存活率高的情况下，标记整理算法由于不需要复制对象，效率更高。</li></ol><p>缺点：整理过程复杂：需要多次遍历内存，导致STW时间比标记清除算法高。</p><h1 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h1><h2 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h2><p>为了解决原始标记清除算法带来的长时间STW, Go从v1.5版本实现了<strong>基于三色标记清除的并发垃圾收集器</strong>，在<strong>不暂停程序的情况下即可完成对象的可达性分析</strong>，三色标记算法将程序中的对象分成白色、黑色和灰色三类：</p><ul><li><strong>白色对象 - 潜在的垃圾，其内存可能会被垃圾收集器回收；</strong></li><li><strong>灰色对象 - 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；</strong></li><li><strong>黑色对象 - 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象</strong></li></ul><p>三色标记法属于增量式GC算法，回收器<strong>首先将所有对象标记成白色</strong>，然后从gc root出发，<strong>逐步把所有可达的对象变成灰色再到黑色</strong>，最终所有的白色对象都是不可达对象。</p><p>具体实现：</p><ul><li><strong>初始时所有对象都是白色的</strong></li><li>从<code>gc root</code>对象出发，<strong>扫描所有可达对象标记为灰色，放入待处理队列</strong></li><li><strong>从队列取出一个灰色对象并标记为黑色，将其引用对象标记为灰色</strong>，放入队列</li><li><strong>重复上一步骤，直到灰色对象队列为空</strong></li><li><strong>此时剩下的所有白色对象都是垃圾对象</strong></li></ul><img src="/noteimg/Go知识点/GO基础知识/img/45d06eb5f99d49f385ac21e4027b4973tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img" style="zoom:50%;" /> <p>优点：</p><ul><li>不需要STW</li></ul><p>缺点：</p><ul><li>如果产生垃圾速度大于回收速度时，可能会导致程序中垃圾对象越来越多而无法及时收集</li><li>线程切换和上下文转换的消耗会使得垃圾回收的总体成本上升，从而降低系统吞吐量</li></ul><p>三色标记法存在并发性问题，</p><ul><li><strong>可能会出现野指针(指向没有合法地址的指针)，从而造成严重的程序错误</strong></li><li><strong>漏标，错误的回收非垃圾对象</strong></li></ul><h2 id="三色不变性"><a href="#三色不变性" class="headerlink" title="三色不变性"></a>三色不变性</h2><p>想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性中的任意一种。</p><ul><li><p>强三色不变性——<strong>黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象。</strong></p><img src="/noteimg/Go知识点/GO基础知识/img/8bf86801841744ab97923af572b763f2tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img" style="zoom: 50%;" /> </li><li><p>弱三色不变性——<strong>黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径</strong>。</p></li></ul><img src="/noteimg/Go知识点/GO基础知识/img/4fc07e2bf7a743d0902fac72ed174f80tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img" style="zoom:67%;" /> <h2 id="屏障技术"><a href="#屏障技术" class="headerlink" title="屏障技术"></a>屏障技术</h2><p>垃圾收集中的屏障技术更像是一个钩子方法，<strong>它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码</strong>，根据操作类型的不同，我们可以将它们分成读屏障和写屏障两种，<strong>因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以往往都会采用写屏障保证三色不变性。</strong></p><h3 id="插入写屏障"><a href="#插入写屏障" class="headerlink" title="插入写屏障"></a><strong>插入写屏障</strong></h3><p><strong>当一个对象引用另外一个对象时，将另外一个对象标记为灰色，以此满足强三色不变性，不会存在黑色对象引用白色对象。</strong></p><h3 id="删除写屏障"><a href="#删除写屏障" class="headerlink" title="删除写屏障"></a>删除写屏障</h3><p><strong>在灰色对象删除对白色对象的引用时，将白色对象置为灰色，其实就是快照保存旧的引用关系，这叫STAB,以此满足弱三色不变性。</strong></p><h3 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h3><p>v1.8版本之前，运行时会使用插入写屏障保证强三色不变性；</p><p>在v1.8中，<strong>组合插入写屏障和删除写屏障构成了混合写屏障，保证弱三色不变性；</strong>该写屏障会<strong>将覆盖的对象标记成灰色(删除写屏障)并在当前栈没有扫描时将新对象也标记成灰色(插入写屏障)：</strong></p><p><strong>写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新建的对象都会被直接标记成黑色。</strong></p><h1 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h1><p>Go语言的垃圾收集可以分成清除终止、标记、标记终止和清除四个不同阶段：</p><img src="/noteimg/Go知识点/GO基础知识/img/0a5a6c1f177d41f393de2a6a8f860c13tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img" style="zoom:50%;" /> <p><strong>清理终止阶段</strong></p><ol><li>清扫终止阶段，为下一个阶段的并发标记做准备工作，启动写屏障</li></ol><p><strong>标记阶段</strong></p><ol><li>将状态切换至<code>_GCmark</code>、<strong>与赋值器并发执行，开启写屏障</strong>、用户程序协助(<code>Mutator Assists</code>)并将根对象入队；</li><li>恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，<strong>写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；</strong></li><li><strong>开始扫描根对象，包括所有<code>Goroutine</code>的栈、全局对象以及不在堆中的运行时数据结构，扫描<code>Goroutine</code>栈期间会暂停当前处理器；</strong></li><li><strong>依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；</strong></li><li>使用分布式的终止算法检查剩余的工作，<strong>发现标记阶段完成后进入标记终止阶段；</strong></li></ol><p><strong>标记终止阶段</strong></p><ol><li><strong>保证一个周期内标记任务完成，停止写屏障</strong></li><li>暂停程序、将状态切换至<code>_GCmarktermination </code>并关闭辅助标记的用户程序；</li><li>清理处理器上的线程缓存；</li></ol><p><strong>清理阶段</strong></p><ol><li>将状态切换至<code>_GCoff</code> <strong>开始清理阶段、初始化清理状态并关闭写屏障；</strong></li><li><strong>恢复用户程序，所有新创建的对象会标记成白色；</strong></li><li><strong>后台并发清理所有的内存管理单元，当<code>Goroutine</code>申请新的内存管理单元时就会触发清理；</strong></li></ol><h1 id="GC触发时机"><a href="#GC触发时机" class="headerlink" title="GC触发时机"></a>GC触发时机</h1><p>当满足触发垃圾收集的基本条件：允许垃圾收集、程序没有崩溃并且没有处于垃圾循环；</p><p>注：运行时会通过如下所示的<code>runtime.gcTrigger.test</code>方法决定是否需要触发垃圾收集，该方法会根据三种不同方式触发进行不同的检查。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t gcTrigger)</span></span> test() <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !memstats.enablegc || panicking != <span class="number">0</span> || gcphase != _GCoff &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> t.kind &#123;</span><br><span class="line"><span class="keyword">case</span> gcTriggerHeap:</span><br><span class="line"><span class="keyword">return</span> memstats.heap_live &gt;= memstats.gc_trigger</span><br><span class="line"><span class="keyword">case</span> gcTriggerTime:</span><br><span class="line"><span class="keyword">if</span> gcpercent &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">lastgc := <span class="type">int64</span>(atomic.Load64(&amp;memstats.last_gc_nanotime))</span><br><span class="line"><span class="keyword">return</span> lastgc != <span class="number">0</span> &amp;&amp; t.now-lastgc &gt; forcegcperiod</span><br><span class="line"><span class="keyword">case</span> gcTriggerCycle:</span><br><span class="line"><span class="keyword">return</span> <span class="type">int32</span>(t.n-work.cycles) &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>超过内存大小阙值，分配内存时</strong>，当前已分配内存与上一次<code>GC</code>结束时存活对象的内存达到某个比例时就触发<code>GC</code>。(默认配置会在堆内存达到上一次垃圾收集的2倍时，触发新一轮的垃圾收集，可以通过环境变量<code>GOGC</code>调整，在默认情况下他的值为100，即增长100%的堆内存才会触发<code>GC</code>)；比如一次回收完毕后，内存的使用量为5M，那么下次回收的机制则是内存分配达到10M的时候，也就是说，并不是内存分配越多，垃圾回收频率越高。</li><li>如果一直达不到内存大小的阙值，<code>sysmon</code>检测出一段时间内（由<code>runtime.forcegcperiod</code>变量控制，<strong>默认为2分钟）没有触发过<code>GC</code>，就会触发新的GC。</strong></li><li><strong>手动调用<code>runtime.GC()</code>强制触发<code>GC</code></strong></li></ul><h1 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h1><p>减少堆内存的分配是最好的优化方式。比如合理重复利用对象；避免<code>string</code>和<code>byte[]</code>之间的转化等，两者发生转换的时候，底层数据结构会进行复制，因此导致gc效率会变低，少量使用<code>+</code>连接<code>string</code>，Go里面<code>string</code>是最基础的类型，是一个只读类型，针对他的每一个操作都会创建一个新的<code>string</code>，如果是少量小文本拼接，用<code>“+”</code>就好，如果是大量小文本拼接，用<code>strings.Join</code>;如果是大量大文本拼接，用<code>bytes.Buffer</code>。</p><p>优化努力的方向：</p><ul><li>控制内存分配的速度，限制 goroutine 的数量，从而提高赋值器对 CPU 的利用率。</li><li>减少并复用内存，例如使用 sync.Pool 来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的拷贝。</li><li>需要时，增大 GOGC 的值，降低 GC 的运行频率。</li></ul>]]></content>
      
      
      <categories>
          
          <category> GO基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GO基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-调度器</title>
      <link href="/2022/01/07/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7-%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
      <url>/2022/01/07/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7-%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> GO基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GO基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-编译</title>
      <link href="/2022/01/01/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6-%E7%BC%96%E8%AF%91/"/>
      <url>/2022/01/01/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6-%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> GO基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GO基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-标准库</title>
      <link href="/2021/12/26/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5-%E6%A0%87%E5%87%86%E5%BA%93/"/>
      <url>/2021/12/26/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5-%E6%A0%87%E5%87%86%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p>context 用来解决 goroutine 之间<code>退出通知</code>、<code>元数据传递</code>的功能。</p><p>context 使用起来非常方便。源码里对外提供了一个创建根节点 context 的函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context</span><br></pre></td></tr></table></figure><p>background 是一个空的 context， 它不能被取消，没有值，也没有超时时间。</p><p>有了根节点 context，又提供了四个函数创建子节点 context：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context</span><br></pre></td></tr></table></figure><p>context 会在函数传递间传递,需要在适当的时间<strong>调用 cancel 函数向 goroutines 发出取消信号</strong>或者<strong>调用 Value 函数取出 context 中的值。</strong></p><h3 id="传递共享的数据"><a href="#传递共享的数据" class="headerlink" title="传递共享的数据"></a>传递共享的数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">process(ctx)</span><br><span class="line"></span><br><span class="line">ctx = context.WithValue(ctx, <span class="string">&quot;traceId&quot;</span>, <span class="string">&quot;qcrao-2019&quot;</span>)</span><br><span class="line">process(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">traceId, ok := ctx.Value(<span class="string">&quot;traceId&quot;</span>).(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;process over. trace_id=%s\n&quot;</span>, traceId)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;process over. no trace_id\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">process over. no trace_id</span><br><span class="line">process over. trace_id=qcrao<span class="number">-2019</span></span><br></pre></td></tr></table></figure><h3 id="取消-goroutine"><a href="#取消-goroutine" class="headerlink" title="取消 goroutine"></a>取消 goroutine</h3><p>我们先来设想一个场景：打开外卖的订单页，地图上显示外卖小哥的位置，而且是每秒更新 1 次。app 端向后台发起 websocket 连接（现实中可能是轮询）请求后，后台启动一个协程，每隔 1 秒计算 1 次小哥的位置，并发送给端。如果用户退出此页面，则后台需要“取消”此过程，退出 goroutine，系统回收资源。</p><p>后端可能的实现如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Perform</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        calculatePos()</span><br><span class="line">        sendResult()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="comment">// 被取消，直接返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">            <span class="comment">// block 1 秒钟 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主流程可能是这样的：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Hour)</span><br><span class="line"><span class="keyword">go</span> Perform(ctx)</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line"><span class="comment">// app 端返回页面，调用cancel 函数</span></span><br><span class="line">cancel()</span><br></pre></td></tr></table></figure><h3 id="防止-goroutine-泄漏"><a href="#防止-goroutine-泄漏" class="headerlink" title="防止 goroutine 泄漏"></a>防止 goroutine 泄漏</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(ctx context.Context)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> ch &lt;- n:</span><br><span class="line">n++</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel() <span class="comment">// 避免其他地方忘记 cancel，且重复调用不影响</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) &#123;</span><br><span class="line">fmt.Println(n)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">cancel()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h1><p>使用反射的常见场景有以下两种：</p><ol><li>不能明确接口调用哪个函数，需要根据传入的参数在运行时决定。</li><li>不能明确传入函数的参数类型，需要在运行时处理任意对象。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeepEqual</span><span class="params">(x, y <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure><p><code>DeepEqual</code> 函数的参数是两个 <code>interface</code>，实际上也就是可以输入任意类型，输出 true 或者 flase 表示输入的两个变量是否是“深度”相等。</p>]]></content>
      
      
      <categories>
          
          <category> GO基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GO基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-接口</title>
      <link href="/2021/12/21/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3-%E6%8E%A5%E5%8F%A3/"/>
      <url>/2021/12/21/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3-%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h1><p>我们来定义一个Sayer接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">    say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义dog和cat两个结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>因为Sayer接口里只有一个say方法，所以我们只需要给dog和cat 分别实现say方法就可以实现Sayer接口了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dog实现了Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> say() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;汪汪汪&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat实现了Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span></span> say() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;喵喵喵&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的实现就是这么简单，只要实现了接口中的所有方法，就实现了这个接口。</p><h1 id="值接收者和指针接收者的区别"><a href="#值接收者和指针接收者的区别" class="headerlink" title="值接收者和指针接收者的区别"></a>值接收者和指针接收者的区别</h1><p>实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；</p><p>而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下程序会报错</span></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span><br><span class="line">    Speak(<span class="type">string</span>) <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Stduent)</span></span> Speak(think <span class="type">string</span>) (talk <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> think == <span class="string">&quot;sb&quot;</span> &#123;</span><br><span class="line">        talk = <span class="string">&quot;你是个大帅比&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        talk = <span class="string">&quot;您好&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> peo People = Student&#123;&#125;</span><br><span class="line">    think := <span class="string">&quot;bitch&quot;</span></span><br><span class="line">    fmt.Println(peo.Speak(think))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编译器自动检测类型是否实现接口"><a href="#编译器自动检测类型是否实现接口" class="headerlink" title="编译器自动检测类型是否实现接口"></a>编译器自动检测类型是否实现接口</h1><p>经常看到一些开源库里会有一些类似下面这种奇怪的用法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>这时候会有点懵，不知道作者想要干什么，实际上这就是此问题的答案。编译器会由此检查 <code>*myWriter</code> 类型是否实现了 <code>io.Writer</code> 接口。</p><p>来看一个例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w myWriter)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 检查 *myWriter 类型是否实现了 io.Writer 接口</span></span><br><span class="line">    <span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 检查 myWriter 类型是否实现了 io.Writer 接口</span></span><br><span class="line">    <span class="keyword">var</span> _ io.Writer = myWriter&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GO基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GO基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-通道</title>
      <link href="/2021/12/21/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4-%E9%80%9A%E9%81%93/"/>
      <url>/2021/12/21/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4-%E9%80%9A%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h1 id="channel底层"><a href="#channel底层" class="headerlink" title="channel底层"></a>channel底层</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// chan 里元素数量</span></span><br><span class="line">qcount   <span class="type">uint</span></span><br><span class="line"><span class="comment">// chan 底层循环数组的长度</span></span><br><span class="line">dataqsiz <span class="type">uint</span></span><br><span class="line"><span class="comment">// 指向底层循环数组的指针</span></span><br><span class="line"><span class="comment">// 只针对有缓冲的 channel</span></span><br><span class="line">buf      unsafe.Pointer</span><br><span class="line"><span class="comment">// chan 中元素大小</span></span><br><span class="line">elemsize <span class="type">uint16</span></span><br><span class="line"><span class="comment">// chan 是否被关闭的标志</span></span><br><span class="line">closed   <span class="type">uint32</span></span><br><span class="line"><span class="comment">// chan 中元素类型</span></span><br><span class="line">elemtype *_type <span class="comment">// element type</span></span><br><span class="line"><span class="comment">// 已发送元素在循环数组中的索引</span></span><br><span class="line">sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line"><span class="comment">// 已接收元素在循环数组中的索引</span></span><br><span class="line">recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line"><span class="comment">// 等待接收的 goroutine 队列</span></span><br><span class="line">recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line"><span class="comment">// 等待发送的 goroutine 队列</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"><span class="comment">// 保护 hchan 中所有字段</span></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于字段的含义都写在注释里了，再来重点说几个字段：</p><p><code>buf</code> <strong>指向底层循环数组，只有缓冲型的 channel 才有。</strong></p><p><code>sendx</code>，<code>recvx</code> 均指向底层循环数组，表示<strong>当前可以发送和接收的元素位置索引值</strong>（相对于底层数组）。</p><p><code>sendq</code>，<code>recvq</code> 分别表示<strong>被阻塞的 goroutine，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据而被阻塞</strong>。</p><p><code>waitq</code> 是 一个双向链表，</p><p><code>lock</code> 用来<strong>保证每个读 channel 或写 channel 的操作都是原子的。</strong></p><p>channel基于一些数据结构和同步原语来实现通信和同步的功能,以下是Channel底层的一些关键特性：</p><ol><li><strong>管道（Pipeline）数据结构</strong>：Channel底层<strong>使用管道数据结构</strong>（Pipeline）来存储和传递数，通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。可以在发送和接收操作之间传递数据。<strong>每个管道都有一个缓冲区（buffer）是个循环链表，用于临时存储发送的数据，当缓冲区满时，发送操作将会阻塞</strong>。</li><li><strong>互斥锁和条件变量</strong>：为了实现Channel的<strong>同步功能，底层使用了互斥锁和条件变量</strong>。<strong>互斥锁用于保护Channel的访问和修改操作，条件变量用于实现goroutine之间的等待和唤醒机制</strong>。通过这些同步原语，可以保证Channel的安全访问和正确的同步行为。</li><li><strong>Select语句和伪随机调度</strong>：当<strong>有多个Channel操作同时准备就绪</strong>时，Go语言<strong>使用伪随机的调度算法来选择其中一个操作执行</strong>。这种调度算法可以避免饥饿和不公平的情况发生。<strong>Select语句是一种特殊的语法结构，用于监听多个Channel操作的完成情况，并根据情况执行相应的代码块。</strong></li></ol><p>总结起来，<strong>Channel的底层实现是基于管道数据结构、互斥锁、条件变量和伪随机调度等机制</strong>。这些底层机制共同实现了Channel的并发安全性、同步和通信功能。</p><h1 id="操作-channel-的结果"><a href="#操作-channel-的结果" class="headerlink" title="操作 channel 的结果"></a>操作 channel 的结果</h1><p>发生 panic 的情况有三种：向一个关闭的 channel 进行写操作；关闭一个 nil 的 channel；重复关闭一个 channel。</p><p>读、写一个 nil channel 都会被阻塞。</p>]]></content>
      
      
      <categories>
          
          <category> GO基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GO基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-哈希表</title>
      <link href="/2021/12/18/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2021/12/18/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="map的底层实现原理"><a href="#map的底层实现原理" class="headerlink" title="map的底层实现原理"></a>map的底层实现原理</h1><p>Go 语言采用的是哈希查找表，并且使用链表解决哈希冲突。</p><h2 id="map-内存模型"><a href="#map-内存模型" class="headerlink" title="map 内存模型"></a>map 内存模型</h2><p>在源码中，表示 map 的结构体是 hmap，它是 hashmap 的“缩写”：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 元素个数，调用 len(map) 时，直接返回此值</span></span><br><span class="line">count     <span class="type">int</span></span><br><span class="line">flags     <span class="type">uint8</span></span><br><span class="line"><span class="comment">// buckets 的对数 log_2</span></span><br><span class="line">B         <span class="type">uint8</span></span><br><span class="line"><span class="comment">// overflow 的 bucket 近似数</span></span><br><span class="line">noverflow <span class="type">uint16</span></span><br><span class="line"><span class="comment">// 计算 key 的哈希的时候会传入哈希函数</span></span><br><span class="line">hash0     <span class="type">uint32</span></span><br><span class="line">    <span class="comment">// 指向 buckets 数组，大小为 2^B</span></span><br><span class="line">    <span class="comment">// 如果元素个数为0，就为 nil</span></span><br><span class="line">buckets    unsafe.Pointer</span><br><span class="line"><span class="comment">// 等量扩容的时候，buckets 长度和 oldbuckets 相等</span></span><br><span class="line"><span class="comment">// 双倍扩容的时候，buckets 长度会是 oldbuckets 的两倍</span></span><br><span class="line">oldbuckets unsafe.Pointer</span><br><span class="line"><span class="comment">// 指示扩容进度，小于此地址的 buckets 迁移完成</span></span><br><span class="line">nevacuate  <span class="type">uintptr</span></span><br><span class="line">extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明一下，<code>B</code> 是 buckets 数组的长度的对数，也就是说 buckets 数组的长度就是 2^B。<strong>bucket 里面存储了 key 和 value</strong>，后面会再讲。</p><p>buckets 是一个指针，最终它指向的是一个结构体：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这只是表面(src&#x2F;runtime&#x2F;hashmap.go)的结构，编译期间会给它加料，动态地创建一个新的结构：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="type">uintptr</span></span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>bmap</code> 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置</strong>（一个桶内最多有8个位置）。</p><p>来一个整体的图：</p><img src="/noteimg/Go知识点/GO基础知识/img/image-20230614154516323.png" alt="image-20230614154516323" style="zoom:80%;" /> <p>bmap 是存放 k-v 的地方，我们把视角拉近，仔细看 bmap 的内部组成。</p><img src="/noteimg/Go知识点/GO基础知识/img/image-20230614154819161.png" alt="image-20230614154819161" style="zoom:50%;" /> <p>上图就是 bucket 的内存模型，<code>HOB Hash</code> 指的就是 top hash。 注意到 key 和 value 是各自放在一起的，并不是 <code>key/value/key/value/...</code> 这样的形式。源码里说明这样的好处是在某些情况下可以省略掉 padding 字段，节省内存空间。</p><p><strong>每个 bucket 设计成最多只能放 8 个 key-value 对，如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个 bucket ，通过 <code>overflow</code> 指针连接起来。</strong></p><h2 id="创建-map"><a href="#创建-map" class="headerlink" title="创建 map"></a>创建 map</h2><p>从语法层面上来说，创建 map 很简单：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ageMp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">// 指定 map 长度</span></span><br><span class="line">ageMp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">8</span>)</span><br><span class="line"><span class="comment">// ageMp 为 nil，不能向其添加元素，会直接panic</span></span><br><span class="line"><span class="keyword">var</span> ageMp <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure><p>通过汇编语言可以看到，实际上底层调用的是 <code>makemap</code> 函数，主要做的工作就是初始化 <code>hmap</code> 结构体的各种字段，例如计算 B 的大小，设置哈希种子 hash0 等等。</p><h3 id="slice-和-map-分别作为函数参数时有什么区别？"><a href="#slice-和-map-分别作为函数参数时有什么区别？" class="headerlink" title="slice 和 map 分别作为函数参数时有什么区别？"></a>slice 和 map 分别作为函数参数时有什么区别？</h3><blockquote><p>注意，<code>makemap</code> 函数返回的结果：<code>*hmap</code>，它是一个指针，而我们之前讲过的 <code>makeslice</code> 函数返回的是 <code>Slice</code> 结构体：</p></blockquote><p>当 map 和 slice 作为函数参数时，在函数参数内部对 map 的操作会影响 map 自身；而对 slice 却不会。</p><p>主要原因：一个是指针（<code>*hmap</code>），一个是结构体（<code>slice</code>）。Go 语言中的函数传参都是值传递，在函数内部，参数会被 copy 到本地。<code>*hmap</code>指针 copy 完之后，仍然指向同一个 map，因此函数内部对 map 的操作会影响实参。而 slice 被 copy 后，会成为一个新的 slice，对它进行的操作不会影响到实参。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>map 的一个关键点在于，哈希函数的选择。在程序启动时，会检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。这是在函数 <code>alginit()</code> 中完成</p><h1 id="如何实现两种get操作"><a href="#如何实现两种get操作" class="headerlink" title="如何实现两种get操作"></a>如何实现两种get操作</h1><p>Go 语言中读取 map 有两种语法：带 comma 和 不带 comma。当要查询的 key 不在 map 里，带 comma 的用法会返回一个 bool 型变量提示 key 是否在 map 中；而不带 comma 的语句则会返回一个 key 对应 value 类型的零值。如果 value 是 int 型就会返回 0，如果 value 是 string 类型，就会返回空字符串。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ageMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">ageMap[<span class="string">&quot;qcrao&quot;</span>] = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不带 comma 用法</span></span><br><span class="line">age1 := ageMap[<span class="string">&quot;stefno&quot;</span>]</span><br><span class="line">fmt.Println(age1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带 comma 用法</span></span><br><span class="line">age2, ok := ageMap[<span class="string">&quot;stefno&quot;</span>]</span><br><span class="line">fmt.Println(age2, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h1 id="map的遍历过程"><a href="#map的遍历过程" class="headerlink" title="map的遍历过程"></a>map的遍历过程</h1><p>map 是无序的数据结构，所以迭代的顺序不一定与添加键-值对的顺序一致。需要注意的是，<strong>在遍历过程中，如果在循环体内修改了 map 的内容</strong>，可能<strong>会导致不确定的行为。如果你需要修改 map 的同时进行遍历，可以考虑先将需要修改的键存储到一个临时的切片中，然后再进行遍历和修改操作。</strong></p><h1 id="map的扩容过程"><a href="#map的扩容过程" class="headerlink" title="map的扩容过程"></a>map的扩容过程</h1><p>map 是一种动态大小的数据结构，<strong>当 map 中的键-值对数量超过当前容量的时候，Go 会自动重新分配更大的内存空间</strong>，并<strong>将现有的键-值对重新哈希到新的内存位置</strong>。扩容过程中，Go 会<strong>创建一个新的内存区域来存储扩容后的 map 数据，并将原有的键-值对重新哈希到新的内存位置</strong>。扩容完成后，原有的内存区域会被释放。</p><h1 id="key为什么是无序的"><a href="#key为什么是无序的" class="headerlink" title="key为什么是无序的"></a>key为什么是无序的</h1><p><strong>map 在扩容后，会发生 key 的搬迁，原来落在同一个 bucket 中的 key，搬迁后，key 的位置发生了重大的变化，有些 key 飞上高枝，有些 key 则原地不动。</strong>这样，<strong>遍历 map 的结果就不可能按原来的顺序了。</strong></p><p>当我们<strong>在遍历 map 时，并不是固定地从 0 号 bucket 开始遍历，每次都是从一个随机值序号的 bucket 开始遍历，</strong>并且是从这个 bucket 的一个随机序号的 cell 开始遍历。这样，即使你是一个写死的 map，仅仅只是遍历它，也不太可能会返回一个固定序列的 key&#x2F;value 对了。</p><h1 id="可以对-map-的元素取地址吗"><a href="#可以对-map-的元素取地址吗" class="headerlink" title="可以对 map 的元素取地址吗"></a>可以对 map 的元素取地址吗</h1><p>无法对 map 的 key 或 value 进行取址</p><p>如果通过其他 hack 的方式，例如 unsafe.Pointer 等获取到了 key 或 value 的地址，也不能长期持有，因为一旦发生扩容，key 和 value 的位置就会改变，之前保存的地址也就失效了。</p><h1 id="如何比较两个-map-相等"><a href="#如何比较两个-map-相等" class="headerlink" title="如何比较两个 map 相等"></a>如何比较两个 map 相等</h1><p>不能直接使用 <code>==</code> 运算符来比较两个 map 是否相等。这是因为 map 是引用类型，即使两个 map 存储的键-值对内容相同，它们的指针地址不同，所以直接使用 <code>==</code> 运算符比较的结果会始终为 false。</p><p>要比较两个 map 是否相等，可以使用以下步骤：</p><ol><li>首先，比较两个 map 的长度（键-值对的数量）。如果长度不相等，可以立即确定两个 map 不相等。</li><li>接下来，逐个比较两个 map 中的键-值对。对于每个键-值对，在第一个 map 中查找对应的值，并进行比较。如果存在不同的键或对应的值不相等，可以确定两个 map 不相等。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapsAreEqual</span><span class="params">(map1, map2 <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 比较长度</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(map1) != <span class="built_in">len</span>(map2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逐个比较键-值对</span></span><br><span class="line">    <span class="keyword">for</span> key, value1 := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">        value2, ok := map2[key]</span><br><span class="line">        <span class="keyword">if</span> !ok || value1 != value2 &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>reflect.DeepEqual(map1,map2)</p></blockquote><p>map 不是线程安全的。</p><h1 id="map是线程安全的吗"><a href="#map是线程安全的吗" class="headerlink" title="map是线程安全的吗"></a>map是线程安全的吗</h1><p>在查找、赋值、遍历、删除的过程中都会检测写标志，一旦发现写标志置位（等于1），则直接 panic。</p>]]></content>
      
      
      <categories>
          
          <category> GO基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GO基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-数组与切片</title>
      <link href="/2021/12/12/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"/>
      <url>/2021/12/12/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="数组和切片的异同"><a href="#数组和切片的异同" class="headerlink" title="数组和切片的异同"></a>数组和切片的异同</h1><p><strong>slice 的底层数据是数组，slice 是对数组的封装</strong>，它描述一个数组的片段。两者都可以通过下标来访问单个元素。</p><p><strong>数组是定长的，长度定义好之后，不能再更改，而切片则非常灵活，它可以动态地扩容。</strong>切片的类型和长度无关。</p><blockquote><p>数组：因为其长度是类型的一部分，限制了它的表达能力，比如 [3]int 和 [4]int 就是不同的类型。</p></blockquote><p><strong>数组就是一片连续的内存， slice 实际上是一个结构体，包含三个字段：长度、容量、底层数组。</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer <span class="comment">// 元素指针</span></span><br><span class="line"><span class="built_in">len</span>   <span class="type">int</span> <span class="comment">// 长度 </span></span><br><span class="line"><span class="built_in">cap</span>   <span class="type">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">s1 := slice[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">s2 := s1[<span class="number">2</span>:<span class="number">6</span>:<span class="number">7</span>]  <span class="comment">//len=4,cap=5</span></span><br><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">100</span>)<span class="comment">//s2容量够，直接追加，会直接影响到s1和slice</span></span><br><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">200</span>)<span class="comment">//s2容量已满，进行扩容，底层数组指针更改，不影响</span></span><br><span class="line">s1[<span class="number">2</span>] = <span class="number">20</span><span class="comment">//影响slice</span></span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Println(s2)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">20</span>]</span><br><span class="line">[<span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">100</span> <span class="number">200</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">20</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">100</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure><h1 id="切片容量的增长"><a href="#切片容量的增长" class="headerlink" title="切片容量的增长"></a>切片容量的增长</h1><p><strong>使用 append 可以向 slice 追加元素，实际上是往底层数组添加元素</strong>。但是<strong>底层数组的长度是固定的</strong>，<strong>如果索引</strong> <code>len-1</code> 所指向的元素<strong>已经是底层数组的最后一个元素，就没法再添加了。</strong></p><p>这时，<strong>slice 会迁移到新的内存位置，新底层数组的长度也会增加，</strong>这样就可以放置新增的元素。同时，为了应对未来可能再次发生的 append 操作，新的底层数组的长度，也就是新 <code>slice</code> 的容量是留了一定的 <code>buffer</code> 的。否则，每次添加元素的时候，都会发生迁移，成本太高。</p><p>在golang1.18版本更新之前网上大多数的文章都是这样描述slice的扩容策略的：</p><blockquote><p>当原 slice 容量小于 <code>1024</code> 的时候，新 slice 容量变成原来的 <code>2</code> 倍；原 slice 容量超过 <code>1024</code>，新 slice 容量变成原来的<code>1.25</code>倍。</p></blockquote><p>在1.18版本更新之后，slice的扩容策略变为了：</p><blockquote><p>当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap &#x3D; oldcap+(oldcap+3*256)&#x2F;4</p></blockquote><p>向一个nil的slice添加元素会发生什么？为什么？</p><p>其实 <code>nil slice</code> 或者 <code>empty slice</code> 都是可以通过调用 append 函数来获得底层数组的扩容。最终都是调用 <code>mallocgc</code> 来向 Go 的内存管理器申请到一块内存，然后再赋给原来的<code>nil slice</code> 或 <code>empty slice</code>，然后摇身一变，成为“真正”的 <code>slice</code> 了。</p><h1 id="切片作为函数参数"><a href="#切片作为函数参数" class="headerlink" title="切片作为函数参数"></a>切片作为函数参数</h1><p>不管传的是 slice 还是 slice 指针，如果改变了 slice 底层数组的数据，会反应到实参 slice 的底层数据</p><blockquote><p>值得注意的是，Go 语言的函数参数传递，只有值传递，没有引用传递。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> GO基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GO基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-原生sql</title>
      <link href="/2021/12/12/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GORM/7-%E5%8E%9F%E7%94%9Fsql/"/>
      <url>/2021/12/12/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GORM/7-%E5%8E%9F%E7%94%9Fsql/</url>
      
        <content type="html"><![CDATA[<h1 id="Sql构建"><a href="#Sql构建" class="headerlink" title="Sql构建"></a>Sql构建</h1><h3 id="执行原生SQL"><a href="#执行原生SQL" class="headerlink" title="执行原生SQL"></a>执行原生SQL</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.Exec(&quot;DROP TABLE users;&quot;)</span><br><span class="line">db.Exec(&quot;UPDATE orders SET shipped_at=? WHERE id IN (?)&quot;, time.Now, []int64&#123;11,22,33&#125;)</span><br><span class="line"></span><br><span class="line">// Scan</span><br><span class="line">type Result struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">    Age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result Result</span><br><span class="line">db.Raw(&quot;SELECT name, age FROM users WHERE name = ?&quot;, 3).Scan(&amp;result)</span><br></pre></td></tr></table></figure><h3 id="sql-Row-sql-Rows"><a href="#sql-Row-sql-Rows" class="headerlink" title="sql.Row &amp; sql.Rows"></a>sql.Row &amp; sql.Rows</h3><p>获取查询结果为<code>*sql.Row</code>或<code>*sql.Rows</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">row := db.Table(&quot;users&quot;).Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).Select(&quot;name, age&quot;).Row() // (*sql.Row)</span><br><span class="line">row.Scan(&amp;name, &amp;age)</span><br><span class="line"></span><br><span class="line">rows, err := db.Model(&amp;User&#123;&#125;).Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).Select(&quot;name, age, email&quot;).Rows() // (*sql.Rows, error)</span><br><span class="line">defer rows.Close()</span><br><span class="line">for rows.Next() &#123;</span><br><span class="line">    ...</span><br><span class="line">    rows.Scan(&amp;name, &amp;age, &amp;email)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Raw SQL</span><br><span class="line">rows, err := db.Raw(&quot;select name, age, email from users where name = ?&quot;, &quot;jinzhu&quot;).Rows() // (*sql.Rows, error)</span><br><span class="line">defer rows.Close()</span><br><span class="line">for rows.Next() &#123;</span><br><span class="line">    ...</span><br><span class="line">    rows.Scan(&amp;name, &amp;age, &amp;email)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代中使用sql-Rows的Scan"><a href="#迭代中使用sql-Rows的Scan" class="headerlink" title="迭代中使用sql.Rows的Scan"></a>迭代中使用sql.Rows的Scan</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rows, err := db.Model(&amp;User&#123;&#125;).Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).Select(&quot;name, age, email&quot;).Rows() // (*sql.Rows, error)</span><br><span class="line">defer rows.Close()</span><br><span class="line"></span><br><span class="line">for rows.Next() &#123;</span><br><span class="line">  var user User</span><br><span class="line">  db.ScanRows(rows, &amp;user)</span><br><span class="line">  // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GORM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GORM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-事务</title>
      <link href="/2021/12/08/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GORM/6-%E4%BA%8B%E5%8A%A1/"/>
      <url>/2021/12/08/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GORM/6-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Gorm事务"><a href="#Gorm事务" class="headerlink" title="Gorm事务"></a>Gorm事务</h1><h3 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h3><p>要在事务中执行一组操作，一般流程如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 开始事务</span><br><span class="line">tx := db.Begin()</span><br><span class="line"></span><br><span class="line">// 在事务中做一些数据库操作（从这一点使用&#x27;tx&#x27;，而不是&#x27;db&#x27;）</span><br><span class="line">tx.Create(...)</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// 发生错误时回滚事务</span><br><span class="line">tx.Rollback()</span><br><span class="line"></span><br><span class="line">// 或提交事务</span><br><span class="line">tx.Commit()</span><br></pre></td></tr></table></figure><p>一个具体的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func CreateAnimals(db *gorm.DB) err &#123;</span><br><span class="line">  tx := db.Begin()</span><br><span class="line">  // 注意，一旦你在一个事务中，使用tx作为数据库句柄</span><br><span class="line"></span><br><span class="line">  if err := tx.Create(&amp;Animal&#123;Name: &quot;Giraffe&quot;&#125;).Error; err != nil &#123;</span><br><span class="line">     tx.Rollback()</span><br><span class="line">     return err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if err := tx.Create(&amp;Animal&#123;Name: &quot;Lion&quot;&#125;).Error; err != nil &#123;</span><br><span class="line">     tx.Rollback()</span><br><span class="line">     return err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tx.Commit()</span><br><span class="line">  return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GORM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GORM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-错误处理</title>
      <link href="/2021/12/07/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GORM/5-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
      <url>/2021/12/07/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GORM/5-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Gorm错误处理"><a href="#Gorm错误处理" class="headerlink" title="Gorm错误处理"></a>Gorm错误处理</h1><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>执行任何操作后，如果发生任何错误，GORM将其设置为<code>*DB</code>的Error字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if err := db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).First(&amp;user).Error; err != nil &#123;</span><br><span class="line">    // 错误处理...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果有多个错误发生，用`GetErrors`获取所有的错误，它返回`[]error`</span><br><span class="line">db.First(&amp;user).Limit(10).Find(&amp;users).GetErrors()</span><br><span class="line"></span><br><span class="line">// 检查是否返回RecordNotFound错误</span><br><span class="line">db.Where(&quot;name = ?&quot;, &quot;hello world&quot;).First(&amp;user).RecordNotFound()</span><br><span class="line"></span><br><span class="line">if db.Model(&amp;user).Related(&amp;credit_card).RecordNotFound() &#123;</span><br><span class="line">    // 没有信用卡被发现处理...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GORM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GORM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-删除</title>
      <link href="/2021/12/06/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GORM/4-%E5%88%A0%E9%99%A4/"/>
      <url>/2021/12/06/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GORM/4-%E5%88%A0%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Gorm删除"><a href="#Gorm删除" class="headerlink" title="Gorm删除"></a>Gorm删除</h1><h3 id="删除-软删除"><a href="#删除-软删除" class="headerlink" title="删除&#x2F;软删除"></a>删除&#x2F;软删除</h3><p>警告删除记录时，需要确保其主要字段具有值，GORM将使用主键删除记录，如果主要字段为空，GORM将删除模型的所有记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 删除存在的记录</span><br><span class="line">db.Delete(&amp;email)</span><br><span class="line">//// DELETE from emails where id=10;</span><br><span class="line"></span><br><span class="line">// 为Delete语句添加额外的SQL选项</span><br><span class="line">db.Set(&quot;gorm:delete_option&quot;, &quot;OPTION (OPTIMIZE FOR UNKNOWN)&quot;).Delete(&amp;email)</span><br><span class="line">//// DELETE from emails where id=10 OPTION (OPTIMIZE FOR UNKNOWN);</span><br></pre></td></tr></table></figure><h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><p>删除所有匹配记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Where(&quot;email LIKE ?&quot;, &quot;%jinzhu%&quot;).Delete(Email&#123;&#125;)</span><br><span class="line">//// DELETE from emails where email LIKE &quot;%jinhu%&quot;;</span><br><span class="line"></span><br><span class="line">db.Delete(Email&#123;&#125;, &quot;email LIKE ?&quot;, &quot;%jinzhu%&quot;)</span><br><span class="line">//// DELETE from emails where email LIKE &quot;%jinhu%&quot;;</span><br></pre></td></tr></table></figure><h3 id="软删除"><a href="#软删除" class="headerlink" title="软删除"></a>软删除</h3><p>如果模型有DeletedAt字段，它将自动获得软删除功能！ 那么在调用Delete时不会从数据库中永久删除，而是只将字段DeletedAt的值设置为当前时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">db.Delete(&amp;user)</span><br><span class="line">//// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE id = 111;</span><br><span class="line"></span><br><span class="line">// 批量删除</span><br><span class="line">db.Where(&quot;age = ?&quot;, 20).Delete(&amp;User&#123;&#125;)</span><br><span class="line">//// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE age = 20;</span><br><span class="line"></span><br><span class="line">// 软删除的记录将在查询时被忽略</span><br><span class="line">db.Where(&quot;age = 20&quot;).Find(&amp;user)</span><br><span class="line">//// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;</span><br><span class="line"></span><br><span class="line">// 使用Unscoped查找软删除的记录</span><br><span class="line">db.Unscoped().Where(&quot;age = 20&quot;).Find(&amp;users)</span><br><span class="line">//// SELECT * FROM users WHERE age = 20;</span><br><span class="line"></span><br><span class="line">// 使用Unscoped永久删除记录</span><br><span class="line">db.Unscoped().Delete(&amp;order)</span><br><span class="line">//// DELETE FROM orders WHERE id=10;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GORM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GORM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-更新</title>
      <link href="/2021/12/03/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GORM/3-%E6%9B%B4%E6%96%B0/"/>
      <url>/2021/12/03/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GORM/3-%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Gorm更新"><a href="#Gorm更新" class="headerlink" title="Gorm更新"></a>Gorm更新</h1><h3 id="更新全部字段"><a href="#更新全部字段" class="headerlink" title="更新全部字段"></a>更新全部字段</h3><p>Save将包括执行更新SQL时的所有字段，即使它没有更改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user)</span><br><span class="line"></span><br><span class="line">user.Name = &quot;jinzhu 2&quot;</span><br><span class="line">user.Age = 100</span><br><span class="line">db.Save(&amp;user)</span><br><span class="line"></span><br><span class="line">//// UPDATE users SET name=&#x27;jinzhu 2&#x27;, age=100, birthday=&#x27;2016-01-01&#x27;, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span><br></pre></td></tr></table></figure><h3 id="更新更改字段"><a href="#更新更改字段" class="headerlink" title="更新更改字段"></a>更新更改字段</h3><p>如果只想更新更改的字段，可以使用Update,Updates</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 更新单个属性（如果更改）</span><br><span class="line">db.Model(&amp;user).Update(&quot;name&quot;, &quot;hello&quot;)</span><br><span class="line">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span><br><span class="line"></span><br><span class="line">// 使用组合条件更新单个属性</span><br><span class="line">db.Model(&amp;user).Where(&quot;active = ?&quot;, true).Update(&quot;name&quot;, &quot;hello&quot;)</span><br><span class="line">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111 AND active=true;</span><br><span class="line"></span><br><span class="line">// 使用`map`更新多个属性，只会更新这些更改的字段</span><br><span class="line">db.Model(&amp;user).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18, &quot;actived&quot;: false&#125;)</span><br><span class="line">//// UPDATE users SET name=&#x27;hello&#x27;, age=18, actived=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span><br><span class="line"></span><br><span class="line">// 使用`struct`更新多个属性，只会更新这些更改的和非空白字段</span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: &quot;hello&quot;, Age: 18&#125;)</span><br><span class="line">//// UPDATE users SET name=&#x27;hello&#x27;, age=18, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id = 111;</span><br><span class="line"></span><br><span class="line">// 警告:当使用struct更新时，FORM将仅更新具有非空值的字段</span><br><span class="line">// 对于下面的更新，什么都不会更新为&quot;&quot;，0，false是其类型的空白值</span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: &quot;&quot;, Age: 0, Actived: false&#125;)</span><br></pre></td></tr></table></figure><h3 id="更新选择的字段"><a href="#更新选择的字段" class="headerlink" title="更新选择的字段"></a>更新选择的字段</h3><p>如果您只想在更新时更新或忽略某些字段，可以使用Select,Omit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Model(&amp;user).Select(&quot;name&quot;).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18, &quot;actived&quot;: false&#125;)</span><br><span class="line">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Omit(&quot;name&quot;).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18, &quot;actived&quot;: false&#125;)</span><br><span class="line">//// UPDATE users SET age=18, actived=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span><br></pre></td></tr></table></figure><h3 id="更新更改字段但不进行Callbacks"><a href="#更新更改字段但不进行Callbacks" class="headerlink" title="更新更改字段但不进行Callbacks"></a>更新更改字段但不进行Callbacks</h3><p>以上更新操作将执行模型的BeforeUpdate,AfterUpdate方法，更新其UpdatedAt时间戳，在更新时保存它的Associations，如果不想调用它们，可以使用UpdateColumn,UpdateColumns</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 更新单个属性，类似于`Update`</span><br><span class="line">db.Model(&amp;user).UpdateColumn(&quot;name&quot;, &quot;hello&quot;)</span><br><span class="line">//// UPDATE users SET name=&#x27;hello&#x27; WHERE id = 111;</span><br><span class="line"></span><br><span class="line">// 更新多个属性，与“更新”类似</span><br><span class="line">db.Model(&amp;user).UpdateColumns(User&#123;Name: &quot;hello&quot;, Age: 18&#125;)</span><br><span class="line">//// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE id = 111;</span><br></pre></td></tr></table></figure><h3 id="Batch-Updates-批量更新"><a href="#Batch-Updates-批量更新" class="headerlink" title="Batch Updates 批量更新"></a>Batch Updates 批量更新</h3><p>Callbacks在批量更新时不会运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.Table(&quot;users&quot;).Where(&quot;id IN (?)&quot;, []int&#123;10, 11&#125;).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18&#125;)</span><br><span class="line">//// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE id IN (10, 11);</span><br><span class="line"></span><br><span class="line">// 使用struct更新仅适用于非零值，或使用map[string]interface&#123;&#125;</span><br><span class="line">db.Model(User&#123;&#125;).Updates(User&#123;Name: &quot;hello&quot;, Age: 18&#125;)</span><br><span class="line">//// UPDATE users SET name=&#x27;hello&#x27;, age=18;</span><br><span class="line"></span><br><span class="line">// 使用`RowsAffected`获取更新记录计数</span><br><span class="line">db.Model(User&#123;&#125;).Updates(User&#123;Name: &quot;hello&quot;, Age: 18&#125;).RowsAffected</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DB.Model(&amp;product).Update(&quot;price&quot;, gorm.Expr(&quot;price * ? + ?&quot;, 2, 100))</span><br><span class="line">//// UPDATE &quot;products&quot; SET &quot;price&quot; = price * &#x27;2&#x27; + &#x27;100&#x27;, &quot;updated_at&quot; = &#x27;2013-11-17 21:34:10&#x27; WHERE &quot;id&quot; = &#x27;2&#x27;;</span><br><span class="line"></span><br><span class="line">DB.Model(&amp;product).Updates(map[string]interface&#123;&#125;&#123;&quot;price&quot;: gorm.Expr(&quot;price * ? + ?&quot;, 2, 100)&#125;)</span><br><span class="line">//// UPDATE &quot;products&quot; SET &quot;price&quot; = price * &#x27;2&#x27; + &#x27;100&#x27;, &quot;updated_at&quot; = &#x27;2013-11-17 21:34:10&#x27; WHERE &quot;id&quot; = &#x27;2&#x27;;</span><br><span class="line"></span><br><span class="line">DB.Model(&amp;product).UpdateColumn(&quot;quantity&quot;, gorm.Expr(&quot;quantity - ?&quot;, 1))</span><br><span class="line">//// UPDATE &quot;products&quot; SET &quot;quantity&quot; = quantity - 1 WHERE &quot;id&quot; = &#x27;2&#x27;;</span><br><span class="line"></span><br><span class="line">DB.Model(&amp;product).Where(&quot;quantity &gt; 1&quot;).UpdateColumn(&quot;quantity&quot;, gorm.Expr(&quot;quantity - ?&quot;, 1))</span><br><span class="line">//// UPDATE &quot;products&quot; SET &quot;quantity&quot; = quantity - 1 WHERE &quot;id&quot; = &#x27;2&#x27; AND quantity &gt; 1;</span><br></pre></td></tr></table></figure><h3 id="在Callbacks中更改更新值"><a href="#在Callbacks中更改更新值" class="headerlink" title="在Callbacks中更改更新值"></a>在Callbacks中更改更新值</h3><p>如果要使用BeforeUpdate,BeforeSave更改回调中的更新值，可以使用scope.SetColumn，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (user *User) BeforeSave(scope *gorm.Scope) (err error) &#123;</span><br><span class="line">  if pw, err := bcrypt.GenerateFromPassword(user.Password, 0); err == nil &#123;</span><br><span class="line">    scope.SetColumn(&quot;EncryptedPassword&quot;, pw)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="额外更新选项"><a href="#额外更新选项" class="headerlink" title="额外更新选项"></a>额外更新选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 为Update语句添加额外的SQL选项</span><br><span class="line">db.Model(&amp;user).Set(&quot;gorm:update_option&quot;, &quot;OPTION (OPTIMIZE FOR UNKNOWN)&quot;).Update(&quot;name, &quot;hello&quot;)</span><br><span class="line">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id=111 OPTION (OPTI</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GORM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GORM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-介绍</title>
      <link href="/2021/11/30/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GORM/1-%E4%BB%8B%E7%BB%8D/"/>
      <url>/2021/11/30/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GORM/1-%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Gorm介绍"><a href="#Gorm介绍" class="headerlink" title="Gorm介绍"></a>Gorm介绍</h1><p>GORM是使用Go语言开发的友好的ORM库。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/jinzhu/gorm</span><br></pre></td></tr></table></figure><p>通用数据库接口sql.DB</p><p>从<code>*gorm.DB</code>连接获取通用数据库接口<code>*sql.DB</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 获取通用数据库对象`*sql.DB`以使用其函数</span><br><span class="line">db.DB()</span><br><span class="line"></span><br><span class="line">// Ping</span><br><span class="line">db.DB().Ping()</span><br></pre></td></tr></table></figure><h3 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserInfo 用户信息</span></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID <span class="type">uint</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Gender <span class="type">string</span></span><br><span class="line">    Hobby <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db, err := gorm.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:root@(127.0.0.1:3306)/db1?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err!= <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动迁移</span></span><br><span class="line">    db.AutoMigrate(&amp;UserInfo&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    u1 := UserInfo&#123;<span class="number">1</span>, <span class="string">&quot;枯藤&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;篮球&quot;</span>&#125;</span><br><span class="line">    u2 := UserInfo&#123;<span class="number">2</span>, <span class="string">&quot;topgoer.com&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="string">&quot;足球&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 创建记录</span></span><br><span class="line">    db.Create(&amp;u1)</span><br><span class="line">    db.Create(&amp;u2)</span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="keyword">var</span> u = <span class="built_in">new</span>(UserInfo)</span><br><span class="line">    db.First(u)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, u)</span><br><span class="line">    <span class="keyword">var</span> uu UserInfo</span><br><span class="line">    db.Find(&amp;uu, <span class="string">&quot;hobby=?&quot;</span>, <span class="string">&quot;足球&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, uu)</span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    db.Model(&amp;u).Update(<span class="string">&quot;hobby&quot;</span>, <span class="string">&quot;双色球&quot;</span>)</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    db.Delete(&amp;u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接比较简单，直接调用 gorm.Open 传入数据库地址即可 github.com&#x2F;jinzhu&#x2F;gorm&#x2F;dialects&#x2F;mysql 是 golang 的 mysql 驱动，实际上就是 github.com&#x2F;go-sql-driver&#x2F;mysql 作者这里为了好记，重新弄了个名字 这里我用的 mysql，实际上支持基本上所有主流的关系数据库，连接方式上略有不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.DB().SetMaxIdleConns(10)</span><br><span class="line">db.DB().SetMaxOpenConns(100)</span><br></pre></td></tr></table></figure><p>还可以使用 db.DB() 对象设置连接池信息</p><h3 id="表定义"><a href="#表定义" class="headerlink" title="表定义"></a>表定义</h3><p>先来定义一个点赞表，这里面一条记录表示某个用户在某个时刻对某篇文章点了一个赞，用 ip + ua 来标识用户，title 标识文章标题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Like struct &#123;</span><br><span class="line">    ID        int    `gorm:&quot;primary_key&quot;`</span><br><span class="line">    Ip        string `gorm:&quot;type:varchar(20);not null;index:ip_idx&quot;`</span><br><span class="line">    Ua        string `gorm:&quot;type:varchar(256);not null;&quot;`</span><br><span class="line">    Title     string `gorm:&quot;type:varchar(128);not null;index:title_idx&quot;`</span><br><span class="line">    Hash      uint64 `gorm:&quot;unique_index:hash_idx;&quot;`</span><br><span class="line">    CreatedAt time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gorm 用 tag 的方式来标识 mysql 里面的约束</p><p>创建索引只需要直接指定列即可，这里创建了两个索引，ip_idx 和 title_idx；如果需要多列组合索引，直接让索引的名字相同即可；如果需要创建唯一索引，指定为 unique_index 即可</p><p>支持时间类型，直接使用 time.Time 即可</p><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if !db.HasTable(&amp;Like&#123;&#125;) &#123;</span><br><span class="line">    if err := db.Set(&quot;gorm:table_options&quot;, &quot;ENGINE=InnoDB DEFAULT CHARSET=utf8&quot;).CreateTable(&amp;Like&#123;&#125;).Error; err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接通过 db.CreateTable 就可以创建表了，非常方便，还可以通过 db.Set 设置一些额外的表属性</p><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.DB().SetMaxIdleConns(10)</span><br><span class="line">db.DB().SetMaxOpenConns(100)</span><br></pre></td></tr></table></figure><h3 id="复合主键"><a href="#复合主键" class="headerlink" title="复合主键"></a>复合主键</h3><p>将多个字段设置为主键以启用复合主键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Product struct &#123;</span><br><span class="line">    ID           string `gorm:&quot;primary_key&quot;`</span><br><span class="line">    LanguageCode string `gorm:&quot;primary_key&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>Gorm有内置的日志记录器支持，默认情况下，它会打印发生的错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 启用Logger，显示详细日志</span><br><span class="line">db.LogMode(true)</span><br><span class="line"></span><br><span class="line">// 禁用日志记录器，不显示任何日志</span><br><span class="line">db.LogMode(false)</span><br><span class="line"></span><br><span class="line">// 调试单个操作，显示此操作的详细日志</span><br><span class="line">db.Debug().Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).First(&amp;User&#123;&#125;)</span><br></pre></td></tr></table></figure><h3 id="自定义日志"><a href="#自定义日志" class="headerlink" title="自定义日志"></a>自定义日志</h3><p>参考GORM的默认记录器如何自定义它<a href="https://github.com/jinzhu/gorm/blob/master/logger.go">https://github.com/jinzhu/gorm/blob/master/logger.go</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.SetLogger(gorm.Logger&#123;revel.TRACE&#125;)</span><br><span class="line">db.SetLogger(log.New(os.Stdout, &quot;\r\n&quot;, 0))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GORM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GORM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-查询</title>
      <link href="/2021/11/30/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GORM/2-%E6%9F%A5%E8%AF%A2/"/>
      <url>/2021/11/30/Go%E7%9F%A5%E8%AF%86%E7%82%B9/GORM/2-%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Gorm查询"><a href="#Gorm查询" class="headerlink" title="Gorm查询"></a>Gorm查询</h1><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 获取第一条记录，按主键排序</span><br><span class="line">db.First(&amp;user)</span><br><span class="line">//// SELECT * FROM users ORDER BY id LIMIT 1;</span><br><span class="line"></span><br><span class="line">// 获取最后一条记录，按主键排序</span><br><span class="line">db.Last(&amp;user)</span><br><span class="line">//// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span><br><span class="line"></span><br><span class="line">// 获取所有记录</span><br><span class="line">db.Find(&amp;users)</span><br><span class="line">//// SELECT * FROM users;</span><br><span class="line"></span><br><span class="line">// 使用主键获取记录</span><br><span class="line">db.First(&amp;user, 10)</span><br><span class="line">//// SELECT * FROM users WHERE id = 10;</span><br></pre></td></tr></table></figure><h3 id="Where查询条件-简单SQL"><a href="#Where查询条件-简单SQL" class="headerlink" title="Where查询条件 (简单SQL)"></a>Where查询条件 (简单SQL)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 获取第一个匹配记录</span><br><span class="line">db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).First(&amp;user)</span><br><span class="line">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; limit 1;</span><br><span class="line"></span><br><span class="line">// 获取所有匹配记录</span><br><span class="line">db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).Find(&amp;users)</span><br><span class="line">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27;;</span><br><span class="line"></span><br><span class="line">db.Where(&quot;name &lt;&gt; ?&quot;, &quot;jinzhu&quot;).Find(&amp;users)</span><br><span class="line"></span><br><span class="line">// IN</span><br><span class="line">db.Where(&quot;name in (?)&quot;, []string&#123;&quot;jinzhu&quot;, &quot;jinzhu 2&quot;&#125;).Find(&amp;users)</span><br><span class="line"></span><br><span class="line">// LIKE</span><br><span class="line">db.Where(&quot;name LIKE ?&quot;, &quot;%jin%&quot;).Find(&amp;users)</span><br><span class="line"></span><br><span class="line">// AND</span><br><span class="line">db.Where(&quot;name = ? AND age &gt;= ?&quot;, &quot;jinzhu&quot;, &quot;22&quot;).Find(&amp;users)</span><br><span class="line"></span><br><span class="line">// Time</span><br><span class="line">db.Where(&quot;updated_at &gt; ?&quot;, lastWeek).Find(&amp;users)</span><br><span class="line"></span><br><span class="line">db.Where(&quot;created_at BETWEEN ? AND ?&quot;, lastWeek, today).Find(&amp;users)</span><br></pre></td></tr></table></figure><h3 id="Where查询条件-Struct-Map"><a href="#Where查询条件-Struct-Map" class="headerlink" title="Where查询条件 (Struct &amp; Map)"></a>Where查询条件 (Struct &amp; Map)</h3><p>注意：当使用struct查询时，GORM将只查询那些具有值的字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Struct</span><br><span class="line">db.Where(&amp;User&#123;Name: &quot;jinzhu&quot;, Age: 20&#125;).First(&amp;user)</span><br><span class="line">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20 LIMIT 1;</span><br><span class="line"></span><br><span class="line">// Map</span><br><span class="line">db.Where(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;jinzhu&quot;, &quot;age&quot;: 20&#125;).Find(&amp;users)</span><br><span class="line">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20;</span><br><span class="line"></span><br><span class="line">// 主键的Slice</span><br><span class="line">db.Where([]int64&#123;20, 21, 22&#125;).Find(&amp;users)</span><br><span class="line">//// SELECT * FROM users WHERE id IN (20, 21, 22);</span><br></pre></td></tr></table></figure><h3 id="Not条件查询"><a href="#Not条件查询" class="headerlink" title="Not条件查询"></a>Not条件查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">db.Not(&quot;name&quot;, &quot;jinzhu&quot;).First(&amp;user)</span><br><span class="line">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; LIMIT 1;</span><br><span class="line"></span><br><span class="line">// Not In</span><br><span class="line">db.Not(&quot;name&quot;, []string&#123;&quot;jinzhu&quot;, &quot;jinzhu 2&quot;&#125;).Find(&amp;users)</span><br><span class="line">//// SELECT * FROM users WHERE name NOT IN (&quot;jinzhu&quot;, &quot;jinzhu 2&quot;);</span><br><span class="line"></span><br><span class="line">// Not In slice of primary keys</span><br><span class="line">db.Not([]int64&#123;1,2,3&#125;).First(&amp;user)</span><br><span class="line">//// SELECT * FROM users WHERE id NOT IN (1,2,3);</span><br><span class="line"></span><br><span class="line">db.Not([]int64&#123;&#125;).First(&amp;user)</span><br><span class="line">//// SELECT * FROM users;</span><br><span class="line"></span><br><span class="line">// Plain SQL</span><br><span class="line">db.Not(&quot;name = ?&quot;, &quot;jinzhu&quot;).First(&amp;user)</span><br><span class="line">//// SELECT * FROM users WHERE NOT(name = &quot;jinzhu&quot;);</span><br><span class="line"></span><br><span class="line">// Struct</span><br><span class="line">db.Not(User&#123;Name: &quot;jinzhu&quot;&#125;).First(&amp;user)</span><br><span class="line">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot;;</span><br></pre></td></tr></table></figure><h3 id="带内联条件的查询"><a href="#带内联条件的查询" class="headerlink" title="带内联条件的查询"></a>带内联条件的查询</h3><p>注意：使用主键查询时，应仔细检查所传递的值是否为有效主键，以避免SQL注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 按主键获取</span><br><span class="line">db.First(&amp;user, 23)</span><br><span class="line">//// SELECT * FROM users WHERE id = 23 LIMIT 1;</span><br><span class="line"></span><br><span class="line">// 简单SQL</span><br><span class="line">db.Find(&amp;user, &quot;name = ?&quot;, &quot;jinzhu&quot;)</span><br><span class="line">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot;;</span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, &quot;name &lt;&gt; ? AND age &gt; ?&quot;, &quot;jinzhu&quot;, 20)</span><br><span class="line">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; AND age &gt; 20;</span><br><span class="line"></span><br><span class="line">// Struct</span><br><span class="line">db.Find(&amp;users, User&#123;Age: 20&#125;)</span><br><span class="line">//// SELECT * FROM users WHERE age = 20;</span><br><span class="line"></span><br><span class="line">// Map</span><br><span class="line">db.Find(&amp;users, map[string]interface&#123;&#125;&#123;&quot;age&quot;: 20&#125;)</span><br><span class="line">//// SELECT * FROM users WHERE age = 20;</span><br></pre></td></tr></table></figure><h3 id="Or条件查询"><a href="#Or条件查询" class="headerlink" title="Or条件查询"></a>Or条件查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.Where(&quot;role = ?&quot;, &quot;admin&quot;).Or(&quot;role = ?&quot;, &quot;super_admin&quot;).Find(&amp;users)</span><br><span class="line">//// SELECT * FROM users WHERE role = &#x27;admin&#x27; OR role = &#x27;super_admin&#x27;;</span><br><span class="line"></span><br><span class="line">// Struct</span><br><span class="line">db.Where(&quot;name = &#x27;jinzhu&#x27;&quot;).Or(User&#123;Name: &quot;jinzhu 2&quot;&#125;).Find(&amp;users)</span><br><span class="line">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;;</span><br><span class="line"></span><br><span class="line">// Map</span><br><span class="line">db.Where(&quot;name = &#x27;jinzhu&#x27;&quot;).Or(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;jinzhu 2&quot;&#125;).Find(&amp;users)</span><br></pre></td></tr></table></figure><h3 id="查询链"><a href="#查询链" class="headerlink" title="查询链"></a>查询链</h3><p>Gorm有一个可链接的API，你可以这样使用它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.Where(&quot;name &lt;&gt; ?&quot;,&quot;jinzhu&quot;).Where(&quot;age &gt;= ? and role &lt;&gt; ?&quot;,20,&quot;admin&quot;).Find(&amp;users)</span><br><span class="line">//// SELECT * FROM users WHERE name &lt;&gt; &#x27;jinzhu&#x27; AND age &gt;= 20 AND role &lt;&gt; &#x27;admin&#x27;;</span><br><span class="line"></span><br><span class="line">db.Where(&quot;role = ?&quot;, &quot;admin&quot;).Or(&quot;role = ?&quot;, &quot;super_admin&quot;).Not(&quot;name = ?&quot;, &quot;jinzhu&quot;).Find(&amp;users)</span><br></pre></td></tr></table></figure><h3 id="扩展查询选项"><a href="#扩展查询选项" class="headerlink" title="扩展查询选项"></a>扩展查询选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 为Select语句添加扩展SQL选项</span><br><span class="line">db.Set(&quot;gorm:query_option&quot;, &quot;FOR UPDATE&quot;).First(&amp;user, 10)</span><br><span class="line">//// SELECT * FROM users WHERE id = 10 FOR UPDATE;</span><br></pre></td></tr></table></figure><h3 id="FirstOrInit"><a href="#FirstOrInit" class="headerlink" title="FirstOrInit"></a>FirstOrInit</h3><p>获取第一个匹配的记录，或者使用给定的条件初始化一个新的记录（仅适用于struct，map条件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Unfound</span><br><span class="line">db.FirstOrInit(&amp;user, User&#123;Name: &quot;non_existing&quot;&#125;)</span><br><span class="line">//// user -&gt; User&#123;Name: &quot;non_existing&quot;&#125;</span><br><span class="line"></span><br><span class="line">// Found</span><br><span class="line">db.Where(User&#123;Name: &quot;Jinzhu&quot;&#125;).FirstOrInit(&amp;user)</span><br><span class="line">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 20&#125;</span><br><span class="line">db.FirstOrInit(&amp;user, map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;jinzhu&quot;&#125;)</span><br><span class="line">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 20&#125;</span><br></pre></td></tr></table></figure><h3 id="Attrs"><a href="#Attrs" class="headerlink" title="Attrs"></a>Attrs</h3><p>如果未找到记录，则使用参数初始化结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Unfound</span><br><span class="line">db.Where(User&#123;Name: &quot;non_existing&quot;&#125;).Attrs(User&#123;Age: 20&#125;).FirstOrInit(&amp;user)</span><br><span class="line">//// SELECT * FROM USERS WHERE name = &#x27;non_existing&#x27;;</span><br><span class="line">//// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span><br><span class="line"></span><br><span class="line">db.Where(User&#123;Name: &quot;non_existing&quot;&#125;).Attrs(&quot;age&quot;, 20).FirstOrInit(&amp;user)</span><br><span class="line">//// SELECT * FROM USERS WHERE name = &#x27;non_existing&#x27;;</span><br><span class="line">//// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span><br><span class="line"></span><br><span class="line">// Found</span><br><span class="line">db.Where(User&#123;Name: &quot;Jinzhu&quot;&#125;).Attrs(User&#123;Age: 30&#125;).FirstOrInit(&amp;user)</span><br><span class="line">//// SELECT * FROM USERS WHERE name = jinzhu&#x27;;</span><br><span class="line">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 20&#125;</span><br></pre></td></tr></table></figure><h3 id="Assign"><a href="#Assign" class="headerlink" title="Assign"></a>Assign</h3><p>将参数分配给结果，不管它是否被找到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.Where(User&#123;Name: &quot;non_existing&quot;&#125;).Assign(User&#123;Age: 20&#125;).FirstOrInit(&amp;user)</span><br><span class="line">//// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span><br><span class="line"></span><br><span class="line">// Found</span><br><span class="line">db.Where(User&#123;Name: &quot;Jinzhu&quot;&#125;).Assign(User&#123;Age: 30&#125;).FirstOrInit(&amp;user)</span><br><span class="line">//// SELECT * FROM USERS WHERE name = jinzhu&#x27;;</span><br><span class="line">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 30&#125;</span><br></pre></td></tr></table></figure><h3 id="FirstOrCreate"><a href="#FirstOrCreate" class="headerlink" title="FirstOrCreate"></a>FirstOrCreate</h3><p>获取第一个匹配的记录，或创建一个具有给定条件的新记录（仅适用于struct, map条件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Unfound</span><br><span class="line">db.FirstOrCreate(&amp;user, User&#123;Name: &quot;non_existing&quot;&#125;)</span><br><span class="line">//// INSERT INTO &quot;users&quot; (name) VALUES (&quot;non_existing&quot;);</span><br><span class="line">//// user -&gt; User&#123;Id: 112, Name: &quot;non_existing&quot;&#125;</span><br><span class="line"></span><br><span class="line">// Found</span><br><span class="line">db.Where(User&#123;Name: &quot;Jinzhu&quot;&#125;).FirstOrCreate(&amp;user)</span><br><span class="line">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="Attrs-1"><a href="#Attrs-1" class="headerlink" title="Attrs"></a>Attrs</h3><p>如果未找到记录，则为参数分配结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Unfound</span><br><span class="line">db.Where(User&#123;Name: &quot;non_existing&quot;&#125;).Attrs(User&#123;Age: 20&#125;).FirstOrCreate(&amp;user)</span><br><span class="line">//// SELECT * FROM users WHERE name = &#x27;non_existing&#x27;;</span><br><span class="line">//// INSERT INTO &quot;users&quot; (name, age) VALUES (&quot;non_existing&quot;, 20);</span><br><span class="line">//// user -&gt; User&#123;Id: 112, Name: &quot;non_existing&quot;, Age: 20&#125;</span><br><span class="line"></span><br><span class="line">// Found</span><br><span class="line">db.Where(User&#123;Name: &quot;jinzhu&quot;&#125;).Attrs(User&#123;Age: 30&#125;).FirstOrCreate(&amp;user)</span><br><span class="line">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27;;</span><br><span class="line">//// user -&gt; User&#123;Id: 111, Name: &quot;jinzhu&quot;, Age: 20&#125;</span><br></pre></td></tr></table></figure><h3 id="Assign-1"><a href="#Assign-1" class="headerlink" title="Assign"></a>Assign</h3><p>将其分配给记录，而不管它是否被找到，并保存回数据库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Unfound</span><br><span class="line">db.Where(User&#123;Name: &quot;non_existing&quot;&#125;).Assign(User&#123;Age: 20&#125;).FirstOrCreate(&amp;user)</span><br><span class="line">//// SELECT * FROM users WHERE name = &#x27;non_existing&#x27;;</span><br><span class="line">//// INSERT INTO &quot;users&quot; (name, age) VALUES (&quot;non_existing&quot;, 20);</span><br><span class="line">//// user -&gt; User&#123;Id: 112, Name: &quot;non_existing&quot;, Age: 20&#125;</span><br><span class="line"></span><br><span class="line">// Found</span><br><span class="line">db.Where(User&#123;Name: &quot;jinzhu&quot;&#125;).Assign(User&#123;Age: 30&#125;).FirstOrCreate(&amp;user)</span><br><span class="line">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27;;</span><br><span class="line">//// UPDATE users SET age=30 WHERE id = 111;</span><br><span class="line">//// user -&gt; User&#123;Id: 111, Name: &quot;jinzhu&quot;, Age: 30&#125;</span><br></pre></td></tr></table></figure><h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p>指定要从数据库检索的字段，默认情况下，将选择所有字段;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.Select(&quot;name, age&quot;).Find(&amp;users)</span><br><span class="line">//// SELECT name, age FROM users;</span><br><span class="line"></span><br><span class="line">db.Select([]string&#123;&quot;name&quot;, &quot;age&quot;&#125;).Find(&amp;users)</span><br><span class="line">//// SELECT name, age FROM users;</span><br><span class="line"></span><br><span class="line">db.Table(&quot;users&quot;).Select(&quot;COALESCE(age,?)&quot;, 42).Rows()</span><br><span class="line">//// SELECT COALESCE(age,&#x27;42&#x27;) FROM users;</span><br></pre></td></tr></table></figure><h3 id="Order"><a href="#Order" class="headerlink" title="Order"></a>Order</h3><p>在从数据库检索记录时指定顺序，将重排序设置为true以覆盖定义的条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.Order(&quot;age desc, name&quot;).Find(&amp;users)</span><br><span class="line">//// SELECT * FROM users ORDER BY age desc, name;</span><br><span class="line"></span><br><span class="line">// Multiple orders</span><br><span class="line">db.Order(&quot;age desc&quot;).Order(&quot;name&quot;).Find(&amp;users)</span><br><span class="line">//// SELECT * FROM users ORDER BY age desc, name;</span><br><span class="line"></span><br><span class="line">// ReOrder</span><br><span class="line">db.Order(&quot;age desc&quot;).Find(&amp;users1).Order(&quot;age&quot;, true).Find(&amp;users2)</span><br><span class="line">//// SELECT * FROM users ORDER BY age desc; (users1)</span><br><span class="line">//// SELECT * FROM users ORDER BY age; (users2)</span><br></pre></td></tr></table></figure><h3 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h3><p>指定要检索的记录数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.Limit(3).Find(&amp;users)</span><br><span class="line">//// SELECT * FROM users LIMIT 3;</span><br><span class="line"></span><br><span class="line">// Cancel limit condition with -1</span><br><span class="line">db.Limit(10).Find(&amp;users1).Limit(-1).Find(&amp;users2)</span><br><span class="line">//// SELECT * FROM users LIMIT 10; (users1)</span><br><span class="line">//// SELECT * FROM users; (users2)</span><br></pre></td></tr></table></figure><h3 id="Offset"><a href="#Offset" class="headerlink" title="Offset"></a>Offset</h3><p>指定在开始返回记录之前要跳过的记录数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.Offset(3).Find(&amp;users)</span><br><span class="line">//// SELECT * FROM users OFFSET 3;</span><br><span class="line"></span><br><span class="line">// Cancel offset condition with -1</span><br><span class="line">db.Offset(10).Find(&amp;users1).Offset(-1).Find(&amp;users2)</span><br><span class="line">//// SELECT * FROM users OFFSET 10; (users1)</span><br><span class="line">//// SELECT * FROM users; (users2)</span><br></pre></td></tr></table></figure><h3 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h3><p>获取模型的记录数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).Or(&quot;name = ?&quot;, &quot;jinzhu 2&quot;).Find(&amp;users).Count(&amp;count)</span><br><span class="line">//// SELECT * from USERS WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;; (users)</span><br><span class="line">//// SELECT count(*) FROM users WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;; (count)</span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).Count(&amp;count)</span><br><span class="line">//// SELECT count(*) FROM users WHERE name = &#x27;jinzhu&#x27;; (count)</span><br><span class="line"></span><br><span class="line">db.Table(&quot;deleted_users&quot;).Count(&amp;count)</span><br><span class="line">//// SELECT count(*) FROM deleted_users;</span><br></pre></td></tr></table></figure><h3 id="Group-Having"><a href="#Group-Having" class="headerlink" title="Group &amp; Having"></a>Group &amp; Having</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rows, err := db.Table(&quot;orders&quot;).Select(&quot;date(created_at) as date, sum(amount) as total&quot;).Group(&quot;date(created_at)&quot;).Rows()</span><br><span class="line">for rows.Next() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rows, err := db.Table(&quot;orders&quot;).Select(&quot;date(created_at) as date, sum(amount) as total&quot;).Group(&quot;date(created_at)&quot;).Having(&quot;sum(amount) &gt; ?&quot;, 100).Rows()</span><br><span class="line">for rows.Next() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Result struct &#123;</span><br><span class="line">    Date  time.Time</span><br><span class="line">    Total int64</span><br><span class="line">&#125;</span><br><span class="line">db.Table(&quot;orders&quot;).Select(&quot;date(created_at) as date, sum(amount) as total&quot;).Group(&quot;date(created_at)&quot;).Having(&quot;sum(amount) &gt; ?&quot;, 100).Scan(&amp;results)</span><br></pre></td></tr></table></figure><h3 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h3><p>指定连接条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rows, err := db.Table(&quot;users&quot;).Select(&quot;users.name, emails.email&quot;).Joins(&quot;left join emails on emails.user_id = users.id&quot;).Rows()</span><br><span class="line">for rows.Next() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Table(&quot;users&quot;).Select(&quot;users.name, emails.email&quot;).Joins(&quot;left join emails on emails.user_id = users.id&quot;).Scan(&amp;results)</span><br><span class="line"></span><br><span class="line">// 多个连接与参数</span><br><span class="line">db.Joins(&quot;JOIN emails ON emails.user_id = users.id AND emails.email = ?&quot;, &quot;jinzhu@example.org&quot;).Joins(&quot;JOIN credit_cards ON credit_cards.user_id = users.id&quot;).Where(&quot;credit_cards.number = ?&quot;, &quot;411111111111&quot;).Find(&amp;user)</span><br></pre></td></tr></table></figure><h3 id="Pluck"><a href="#Pluck" class="headerlink" title="Pluck"></a>Pluck</h3><p>将模型中的单个列作为地图查询，如果要查询多个列，可以使用Scan</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var ages []int64</span><br><span class="line">db.Find(&amp;users).Pluck(&quot;age&quot;, &amp;ages)</span><br><span class="line"></span><br><span class="line">var names []string</span><br><span class="line">db.Model(&amp;User&#123;&#125;).Pluck(&quot;name&quot;, &amp;names)</span><br><span class="line"></span><br><span class="line">db.Table(&quot;deleted_users&quot;).Pluck(&quot;name&quot;, &amp;names)</span><br><span class="line"></span><br><span class="line">// 要返回多个列，做这样：</span><br><span class="line">db.Select(&quot;name, age&quot;).Find(&amp;users)</span><br></pre></td></tr></table></figure><h3 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h3><p>将结果扫描到另一个结构中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Result struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">    Age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result Result</span><br><span class="line">db.Table(&quot;users&quot;).Select(&quot;name, age&quot;).Where(&quot;name = ?&quot;, 3).Scan(&amp;result)</span><br><span class="line"></span><br><span class="line">// Raw SQL</span><br><span class="line">db.Raw(&quot;SELECT name, age FROM users WHERE name = ?&quot;, 3).Scan(&amp;result)</span><br></pre></td></tr></table></figure><h3 id="Scopes"><a href="#Scopes" class="headerlink" title="Scopes"></a>Scopes</h3><p>将当前数据库连接传递到<code>func(*DB) *DB</code>，可以用于动态添加条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func AmountGreaterThan1000(db *gorm.DB) *gorm.DB &#123;</span><br><span class="line">    return db.Where(&quot;amount &gt; ?&quot;, 1000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func PaidWithCreditCard(db *gorm.DB) *gorm.DB &#123;</span><br><span class="line">    return db.Where(&quot;pay_mode_sign = ?&quot;, &quot;C&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func PaidWithCod(db *gorm.DB) *gorm.DB &#123;</span><br><span class="line">    return db.Where(&quot;pay_mode_sign = ?&quot;, &quot;C&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func OrderStatus(status []string) func (db *gorm.DB) *gorm.DB &#123;</span><br><span class="line">    return func (db *gorm.DB) *gorm.DB &#123;</span><br><span class="line">        return db.Scopes(AmountGreaterThan1000).Where(&quot;status in (?)&quot;, status)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Scopes(AmountGreaterThan1000, PaidWithCreditCard).Find(&amp;orders)</span><br><span class="line">// 查找所有信用卡订单和金额大于1000</span><br><span class="line"></span><br><span class="line">db.Scopes(AmountGreaterThan1000, PaidWithCod).Find(&amp;orders)</span><br><span class="line">// 查找所有COD订单和金额大于1000</span><br><span class="line"></span><br><span class="line">db.Scopes(OrderStatus([]string&#123;&quot;paid&quot;, &quot;shipped&quot;&#125;)).Find(&amp;orders)</span><br><span class="line">// 查找所有付费，发货订单</span><br></pre></td></tr></table></figure><h3 id="指定表名"><a href="#指定表名" class="headerlink" title="指定表名"></a>指定表名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用User结构定义创建`deleted_users`表</span><br><span class="line">db.Table(&quot;deleted_users&quot;).CreateTable(&amp;User&#123;&#125;)</span><br><span class="line"></span><br><span class="line">var deleted_users []User</span><br><span class="line">db.Table(&quot;deleted_users&quot;).Find(&amp;deleted_users)</span><br><span class="line">//// SELECT * FROM deleted_users;</span><br><span class="line"></span><br><span class="line">db.Table(&quot;deleted_users&quot;).Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).Delete()</span><br><span class="line">//// DELETE FROM deleted_users WHERE name = &#x27;jinzhu&#x27;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GORM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go知识点 </tag>
            
            <tag> GORM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07-信息 Informational</title>
      <link href="/2021/11/29/EIP%E7%AC%94%E8%AE%B0/07-%E4%BF%A1%E6%81%AF%20Informational/"/>
      <url>/2021/11/29/EIP%E7%AC%94%E8%AE%B0/07-%E4%BF%A1%E6%81%AF%20Informational/</url>
      
        <content type="html"><![CDATA[<h1 id="Informational-信息"><a href="#Informational-信息" class="headerlink" title="Informational 信息"></a>Informational 信息</h1><h2 id="活的"><a href="#活的" class="headerlink" title="活的"></a>活的</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5069">5069</a></td><td>EIP编辑手册</td></tr></tbody></table><h2 id="最终的"><a href="#最终的" class="headerlink" title="最终的"></a>最终的</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2228">2228</a></td><td>规范化网络 ID 1 和链 ID 1 的名称</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2982">2982</a></td><td>宁静阶段 0</td></tr></tbody></table><h2 id="审查"><a href="#审查" class="headerlink" title="审查"></a>审查</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6953">6953</a></td><td>网络升级激活触发器</td></tr></tbody></table><h2 id="停滞不前"><a href="#停滞不前" class="headerlink" title="停滞不前"></a>停滞不前</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1470">1470</a></td><td>智能合约弱点分类（SWC）</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2069">2069</a></td><td>在 ERC&#x2F;EIP 中使用 YAML ABI 的建议</td></tr></tbody></table><h2 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2458">2458</a></td><td>更新和更新者标题</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> EIP笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EIP笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06-元 Meta</title>
      <link href="/2021/11/25/EIP%E7%AC%94%E8%AE%B0/06-%E5%85%83%20Meta/"/>
      <url>/2021/11/25/EIP%E7%AC%94%E8%AE%B0/06-%E5%85%83%20Meta/</url>
      
        <content type="html"><![CDATA[<h1 id="Meta-元"><a href="#Meta-元" class="headerlink" title="Meta 元"></a>Meta 元</h1><h2 id="活的"><a href="#活的" class="headerlink" title="活的"></a>活的</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1">1</a></td><td>生态产业园的目的和指导方针</td></tr></tbody></table><h2 id="最终的"><a href="#最终的" class="headerlink" title="最终的"></a>最终的</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4">4</a></td><td>生态工业园区分类</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-606">606</a></td><td>硬分叉元：Homestead</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-607">607</a></td><td>硬分叉元：伪龙</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-608">608</a></td><td>硬分叉元：橘子口哨</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-609">609</a></td><td>硬分叉元：拜占庭</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-779">779</a></td><td>硬分叉元：DAO 分叉</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1013">1013</a></td><td>硬分叉元：君士坦丁堡</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1679">1679</a></td><td>硬分叉元：伊斯坦布尔</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1716">1716</a></td><td>硬分叉元：彼得斯堡</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2387">2387</a></td><td>硬分叉元：缪尔冰川</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5757">5757</a></td><td>批准外部资源的流程</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6049">6049</a></td><td>弃用自毁</td></tr></tbody></table><h2 id="审查"><a href="#审查" class="headerlink" title="审查"></a>审查</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7329">7329</a></td><td>ERC&#x2F;EIP 存储库拆分</td></tr></tbody></table><h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7199">7199</a></td><td>短绒范围</td></tr></tbody></table><h2 id="停滞不前"><a href="#停滞不前" class="headerlink" title="停滞不前"></a>停滞不前</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-233">233</a></td><td>硬分叉正式流程</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-867">867</a></td><td>标准化以太坊恢复提案</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1588">1588</a></td><td>硬分叉元：以太坊 ProgPoW</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1872">1872</a></td><td>以太坊网络升级窗口</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2070">2070</a></td><td>硬分叉元：柏林</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2378">2378</a></td><td>符合纳入资格的生态工业园区</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2657">2657</a></td><td>临时测试网 Yolo</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> EIP笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EIP笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05-ERC</title>
      <link href="/2021/11/21/EIP%E7%AC%94%E8%AE%B0/05-ERC/"/>
      <url>/2021/11/21/EIP%E7%AC%94%E8%AE%B0/05-ERC/</url>
      
        <content type="html"><![CDATA[<h1 id="ERC"><a href="#ERC" class="headerlink" title="ERC"></a>ERC</h1><h2 id="最终的"><a href="#最终的" class="headerlink" title="最终的"></a>最终的</h2><table><thead><tr><th>数字</th><th>标题</th><th>内容</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-20">20</a></td><td>代币标准</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-55">55</a></td><td>混合大小写校验和地址编码</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-137">137</a></td><td>以太坊域名服务 - 规范</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-162">162</a></td><td>初始 ENS 哈希注册器</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-165">165</a></td><td>标准接口检测</td><td>查询合约是否支持某个接口</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-173">173</a></td><td>合同所有权标准</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-181">181</a></td><td>ENS 支持以太坊地址反向解析</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-190">190</a></td><td>以太坊智能合约封装标准</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-191">191</a></td><td>签名数据标准</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-600">600</a></td><td>确定性钱包的以太坊用途分配</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-601">601</a></td><td>确定性钱包的以太坊层次结构</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-681">681</a></td><td>交易请求的 URL 格式</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-721">721</a></td><td>不可替代代币标准</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-777">777</a></td><td>代币标准</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-820">820</a></td><td>伪内省注册合约</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1046">1046</a></td><td>tokenURI 互操作性</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1155">1155</a></td><td>多代币标准</td><td>结合了ERC20和ERC721，既可以发行同质化也可以发行非同质化代币，可以批量转移代币资产</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1167">1167</a></td><td>最小代理合同</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1271">1271</a></td><td>合同的标准签名验证方法</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1363">1363</a></td><td>应付代币</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1820">1820</a></td><td>伪内省注册合约</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1967">1967</a></td><td>代理存储插槽</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2098">2098</a></td><td>紧凑的签名表示</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2135">2135</a></td><td>消费接口（门票等）</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2309">2309</a></td><td>ERC-721连续传输扩展</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2535">2535</a></td><td>钻石，多方面代理</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2612">2612</a></td><td>EIP-20 签名批准的许可延期</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2678">2678</a></td><td>修订后的以太坊智能合约打包标准（EthPM v3）</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2771">2771</a></td><td>本机元交易的安全协议</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2981">2981</a></td><td>NFT 版税标准</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3156">3156</a></td><td>闪电贷</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3448">3448</a></td><td>元代理标准</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3475">3475</a></td><td>抽象存储债券</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3525">3525</a></td><td>半同质代币</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3668">3668</a></td><td>CCIP Read：安全的链下数据检索</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4400">4400</a></td><td>EIP-721 消耗品扩展</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4519">4519</a></td><td>与实物资产挂钩的不可替代代币</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4626">4626</a></td><td>代币化金库</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4804">4804</a></td><td>Web3 URL 到 EVM 呼叫消息翻译</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4834">4834</a></td><td>层次结构域</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4906">4906</a></td><td>EIP-721 元数据更新扩展</td><td>将<code>MetadataUpdate</code>事件添加到 EIP-721 令牌</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4907">4907</a></td><td>租赁 NFT，EIP-721 的扩展</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4910">4910</a></td><td>特许权使用费 NFT</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4955">4955</a></td><td>NFT 的供应商元数据扩展</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5006">5006</a></td><td>租赁NFT、NFT用户扩展</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5007">5007</a></td><td>时间 NFT、ERC-721 时间扩展</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5023">5023</a></td><td>可共享的不可替代代币</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5169">5169</a></td><td>令牌合约的客户端脚本 URI</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5192">5192</a></td><td>最小的 Soulbound NFT</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5202">5202</a></td><td>蓝图合同格式</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5219">5219</a></td><td>合同资源请求</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5267">5267</a></td><td>检索 EIP-712 域</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5313">5313</a></td><td>轻型合同所有权</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5375">5375</a></td><td>NFT 作者信息和同意</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5380">5380</a></td><td>ERC-721 权利扩展</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5484">5484</a></td><td>共识灵魂绑定代币</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5489">5489</a></td><td>NFT 超链接扩展</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5507">5507</a></td><td>可退还代币</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5528">5528</a></td><td>可退款的同质代币</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5570">5570</a></td><td>数字收据不可替代代币</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5606">5606</a></td><td>多元宇宙 NFT</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5615">5615</a></td><td>ERC-1155 供应扩展</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5646">5646</a></td><td>令牌状态指纹</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5679">5679</a></td><td>代币铸造和燃烧</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5732">5732</a></td><td>提交接口</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5750">5750</a></td><td>方法行为的一般可扩展性</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5773">5773</a></td><td>上下文相关的多资产代币</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6059">6059</a></td><td>家长管理的可嵌套不可替代代币</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6066">6066</a></td><td>NFT 的签名验证方法</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6105">6105</a></td><td>无中介 NFT 交易协议</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6147">6147</a></td><td>NFT&#x2F;SBT 的守护，ERC-721 的扩展</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6150">6150</a></td><td>分层 NFT</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6220">6220</a></td><td>利用可装备部件的可组合 NFT</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6239">6239</a></td><td>语义灵魂绑定标记</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6381">6381</a></td><td>公共不可替代代币表情存储库</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6454">6454</a></td><td>最小可转移NFT检测接口</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6672">6672</a></td><td>可多次赎回的 NFT</td><td></td></tr></tbody></table><h2 id="最后一次call"><a href="#最后一次call" class="headerlink" title="最后一次call"></a>最后一次call</h2><table><thead><tr><th>数字</th><th>审核结束</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1191">1191</a></td><td>2019-11-18</td><td>将链 ID 添加到混合大小写校验和地址编码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2266">2266</a></td><td>2020-12-31</td><td>基于原子互换的美式看涨期权合约标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5008">5008</a></td><td>2023-08-15</td><td>ERC-721 随机数扩展</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5216">5216</a></td><td>2022-11-12</td><td>EIP-1155 按金额扩展批准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5496">5496</a></td><td>202211月29日</td><td>多权限管理NFT扩展</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6093">6093</a></td><td>2023-08-15</td><td>常用令牌的自定义错误</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6492">6492</a></td><td>2023-08-29</td><td>预部署合同的签名验证</td></tr></tbody></table><h2 id="审查"><a href="#审查" class="headerlink" title="审查"></a>审查</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-223">223</a></td><td>具有交易处理模型的令牌</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1185">1185</a></td><td>ENS 中 DNS 记录的存储</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1328">1328</a></td><td>WalletConnect URI 格式</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3561">3561</a></td><td>信任最小化可升级代理</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3643">3643</a></td><td>T-REX - 受监管交易所的代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3770">3770</a></td><td>链特定地址</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4361">4361</a></td><td>使用以太坊登录</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4527">4527</a></td><td>钱包二维码传输协议</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4973">4973</a></td><td>账户绑定代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4974">4974</a></td><td>评级</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4987">4987</a></td><td>持有代币接口</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5005">5005</a></td><td>Zodiac 模块化账户</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5018">5018</a></td><td>类似文件系统的合约接口</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5114">5114</a></td><td>魂缚徽</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5164">5164</a></td><td>跨链执行</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5252">5252</a></td><td>账户绑定金融</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5269">5269</a></td><td>EIP&#x2F;ERC 检测和发现</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5289">5289</a></td><td>以太坊公证人接口</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5298">5298</a></td><td>ENS 信托将以 ENS 名义持有 NFT</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5516">5516</a></td><td>Soulbound 多所有者代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5553">5553</a></td><td>代表知识产权及其使用费结构</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5568">5568</a></td><td>恢复所需操作的原因</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5585">5585</a></td><td>ERC-721 NFT授权</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5604">5604</a></td><td>NFT 留置权</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5625">5625</a></td><td>NFT 元数据 JSON 架构 dStorage 扩展</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5639">5639</a></td><td>代表团登记处</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5643">5643</a></td><td>订阅 NFT</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5725">5725</a></td><td>可转让归属NFT</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5805">5805</a></td><td>代表团投票</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5982">5982</a></td><td>基于角色的访问控制</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6065">6065</a></td><td>房地产代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6120">6120</a></td><td>通用令牌路由器</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6357">6357</a></td><td>单合约多委托调用</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6358">6358</a></td><td>跨链代币状态同步</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6372">6372</a></td><td>合约钟</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6551">6551</a></td><td>不可替代的代币绑定账户</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6808">6808</a></td><td>可替代的密钥绑定令牌</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6809">6809</a></td><td>不可替代的密钥绑定令牌</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6982">6982</a></td><td>高效的默认可锁定代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6997">6997</a></td><td>ERC-721 带有交易验证步骤。</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7053">7053</a></td><td>可互操作的数字媒体索引</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7066">7066</a></td><td>ERC-721 可锁定扩展件</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7144">7144</a></td><td>ERC-20 具有交易验证步骤。</td></tr></tbody></table><h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-725">725</a></td><td>通用数据键&#x2F;值存储和执行</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-998">998</a></td><td>可组合的不可替代代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1202">1202</a></td><td>投票界面</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4337">4337</a></td><td>使用 Alt Mempool 进行账户抽象</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4393">4393</a></td><td>NFT 和多代币的小额支付</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4494">4494</a></td><td>ERC-721 NFT 许可证</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4675">4675</a></td><td>多分数不可替代代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4824">4824</a></td><td>DAO 的通用接口</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4883">4883</a></td><td>可组合的 SVG NFT</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4944">4944</a></td><td>只包含一个不可替代代币的合约</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4950">4950</a></td><td>纠缠代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4972">4972</a></td><td>名下账户</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5058">5058</a></td><td>可锁定的不可替代代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5115">5115</a></td><td>SY代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5139">5139</a></td><td>远程过程调用提供者列表</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5173">5173</a></td><td>NFT 未来奖励 (nFR)</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5187">5187</a></td><td>通过可出租使用权扩展 EIP-1155</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5218">5218</a></td><td>NFT 版权管理</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5247">5247</a></td><td>智能合约可执行提案接口</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5334">5334</a></td><td>EIP-721 用户和到期以及级别扩展</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5437">5437</a></td><td>安全接触接口</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5453">5453</a></td><td>认可 - 任何职能的许可</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5485">5485</a></td><td>合法性、管辖权和主权</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5501">5501</a></td><td>租赁和委托 NFT - EIP-721 扩展</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5521">5521</a></td><td>可参考 NFT</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5539">5539</a></td><td>撤销清单登记处</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5554">5554</a></td><td>NFT 的合法使用、重新利用和重新混合</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5564">5564</a></td><td>隐形地址</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5573">5573</a></td><td>使用以太坊功能登录，回顾</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5630">5630</a></td><td>加密&#x2F;解密的新方法</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5635">5635</a></td><td>NFT 许可协议</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5700">5700</a></td><td>可绑定令牌接口</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5719">5719</a></td><td>签名替换接口</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5727">5727</a></td><td>半可替代的 Soulbound 代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5744">5744</a></td><td>潜在的可替代代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5753">5753</a></td><td>EIP-721 可锁定扩展件</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5791">5791</a></td><td>实物支持代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5827">5827</a></td><td>自动更新津贴延期</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5850">5850</a></td><td>存储在“bytes32”类型中的复数</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5851">5851</a></td><td>链上可验证凭证</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5883">5883</a></td><td>通过 Social Recovery 进行代币转移</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5902">5902</a></td><td>智能合约事件挂钩</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6047">6047</a></td><td>ERC-721 通过转账事件进行余额索引</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6123">6123</a></td><td>智能衍生品合约</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6170">6170</a></td><td>跨链消息接口</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6224">6224</a></td><td>合同依赖注册表</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6268">6268</a></td><td>EIP-1155 的不可转移性指示器</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6315">6315</a></td><td>ERC-2771 账户抽象</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6327">6327</a></td><td>弹性签名</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6353">6353</a></td><td>慈善代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6366">6366</a></td><td>权限令牌</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6384">6384</a></td><td>人类可读的离线签名</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6464">6464</a></td><td>多运营商、每个代币 ERC-721 批准。</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6506">6506</a></td><td>P2P 托管治理激励</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6538">6538</a></td><td>隐形元地址注册表</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6596">6596</a></td><td>历史资产元数据 JSON 架构</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6617">6617</a></td><td>基于位的权限</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6662">6662</a></td><td>用于身份验证的 AA 帐户元数据</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6682">6682</a></td><td>NFT 闪贷</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6735">6735</a></td><td>基于 EVM 的地址的 L2 别名</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6785">6785</a></td><td>ERC-721 公用事业信息扩展</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6786">6786</a></td><td>NFT 版税支付登记处</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6787">6787</a></td><td>具有两阶段提款功能的订单簿 DEX</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6806">6806</a></td><td>ERC-721 保持时间跟踪</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6821">6821</a></td><td>支持 Web3 URL 的 ENS 名称</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6823">6823</a></td><td>令牌映射槽检索扩展</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6865">6865</a></td><td>链上 EIP-712 可视化</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6900">6900</a></td><td>模块化智能合约账户和插件</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6909">6909</a></td><td>最小多令牌接口</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6944">6944</a></td><td>ERC-5219 解决模式</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6956">6956</a></td><td>资产绑定的不可替代代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6960">6960</a></td><td>双层代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6981">6981</a></td><td>保留所有权帐户</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7007">7007</a></td><td>零知识人工智能生成的内容代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7015">7015</a></td><td>NFT 创建者归属</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7092">7092</a></td><td>金融债券</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7093">7093</a></td><td>社交恢复界面</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7160">7160</a></td><td>ERC-721 多元数据扩展</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7201">7201</a></td><td>命名空间存储布局</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7231">7231</a></td><td>身份聚合 NFT</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7303">7303</a></td><td>代币控制的代币流通</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7401">7401</a></td><td>父级管理的不可替代代币嵌套</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7444">7444</a></td><td>时间锁定成熟度</td></tr></tbody></table><h2 id="停滞不前"><a href="#停滞不前" class="headerlink" title="停滞不前"></a>停滞不前</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-205">205</a></td><td>ENS 对合约 ABI 的支持</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-634">634</a></td><td>ENS 中文本记录的存储</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-801">801</a></td><td>金丝雀标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-823">823</a></td><td>代币交换标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-831">831</a></td><td>以太坊的 URI 格式</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-884">884</a></td><td>DGCL 代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-897">897</a></td><td>委托代理</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-900">900</a></td><td>简单的质押界面</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-902">902</a></td><td>令牌验证</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-918">918</a></td><td>可开采代币标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-926">926</a></td><td>地址元数据注册表</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-927">927</a></td><td>通用授权</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1056">1056</a></td><td>以太坊轻量级身份</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1062">1062</a></td><td>将 IPFS 哈希形式化为 ENS（以太坊名称服务）解析器</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1066">1066</a></td><td>状态代码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1077">1077</a></td><td>用于合约调用的气体继电器</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1078">1078</a></td><td>使用 ENS 子域的通用登录&#x2F;注册</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1080">1080</a></td><td>可恢复代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1081">1081</a></td><td>标准赏金</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1129">1129</a></td><td>标准化DAPP公告</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1132">1132</a></td><td>通过代币锁定功能扩展 ERC20</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1175">1175</a></td><td>所有代币的钱包和商店标准 (erc20)</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1178">1178</a></td><td>多类别代币标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1203">1203</a></td><td>ERC-1203 多类代币标准（ERC-20 扩展）</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1207">1207</a></td><td>DAuth 访问委托标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1261">1261</a></td><td>会员验证令牌 (MVT)</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1319">1319</a></td><td>智能合约包注册接口</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1337">1337</a></td><td>区块链上的订阅</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1386">1386</a></td><td>鉴证管理合同</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1387">1387</a></td><td>启用隐私的默克尔树证明</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1388">1388</a></td><td>证明签发者管理列表</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1417">1417</a></td><td>投票标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1438">1438</a></td><td>dApp 组件（头像）和通用钱包</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1444">1444</a></td><td>使用信号到文本的本地化消息传递</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1450">1450</a></td><td>ERC-1450 一种兼容的安全令牌，用于发行和交易符合 SEC 规定的证券</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1462">1462</a></td><td>基础安全令牌</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1484">1484</a></td><td>数字身份聚合器</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1491">1491</a></td><td>人力成本会计标准（类似于天然气，但针对人类）</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1504">1504</a></td><td>可升级的智能合约</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1523">1523</a></td><td>ERC-721 不可替代代币保险单标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1577">1577</a></td><td>ENS 的 contenthash 字段</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1581">1581</a></td><td>来自 BIP-32 树的密钥的非钱包使用</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1592">1592</a></td><td>地址和符合ERC20的传输规则</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1613">1613</a></td><td>加油站网络</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1616">1616</a></td><td>属性注册标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1620">1620</a></td><td>资金流</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1633">1633</a></td><td>可替换代币标准（RFT）</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1710">1710</a></td><td>Web3 浏览器的 URL 格式</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1753">1753</a></td><td>许可证智能合约接口</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1761">1761</a></td><td>范围批准接口</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1775">1775</a></td><td>应用程序密钥，应用程序特定的钱包帐户</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1812">1812</a></td><td>以太坊可验证声明</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1822">1822</a></td><td>通用可升级代理标准 (UUPS)</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1844">1844</a></td><td>ENS 接口发现</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1900">1900</a></td><td>dType - EVM 的分散式系统</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1921">1921</a></td><td>dType 函数扩展</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1922">1922</a></td><td>zk-SNARK验证器标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1923">1923</a></td><td>zk-SNARK 验证器注册标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1948">1948</a></td><td>不可替代的数据代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1973">1973</a></td><td>可扩展的奖励</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1996">1996</a></td><td>可持有代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2009">2009</a></td><td>合规服务</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2018">2018</a></td><td>可清算代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2019">2019</a></td><td>可资助代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2020">2020</a></td><td>电子货币标准代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2021">2021</a></td><td>支付代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2157">2157</a></td><td>dType 存储扩展 - EVM 的去中心化类型系统</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2193">2193</a></td><td>dType 别名扩展 - 去中心化类型系统</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2304">2304</a></td><td>ENS 的多链地址解析</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2333">2333</a></td><td>BLS12-381 密钥生成</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2334">2334</a></td><td>BLS12-381 确定性帐户层次结构</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2335">2335</a></td><td>BLS12-381 密钥库</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2386">2386</a></td><td>以太坊 2 分层确定性钱包商店</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2390">2390</a></td><td>地理电子系统</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2400">2400</a></td><td>交易收据 URI</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2470">2470</a></td><td>辛格尔顿工厂</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2477">2477</a></td><td>令牌元数据完整性</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2494">2494</a></td><td>Baby Jubjub 椭圆曲线</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2520">2520</a></td><td>ENS 的多个内容哈希记录</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2525">2525</a></td><td>ENS登录</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2544">2544</a></td><td>ENS 通配符解析</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2569">2569</a></td><td>在链上保存和显示通用代币的图像</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2615">2615</a></td><td>具有抵押和租赁功能的不可替代代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2645">2645</a></td><td>Layer-2 的分层确定性钱包</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2680">2680</a></td><td>以太坊2钱包布局</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2746">2746</a></td><td>规则引擎标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2767">2767</a></td><td>合同所有权治理</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2770">2770</a></td><td>元交易转发合约</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2848">2848</a></td><td>我自己的消息 (MOM)</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2876">2876</a></td><td>充值合约及地址标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2917">2917</a></td><td>质押奖励计算</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2942">2942</a></td><td>EthPM URI 规范</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2980">2980</a></td><td>瑞士合规资产代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3000">3000</a></td><td>乐观制定治理标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3005">3005</a></td><td>批量元交易</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3009">3009</a></td><td>授权转让</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3135">3135</a></td><td>独家可领取代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3224">3224</a></td><td>描述数据</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3234">3234</a></td><td>批量闪电贷</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3386">3386</a></td><td>ERC-721 和 ERC-1155 到 ERC-20 包装器</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3440">3440</a></td><td>ERC-721 版本标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3450">3450</a></td><td>BIP-39 助记符的标准化 Shamir 秘密共享方案</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3569">3569</a></td><td>密封的 NFT 元数据标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3589">3589</a></td><td>将资产组装成 NFT</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3722">3722</a></td><td>海报</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3754">3754</a></td><td>普通的不可替代代币标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3772">3772</a></td><td>压缩整数</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4341">4341</a></td><td>订购 NFT 批量标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4353">4353</a></td><td>NFT 中质押代币的接口</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4430">4430</a></td><td>交易描述</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4521">4521</a></td><td>721&#x2F;20 兼容传输</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4524">4524</a></td><td>更安全的ERC-20</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4546">4546</a></td><td>打包存款</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4671">4671</a></td><td>非交易代币标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4799">4799</a></td><td>不可替代的代币所有权指定标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4885">4885</a></td><td>订阅 NFT 和多代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4886">4886</a></td><td>代理所有权登记册</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4931">4931</a></td><td>通用代币升级标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5050">5050</a></td><td>具有模块化环境的交互式 NFT</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5094">5094</a></td><td>以太坊网络切换的 URL 格式</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5095">5095</a></td><td>本金代币</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5131">5131</a></td><td>ENS 的安全认证</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5143">5143</a></td><td>代币化金库的滑点保护</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5185">5185</a></td><td>NFT 可更新元数据扩展</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5189">5189</a></td><td>通过认可操作提取账户</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5409">5409</a></td><td>EIP-1155 不可替代令牌扩展</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5505">5505</a></td><td>EIP-1155 资产支持的 NFT 扩展</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5559">5559</a></td><td>跨链写延迟协议</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5560">5560</a></td><td>可赎回的 NFT</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5633">5633</a></td><td>可组合的 Soulbound NFT，EIP-1155 扩展</td></tr></tbody></table><h2 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-67">67</a></td><td>具有元数据、值和字节码的 URI 方案</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-875">875</a></td><td>具有批处理和本机原子交换的更简单的 NFT 标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1123">1123</a></td><td>修订后的以太坊智能合约打包标准</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1154">1154</a></td><td>甲骨文接口</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1538">1538</a></td><td>透明合约标准</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> EIP笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EIP笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-接口 Interface</title>
      <link href="/2021/11/17/EIP%E7%AC%94%E8%AE%B0/04-%E6%8E%A5%E5%8F%A3%20Interface/"/>
      <url>/2021/11/17/EIP%E7%AC%94%E8%AE%B0/04-%E6%8E%A5%E5%8F%A3%20Interface/</url>
      
        <content type="html"><![CDATA[<h1 id="Interface-接口"><a href="#Interface-接口" class="headerlink" title="Interface 接口"></a>Interface 接口</h1><h2 id="最终的"><a href="#最终的" class="headerlink" title="最终的"></a>最终的</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6">6</a></td><td>重命名 SUICIDE 操作码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-234">234</a></td><td>将“blockHash”添加到 JSON-RPC 过滤器选项。</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-695">695</a></td><td>为 JSON-RPC 创建 <code>eth_chainId</code> 方法</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-712">712</a></td><td>类型化结构化数据散列和签名</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-747">747</a></td><td>wallet_watchAsset RPC方法</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1193">1193</a></td><td>以太坊提供商 JavaScript API</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2159">2159</a></td><td>客户端常用的 Prometheus 指标名称</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2255">2255</a></td><td>钱包权限系统</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2696">2696</a></td><td>JavaScript <code>request</code> 方法 RPC 传输</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2700">2700</a></td><td>JavaScript 提供者事件发射器</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4736">4736</a></td><td>共识层撤回保护</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5749">5749</a></td><td>“window.evmproviders”对象</td></tr></tbody></table><h2 id="最后一次call"><a href="#最后一次call" class="headerlink" title="最后一次call"></a>最后一次call</h2><table><thead><tr><th>数字</th><th>审核结束</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3076">3076</a></td><td>2021-11-03</td><td>削减保护交换格式</td></tr></tbody></table><h2 id="审查"><a href="#审查" class="headerlink" title="审查"></a>审查</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1898">1898</a></td><td>将 <code>blockHash</code> 添加到 defaultBlock 方法中</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2015">2015</a></td><td>wallet_updateEthereumChain RPC方法</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4881">4881</a></td><td>充值合约快照接口</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6963">6963</a></td><td>多注入提供商发现</td></tr></tbody></table><h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5593">5593</a></td><td>限制以太坊提供商 API 注入</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5792">5792</a></td><td>钱包功能调用API</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6051">6051</a></td><td>私钥封装</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6789">6789</a></td><td>将gas重命名为mana</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7039">7039</a></td><td>钱包的方案处理程序发现选项</td></tr></tbody></table><h2 id="停滞不前"><a href="#停滞不前" class="headerlink" title="停滞不前"></a>停滞不前</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-107">107</a></td><td>通过 html 弹出窗口进行安全“eth_sendTransaction”授权</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-758">758</a></td><td>已完成交易的订阅和过滤器</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1102">1102</a></td><td>选择加入帐户曝光</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1186">1186</a></td><td>获取 Merkle 证明的 RPC 方法 - eth_getProof</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1474">1474</a></td><td>远程过程调用规范</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1571">1571</a></td><td>以太坊层&#x2F;2.0.0</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1767">1767</a></td><td>以太坊节点数据的 GraphQL 接口</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1803">1803</a></td><td>为了清晰起见，重命名操作码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1901">1901</a></td><td>将 OpenRPC 服务发现添加到 JSON-RPC 服务</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2003">2003</a></td><td>用于实现预编译合约的 EVMC 模块</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2256">2256</a></td><td>wallet_getOwnedAssets JSON-RPC 方法</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2566">2566</a></td><td>用于合约功能执行的人类可读参数</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2831">2831</a></td><td>交易替换消息类型</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2844">2844</a></td><td>在JSON-RPC中添加DID相关方法</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3014">3014</a></td><td>eth_symbol JSON-RPC 方法</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3030">3030</a></td><td>BLS 远程签名者 HTTP API</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3041">3041</a></td><td>将“baseFee”添加到“eth_getBlockByHash”</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3044">3044</a></td><td>将“baseFee”添加到“eth_getBlockByNumber”</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3045">3045</a></td><td>将“baseFee”添加到“eth_getUncleByBlockHashAndIndex”</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3046">3046</a></td><td>将“baseFee”添加到“eth_getUncleByBlockNumberAndIndex”</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3085">3085</a></td><td>钱包添加以太坊链 RPC 方法（<code>wallet_addEthereumChain</code>）</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3091">3091</a></td><td>区块浏览器 API 路由</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3155">3155</a></td><td>EVM 跟踪规范</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3326">3326</a></td><td>钱包切换以太坊链 RPC 方法（<code>wallet_switchEthereumChain</code>）</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3709">3709</a></td><td>删除对类型 1 交易的支持</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5345">5345</a></td><td>JSON-RPC 的静默签名扩展</td></tr></tbody></table><h2 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2786">2786</a></td><td>以太坊提供商连接&#x2F;断开事件</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> EIP笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EIP笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-网络 Networking</title>
      <link href="/2021/11/14/EIP%E7%AC%94%E8%AE%B0/03-%E7%BD%91%E7%BB%9C%20Networking/"/>
      <url>/2021/11/14/EIP%E7%AC%94%E8%AE%B0/03-%E7%BD%91%E7%BB%9C%20Networking/</url>
      
        <content type="html"><![CDATA[<h1 id="Networking-网络"><a href="#Networking-网络" class="headerlink" title="Networking 网络"></a>Networking 网络</h1><h2 id="最终的"><a href="#最终的" class="headerlink" title="最终的"></a>最终的</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-8">8</a></td><td>Homestead 的 devp2p 前向兼容性要求</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-627">627</a></td><td>耳语规格</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-706">706</a></td><td>DEVp2p 快速压缩</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-778">778</a></td><td>以太坊节点记录（ENR）</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-868">868</a></td><td>节点发现 v4 ENR 扩展</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2124">2124</a></td><td>用于链兼容性检查的分叉标识符</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2364">2364</a></td><td>eth&#x2F;64：forkid 扩展协议握手</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2464">2464</a></td><td>eth&#x2F;65：交易公告和检索</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2481">2481</a></td><td>eth&#x2F;66 请求标识符</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2976">2976</a></td><td>八卦上的类型化交易</td></tr></tbody></table><h2 id="审查"><a href="#审查" class="headerlink" title="审查"></a>审查</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4938">4938</a></td><td>eth&#x2F;67 - 删除 GetNodeData</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5793">5793</a></td><td>eth&#x2F;68 - 将 tx 类型添加到 tx 公告</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6122">6122</a></td><td>基于时间戳的 Forkid 检查</td></tr></tbody></table><h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1459">1459</a></td><td>通过 DNS 发现节点</td></tr></tbody></table><h2 id="停滞不前"><a href="#停滞不前" class="headerlink" title="停滞不前"></a>停滞不前</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4444">4444</a></td><td>执行客户端中绑定历史数据</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> EIP笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EIP笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-核心 Core</title>
      <link href="/2021/11/08/EIP%E7%AC%94%E8%AE%B0/02-%E6%A0%B8%E5%BF%83%20Core/"/>
      <url>/2021/11/08/EIP%E7%AC%94%E8%AE%B0/02-%E6%A0%B8%E5%BF%83%20Core/</url>
      
        <content type="html"><![CDATA[<h1 id="Core-核心"><a href="#Core-核心" class="headerlink" title="Core 核心"></a>Core 核心</h1><h2 id="最终的"><a href="#最终的" class="headerlink" title="最终的"></a>最终的</h2><table><thead><tr><th>数字</th><th>标题</th><th>内容</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2">2</a></td><td>Homestead 硬分叉变化</td><td>增加了创建合约的Gas成本(create不受影响)、调整难度算法</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5">5</a></td><td>“RETURN”和“CALL”的 Gas 使用情况</td><td>只对CALL返回时实际写入的内存收取gas费用</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7">7</a></td><td>DELEGATECALL</td><td>添加一个新的操作码<code>DELEGATECALL</code></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-100">100</a></td><td>将难度调整更改为目标平均区块时间（包括叔块）</td><td>调整难度算法</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-140">140</a></td><td>REVERT指令</td><td>增加了REVERT指令</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-141">141</a></td><td>指定无效的EVM指令</td><td>无效指令可以用作中止执行的明显原因(从未使用)</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-145">145</a></td><td>EVM 中的按位移位指令</td><td>提供本机按位移位，其成本与其他算术运算相当</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-150">150</a></td><td>IO 密集型操作的 Gas 成本变化</td><td>修改了一些指令的Gas成本</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-152">152</a></td><td>添加 BLAKE2 压缩函数 <code>F</code> 预编译</td><td>引入了一个新的预编译合约，该合约实现了BLAKE2加密哈希算法中使用的压缩功能<code>F</code></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-155">155</a></td><td>简单的重放攻击保护</td><td>当出于签名目的计算交易的散列时，您<strong>应该</strong>散列九个 rlp 编码元素，而不是仅散列六个 rlp 编码元素</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-158">158</a></td><td>状态清算</td><td>消除了大量空帐户，缩小负担</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-160">160</a></td><td>EXP成本增加</td><td>EXP 的 Gas 成本从指数中每字节 10 + 10 增加到指数中每字节 10 + 50</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-161">161</a></td><td>状态特里树清理（不变性保留替代方案）</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-170">170</a></td><td>合约代码大小限制</td><td>如果合约创建初始化返回长度<strong>超过</strong> <code>MAX_CODE_SIZE</code>字节的数据，合约创建将失败并出现耗尽气体错误</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-196">196</a></td><td>椭圆曲线上的加法和标量乘法的预编译合约 alt_bn128</td><td>为了在区块 Gas 限制内执行 zkSNARK 验证，需要用于椭圆曲线操作的预编译合约</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-197">197</a></td><td>用于椭圆曲线上最佳 ate 配对检查的预编译合约 alt_bn128</td><td>为了在区块 Gas 限制内执行 zkSNARK 验证，需要用于椭圆曲线配对操作的预编译合约。</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-198">198</a></td><td>大整数模幂</td><td>允许在 EVM 内部进行高效的 RSA 验证，以及其他形式的基于数论的密码学。</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-211">211</a></td><td>新操作码：RETURNDATASIZE 和 RETURNDATACOPY</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-214">214</a></td><td>新操作码 STATICCALL</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-225">225</a></td><td>Clique 权威证明共识协议</td><td>Clique 是一种权威证明共识协议。它模仿了以太坊主网的设计，因此可以以最小的努力将其添加到任何客户端</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-649">649</a></td><td>大都会难度炸弹延迟和区块奖励减少</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-658">658</a></td><td>在收据中嵌入交易状态代码</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-684">684</a></td><td>发生碰撞时恢复创建</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1014">1014</a></td><td>瘦CREATE2</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1052">1052</a></td><td>EXTCODEHASH 操作码</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1108">1108</a></td><td>减少 alt_bn128 预编译 Gas 成本</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1234">1234</a></td><td>君士坦丁堡难度炸弹延迟和区块奖励调整</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1283">1283</a></td><td>SSTORE 的净燃气计量，无需脏地图</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1344">1344</a></td><td>ChainID操作码</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1559">1559</a></td><td>ETH 1.0 链的费用市场变化</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1884">1884</a></td><td>依赖特里结构大小的操作码的重新定价</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2028">2028</a></td><td>交易数据gas成本降低</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2200">2200</a></td><td>净燃气计量的结构化定义</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2384">2384</a></td><td>缪尔冰川难度炸弹延迟</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2565">2565</a></td><td>ModExp 天然气成本</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2681">2681</a></td><td>将帐户随机数限制为 2^64-1</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2718">2718</a></td><td>打字交易信封</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2929">2929</a></td><td>状态访问操作码的 Gas 成本增加</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2930">2930</a></td><td>可选访问列表</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3198">3198</a></td><td>基本费操作码</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3529">3529</a></td><td>减少退款</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3541">3541</a></td><td>拒绝以 0xEF 字节开头的新合约代码</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3554">3554</a></td><td>难度炸弹延迟至 2021  12 月</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3607">3607</a></td><td>使用已部署的代码拒绝来自发件人的交易</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3651">3651</a></td><td>温暖的COINBASE</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3675">3675</a></td><td>将共识升级为权益证明</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3855">3855</a></td><td>PUSH0指令</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3860">3860</a></td><td>限制和计量初始化代码</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4345">4345</a></td><td>难度炸弹延迟至 2022  6 月</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4399">4399</a></td><td>用 PREVRANDAO 替换 DIFFICULTY 操作码</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4895">4895</a></td><td>信标链将提款作为操作</td><td></td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5133">5133</a></td><td>将难度炸弹推迟到 2022  9 月中旬</td><td></td></tr></tbody></table><h2 id="最后一次call"><a href="#最后一次call" class="headerlink" title="最后一次call"></a>最后一次call</h2><table><thead><tr><th>数字</th><th>审核结束</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1153">1153</a></td><td>2022-12-08</td><td>瞬时存储操作码</td></tr></tbody></table><h2 id="审查"><a href="#审查" class="headerlink" title="审查"></a>审查</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-663">663</a></td><td>无限的 SWAP 和 DUP 指令</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2294">2294</a></td><td>显式绑定到 Chain ID 大小</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3074">3074</a></td><td>AUTH 和 AUTHCALL 操作码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3540">3540</a></td><td>EOF - EVM 对象格式 v1</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3670">3670</a></td><td>EOF - 代码验证</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4200">4200</a></td><td>EOF - 静态相对跳转</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4750">4750</a></td><td>EOF——函数</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4758">4758</a></td><td>停用自毁功能</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4844">4844</a></td><td>分片 Blob 交易</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5450">5450</a></td><td>EOF - 堆栈验证</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5656">5656</a></td><td>MCOPY——内存复制指令</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5920">5920</a></td><td>支付操作码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6188">6188</a></td><td>随机数上限</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6189">6189</a></td><td>别名合约</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6190">6190</a></td><td>Verkle 兼容的自毁</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7044">7044</a></td><td>永久有效的签名自愿退出</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7045">7045</a></td><td>增加最大证明包含槽</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7212">7212</a></td><td>预编译 secp256r1 曲线支持</td></tr></tbody></table><h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1418">1418</a></td><td>区块链存储租金支付</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3102">3102</a></td><td>二元特里结构</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3455">3455</a></td><td>SUDO 操作码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4788">4788</a></td><td>EVM 中的信标块根</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5000">5000</a></td><td>MULDIV指令</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5027">5027</a></td><td>取消合约代码大小限制</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5081">5081</a></td><td>过期火车动作</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5806">5806</a></td><td>委托交易</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5988">5988</a></td><td>添加Poseidon哈希函数预编译</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6046">6046</a></td><td>将 SELFDESTRUCT 替换为 DEACTIVATE</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6110">6110</a></td><td>在链上提供验证者存款</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6206">6206</a></td><td>EOF-JUMPF指令</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6404">6404</a></td><td>SSZ 交易根</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6465">6465</a></td><td>SSZ提款根</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6466">6466</a></td><td>SSZ 收据根</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6475">6475</a></td><td>SSZ 可选</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6493">6493</a></td><td>SSZ交易签名方案</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6780">6780</a></td><td>仅在同一事务中自毁</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6810">6810</a></td><td>事后级联恢复</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6811">6811</a></td><td>前往月球——10 分钟街区</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6888">6888</a></td><td>EVM 中的数学检查</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6913">6913</a></td><td>设置代码指令</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6968">6968</a></td><td>基于 EVM 的 L2 上的合同担保收入</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-6988">6988</a></td><td>当选的区块提议者尚未被削减</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7002">7002</a></td><td>执行层可触发退出</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7069">7069</a></td><td>修改了 CALL 指令</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7266">7266</a></td><td>删除 BLAKE2 压缩预编译</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-7377">7377</a></td><td>移民交易</td></tr></tbody></table><h2 id="停滞不前"><a href="#停滞不前" class="headerlink" title="停滞不前"></a>停滞不前</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-86">86</a></td><td>交易来源和签名的抽象</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-101">101</a></td><td>宁静货币和加密抽象</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-210">210</a></td><td>区块哈希重构</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-615">615</a></td><td>EVM 的子例程和静态跳转</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-616">616</a></td><td>EVM 的 SIMD 操作</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-665">665</a></td><td>添加Ed25519签名验证的预编译合约</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-689">689</a></td><td>合约地址冲突导致异常停顿</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-698">698</a></td><td>操作码 0x46 区块奖励</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-858">858</a></td><td>减少区块奖励并延迟难度炸弹</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-969">969</a></td><td>修改 ethash 以使现有的专用硬件实现失效</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1010">1010</a></td><td>0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B 和 0x15E55EF43efA8348dDaeAa455F16C43B64917e3c 之间的一致性</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1011">1011</a></td><td>混合 Casper FFG</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1015">1015</a></td><td>可配置的链上发行</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1051">1051</a></td><td>EVM 的溢出检查</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1057">1057</a></td><td>ProgPoW，一种程序化的工作量证明</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1087">1087</a></td><td>SSTORE 运营的净燃气计量</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1109">1109</a></td><td>PRECOMPILEDCALL 操作码（删除预编译合约的 CALL 成本）</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1227">1227</a></td><td>拆除难度炸弹并重置区块奖励</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1276">1276</a></td><td>消除难度炸弹并调整君士坦丁堡转移的区块奖励</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1285">1285</a></td><td>增加 CALL 操作码中的 Gcallstipend 气体</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1295">1295</a></td><td>修改以太坊PoW激励结构并延迟难度炸弹</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1352">1352</a></td><td>指定预编译&#x2F;系统合约的限制地址范围</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1380">1380</a></td><td>降低自我调用的 Gas 成本</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1482">1482</a></td><td>定义最大区块时间戳漂移</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1485">1485</a></td><td>TEthashV1</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1681">1681</a></td><td>临时重放保护</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1702">1702</a></td><td>通用帐户版本控制方案</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1829">1829</a></td><td>椭圆曲线线性组合的预编译</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1895">1895</a></td><td>支持椭圆曲线循环</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1930">1930</a></td><td>具有严格气体语义的 CALL。如果没有足够的可用气体，请恢复。</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1959">1959</a></td><td>用于检查 chainID 是否是 chainID 历史记录的一部分的新操作码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1962">1962</a></td><td>EC 算术和与运行时定义的配对</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1965">1965</a></td><td>检查 chainID 在特定区块号上是否有效的方法</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1985">1985</a></td><td>某些 EVM 参数的合理限制</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2014">2014</a></td><td>扩展状态预言机</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2026">2026</a></td><td>状态租金 H - 账户固定预付款</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2027">2027</a></td><td>State Ren C - 净合同规模核算</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2029">2029</a></td><td>State Rent A - 国家柜台合同</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2031">2031</a></td><td>国租B - 净交易柜台</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2035">2035</a></td><td>无状态客户端 - 重新定价 SLOAD 和 SSTORE 以支付区块证明</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2045">2045</a></td><td>EVM 操作码的粒子气体成本</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2046">2046</a></td><td>减少预编译静态调用的 Gas 成本</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2242">2242</a></td><td>交易后数据</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2327">2327</a></td><td>BEGINDATA 操作码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2330">2330</a></td><td>EXTSLOAD 操作码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2474">2474</a></td><td>Coinbase 电话</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2488">2488</a></td><td>弃用 CALLCODE 操作码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2515">2515</a></td><td>实施难度冻结</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2537">2537</a></td><td>BLS12-381 曲线操作的预编译</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2539">2539</a></td><td>BLS12-377 曲线运算</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2542">2542</a></td><td>新操作码 TXGASLIMIT 和 CALLGASLIMIT</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2583">2583</a></td><td>对帐户 trie 未命中的惩罚</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2584">2584</a></td><td>具有覆盖树的 Trie 格式转换</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2593">2593</a></td><td>ETH 1.0 链的自动扶梯费用市场变化</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2666">2666</a></td><td>预编译和 Keccak256 函数的重新定价</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2803">2803</a></td><td>丰富的交易</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2926">2926</a></td><td>基于块的代码默克尔化</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2935">2935</a></td><td>在状态中保存历史区块哈希</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2936">2936</a></td><td>用于自毁合约的 EXTCLEAR 操作码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2937">2937</a></td><td>SET_INDESTRUCTIBLE 操作码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2938">2938</a></td><td>账户抽象</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2970">2970</a></td><td>IS_STATIC 操作码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2997">2997</a></td><td>IMPERSONATECALL 操作码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3026">3026</a></td><td>BW6-761曲线运算</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3068">3068</a></td><td>BN256 HashToCurve 算法的预编译</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3143">3143</a></td><td>将区块奖励增加至 5 ETH</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3220">3220</a></td><td>跨链标识符规范</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3238">3238</a></td><td>难度炸弹延迟至 2022 二季度</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3267">3267</a></td><td>将以太坊费用支付给未来工资</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3298">3298</a></td><td>取消退款</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3300">3300</a></td><td>逐步取消退款</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3322">3322</a></td><td>账户储气操作码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3336">3336</a></td><td>EVM 的分页内存分配</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3337">3337</a></td><td>内存加载和存储操作的帧指针支持</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3368">3368</a></td><td>将区块奖励增加至 3 ETH，计划 2 衰减至 1 ETH</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3372">3372</a></td><td>ethash 的 5 个 FNV 素数</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3403">3403</a></td><td>部分取消退款</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3416">3416</a></td><td>天然气溢价中位数</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3436">3436</a></td><td>扩展派块选择规则</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3508">3508</a></td><td>交易数据操作码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3520">3520</a></td><td>交易目标操作码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3521">3521</a></td><td>降低访问列表成本</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3534">3534</a></td><td>受限链上下文类型交易</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3584">3584</a></td><td>阻止访问列表</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3690">3690</a></td><td>EOF - JUMPDEST 表</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3756">3756</a></td><td>气体限制上限</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3788">3788</a></td><td>严格执行chainId</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3978">3978</a></td><td>恢复时 Gas 退款</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4396">4396</a></td><td>时间感知的基本费用计算</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4488">4488</a></td><td>通过总调用数据限制，交易调用数据 Gas 成本降低</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4520">4520</a></td><td>以 EB 和 EC 为前缀的多字节操作码。</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4573">4573</a></td><td>EVM 的程序</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4747">4747</a></td><td>简化 EIP-161</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4760">4760</a></td><td>自毁炸弹</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4762">4762</a></td><td>无状态 Gas 成本变化</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4803">4803</a></td><td>将交易 Gas 限制为最大 2^63-1</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-4863">4863</a></td><td>信标链推送提现</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5003">5003</a></td><td>使用 AUTHUSURP 将代码插入 EOA</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5022">5022</a></td><td>将 SSTORE 的价格从零提高到非零至 40k Gas</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5065">5065</a></td><td>以太币转账说明</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5283">5283</a></td><td>用于重入保护的信号量</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-5478">5478</a></td><td>CREATE2COPY 操作码</td></tr></tbody></table><h2 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h2><table><thead><tr><th>数字</th><th>标题</th></tr></thead><tbody><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3">3</a></td><td>添加 CALLDEPTH 操作码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-908">908</a></td><td>奖励客户建立可持续的网络</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-999">999</a></td><td>恢复合约代码0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1240">1240</a></td><td>移除难度炸弹</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1355">1355</a></td><td>以太坊1a</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1682">1682</a></td><td>仓储租金</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1706">1706</a></td><td>禁用 SSTORE，gasleft 低于call津贴</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-1890">1890</a></td><td>对可持续生态系统资金的承诺</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2025">2025</a></td><td>资助 Eth1.x 的区块奖励提案</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2315">2315</a></td><td>EVM 的简单子例程</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2677">2677</a></td><td>限制“initcode”的大小</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2711">2711</a></td><td>赞助、到期和批量交易。</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2733">2733</a></td><td>交易套餐</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2780">2780</a></td><td>减少内在交易气体</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-2972">2972</a></td><td>打包的旧交易</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3332">3332</a></td><td>MEDGAASPRICE 操作码</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3338">3338</a></td><td>将帐户随机数限制为 2^52</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3374">3374</a></td><td>可预测的工作量证明（POW）日落</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3382">3382</a></td><td>硬编码的区块 Gas 限制</td></tr><tr><td><a href="https://eips.ethereum.org/EIPS/eip-3779">3779</a></td><td>EVM 更安全的控制流程</td></tr></tbody></table><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> EIP笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EIP笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-状态</title>
      <link href="/2021/11/07/EIP%E7%AC%94%E8%AE%B0/01-%E7%8A%B6%E6%80%81/"/>
      <url>/2021/11/07/EIP%E7%AC%94%E8%AE%B0/01-%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="EIP状态"><a href="#EIP状态" class="headerlink" title="EIP状态"></a>EIP状态</h1><ul><li>想法- 预草案的想法。EIP 存储库中不会对此进行跟踪。</li><li>草案- EIP 开发中的第一个正式跟踪阶段。当格式正确时，EIP 会被 EIP 编辑器合并到 EIP 存储库中。</li><li>审查- EIP 作者将 EIP 标记为准备好并请求同行审查。</li><li>最后一次call- 这是进入最终阶段之前 EIP 的最终审核窗口。EIP 编辑将分配“最后一次call”状态并设置审核结束日期(“最后一次call截止日期”)，通常为 14 天后。如果在此期间导致必要的规范性变更，EIP 将会重新接受审查。</li><li>最终版- 该 EIP 代表最终标准。最终 EIP 处于最终确定状态，仅应更新以更正勘误表并添加非规范性说明。</li><li>停滞- 任何处于草案或审查阶段的 EIP 如果在 6 个月或更长时间内处于非活动状态，则将转为停滞。作者或 EIP 编辑者可以通过将 EIP 移回草稿来使其从此状态复活。</li><li>撤回- EIP 作者已撤回提议的 EIP。该状态具有最终性，不能再使用该EIP号复活。如果稍后继续实施该想法，则该想法将被视为新提案。</li><li>Living - EIP 的一种特殊状态，旨在不断更新且不会达到最终状态。其中最著名的是 EIP-1。</li></ul><hr><ul><li>Idea - An idea that is pre-draft. This is not tracked within the EIP Repository.</li><li>Draft - The first formally tracked stage of an EIP in development. An EIP is merged by an EIP Editor into the EIP repository when properly formatted.</li><li>Review - An EIP Author marks an EIP as ready for and requesting Peer Review.</li><li>Last Call - This is the final review window for an EIP before moving to FINAL. An EIP editor will assign Last Call status and set a review end date (last-call-deadline), typically 14 days later. If this period results in necessary normative changes it will revert the EIP to Review.</li><li>Final - This EIP represents the final standard. A Final EIP exists in a state of finality and should only be updated to correct errata and add non-normative clarifications.</li><li>Stagnant - Any EIP in Draft or Review if inactive for a period of 6 months or greater is moved to Stagnant. An EIP may be resurrected from this state by Authors or EIP Editors through moving it back to Draft.</li><li>Withdrawn - The EIP Author(s) have withdrawn the proposed EIP. This state has finality and can no longer be resurrected using this EIP number. If the idea is pursued at later date it is considered a new proposal.</li><li>Living - A special status for EIPs that are designed to be continually updated and not reach a state of finality. This includes most notably EIP-1.</li></ul><h1 id="EIP类型"><a href="#EIP类型" class="headerlink" title="EIP类型"></a>EIP类型</h1><blockquote><p>EIP 分为多种类型，每种类型都有自己的 EIP 列表</p></blockquote><h2 id="标准轨道-630"><a href="#标准轨道-630" class="headerlink" title="标准轨道 (630)"></a>标准轨道 (630)</h2><p>描述影响大多数或所有以太坊实现的任何更改，例如网络协议的更改、块或交易有效性规则的更改、提议的应用程序标准&#x2F;约定，或者影响使用以太坊的应用程序的互操作性的任何更改或添加。此外，标准 EIP 可以分为以下几类：</p><h3 id="核心-221"><a href="#核心-221" class="headerlink" title="核心(221)"></a>核心(221)</h3><p>需要共识分叉的改进(例如EIP-5、EIP-211)，以及不一定是共识关键但可能与“核心开发”讨论相关的更改(例如，EIP-225中描述的测试网的 PoA 算法) )。</p><h3 id="网络-15"><a href="#网络-15" class="headerlink" title="网络(15)"></a>网络(15)</h3><p>包括围绕 devp2p ( EIP-8 ) 和 Light Ethereum Subprotocol 的改进，以及对 Whisper 和 swarm 网络协议规范的拟议改进。</p><h3 id="接口-49"><a href="#接口-49" class="headerlink" title="接口(49)"></a>接口(49)</h3><p>包括围绕客户端 API&#x2F;RPC 规范和标准的改进，以及某些语言级标准，例如方法名称 ( EIP-6 ) 和合约 ABI。“接口”标签与接口存储库一致，在将 EIP 提交到 EIP 存储库之前，讨论应主要在该存储库中进行。</p><h3 id="ERC-345"><a href="#ERC-345" class="headerlink" title="ERC(345)"></a>ERC(345)</h3><p>应用程序级标准和约定，包括合约标准，例如代币标准 ( EIP-20 )、名称注册中心 ( EIP-137 )、URI 方案 ( EIP-681 )、库&#x2F;包格式 ( EIP-190 ) 和帐户抽象 (EIP-190) EIP-4337)。</p><h3 id="元-22"><a href="#元-22" class="headerlink" title="元(22)"></a>元(22)</h3><p>描述围绕以太坊的流程或建议对流程(或流程中的事件)进行更改。流程 EIP 类似于标准跟踪 EIP，但适用于以太坊协议本身以外的领域。他们可能会提出一个实现方案，但不会针对以太坊的代码库；它们通常需要社区共识；与信息 EIP 不同，它们不仅仅是建议，而且用户通常不能随意忽略它们。示例包括程序、指南、决策过程的更改以及以太坊开发中使用的工具或环境的更改。任何元 EIP 也被视为进程 EIP。</p><h3 id="信息-7"><a href="#信息-7" class="headerlink" title="信息(7)"></a>信息(7)</h3><p>描述以太坊设计问题，或向以太坊社区提供一般指南或信息，但不提出新功能。信息性 EIP 并不一定代表以太坊社区的共识或建议，因此用户和实施者可以自由地忽略信息性 EIP 或遵循他们的建议。</p>]]></content>
      
      
      <categories>
          
          <category> EIP笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EIP笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker命令</title>
      <link href="/2021/11/01/Docker/Docker%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/11/01/Docker/Docker%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="新建-启动容器"><a href="#新建-启动容器" class="headerlink" title="新建+启动容器"></a>新建+启动容器</h2><p>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p><p>OPTIONS说明（常用）：有些是一个减号，有些是两个减号</p><p>–name&#x3D;”容器新名字”    为容器指定一个名称；</p><p>-d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；</p><p>-i：以交互模式运行容器，通常与 -t 同时使用；</p><p>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p><p>-P: 随机端口映射，大写P</p><p>-p: 指定端口映射，小写p</p><p><img src="/noteimg/Docker/img/image-20230823095858023.png" alt="image-20230823095858023"> </p><p>使用镜像centos:latest以交互模式启动一个容器,在容器内执行&#x2F;bin&#x2F;bash命令。</p><p>docker run -it centos &#x2F;bin&#x2F;bash</p><h2 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h2><p><strong>退出容器：</strong></p><p><img src="/noteimg/Docker/img/image-20230823100125508.png" alt="image-20230823100125508"> </p><p><strong>启动停止的容器：</strong><img src="/noteimg/Docker/img/image-20230823100154247.png" alt="image-20230823100154247"> </p><p><strong>重启：</strong>restart</p><p><strong>停止：</strong>stop</p><p><strong>强制停止：</strong>kill</p><p><strong>删除已停止：</strong>rm 容器ID (一次性删除多个：<img src="/noteimg/Docker/img/image-20230823100515195.png" alt="image-20230823100515195">)</p><p><strong>日志：</strong>logs 容器ID</p><p><strong>容器呢i运行的进程：</strong>top 容器ID</p><p><strong>容器内部细节：</strong>inspect 容器ID</p><p><strong>拷贝文件到主机：</strong>cp 容器ID:容器内路径 目的主机路径</p><p><strong>导入和导出容器：</strong><img src="/noteimg/Docker/img/image-20230823101344450.png" alt="image-20230823101344450"></p><p><strong>提交容器副本使之成为一个新的镜像：</strong>docker commit -m&#x3D;”提交的描述信息”-a&#x3D;”作者”容器ID 要创建的目标镜像名:[标签名]</p><h2 id="进入正在运行的容器并以命令行交互"><a href="#进入正在运行的容器并以命令行交互" class="headerlink" title="进入正在运行的容器并以命令行交互"></a>进入正在运行的容器并以命令行交互</h2><p><img src="/noteimg/Docker/img/image-20230823100942131.png" alt="image-20230823100942131"></p><h2 id="容器卷"><a href="#容器卷" class="headerlink" title="容器卷"></a>容器卷</h2><p><img src="/noteimg/Docker/img/image-20230823101940115.png" alt="image-20230823101940115"></p><p><img src="/noteimg/Docker/img/image-20230823102211961.png" alt="image-20230823102211961"> </p><h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><h2 id="Dokcer执行Dockerfile的大致过程"><a href="#Dokcer执行Dockerfile的大致过程" class="headerlink" title="Dokcer执行Dockerfile的大致过程"></a>Dokcer执行Dockerfile的大致过程</h2><p><img src="/noteimg/Docker/img/image-20230823140711653.png" alt="image-20230823140711653"> </p><h2 id="常用保留字指令"><a href="#常用保留字指令" class="headerlink" title="常用保留字指令"></a>常用保留字指令</h2><img src="/noteimg/Docker/img/image-20230823140938785.png" alt="image-20230823140938785" style="zoom:150%;" /><p>构建：docker build -t 新镜像名字:TAG . (最后面有个点)</p><h1 id="Docker-compouse容器编排"><a href="#Docker-compouse容器编排" class="headerlink" title="Docker-compouse容器编排"></a>Docker-compouse容器编排</h1><p>Compose 是 Docker 公司推出的一个工具软件，可以管理多个 Docker 容器组成一个应用。你需要定义一个 YAML 格式的配置文件docker-compose.yml，写好多个容器之间的调用关系。然后，只要一个命令，就能同时启动&#x2F;关闭这些容器</p><h2 id="Compose常用命令"><a href="#Compose常用命令" class="headerlink" title="Compose常用命令"></a>Compose常用命令</h2><p>docker-compose -h              # 查看帮助</p><p>docker-compose up              # 启动所有docker-compose服务</p><p>docker-compose up -d             # 启动所有docker-compose服务并后台运行</p><p>docker-compose down             # 停止并删除容器、网络、卷、镜像。</p><p>docker-compose exec  yml里面的服务id         # 进入容器实例内部 docker-compose exec docker-compose.yml文件中写的服务id &#x2F;bin&#x2F;bash</p><p>docker-compose ps            # 展示当前docker-compose编排过的运行的所有容器</p><p>docker-compose top           # 展示当前docker-compose编排过的容器进程</p><p>docker-compose logs  yml里面的服务id   # 查看容器输出日志</p><p>docker-compose config   # 检查配置</p><p>docker-compose config -q # 检查配置，有问题才有输出</p><p>docker-compose restart  # 重启服务</p><p>docker-compose start   # 启动服务</p><p>docker-compose stop    # 停止服务</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
